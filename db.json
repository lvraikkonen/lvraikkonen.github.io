{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/uploads/WeChatImage_20170527190034.jpg","path":"uploads/WeChatImage_20170527190034.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/particle.js","path":"js/src/particle.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/favicon.ico","hash":"74cc44e62e66f44c5dc1638b28f1b60c8a829899","modified":1496395746000},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1496286320000},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1496286320000},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1496286320000},{"_id":"themes/next/.git","hash":"042ff34da0707513a5681580b37513c890c671ef","modified":1496286320000},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1496286320000},{"_id":"themes/next/.javascript_ignore","hash":"74b54cf920cbbf4038a68e54b7138af8b8f45588","modified":1496286320000},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1496286320000},{"_id":"themes/next/.gitignore","hash":"b935cc0e5b099ebd343ca1766e02f65138c13dd0","modified":1496286320000},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1496286320000},{"_id":"themes/next/README.en.md","hash":"953873fe2ee79bfc567b16dcdf8f91c1410444f8","modified":1496286320000},{"_id":"themes/next/README.md","hash":"06aaf1241e9e1619956c86d8b1397a643840a9d1","modified":1496286320000},{"_id":"themes/next/_config.yml","hash":"439dc838d04aa41e28509a086097d346a3ae2c1d","modified":1502276084000},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1496286320000},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1496286320000},{"_id":"themes/next/bower.json","hash":"936b9aed1934471bb74cdaacc3fb8031eb01fe23","modified":1496286320000},{"_id":"themes/next/.travis.yml","hash":"360f38044910e74bf628b0799e19db90718b2cbe","modified":1496286320000},{"_id":"themes/next/package.json","hash":"a5c189d4c4e946e936d3b5e29e2d81ddaf03ff96","modified":1496286320000},{"_id":"source/_drafts/Python-”ˆµΩµƒœ›⁄Â.md","hash":"1ae0484925ef6884e6e2de54c500bd27cf12620f","modified":1501483598000},{"_id":"source/_drafts/Pythonµ¸¥˙∂‘œÛ°¢µ¸¥˙∆˜°¢…˙≥…∆˜.md","hash":"4ffaf622dac55ada4fc217e3a3f73ca4ed0c5dd3","modified":1496828408000},{"_id":"source/_drafts/Running-Totals–¥∑®–‘ƒ‹∑÷Œˆ.md","hash":"ea305ebd652762cd6168382f900dfda5991f0192","modified":1497257922000},{"_id":"source/_drafts/SQL-Server-IO-Õ≥º∆.md","hash":"0745081d51e06286db3d2f25b7e57cea0326f337","modified":1498467040000},{"_id":"source/_drafts/SQL-Server- ˝æ›¥Ê¥¢∑Ω Ω.md","hash":"67f7f3859c3676ec5c98038d43c6a153a0284016","modified":1498553384000},{"_id":"source/_drafts/SQL-Server ¬ŒÒ.md","hash":"6d41f24630cda10f7aab89fca3527e010e9218ac","modified":1496822522000},{"_id":"source/_drafts/SQL-Server–‘ƒ‹”≈ªØœ‡πÿ.md","hash":"60a0e2cbca61ed7f3ca910aa9b540f36eed7ac1d","modified":1497432726000},{"_id":"source/_drafts/ ˝æ›≤÷ø‚‘ˆ¡ø ˝æ›¥¶¿Ìµƒº∏÷÷∑Ω∑®.md","hash":"ba033f062a546f89e8c57326c348158d5752df3c","modified":1496371504000},{"_id":"source/_drafts/∏„∂ÆPython±‡¬ÎŒ Ã‚.md","hash":"fb2eb07a0e07f3dbd7fdd7662a6178e21309161c","modified":1500454730000},{"_id":"source/categories/index.md","hash":"34e3bee79416eac995c00a928d1740cdb868db9d","modified":1495879814000},{"_id":"source/_posts/2015-07-16-Writing Blogs with Github Pages and Octopress.markdown","hash":"76548f824919ecd12848fd35ae6485a5cabb9e55","modified":1495882200000},{"_id":"source/_posts/2015-07-17-install-spark-on-mac-osx-yosemite.markdown","hash":"c6a43bec30a3266f631430eeb044cb62ca03c9f1","modified":1474337220000},{"_id":"source/_posts/2015-07-17-install-hadoop-on-mac-osx-yosemite.markdown","hash":"105f23ebe98bbdb509c479dbfdc4f8c8655def07","modified":1474337220000},{"_id":"source/_posts/2015-07-23-start-to-use-scikit-learn.markdown","hash":"c7aa649feb899f5e5906e71b869a77de523c7cd8","modified":1474337220000},{"_id":"source/_posts/2015-07-17-write-blog-from-different-machine.markdown","hash":"4c4423ab3a77062fe5db8f2748786e8d66fc9367","modified":1474337220000},{"_id":"source/_posts/2015-08-07-naive-bayes-classifier.markdown","hash":"dab7ca31b0633b923c13178763ae47fa6e673bf2","modified":1474337220000},{"_id":"source/_posts/2015-08-08-adding-support-for-math-formula.markdown","hash":"e89fbd7f9c0f8096c775e56d3221751142579923","modified":1474337220000},{"_id":"source/_posts/2015-08-11-some-note-about-naive-bayes.markdown","hash":"3f9a23c37cb03afaa78a241a2543cdd68bfb616b","modified":1474337220000},{"_id":"source/_posts/2015-08-12-logistic-regression-classifier-on-hands.markdown","hash":"5aa2f23ebfa412396a26f17774a654f70acd7f5e","modified":1474337220000},{"_id":"source/_posts/2015-08-12-word-count-example-in-spark.markdown","hash":"91aa08d7cd07d2a064e9d0c78946a761c930c7fb","modified":1474337220000},{"_id":"source/_posts/2015-08-19-linear-regression-with-one-variable.markdown","hash":"6e5376393ad772928572c3cea19a5c3b3f4cb429","modified":1474337220000},{"_id":"source/_posts/2015-09-18-about-regularization.markdown","hash":"31c2e614a3dc623a221cacbb8645da358e505e92","modified":1474337220000},{"_id":"source/_posts/2015-09-18-how-to-evaluate-algorithm.markdown","hash":"d55c35b328e2ca079a3203f9fd2556ad7191b8ce","modified":1474337220000},{"_id":"source/_posts/2015-11-26-bag-of-words-model.markdown","hash":"77c9c9a7545f31318086b396fafa168599a066a7","modified":1474337220000},{"_id":"source/_posts/2015-09-21-cross-validation-in-scikit-learn.markdown","hash":"a2b399235482e36b03932f8053af678a5d664162","modified":1474337220000},{"_id":"source/_posts/2015-11-27-understanding-tf-idf.markdown","hash":"735638de5041a42dd1b48d10c6c650ac54bb43bb","modified":1474337220000},{"_id":"source/_posts/AnacondaΩ‚æˆpython∞¸π‹¿Ì”Îª∑æ≥π‹¿Ì.md","hash":"f175994b0386e387ab5252b9275580df5547c1e2","modified":1496907688000},{"_id":"source/_posts/Flask-¥”»Î√≈µΩ∑≈∆˙1-Hello-World.md","hash":"01013a22311a7880bab277549b506bded9bd9712","modified":1501042652000},{"_id":"source/_posts/Flask-¥”»Î√≈µΩ∑≈∆˙2-…Ó»Î¿ÌΩ‚-app-route.md","hash":"bcb0ed96040ad2ee963693c9ba12c32dce262f01","modified":1501039032000},{"_id":"source/_posts/Flask-¥”»Î√≈µΩ∑≈∆˙3-‰÷»æƒ£∞Ê.md","hash":"99ec41b632449adc0b25be8030d9742e937face3","modified":1502701634000},{"_id":"source/_posts/Flask-¥”»Î√≈µΩ∑≈∆˙4-Web±Ìµ•.md","hash":"dfd874e5c5f6a5de604b3e33132da2b481dd66ff","modified":1502855972000},{"_id":"source/_posts/Flask-¥”»Î√≈µΩ∑≈∆˙5- ˝æ›ø‚≤Ÿ◊˜.md","hash":"ffa8c8d31ab3d397d7a82e17e824a66454a60229","modified":1503910484000},{"_id":"source/_posts/Flask-¥”»Î√≈µΩ∑≈∆˙6-Õ¯’æΩ·ππ◊Óº— µº˘.md","hash":"fa8cf3b2d4705c522406a1302f4262196cf27fc6","modified":1503913868000},{"_id":"source/_posts/Hexo-command-Cheatsheet.md","hash":"1a280105d24481ffdcd97367912583a1b97814e2","modified":1496907922000},{"_id":"source/_posts/Hexo…Ë÷√÷˜Ã‚∫Õ∆‰À˚≈‰÷√.md","hash":"d9fb06775ec33289ef801d566063a65178a3b4e4","modified":1496907706000},{"_id":"source/_posts/Markdown-Cheatsheet.md","hash":"ebdc2a1d612d79575b652756e82db862ac31a09c","modified":1496907910000},{"_id":"source/_posts/MongoDB-ª˘¥°÷™ ∂.md","hash":"20fe5e060e29924d5e90e0555717f8e04c3c4193","modified":1498721104000},{"_id":"source/_posts/MongoDB-CRUD-øÏÀŸ∏¥œ∞.md","hash":"f18b7fd45c46ae26c6354cbafc5afa51cd4b7d4b","modified":1498630546000},{"_id":"source/_posts/MongoDB-∑÷Œˆ≤È—Øº∆ªÆ.md","hash":"4b3bc029e27d888f991ab50b922c0c4a54f973c3","modified":1498721066000},{"_id":"source/_posts/MongoDBÀ˜“˝≤Ÿ◊˜.md","hash":"f9310e89e0981e7ed11dcf7ecbf3a77472fa7e14","modified":1498721070000},{"_id":"source/_posts/Python-CollectionºØ∫œƒ£øÈ.md","hash":"56b650bb7f2645a3614aeb97dc18fdf9cbcf923e","modified":1496199542000},{"_id":"source/_posts/Python-dict¿‡–Õµƒ µœ÷.md","hash":"21856c0e8d20505a80d61b2ee1d9a0f30d9b9ee4","modified":1500620726000},{"_id":"source/_posts/Python-«≥∏¥÷∆”Î…Ó∏¥÷∆.md","hash":"764138e4fa3654b3350d797d00e2f6dab7dda0c3","modified":1502275312000},{"_id":"source/_posts/Pythonª˘¥°÷™ ∂√Ê ‘Ã‚.md","hash":"d47842618eb3845508114fdb1e842278a06b1c8d","modified":1497599500000},{"_id":"source/_posts/Pythonƒ⁄÷√ ˝æ›Ω·ππ.md","hash":"882d1f537cf3ed757d8c56f0dd5c440a33301a3f","modified":1496199612000},{"_id":"source/_posts/SQL-Server ˝æ›ø‚∑÷“≥.md","hash":"457f253339743961a89022678b913db4211c1284","modified":1496199644000},{"_id":"source/_posts/SQL-Server-Slide-Window-partition.md","hash":"22285452e3930d7c98dda39f2a6678733593c823","modified":1498630914000},{"_id":"source/_posts/SQL-Server¥∞ø⁄∫Ø ˝ π”√.md","hash":"e64468d7ce01630684ea3489be2661f37d71e455","modified":1497599654000},{"_id":"source/_posts/SQL-Server±Ì∑÷«¯.md","hash":"ebff295f884317fe22ad1de772fee1cdfad7523d","modified":1498115398000},{"_id":"source/_posts/SQL-ServerÀ˜“˝.md","hash":"4de203eb1f7c445c7e3d0735ead8ae38b3aa13eb","modified":1497342384000},{"_id":"source/_posts/T-SQL≤È—Ø”Ôæ‰÷¥––À≥–Ú.md","hash":"aa2d984d7de94a8463c8f8581faf5e1463a70dc9","modified":1496727458000},{"_id":"source/_posts/git π”√–°Ω·.md","hash":"ee151a2931f566583009eaa2ac34d193135c5f07","modified":1496733020000},{"_id":"source/_posts/ ˝◊È∫Õ¡¥±Ì.md","hash":"d8dddb4717a72b36892cd279069fea095cc02ad0","modified":1497343604000},{"_id":"source/_posts/ π”√Scrapy±‡–¥≈¿≥Ê.md","hash":"29b001570eec1d2a261a665983744919ad5562f5","modified":1500620752000},{"_id":"source/_posts/ π”√d3.jsªÊÕº¡˜ÀÆ’À.md","hash":"3af8508080b07116b80ded7fe7b5df48582cefe9","modified":1496199740000},{"_id":"source/_posts/±∏∑›Hexo‘¥Œƒº˛÷¡GitHub.md","hash":"d451b50f5e9cb7423cde6f7d0045bf77c60bb152","modified":1496646238000},{"_id":"source/_posts/»Á∫Œ≈ƒ…„–«ø’.md","hash":"3929aaf2387aa326e4e8f0519fcc218bbd7b005b","modified":1495883288000},{"_id":"source/_posts/À—À˜∫Õ≈≈–Ú÷ÆÀ—À˜.md","hash":"5829fcfd24f4e4e8bd697bac5255a594c490fdcf","modified":1497260024000},{"_id":"source/_posts/À—À˜∫Õ≈≈–Ú÷Æ≈≈–Ú.md","hash":"9b5b35fdfa211d17688e77e7dd4060aebc5566e8","modified":1497259988000},{"_id":"source/_posts/ø¥∂ÆSQL-Server÷¥––º∆ªÆ.md","hash":"4db24bb923d698eea2b61a587f241ff1a06e5df4","modified":1497341602000},{"_id":"source/_posts/…Ëº∆∂Ã¡¥Ω”TinyURL.md","hash":"4e292d6b027f131a15ae32b138bf8c7ad0244274","modified":1495882330000},{"_id":"source/_posts/∂˛≤Ê ˜µƒ±È¿˙.md","hash":"886a58f7ab0ad6a1e4a392191f093b33918d2f9c","modified":1495882184000},{"_id":"source/_posts/∂—’ª∫Õ∂”¡–.md","hash":"50360d2f8c8c4cafdc212e157e26bbf38e731a59","modified":1497585216000},{"_id":"source/_posts/∏„∂ÆPython◊∞ Œ∆˜.md","hash":"81329d4a138f8cfb0503bb03d468e56b22d12850","modified":1500886818000},{"_id":"source/tags/index.md","hash":"8aa1fa9a149371e6f9465ef9d8fa99b337b33047","modified":1495879818000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1496286320000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"4de856de657a27f340f245eb491a1f52ceba1735","modified":1496286320000},{"_id":"themes/next/languages/de.yml","hash":"4be3e7d296d5592e0d111dfa6cbbff02602c972d","modified":1496286320000},{"_id":"themes/next/languages/default.yml","hash":"d912814caac150da1611c96843371a87714e52f9","modified":1496286320000},{"_id":"themes/next/languages/en.yml","hash":"b3ee45143bc014578db6b8ac0573f7c7b143a743","modified":1496286320000},{"_id":"themes/next/languages/fr-FR.yml","hash":"0d5bd8bbbeafb72506124ed35e7509debc753612","modified":1496286320000},{"_id":"themes/next/languages/id.yml","hash":"c0848e93bf33a1333ff232905b6b392b1e056dd1","modified":1496286320000},{"_id":"themes/next/languages/ja.yml","hash":"1a608dc799c0f9c36b626bac6fe3404acb45b86d","modified":1496286320000},{"_id":"themes/next/languages/ko.yml","hash":"5c811514aef401317a9ec38b95679d6d2ef0ad42","modified":1496286320000},{"_id":"themes/next/languages/pt-BR.yml","hash":"cc8b5a67ec87b0d5aec6e253bab67ec3cfe3069c","modified":1496286320000},{"_id":"themes/next/languages/pt.yml","hash":"943475a7d681f37ede579cd62da9c50568ca0f8d","modified":1496286320000},{"_id":"themes/next/languages/ru.yml","hash":"84d41a111e497236b2c1fa16e9b91668a1f37037","modified":1496286320000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"3111ce4cc5f30868b3628f9f805d2aef3b75d1c1","modified":1496286320000},{"_id":"themes/next/languages/zh-hk.yml","hash":"b58c0d85daa4d62b0c9753a59de0739aa0120735","modified":1496286320000},{"_id":"themes/next/languages/zh-tw.yml","hash":"8ce0a32411de111ae39d08e4bc936767dacdeb08","modified":1496286320000},{"_id":"themes/next/layout/_layout.swig","hash":"2709dd3c728b6c19f08fbc0755c8ac460930fbf7","modified":1496286960000},{"_id":"themes/next/layout/archive.swig","hash":"a1d1e91013baaaeb7deaf35c6d3975971ce38e02","modified":1496286320000},{"_id":"themes/next/layout/category.swig","hash":"f315f12651de8065fdad73b003da4335ef177173","modified":1496286320000},{"_id":"themes/next/layout/index.swig","hash":"4bf29f44ca9519a005671f2f2a79a48a148b435b","modified":1496286320000},{"_id":"themes/next/layout/page.swig","hash":"22ba721a9688d490fc66f360e5a319288b63b05a","modified":1496286320000},{"_id":"themes/next/layout/post.swig","hash":"182a99b1f6db0350106c6bb480fede0bbdb7e40f","modified":1496286320000},{"_id":"themes/next/layout/schedule.swig","hash":"8086f1163b10460258ecbbbe48b057b22bb2f02e","modified":1496286320000},{"_id":"themes/next/layout/tag.swig","hash":"cc9878932580c890f8f3e569225e29bb37e25b49","modified":1496286320000},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1496286320000},{"_id":"themes/next/scripts/merge-configs.js","hash":"3ce1be32bb77ee19da25e8dae7dc04e2afc46ca1","modified":1496286320000},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1496286320000},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1496286320000},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1496286320000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496286320000},{"_id":"source/_drafts/.idea/misc.xml","hash":"bea972e93dd15c587870a9b3508bacea1a3cbfbf","modified":1502959226000},{"_id":"source/_drafts/.idea/_drafts.iml","hash":"8040b6279a9fd9901af173ef1aa9505182833c81","modified":1502959278000},{"_id":"source/_drafts/.idea/markdown-navigator.xml","hash":"44c86c836bc21b539368a20071227d854b383d55","modified":1502959226000},{"_id":"source/_drafts/.idea/modules.xml","hash":"a9314c6238668c587ebda4770806e6130181d633","modified":1502959218000},{"_id":"source/_drafts/.idea/workspace.xml","hash":"53b292d287cdb04d9b1aee98ab9c2ec8cce80bea","modified":1502959968000},{"_id":"source/_posts/assets/Basic_DataStructure_Python-21a4b.png","hash":"ecca4307d731209478b2ce3db50c835395b6fdce","modified":1490347726000},{"_id":"source/_posts/assets/Basic_DataStructure_Python-277bd.png","hash":"c47ca496369e099fadb59bd067967d6eac700e25","modified":1490347802000},{"_id":"source/uploads/WeChatImage_20170527190034.jpg","hash":"c4e1130c593568d9bf90e25a613b080d2f6b0ccf","modified":1495882860000},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1496286320000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1496286320000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"5258c03149aa18e9abfeb8de10e435a406d9c924","modified":1496286320000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"683616f4a80796051e2346d80acf838a589450b0","modified":1496286320000},{"_id":"themes/next/layout/_partials/head.swig","hash":"09b110f77c415c5b71ebd886771a10bc84b95633","modified":1496286320000},{"_id":"themes/next/layout/_partials/header.swig","hash":"d6bf1d1554d91eaf1bfc40ba8905ae81673e5f45","modified":1496286320000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1496286320000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1496286320000},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1496286320000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1496286320000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"506feb56e9b1091187d2014742f63a17758df933","modified":1496286320000},{"_id":"themes/next/layout/_macro/post.swig","hash":"df3c4dbfab581607e01cc3794a40f9571861c71e","modified":1496654740000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"b6cb171f0ed227b82b8f7601814af2df93f3a09a","modified":1496286320000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"4b029551ddb44c53f895e96cf8ff5ffbe02322fb","modified":1496286320000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"c5cc0070ca7c9a8dbd4b09e0398db536c3cdbe8a","modified":1496286320000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1496286320000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1496286320000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"53c894e6f3573c662dc4e4f7b5a6f1a32f1a8c94","modified":1496286320000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1496286320000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1496286320000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1496286320000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1496286320000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1496286320000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1496286320000},{"_id":"themes/next/scripts/tags/button.js","hash":"aaf71be6b483fca7a65cd6296c2cf1c2271c26a6","modified":1496286320000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1496286320000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1496286320000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1496286320000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1496286320000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1496286320000},{"_id":"themes/next/scripts/tags/note.js","hash":"7dc14db08f2c74f8f1952534b424f220f5c000c6","modified":1496286320000},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1496286320000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1496286320000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1496286320000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1496286320000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1496286320000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1496286320000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1496286320000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1496286320000},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1496286320000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1496286320000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1496286320000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1496286320000},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1496286320000},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1496286320000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1496286320000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496286320000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496286320000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496286320000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496286320000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496286320000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496286320000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496286320000},{"_id":"source/_drafts/.idea/markdown-navigator/profiles_settings.xml","hash":"f6423751179372f7b3b5a7b4e2b153d832cd531a","modified":1502959218000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1496286320000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1496286320000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1496286320000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1496286320000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1496286320000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1496286320000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1496286320000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1496286320000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"12684840de632eb16e53ffa863166306a756fd4f","modified":1496286320000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1496286320000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1496286320000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1496286320000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1496286320000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1496286320000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1496286320000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a79e7e0d809fcf407593dd7ed9e023db21c3cbd6","modified":1496286320000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1496286320000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"441f1a1b4e2f652d3b975995bd9d44ff4866f057","modified":1496286320000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e495aed8fb36bf8015ddbd64366270a7debad2b0","modified":1496286320000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1496286320000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1496286320000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1496286320000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1496286320000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1496286320000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1496286320000},{"_id":"themes/next/layout/_third-party/comments/gentie.swig","hash":"0f38f053841ef77cdce56a84cfbb4dd4c3329486","modified":1496286320000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1496286320000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"0399bbdc524ba50930cb6f8e2d5628ff682fc612","modified":1496286320000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"c75024151fc63220e7d01035d8a1aff9affdecc7","modified":1496286320000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"de95ec8920d1660680078451008f8bd69f14d082","modified":1496286320000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1496286320000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"a0c042a74ea1afcb19daac7e2604a2bc5495037b","modified":1496286320000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1496286320000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1496286320000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1496286320000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"a0f23e75a137d8c996c70e2059e0074f1e97a127","modified":1496286320000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"531934ea21ef4dc9f0978512050f54834f0a6cff","modified":1496286320000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e55265c8a8a6ae0c3c08e3509de92ee62c3cb5f6","modified":1496286320000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"09534b68bd1a708729b3cfffe17737e3af457757","modified":1496286320000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"dacede1cc110c762e7a5468dc0e34ae1a962d5aa","modified":1496286320000},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1496286320000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1496286320000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0ec035e20d1f26bf553a79877180ba312bea885c","modified":1496286320000},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1496286320000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1496286320000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1496286320000},{"_id":"themes/next/source/js/src/motion.js","hash":"ff9ea37d05c269e3a140c4ab448af03efc4bcc76","modified":1496286320000},{"_id":"themes/next/source/js/src/particle.js","hash":"b9e15569215f0ef431a023d57eafb43072db6d29","modified":1496283378000},{"_id":"themes/next/source/js/src/post-details.js","hash":"bfaf52b69aad96566aa21b785973441a2555b4ba","modified":1496286320000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1496286320000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1496286320000},{"_id":"themes/next/source/js/src/utils.js","hash":"c976214b8bbaa9512b886bf3687e94696f705e33","modified":1496286320000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1496286320000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"68db2c0bf1064176627199394f25f6dc37ea23ad","modified":1496286320000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1496286320000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1496286320000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1496286320000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1496286320000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1496286320000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1496286320000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1496286320000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1496286320000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1496286320000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1496286320000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1496286320000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1496286320000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1496286320000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1496286320000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1496286320000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1496286320000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1496286320000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1496286320000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1496286320000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1496286320000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1496286320000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1496286320000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1496286320000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1496286320000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1496286320000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1496286320000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1496286320000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1496286320000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1496286320000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1496286320000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1496286320000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1496286320000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1496286320000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1496286320000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1496286320000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1496286320000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1496286320000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1496286320000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1496286320000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1496286320000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1496286320000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1496286320000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1496286320000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4ba6f2a615693b9b5afc266d9c833697016085fd","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"1dc2ed435e41ca041f43bd9633d5d95139afbb42","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"22828f5141c0cecb9ef25a110e194cdfa3a36423","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"88559b13ce94311405b170a0506ded91273beceb","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1496286320000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1496286320000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"4998bedff9c84a09a294b8ef36ede2e3644d3528","modified":1496286320000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1496286320000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1496286320000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"c9218b48c56e52c06af9ce3cc8fbdae737cf16fe","modified":1496286320000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"ce272226a1570f5f7c70243b751a5b0fe1671a88","modified":1496387688000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"f23ac53ab901c48859dd29eee6e386b60ff956ba","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"c48d4a561d047b3705924949b3ab7b57bee94ecd","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1496286320000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"c4358416f0a116d7f4037542fa3b385947e80908","modified":1496286320000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1496286320000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1496286320000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1496286320000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1496286320000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1496286320000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1496286320000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1496286320000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1496286320000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1496286320000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1496286320000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1496286320000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1496286320000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1496286320000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"95518d298d3c5c271faec2e4977df9e5dedd5d84","modified":1496286320000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1496286320000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1496286320000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1496286320000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1496286320000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1496286320000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"524cfca7b6ab135d81ea723d8de06fdf0dbe7e56","modified":1496286320000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1496286320000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1496286320000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"b3b783511bbd94af7e941abf8ff411885db7395b","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"104b5c79cd891506e0beaf938b083685f1da8637","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"4783f85872bc7e218c1522a5c1c68cd27a5922db","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"58f9e6aba94733244a87d2ba5966c5a009486509","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"658accf8e196721f295003da66941e6d1f7b81b0","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"8355b0e9375b3245508efda0e18acd069c2aa767","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"350469437b20ecfd6f3ca45e400478f8e3f71cfb","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"2cb09973d29a8e34e2a3425ac6e0938296970d8e","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/post/post-wordcount.styl","hash":"268c9704481fdb0b4d1e646196386143990fe235","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bc08cfb2ef2ff44ba3fc7dffdb2deb01a9d17d15","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"7f2bdd6109614d35408ee5ac3335aad4464c69c7","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"ac060861b27b764bc4012fc362a25a332df4045a","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"28a8737c090fbffd188d73a00b42e90b9ee57df2","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"c9f76d4f6806ef70fa2160c97afa0a0e0ae5373e","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"702be9e57dd6ff5fa99642a1f6e3df26215b8805","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"3159b55f35c40bd08e55b00148c523760a708c51","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"8420b4be386469337243336aee694297875bd439","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"e3ad37f2da35e330616a044621ffa50565a20c88","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"cd526e814f9323a79fe835085d64867d34b3715d","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1496286320000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"eb45ee16051624c6e36a274c0a9538e961f10c4d","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1496286320000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1496286320000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1496286320000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1496286320000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1496286320000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1496286320000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1496286320000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1496286320000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1496286320000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1496286320000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1496286320000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1496286320000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1496286320000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1496286320000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1496286320000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1496286320000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1496286320000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1496286320000},{"_id":"source/uploads/avatar.jpg","hash":"408437bd27b9996ba9e634cfa1b9e4afbc965568","modified":1495876216000},{"_id":"public/categories/index.html","hash":"d7c620361c473f044bcc9bf9058aed60d2486d4c","modified":1522814947093},{"_id":"public/tags/index.html","hash":"42661c7ab39a1e83d0fb2f12f1219060d4575af8","modified":1522814947093},{"_id":"public/2017/08/28/Flask-¥”»Î√≈µΩ∑≈∆˙6-Õ¯’æΩ·ππ◊Óº— µº˘/index.html","hash":"6c31e16e125734d5c3614bb8348de529994bb269","modified":1522814947093},{"_id":"public/2017/08/28/Flask-¥”»Î√≈µΩ∑≈∆˙5- ˝æ›ø‚≤Ÿ◊˜/index.html","hash":"c507c3947a41bf47a0dcbfb1282df11bf85b4ed0","modified":1522814947093},{"_id":"public/2017/08/15/Flask-¥”»Î√≈µΩ∑≈∆˙4-Web±Ìµ•/index.html","hash":"b186fe6aa77fde430dabcba19ba70ec955f0fdc0","modified":1522814947093},{"_id":"public/2017/08/14/Flask-¥”»Î√≈µΩ∑≈∆˙3-‰÷»æƒ£∞Ê/index.html","hash":"aafed3e053244e197b164bbf4f0d12fda96f8419","modified":1522814947093},{"_id":"public/2017/07/31/Python-«≥∏¥÷∆”Î…Ó∏¥÷∆/index.html","hash":"0a56d9e84835ea5fa9092ab2a9ef90db8a5bb08a","modified":1522814947094},{"_id":"public/2017/07/26/Flask-¥”»Î√≈µΩ∑≈∆˙2-…Ó»Î¿ÌΩ‚-app-route/index.html","hash":"44e953560720d4cedb8a0a9e591843f6c6440f37","modified":1522814947094},{"_id":"public/2017/07/25/Flask-¥”»Î√≈µΩ∑≈∆˙1-Hello-World/index.html","hash":"55f5b6f3f7d15711fe07783b8c8ef46046d339cc","modified":1522814947094},{"_id":"public/2017/07/20/∏„∂ÆPython◊∞ Œ∆˜/index.html","hash":"8d97fc3611ad615725e93e26b1c6dd1d6a8a9bb4","modified":1522814947094},{"_id":"public/2017/07/18/Python-dict¿‡–Õµƒ µœ÷/index.html","hash":"a6980754f4428a88bf9128f55a178be4edb2463d","modified":1522814947094},{"_id":"public/2017/06/29/MongoDBÀ˜“˝≤Ÿ◊˜/index.html","hash":"18028bd32a6ce35de540d39259f068e60ea40818","modified":1522814947094},{"_id":"public/2017/06/29/MongoDB-∑÷Œˆ≤È—Øº∆ªÆ/index.html","hash":"93ff1e51f584c89ad7ae1d0dc96499c0797be40a","modified":1522814947094},{"_id":"public/2017/06/28/MongoDB-CRUD-øÏÀŸ∏¥œ∞/index.html","hash":"3a103b98cb81ea49e4c9a03a3c3f80ece882d980","modified":1522814947094},{"_id":"public/2017/06/27/MongoDB-ª˘¥°÷™ ∂/index.html","hash":"4f0a6524f899a62e9232b315c6fa569ca448ad94","modified":1522814947094},{"_id":"public/2017/06/22/SQL-Server-Slide-Window-partition/index.html","hash":"5168307b1ea81d324b4f631c4fa4553ca412f2bc","modified":1522814947094},{"_id":"public/2017/06/21/SQL-Server±Ì∑÷«¯/index.html","hash":"f55af0ab3cb334f2829384990bfea22c90829523","modified":1522814947094},{"_id":"public/2017/06/13/∂—’ª∫Õ∂”¡–/index.html","hash":"476f34255ee79bcc6200b2df01a501ce7c0dbd3f","modified":1522814947094},{"_id":"public/2017/06/13/ ˝◊È∫Õ¡¥±Ì/index.html","hash":"ee4d5aadcdf8aca6059f7d42aa8c8a861642bf1a","modified":1522814947094},{"_id":"public/2017/06/12/À—À˜∫Õ≈≈–Ú÷ÆÀ—À˜/index.html","hash":"254b60338554c5bad9974e22748563816e4aa4b4","modified":1522814947094},{"_id":"public/2017/06/12/À—À˜∫Õ≈≈–Ú÷Æ≈≈–Ú/index.html","hash":"85db2dd06840f48b3a76ba885293dc997b77d544","modified":1522814947094},{"_id":"public/2017/06/12/Pythonª˘¥°÷™ ∂√Ê ‘Ã‚/index.html","hash":"ec8084ad334d9c74a470e0b62e64fb394dc2634e","modified":1522814947095},{"_id":"public/2017/06/12/SQL-Server¥∞ø⁄∫Ø ˝ π”√/index.html","hash":"60732372afee9f2042ee326b0f69bb994fa4ce62","modified":1522814947095},{"_id":"public/2017/06/08/AnacondaΩ‚æˆpython∞¸π‹¿Ì”Îª∑æ≥π‹¿Ì/index.html","hash":"7f9514059b29747985948263f7642231362fb23f","modified":1522814947095},{"_id":"public/2017/06/06/T-SQL≤È—Ø”Ôæ‰÷¥––À≥–Ú/index.html","hash":"bd7cbda3a73fd7c59c4958ef53ca410a26d4c4a6","modified":1522814947095},{"_id":"public/2017/06/05/Hexo-command-Cheatsheet/index.html","hash":"6847f5498daf1d8f19a3058a0b21de891d5df990","modified":1522814947095},{"_id":"public/2017/06/05/Hexo…Ë÷√÷˜Ã‚∫Õ∆‰À˚≈‰÷√/index.html","hash":"7f6eca23b1b1dd168e91678a2c3d7aeeabc62d74","modified":1522814947095},{"_id":"public/2017/06/02/SQL-ServerÀ˜“˝/index.html","hash":"633ed51bbee67b99b93aff22642ea6503679ce53","modified":1522814947095},{"_id":"public/2017/06/02/ø¥∂ÆSQL-Server÷¥––º∆ªÆ/index.html","hash":"db2deab4b964c263e422dfe3e4ddb749a5c340df","modified":1522814947095},{"_id":"public/2017/05/31/Markdown-Cheatsheet/index.html","hash":"65778e3a584986d03b289f6bea303ee35108818c","modified":1522814947095},{"_id":"public/2017/05/27/…Ëº∆∂Ã¡¥Ω”TinyURL/index.html","hash":"c46e0cc4c0607801472c0f9ef97b17dc6084a14e","modified":1522814947095},{"_id":"public/2017/05/27/Python-CollectionºØ∫œƒ£øÈ/index.html","hash":"58d9afd47d5f50d73c137252da9b5e9b8329aa02","modified":1522814947095},{"_id":"public/2017/05/27/SQL-Server ˝æ›ø‚∑÷“≥/index.html","hash":"254b297a92f2dd29e1bc87f8ab6dea0b5ef729c7","modified":1522814947095},{"_id":"public/2017/05/27/∂˛≤Ê ˜µƒ±È¿˙/index.html","hash":"7302be4cac52104fa8fef45ac3c50d05c9d65d4e","modified":1522814947095},{"_id":"public/2017/05/27/Pythonƒ⁄÷√ ˝æ›Ω·ππ/index.html","hash":"4a14bb986b3af3c33c3cc9813fa25572530d4d34","modified":1522814947095},{"_id":"public/2016/09/20/git π”√–°Ω·/index.html","hash":"105744b8ec4ee0636ae192dd54a30155b0d69429","modified":1522814947096},{"_id":"public/2016/09/18/ π”√Scrapy±‡–¥≈¿≥Ê/index.html","hash":"b44a29200643c5b5e2cc310815d18322e30bd7b4","modified":1522814947096},{"_id":"public/2016/09/07/»Á∫Œ≈ƒ…„–«ø’/index.html","hash":"68ae8310b146e3e902b0603a0e91e1ca3057e027","modified":1522814947096},{"_id":"public/2016/05/31/±∏∑›Hexo‘¥Œƒº˛÷¡GitHub/index.html","hash":"2cdbd75a8ca364370786bc152dd9998c34ff3947","modified":1522814947096},{"_id":"public/2015/11/28/ π”√d3.jsªÊÕº¡˜ÀÆ’À/index.html","hash":"c6eafb1fc49c657349edc4724eb152912f47c608","modified":1522814947096},{"_id":"public/2015/11/27/2015-11-27-understanding-tf-idf/index.html","hash":"36d481cfe3f8c83881785359975044283bef19f2","modified":1522814947096},{"_id":"public/2015/11/26/2015-11-26-bag-of-words-model/index.html","hash":"b8e0d4066ba876d1c4c2332e0da94c13f51589c8","modified":1522814947096},{"_id":"public/2015/09/21/2015-09-21-cross-validation-in-scikit-learn/index.html","hash":"65589224cacf10a7a8b37c783ce02e786899f4d0","modified":1522814947096},{"_id":"public/2015/09/18/2015-09-18-about-regularization/index.html","hash":"3961f1f82277c51c179d8536cdf1c04751be94a9","modified":1522814947096},{"_id":"public/2015/08/19/2015-08-12-logistic-regression-classifier-on-hands/index.html","hash":"1e78ffb1f3401cee99ab96ef50b27d0f638e8ff6","modified":1522814947096},{"_id":"public/2015/08/13/2015-08-19-linear-regression-with-one-variable/index.html","hash":"c4a688b496c83af8a584734e9a16225bc405edd7","modified":1522814947096},{"_id":"public/2015/08/12/2015-08-12-word-count-example-in-spark/index.html","hash":"f74a1100e459d6d792a9edca6fed44b0480f4c22","modified":1522814947096},{"_id":"public/2015/08/11/2015-08-11-some-note-about-naive-bayes/index.html","hash":"fcecf74900ee59c671fd96c595199698f6b5874c","modified":1522814947096},{"_id":"public/2015/08/08/2015-08-08-adding-support-for-math-formula/index.html","hash":"238962d0401d957d5087bf3a5575bd247d538de8","modified":1522814947096},{"_id":"public/2015/08/07/2015-08-07-naive-bayes-classifier/index.html","hash":"f1f77d28e9a4c83a7f6644a87b435a3688f811ad","modified":1522814947096},{"_id":"public/2015/07/23/2015-07-23-start-to-use-scikit-learn/index.html","hash":"aee3f26d052c578479acebc7e22cd626d780604d","modified":1522814947096},{"_id":"public/2015/07/17/2015-07-17-install-spark-on-mac-osx-yosemite/index.html","hash":"88f14ab41af6d81d55321e2b3d2abb17bfb08817","modified":1522814947096},{"_id":"public/2015/07/17/2015-07-17-install-hadoop-on-mac-osx-yosemite/index.html","hash":"ccf170c7d8f15fc1f05eed16e915ec530ee1f6ba","modified":1522814947096},{"_id":"public/2015/07/17/2015-07-17-write-blog-from-different-machine/index.html","hash":"7808f5f231b29af1aac079fb01598f9bb8a2babd","modified":1522814947096},{"_id":"public/2015/07/16/2015-07-16-Writing Blogs with Github Pages and Octopress/index.html","hash":"e0ed18a85a719b209af87a81c736622afb573860","modified":1522814947097},{"_id":"public/categories/备忘/index.html","hash":"1890946775a6f1cec609b0dd8d7b3dede89e4dc3","modified":1522814947097},{"_id":"public/categories/Big-Data/index.html","hash":"eaf2f5b43f4bc5ec02a89363a3e74d6d5d1d10a1","modified":1522814947097},{"_id":"public/categories/算法/index.html","hash":"881a4a4061ca8154af0bdd6f7738109fe74ce4a5","modified":1522814947097},{"_id":"public/categories/Big-Data/Spark/index.html","hash":"554db8e2cd3b1470ae23011a06cf57d4540d72e4","modified":1522814947097},{"_id":"public/categories/Big-Data/Hadoop/index.html","hash":"6e0c0ffce3ff73a95fae50fcb212fa8eb66c18a3","modified":1522814947097},{"_id":"public/categories/算法/Python/index.html","hash":"d79495f09efcdf0488c6e7ae3c8499852b843fba","modified":1522814947097},{"_id":"public/categories/算法/Kaggle/index.html","hash":"66466be2a062d53e9909b34c8307b38a2a6dac47","modified":1522814947097},{"_id":"public/categories/Flask从入门到放弃/index.html","hash":"937fd259c7590941085321a6154be81fb88b67fd","modified":1522814947097},{"_id":"public/categories/Python/index.html","hash":"5bdff4f92048ab978977b63adfabfa00e75b5281","modified":1522814947097},{"_id":"public/categories/Python/框架/index.html","hash":"87681cb19e98c0b572ccff7d2846a1da3a045433","modified":1522814947097},{"_id":"public/archives/index.html","hash":"fe718a45444d14cea643b63df9aa8a70c3d337b2","modified":1522814947098},{"_id":"public/archives/page/2/index.html","hash":"0add765351443cbbbd3a32aa0f6534b463dfbcac","modified":1522814947098},{"_id":"public/archives/page/3/index.html","hash":"0c0a45332ac78db1e2a2af2b9ef04a3974f1d98f","modified":1522814947098},{"_id":"public/archives/2015/index.html","hash":"bdc73bbea4d629872e88019d58777a82690eb348","modified":1522814947098},{"_id":"public/archives/2015/07/index.html","hash":"f6d57c2f5f5a572763c186d1889a3fcdd8ac53bd","modified":1522814947098},{"_id":"public/archives/2015/08/index.html","hash":"065601ff7784e4e226a60e3373394b62b07e0b40","modified":1522814947098},{"_id":"public/archives/2015/09/index.html","hash":"f762ec2a9b11133073a8affd3bb114411ec9d3db","modified":1522814947098},{"_id":"public/archives/2015/11/index.html","hash":"d17de35adb91fcd7cd0c8f45ff4e7dac6679763d","modified":1522814947098},{"_id":"public/archives/2016/index.html","hash":"084e27072ad852ec66b883f8dcb40dd57fb50024","modified":1522814947098},{"_id":"public/archives/2016/05/index.html","hash":"0782c1c69e5fe190e0e53def20558747749b93ef","modified":1522814947098},{"_id":"public/archives/2016/09/index.html","hash":"a8fee070419398a759d97790c0a068c39ee8eaab","modified":1522814947098},{"_id":"public/archives/2017/index.html","hash":"2b828852c26415f8b633bd30ce22d89a7be4f0cf","modified":1522814947098},{"_id":"public/archives/2017/page/2/index.html","hash":"c39481f49cf21237def5a90423d22777b4d7242c","modified":1522814947098},{"_id":"public/archives/2017/05/index.html","hash":"90bab17cef92880e028b722af3980c5b7d983ae3","modified":1522814947098},{"_id":"public/archives/2017/06/index.html","hash":"73bc12f52f7e287a6d3da0a75e2cdce3ac7e7f17","modified":1522814947098},{"_id":"public/archives/2017/07/index.html","hash":"61c425e7857b090e7a1560bfe0af03855acee546","modified":1522814947098},{"_id":"public/archives/2017/08/index.html","hash":"2c459ca19cf8045ac4985c94514517ed161f9678","modified":1522814947098},{"_id":"public/index.html","hash":"db27e35e1189567046b4d444468eee2df1738c8a","modified":1522814947098},{"_id":"public/page/2/index.html","hash":"1f810d6336ced3d041614c3ab7ce0ab8db501f1c","modified":1522814947098},{"_id":"public/page/3/index.html","hash":"eed12b983cac55243ff27856db04d48c79a59486","modified":1522814947099},{"_id":"public/page/4/index.html","hash":"ed93fb93e61fd3a77acc3f9315555ea8f3901dca","modified":1522814947099},{"_id":"public/page/5/index.html","hash":"a2fe71ca5184fda413ada732f30fff49e9132681","modified":1522814947099},{"_id":"public/page/6/index.html","hash":"1226a73153589fdcf06b539473d88478e015fe90","modified":1522814947099},{"_id":"public/page/7/index.html","hash":"f42e77fee36e952f3bdfe2159a3572094b8f7341","modified":1522814947099},{"_id":"public/page/8/index.html","hash":"d7e198ee30d8ea41ec31410ed5c362260048c0f5","modified":1522814947099},{"_id":"public/page/9/index.html","hash":"6cba7af1ea9606b74e6be3b615417897110b0ff0","modified":1522814947099},{"_id":"public/page/10/index.html","hash":"761b32295094f3ef0d4637bb3272ff1266208afa","modified":1522814947099},{"_id":"public/page/11/index.html","hash":"25e3f091211b183657ca4eb4501e3c14aa9c5afd","modified":1522814947099},{"_id":"public/tags/SQL-Server/index.html","hash":"c2b10dcd884043c64d77e7bf6b677f6adc7aed55","modified":1522814947099},{"_id":"public/tags/Octopress/index.html","hash":"1e49fe67cdd9d67ebed20eafd16b5cc619148e3b","modified":1522814947099},{"_id":"public/tags/Big-Data/index.html","hash":"fb8d011f6fe8873331273d56685f6c375edf0358","modified":1522814947099},{"_id":"public/tags/Spark/index.html","hash":"5c542947f776efa7894a04a800af021b9973b809","modified":1522814947099},{"_id":"public/tags/Hadoop/index.html","hash":"9adf8eb9de604170a4c67357219995094fcc436f","modified":1522814947099},{"_id":"public/tags/Machine-Learning/index.html","hash":"89ca2cd7ea455acd2da8bd3fb2744a4b1a5b9bbd","modified":1522814947099},{"_id":"public/tags/Python/index.html","hash":"274f476c4581fe5df4b451364a46b486f13e7e4e","modified":1522814947099},{"_id":"public/tags/Python/page/2/index.html","hash":"3cb9a989824d61b4379b3123275ea6d95a62e461","modified":1522814947100},{"_id":"public/tags/Scikit-Learn/index.html","hash":"990694679df43f7a44ecf33473fffc988d2deb71","modified":1522814947100},{"_id":"public/tags/Algorithm/index.html","hash":"794066fa851c2b404e02f219fec8b55b85a60bb5","modified":1522814947100},{"_id":"public/tags/Bayes/index.html","hash":"95f34900772830cc726574a503bc811dfee4e549","modified":1522814947100},{"_id":"public/tags/Logistic-Regression/index.html","hash":"da558f73e7e286c947a7b4eab308804442f903d2","modified":1522814947100},{"_id":"public/tags/Coursera/index.html","hash":"2f7f916baafc597d726306169a66a811f5c8d13e","modified":1522814947100},{"_id":"public/tags/Kaggle/index.html","hash":"f2c396dad0c52884e9fcce96ad2046ec3a91bd9b","modified":1522814947100},{"_id":"public/tags/Text-Mining/index.html","hash":"c2ff4649b29c8a0c9e08a8c03c20c6451797054f","modified":1522814947100},{"_id":"public/tags/Feature-Extraction/index.html","hash":"47836cf5ae7417f15346d7b5edfc7681b763f5d4","modified":1522814947100},{"_id":"public/tags/NLP/index.html","hash":"2f23eddf11a26d00d63b8fdd1601fb92c0ead141","modified":1522814947100},{"_id":"public/tags/Anaconda/index.html","hash":"198324f3844d3cc7e3abec87595f8c97044a3218","modified":1522814947101},{"_id":"public/tags/Flask/index.html","hash":"fd848026bb788e1ed8a88370c90d0520d6124898","modified":1522814947101},{"_id":"public/tags/hexo/index.html","hash":"e0bb41bab6ee85035538f21fcd9b205bf98aae20","modified":1522814947101},{"_id":"public/tags/Cheat-Sheet/index.html","hash":"71695c4de8cc854144549b05b5dd1bbba4a13d05","modified":1522814947101},{"_id":"public/tags/Markdown/index.html","hash":"8501b7ceeb5a4488ba533227501db9b05a320802","modified":1522814947101},{"_id":"public/tags/备忘/index.html","hash":"e6365012312afdcef0227dc7e435a187ef1b4e18","modified":1522814947101},{"_id":"public/tags/MongoDB/index.html","hash":"2373c117890a8f38d37951ca6fbe2b182c42e22a","modified":1522814947101},{"_id":"public/tags/Data-Structure/index.html","hash":"74c14bc3d33d30f21928b334ddce41e4dd195395","modified":1522814947101},{"_id":"public/tags/dict/index.html","hash":"dda2483ff568b67ba39e9cf221e3d75c4348d1e6","modified":1522814947101},{"_id":"public/tags/hash/index.html","hash":"ba5b008422e9977d94809fae94b65947a0a44f94","modified":1522814947101},{"_id":"public/tags/Reference/index.html","hash":"7602fe2e3c56a4ad4d655c772a805c4fc31081c8","modified":1522814947101},{"_id":"public/tags/面试/index.html","hash":"de3221250e6e4e0dc78813bd515da7b4084535ed","modified":1522814947101},{"_id":"public/tags/Database/index.html","hash":"afbf4373c4a94ade04fdf56979d390e446c16cd2","modified":1522814947101},{"_id":"public/tags/表分区/index.html","hash":"9d813a8edf290bfc4ca84c8893a9d4164d5fc5a2","modified":1522814947101},{"_id":"public/tags/SQL/index.html","hash":"c472a3a563727de618312751a63cbca8303c2c5d","modified":1522814947101},{"_id":"public/tags/git/index.html","hash":"8ee32f49faed7746c453bd59f6771b52d83efd87","modified":1522814947101},{"_id":"public/tags/github/index.html","hash":"2465ed7bca171a3bc8a2611b1ab68cf5720ee82b","modified":1522814947101},{"_id":"public/tags/爬虫/index.html","hash":"df0095adffdfdfd40acb0a6eeb7e8a39f30185c1","modified":1522814947101},{"_id":"public/tags/d3-js/index.html","hash":"a30239d2db22ff151efff44960f2ee438862f088","modified":1522814947102},{"_id":"public/tags/visualization/index.html","hash":"cf9d25f94d811d7716251c84755cfebb3403d695","modified":1522814947102},{"_id":"public/tags/摄影/index.html","hash":"136fa3bc4a9a7ffb0c5c72901e3b693d73b7429b","modified":1522814947102},{"_id":"public/tags/leetcode/index.html","hash":"5097516f66feb15350e3374cb9e7319b96446e43","modified":1522814947102},{"_id":"public/tags/装饰器/index.html","hash":"0809e9fea0738494e3d9b2212eef6530b442598e","modified":1522814947102},{"_id":"public/favicon.ico","hash":"74cc44e62e66f44c5dc1638b28f1b60c8a829899","modified":1522814947110},{"_id":"public/images/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1522814947110},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1522814947110},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1522814947110},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1522814947110},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1522814947110},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1522814947110},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1522814947110},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1522814947110},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1522814947110},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1522814947110},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1522814947110},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1522814947110},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1522814947110},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1522814947110},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1522814947110},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1522814947110},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1522814947110},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1522814947110},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1522814947111},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1522814947111},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1522814947111},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1522814947111},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1522814947111},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1522814947111},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1522814947111},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1522814947111},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1522814947111},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1522814947111},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1522814947521},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1522814947527},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1522814947539},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1522814947539},{"_id":"public/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1522814947539},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1522814947539},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1522814947539},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1522814947540},{"_id":"public/js/src/particle.js","hash":"d49dedb59fd1c2252241b3bdbf0fef25b3299fb7","modified":1522814947540},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1522814947540},{"_id":"public/js/src/post-details.js","hash":"af7a417dd1cb02465a7b98211653e7c6192e6d55","modified":1522814947540},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1522814947540},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1522814947540},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1522814947540},{"_id":"public/js/src/utils.js","hash":"b2ea56de27fddc6d9118051da384f781cd93951d","modified":1522814947540},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"3587602ad777b031628bb5944864d1a4fcfea4ac","modified":1522814947540},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1522814947540},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1522814947540},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1522814947540},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1522814947540},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1522814947540},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1522814947540},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1522814947540},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1522814947540},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1522814947540},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1522814947541},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1522814947541},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1522814947541},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1522814947541},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1522814947541},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1522814947542},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1522814947542},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1522814947542},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1522814947542},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1522814947542},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1522814947542},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1522814947542},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1522814947542},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1522814947542},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1522814947542},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1522814947542},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1522814947547},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1522814947547},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1522814947547},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1522814947547},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1522814947547},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1522814947547},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1522814947547},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1522814947547},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1522814947547},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1522814947547},{"_id":"public/css/main.css","hash":"7eb9c01753d24742b63fc1f6321d6abcf7ba2b55","modified":1522814947547},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1522814947547},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1522814947547},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1522814947547},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1522814947547},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1522814947547},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1522814947547},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1522814947547},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1522814947547},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1522814947548},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1522814947548},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1522814947548},{"_id":"public/lib/Han/dist/han.min.css","hash":"d9c0b3dc9158e717fde36f554709e6c3a22b5f85","modified":1522814947548},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1522814947548},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1522814947548},{"_id":"public/lib/Han/dist/han.css","hash":"38e48f275ad00daa9dcdcb8d9b44e576acda4707","modified":1522814947548},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1522814947548},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1522814947548},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1522814947548},{"_id":"public/uploads/WeChatImage_20170527190034.jpg","hash":"c4e1130c593568d9bf90e25a613b080d2f6b0ccf","modified":1522814947548},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1522814947549},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1522814947549},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1522814947549},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1522814947563},{"_id":"public/uploads/avatar.jpg","hash":"408437bd27b9996ba9e634cfa1b9e4afbc965568","modified":1522814947608}],"Category":[{"name":"备忘","_id":"cjfkkp3n7000fzd68b6b7m1ua"},{"name":"Big Data","_id":"cjfkkp3na000mzd685r9ffpe5"},{"name":"算法","_id":"cjfkkp3nh000zzd6896hddda8"},{"name":"Spark","parent":"cjfkkp3na000mzd685r9ffpe5","_id":"cjfkkp3np001czd68188u66oy"},{"name":"Hadoop","parent":"cjfkkp3na000mzd685r9ffpe5","_id":"cjfkkp3nu001nzd685yyxmrzs"},{"name":"Python","parent":"cjfkkp3nh000zzd6896hddda8","_id":"cjfkkp3o4002azd68r34u88ba"},{"name":"Machine Learning","_id":"cjfkkp3oc002tzd68jghcej8e"},{"name":"Kaggle","parent":"cjfkkp3nh000zzd6896hddda8","_id":"cjfkkp3of0030zd68576qu4r6"},{"name":"Flask从入门到放弃","_id":"cjfkkp3oi0036zd68svvb8aa3"},{"name":"Scikit-Learn","parent":"cjfkkp3oc002tzd68jghcej8e","_id":"cjfkkp3p8004gzd68z08jbhbj"},{"name":"Python","_id":"cjfkkp3pd004mzd68g3slamhl"},{"name":"Python","parent":"cjfkkp3p8004gzd68z08jbhbj","_id":"cjfkkp3pg004szd68i54g98v0"},{"name":"框架","parent":"cjfkkp3pd004mzd68g3slamhl","_id":"cjfkkp3pi004yzd68kl0yth5g"}],"Data":[],"Page":[{"title":"category","date":"2017-05-27T09:27:23.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: category\ndate: 2017-05-27 17:27:23\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-05-27T10:10:14.000Z","path":"categories/index.html","layout":"page","_id":"cjfkkp3mq0001zd68qz7uuoq5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tag","date":"2017-05-27T09:21:46.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tag\ndate: 2017-05-27 17:21:46\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-05-27T10:10:18.000Z","path":"tags/index.html","layout":"page","_id":"cjfkkp3um0091zd68lptzuquy","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Python 遇到的陷阱","_content":"","source":"_drafts/Python-”ˆµΩµƒœ›⁄Â.md","raw":"---\ntitle: Python 遇到的陷阱\ntags:\n---\n","slug":"Python-”ˆµΩµƒœ›⁄Â","published":0,"date":"2017-07-31T06:46:38.000Z","updated":"2017-07-31T06:46:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3mn0000zd686mybc1i2","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Python迭代对象、迭代器、生成器","_content":"","source":"_drafts/Pythonµ¸¥˙∂‘œÛ°¢µ¸¥˙∆˜°¢…˙≥…∆˜.md","raw":"---\ntitle: Python迭代对象、迭代器、生成器\ntags:\n---\n","slug":"Pythonµ¸¥˙∂‘œÛ°¢µ¸¥˙∆˜°¢…˙≥…∆˜","published":0,"date":"2017-06-07T09:40:08.000Z","updated":"2017-06-07T09:40:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3mr0002zd68dltaxz1p","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Running Totals写法性能分析","_content":"","source":"_drafts/Running-Totals–¥∑®–‘ƒ‹∑÷Œˆ.md","raw":"---\ntitle: Running Totals写法性能分析\ntags:\n---\n","slug":"Running-Totals–¥∑®–‘ƒ‹∑÷Œˆ","published":0,"date":"2017-06-12T08:58:42.000Z","updated":"2017-06-12T08:58:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3mt0003zd68we926ryq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"SQL-Server IO 统计","_content":"\n\n``` sql\nSET STATISTICS IO ON\n\nSELECT *\nFROM Sales.SalesOrderDetail\n```\n\n在执行结果的消息里面显示如下信息：\n\n```\nTable 'SalesOrderDetail'.\nScan count 1,\nlogical reads 1246,\nphysical reads 0,\nread-ahead reads 0,\nlob logical reads 0,\nlob physical reads 0,\nlob read-ahead reads 0.\n```\n\n- 预读：在查询计划生成的过程中，用估计的信息去硬盘读取数据到缓存中，预读1242页，也就是从硬盘中读取了1242页放到了缓存中。\n- 物理读：查询计划生成好以后，如果缓存缺少所需要的数据，再从硬盘里读取缺少的数据到缓存里。\n- 逻辑读：从缓存中读取数据。逻辑读1240次，也就是从缓存中读取1240页数据。\n","source":"_drafts/SQL-Server-IO-Õ≥º∆.md","raw":"---\ntitle: SQL-Server IO 统计\ntags:\n    - SQL Server\n---\n\n\n``` sql\nSET STATISTICS IO ON\n\nSELECT *\nFROM Sales.SalesOrderDetail\n```\n\n在执行结果的消息里面显示如下信息：\n\n```\nTable 'SalesOrderDetail'.\nScan count 1,\nlogical reads 1246,\nphysical reads 0,\nread-ahead reads 0,\nlob logical reads 0,\nlob physical reads 0,\nlob read-ahead reads 0.\n```\n\n- 预读：在查询计划生成的过程中，用估计的信息去硬盘读取数据到缓存中，预读1242页，也就是从硬盘中读取了1242页放到了缓存中。\n- 物理读：查询计划生成好以后，如果缓存缺少所需要的数据，再从硬盘里读取缺少的数据到缓存里。\n- 逻辑读：从缓存中读取数据。逻辑读1240次，也就是从缓存中读取1240页数据。\n","slug":"SQL-Server-IO-Õ≥º∆","published":0,"date":"2017-06-26T08:50:40.000Z","updated":"2017-06-26T08:50:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3mu0004zd68tou7spz9","content":"<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> <span class=\"keyword\">STATISTICS</span> IO <span class=\"keyword\">ON</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.SalesOrderDetail</span><br></pre></td></tr></table></figure>\n<p>在执行结果的消息里面显示如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Table &apos;SalesOrderDetail&apos;.</span><br><span class=\"line\">Scan count 1,</span><br><span class=\"line\">logical reads 1246,</span><br><span class=\"line\">physical reads 0,</span><br><span class=\"line\">read-ahead reads 0,</span><br><span class=\"line\">lob logical reads 0,</span><br><span class=\"line\">lob physical reads 0,</span><br><span class=\"line\">lob read-ahead reads 0.</span><br></pre></td></tr></table></figure>\n<ul>\n<li>预读：在查询计划生成的过程中，用估计的信息去硬盘读取数据到缓存中，预读1242页，也就是从硬盘中读取了1242页放到了缓存中。</li>\n<li>物理读：查询计划生成好以后，如果缓存缺少所需要的数据，再从硬盘里读取缺少的数据到缓存里。</li>\n<li>逻辑读：从缓存中读取数据。逻辑读1240次，也就是从缓存中读取1240页数据。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> <span class=\"keyword\">STATISTICS</span> IO <span class=\"keyword\">ON</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.SalesOrderDetail</span><br></pre></td></tr></table></figure>\n<p>在执行结果的消息里面显示如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Table &apos;SalesOrderDetail&apos;.</span><br><span class=\"line\">Scan count 1,</span><br><span class=\"line\">logical reads 1246,</span><br><span class=\"line\">physical reads 0,</span><br><span class=\"line\">read-ahead reads 0,</span><br><span class=\"line\">lob logical reads 0,</span><br><span class=\"line\">lob physical reads 0,</span><br><span class=\"line\">lob read-ahead reads 0.</span><br></pre></td></tr></table></figure>\n<ul>\n<li>预读：在查询计划生成的过程中，用估计的信息去硬盘读取数据到缓存中，预读1242页，也就是从硬盘中读取了1242页放到了缓存中。</li>\n<li>物理读：查询计划生成好以后，如果缓存缺少所需要的数据，再从硬盘里读取缺少的数据到缓存里。</li>\n<li>逻辑读：从缓存中读取数据。逻辑读1240次，也就是从缓存中读取1240页数据。</li>\n</ul>\n"},{"title":"SQL-Server 数据存储方式","_content":"\nSQL Server把数据记录存在数据页（Data Page）里。数据记录是堆表里、聚集索引里叶子节点的行。\n\n数据页由3个部分组成。页头（标头），数据区（数据行和可用空间）及行偏移数组。\n","source":"_drafts/SQL-Server- ˝æ›¥Ê¥¢∑Ω Ω.md","raw":"---\ntitle: SQL-Server 数据存储方式\ntags:\n---\n\nSQL Server把数据记录存在数据页（Data Page）里。数据记录是堆表里、聚集索引里叶子节点的行。\n\n数据页由3个部分组成。页头（标头），数据区（数据行和可用空间）及行偏移数组。\n","slug":"SQL-Server- ˝æ›¥Ê¥¢∑Ω Ω","published":0,"date":"2017-06-27T08:49:44.000Z","updated":"2017-06-27T08:49:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3mv0005zd68y1t6dpbx","content":"<p>SQL Server把数据记录存在数据页（Data Page）里。数据记录是堆表里、聚集索引里叶子节点的行。</p>\n<p>数据页由3个部分组成。页头（标头），数据区（数据行和可用空间）及行偏移数组。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>SQL Server把数据记录存在数据页（Data Page）里。数据记录是堆表里、聚集索引里叶子节点的行。</p>\n<p>数据页由3个部分组成。页头（标头），数据区（数据行和可用空间）及行偏移数组。</p>\n"},{"title":"SQL Server事务","_content":"","source":"_drafts/SQL-Server ¬ŒÒ.md","raw":"---\ntitle: SQL Server事务\ntags:\n---\n","slug":"SQL-Server ¬ŒÒ","published":0,"date":"2017-06-07T08:02:02.000Z","updated":"2017-06-07T08:02:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3mw0007zd68525shb68","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"SQL Server性能优化相关","_content":"\n## 表、索引扫描的改进\n\n\n## RID Lookup、Key Lookup改进\n\n\n## ","source":"_drafts/SQL-Server–‘ƒ‹”≈ªØœ‡πÿ.md","raw":"---\ntitle: SQL Server性能优化相关\ntags:\n     - SQL Server\n     - 优化\n---\n\n## 表、索引扫描的改进\n\n\n## RID Lookup、Key Lookup改进\n\n\n## ","slug":"SQL-Server–‘ƒ‹”≈ªØœ‡πÿ","published":0,"date":"2017-06-14T09:32:06.000Z","updated":"2017-06-14T09:32:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3mx0008zd68kcfiow45","content":"<h2 id=\"表、索引扫描的改进\"><a href=\"#表、索引扫描的改进\" class=\"headerlink\" title=\"表、索引扫描的改进\"></a>表、索引扫描的改进</h2><h2 id=\"RID-Lookup、Key-Lookup改进\"><a href=\"#RID-Lookup、Key-Lookup改进\" class=\"headerlink\" title=\"RID Lookup、Key Lookup改进\"></a>RID Lookup、Key Lookup改进</h2><p>## </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"表、索引扫描的改进\"><a href=\"#表、索引扫描的改进\" class=\"headerlink\" title=\"表、索引扫描的改进\"></a>表、索引扫描的改进</h2><h2 id=\"RID-Lookup、Key-Lookup改进\"><a href=\"#RID-Lookup、Key-Lookup改进\" class=\"headerlink\" title=\"RID Lookup、Key Lookup改进\"></a>RID Lookup、Key Lookup改进</h2><p>## </p>\n"},{"title":"数据仓库增量数据处理的几种方法","_content":"","source":"_drafts/ ˝æ›≤÷ø‚‘ˆ¡ø ˝æ›¥¶¿Ìµƒº∏÷÷∑Ω∑®.md","raw":"---\ntitle: 数据仓库增量数据处理的几种方法\ntags:\n---\n","slug":" ˝æ›≤÷ø‚‘ˆ¡ø ˝æ›¥¶¿Ìµƒº∏÷÷∑Ω∑®","published":0,"date":"2017-06-02T02:45:04.000Z","updated":"2017-06-02T02:45:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3my0009zd686kqqys5n","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"搞懂Python编码问题","_content":"","source":"_drafts/∏„∂ÆPython±‡¬ÎŒ Ã‚.md","raw":"---\ntitle: 搞懂Python编码问题\ntags:\n---\n","slug":"∏„∂ÆPython±‡¬ÎŒ Ã‚","published":0,"date":"2017-07-19T08:58:50.000Z","updated":"2017-07-19T08:58:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3n1000czd68h3zsflsq","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"post","title":"使用Github与Octopress写博客","date":"2015-07-16T02:06:06.000Z","comments":1,"_content":"\n## Octopress和Github Pages是什么？\n![Octopress_logo](http://7xkfga.com1.z0.glb.clouddn.com/octopress_logo.jpg)\n\n- Octopress是一个基于Ruby语言的开源静态网站框架\n- Github Pages是Github上的一项服务， 注册用户可以申请一个和自己账号关联的二级域名， 在上面可以托管一个静态网站，网站内容本身就是Github的一个repository也就是项目， 维护这个项目的代码就是在维护自己的网站。简单来说就是 yourname.github.io/\n\n使用Octopress搭建博客，然后使用Github托管，有以下几个原因：\n\n1. 免费\n2. 版本控制，可以使用git实现写文章、建网站时候修改的版本控制\n3. Octopress容易上手，并且这个风格正是我喜欢的，尤其对于一个理工男\n4. 使用Markdown，markdown是世界上最流行的轻量级标记语言\n5. 很酷，能装逼，当然这不是重点\n\n<!--more-->\n\n## 搭建Octopress博客系统\n**Note:** *在这儿写的是关于在Mac上安装Octopress博客系统，和windows有细微的差别，不过个人觉得还是用Mac，无论写代码还是做黑客都更专业。*\n\n### 安装基本工具\n**git**\n\n对于Mac来说，安装XCode之后，自带了git，可以使用下面命令检查本机的git版本\n\n``` bash\n$ git version\n```\n\n**Ruby**\n\nMac本身自带Ruby，但是也许版本过低，在这儿多说一句：有时候在低版本ruby下搭建好的Octopress，莫名其妙不好用了，原因也许就是Mac升级之后，ruby也升级了，要注意一下\n\n至于Mac下如何使用Homebrew安装，请查看~~其他文章~~。\n\n``` bash\n$ brew install ruby\n$ ruby --version\n```\n\nRuby版本在1.9.3以上就可以了，就可以使用`gem`来安装Ruby的包了\n\n**PS.** *gem在Ruby中，相当于Python中的`pip`*\n\n由于我们生活在一个伟大的国家，so在下一步安装前，先更改一下`gem`的更新源，改为淘宝的源\n\n``` bash\ngem sources -a http://ruby.taobao.org/\ngem sources -r http://rubygems.org/\ngem sources -l\n```\n三行命令的作用分别是：添加淘宝源；删除默认源；显示当前源列表。显示淘宝地址就表示成功。\n\n安装bundle和bundler，\n\n``` bash\ngem install bundle\ngem install bundler\n```\n\n**Note:** 安装配置完新版本的Ruby后，一定要重新安装bundle和bundler，否则bundle仍会bundler指向旧版本的Ruby，PS. 由于手贱，把MAC升级到最新系统了，结果各种奇妙的事情就发生了，不过处理方法一般都是：安装最新版本的Ruby，然后再安装`bundler`和`bundler`\n\n**Octopress**\n\n这个就是我们要使用的框架，它是基于Jekyll的一个静态博客生成框架，Jekyll是一个静态网站生成框架，它有很多功能，也可以直接使用，但是就麻烦得多，很多东西要配置和从头写。\n\n``` bash\ngit clone git://github.com/imathis/octopress.git octopress\ncd octopress\nbundle install\nrake install\n```\n\n**创建Github账号和Github Pages**\n\n大多数人都已经有了Github帐号了，访问[Github](http://github.com/ \"Github\")来注册帐号，然后访问Github Pages来创建博客空间，唯一需要注意的是Repo必须是Github帐号.github.io，否则不会起作用。 然后运行：\n\n``` bash\nrake setup_github_pages\n```\n输入Github Page的Repo的地址，例如：git@github.com:username/username.github.io.git，就可以了\n\n### 测试一下\n\n输入命令生成页面\n\n``` bash\nrake generate\n```\n\n生成完毕后，使用以下命令启动网站进程，默认占用4000端口， preview一下\n\n``` bash\nrake preview\n```\n\n可以使用 [http://localhost:4000](http://localhost:4000) 访问你的博客页面了\n\n### 配置博客\n\n配置文件是根目录下的 _config.yml文件，使用vim或者其他文本编辑器编辑它吧\n\n``` bash\n# ----------------------- #\n#      Main Configs       #\n# ----------------------- #\n\nurl: http://lvraikkonen.github.io\ntitle: My Data Science Path\nsubtitle: Shut up, just coding\nauthor: Claus Lv\nsimple_search: https://www.google.com/search\ndescription:\n```\n\n### 语法高亮\n\n例子：\n\n``` javascript\nalert(\"欢迎\")\n```\n\n``` python\nimport math\nprint \"Hello World\"\nlst = range(100)\nprint lst.map(lambda x: x**2)\n```\n\n``` html\n\t<!-- mathjax config similar to math.stackexchange -->\n\t<script type=\"text/x-mathjax-config\">\n\t\tMathJax.Hub.Config({\n  \t\tjax: [\"input/TeX\", \"output/HTML-CSS\"],\n  \t\ttex2jax: {\n    \t\tinlineMath: [ ['$', '$'] ],\n    \t\tdisplayMath: [ ['$$', '$$']],\n    \t\tprocessEscapes: true,\n    \t\tskipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']\n  \t\t},\n  \t\tmessageStyle: \"none\",\n  \t\t\"HTML-CSS\": { preferredFont: \"TeX\", availableFonts: [\"STIX\",\"TeX\"] }\n\t\t});\n\t</script>\n\t<script src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML\" type=\"text/javascript\"></script>\n```\n\n### 添加社交分享\n\nOctopress默认是带有社交分享功能的，比如Twitter, Facebook, Google Plus等，但这些全世界都通用的东西在我大天朝就是不好使。\n\n网站页的分享有很多第三方的库，这里用[jiathis](http://www.jiathis.com/)\n\n1. 在`_config.yml`中加入social_share: true\n\n2. 修改/source/_includes/post/sharing.html\n\n3. 访问[jiathis](http://www.jiathis.com/)获取分享的代码，放入新建的/source/_includes/post/social_media.html\n\n### 添加博客评论\n\nOctopress也默认集成有评论系统Disqus，这个是国外最大的第三方评论平台，世界都在用，除了我大天朝。这里使用[多说](http://www.duoshuo.com)\n\n1. 到多说注册，获取用户名，也就是在多说上添的youname.duoshuo.com中的yourname\n2. 在`_config.yml`中添加\n\n   ```\n   duoshuo_comments: true\n   duoshuo_short_name: yourname\n   ```\n3. 在/source/_layouts/post.html中把评论模版添加到网页中 \n \n4. 创建/source/_includes/post/duoshuo.html，将上步获取的HTML代码放进去\n\n      \n### 国内访问加速\n\n**jQuery源**\n\n修改jQuery的源 打开source/_includes/head.html，找到如下\n\n``` html\n    <script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js\"></script>\n```\n改为：\n\n``` html\n    <script src=\"//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.9.1.min.js\"></script>\n```\n\n**字体源**\n\nOctopress的英文字体是加载的Google Fonts，我们将其改成国内的CDN源， 打开source/_includes/custom/head.html, 将其中的`https://fonts.googleapis.com`改为`http://fonts.useso.com`\n\n\n**Twitter Facebook Google+关闭**\n\n在前面提到的`_config.yml`中相关的例如twitter_tweet_butto改为`false`\n\n### 写博客\n\n要发布一篇新文章，在命令行中输入以下命令：\n\n``` bash\nrake new_post[\"postName\"]\n```\n\n之后在/source/_post/里面就有该博文的markdown文件了，使用Markdown文本编辑器写博客吧\n\n- rake generate 生成静态的博客文件，生成的文件在_deploy中\n- rake preview 在本地预览博客，这与发布到Github Pages后的效果是一样的\n- rake deploy 这是最后一步，就是把Octopress生成的文件（在_deploy）发布到Github上面去。这里的实际是Octopress根据你的配置用sources中的模板，生成网页（HTML，JavaScript, CSS和资源），再把这些资源推送到yourname.github.io这个Repo中去，然后访问https://*yourname*.github.io 就能看到你的博客了\n\n### 发布\n\n执行命令\n\n``` bash\n$ rake generate\n$ rake deploy\n```\n\n第一行命令用来生成页面，第二行命令用来部署页面，上述内容完成，就可以访问 http://[your_username].github.io/看博客了\n\n**Note**: octopress 根目录为`source`分支， `_deploy`目录下为`master`分支，`rake deploy`时候会把`_deploy`下的内容发布到github上的`master`分支。别忘了把源文件（包括配置等）发布到`source`分支下\n\npush时候可用\n\n``` bash\n$ git status\n```\n\n查看状态\n\n执行以下命令，将源文件发布到Github的`source`分支\n\n``` bash\ngit add .\ngit commit -m \"备注内容\"\ngit push origin source\n```\n\n如果遇到类似`error: failed to push some refs to`的错误，参考 [stackoverflow](http://stackoverflow.com/questions/24114676/git-error-failed-to-push-some-refs-to)解决\n","source":"_posts/2015-07-16-Writing Blogs with Github Pages and Octopress.markdown","raw":"---\nlayout: post\ntitle: \"使用Github与Octopress写博客\"\ndate: 2015-07-16 10:06:06 +0800\ncomments: true\ntag: \n- Octopress\ncategories: \n- 备忘\n---\n\n## Octopress和Github Pages是什么？\n![Octopress_logo](http://7xkfga.com1.z0.glb.clouddn.com/octopress_logo.jpg)\n\n- Octopress是一个基于Ruby语言的开源静态网站框架\n- Github Pages是Github上的一项服务， 注册用户可以申请一个和自己账号关联的二级域名， 在上面可以托管一个静态网站，网站内容本身就是Github的一个repository也就是项目， 维护这个项目的代码就是在维护自己的网站。简单来说就是 yourname.github.io/\n\n使用Octopress搭建博客，然后使用Github托管，有以下几个原因：\n\n1. 免费\n2. 版本控制，可以使用git实现写文章、建网站时候修改的版本控制\n3. Octopress容易上手，并且这个风格正是我喜欢的，尤其对于一个理工男\n4. 使用Markdown，markdown是世界上最流行的轻量级标记语言\n5. 很酷，能装逼，当然这不是重点\n\n<!--more-->\n\n## 搭建Octopress博客系统\n**Note:** *在这儿写的是关于在Mac上安装Octopress博客系统，和windows有细微的差别，不过个人觉得还是用Mac，无论写代码还是做黑客都更专业。*\n\n### 安装基本工具\n**git**\n\n对于Mac来说，安装XCode之后，自带了git，可以使用下面命令检查本机的git版本\n\n``` bash\n$ git version\n```\n\n**Ruby**\n\nMac本身自带Ruby，但是也许版本过低，在这儿多说一句：有时候在低版本ruby下搭建好的Octopress，莫名其妙不好用了，原因也许就是Mac升级之后，ruby也升级了，要注意一下\n\n至于Mac下如何使用Homebrew安装，请查看~~其他文章~~。\n\n``` bash\n$ brew install ruby\n$ ruby --version\n```\n\nRuby版本在1.9.3以上就可以了，就可以使用`gem`来安装Ruby的包了\n\n**PS.** *gem在Ruby中，相当于Python中的`pip`*\n\n由于我们生活在一个伟大的国家，so在下一步安装前，先更改一下`gem`的更新源，改为淘宝的源\n\n``` bash\ngem sources -a http://ruby.taobao.org/\ngem sources -r http://rubygems.org/\ngem sources -l\n```\n三行命令的作用分别是：添加淘宝源；删除默认源；显示当前源列表。显示淘宝地址就表示成功。\n\n安装bundle和bundler，\n\n``` bash\ngem install bundle\ngem install bundler\n```\n\n**Note:** 安装配置完新版本的Ruby后，一定要重新安装bundle和bundler，否则bundle仍会bundler指向旧版本的Ruby，PS. 由于手贱，把MAC升级到最新系统了，结果各种奇妙的事情就发生了，不过处理方法一般都是：安装最新版本的Ruby，然后再安装`bundler`和`bundler`\n\n**Octopress**\n\n这个就是我们要使用的框架，它是基于Jekyll的一个静态博客生成框架，Jekyll是一个静态网站生成框架，它有很多功能，也可以直接使用，但是就麻烦得多，很多东西要配置和从头写。\n\n``` bash\ngit clone git://github.com/imathis/octopress.git octopress\ncd octopress\nbundle install\nrake install\n```\n\n**创建Github账号和Github Pages**\n\n大多数人都已经有了Github帐号了，访问[Github](http://github.com/ \"Github\")来注册帐号，然后访问Github Pages来创建博客空间，唯一需要注意的是Repo必须是Github帐号.github.io，否则不会起作用。 然后运行：\n\n``` bash\nrake setup_github_pages\n```\n输入Github Page的Repo的地址，例如：git@github.com:username/username.github.io.git，就可以了\n\n### 测试一下\n\n输入命令生成页面\n\n``` bash\nrake generate\n```\n\n生成完毕后，使用以下命令启动网站进程，默认占用4000端口， preview一下\n\n``` bash\nrake preview\n```\n\n可以使用 [http://localhost:4000](http://localhost:4000) 访问你的博客页面了\n\n### 配置博客\n\n配置文件是根目录下的 _config.yml文件，使用vim或者其他文本编辑器编辑它吧\n\n``` bash\n# ----------------------- #\n#      Main Configs       #\n# ----------------------- #\n\nurl: http://lvraikkonen.github.io\ntitle: My Data Science Path\nsubtitle: Shut up, just coding\nauthor: Claus Lv\nsimple_search: https://www.google.com/search\ndescription:\n```\n\n### 语法高亮\n\n例子：\n\n``` javascript\nalert(\"欢迎\")\n```\n\n``` python\nimport math\nprint \"Hello World\"\nlst = range(100)\nprint lst.map(lambda x: x**2)\n```\n\n``` html\n\t<!-- mathjax config similar to math.stackexchange -->\n\t<script type=\"text/x-mathjax-config\">\n\t\tMathJax.Hub.Config({\n  \t\tjax: [\"input/TeX\", \"output/HTML-CSS\"],\n  \t\ttex2jax: {\n    \t\tinlineMath: [ ['$', '$'] ],\n    \t\tdisplayMath: [ ['$$', '$$']],\n    \t\tprocessEscapes: true,\n    \t\tskipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']\n  \t\t},\n  \t\tmessageStyle: \"none\",\n  \t\t\"HTML-CSS\": { preferredFont: \"TeX\", availableFonts: [\"STIX\",\"TeX\"] }\n\t\t});\n\t</script>\n\t<script src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML\" type=\"text/javascript\"></script>\n```\n\n### 添加社交分享\n\nOctopress默认是带有社交分享功能的，比如Twitter, Facebook, Google Plus等，但这些全世界都通用的东西在我大天朝就是不好使。\n\n网站页的分享有很多第三方的库，这里用[jiathis](http://www.jiathis.com/)\n\n1. 在`_config.yml`中加入social_share: true\n\n2. 修改/source/_includes/post/sharing.html\n\n3. 访问[jiathis](http://www.jiathis.com/)获取分享的代码，放入新建的/source/_includes/post/social_media.html\n\n### 添加博客评论\n\nOctopress也默认集成有评论系统Disqus，这个是国外最大的第三方评论平台，世界都在用，除了我大天朝。这里使用[多说](http://www.duoshuo.com)\n\n1. 到多说注册，获取用户名，也就是在多说上添的youname.duoshuo.com中的yourname\n2. 在`_config.yml`中添加\n\n   ```\n   duoshuo_comments: true\n   duoshuo_short_name: yourname\n   ```\n3. 在/source/_layouts/post.html中把评论模版添加到网页中 \n \n4. 创建/source/_includes/post/duoshuo.html，将上步获取的HTML代码放进去\n\n      \n### 国内访问加速\n\n**jQuery源**\n\n修改jQuery的源 打开source/_includes/head.html，找到如下\n\n``` html\n    <script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js\"></script>\n```\n改为：\n\n``` html\n    <script src=\"//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.9.1.min.js\"></script>\n```\n\n**字体源**\n\nOctopress的英文字体是加载的Google Fonts，我们将其改成国内的CDN源， 打开source/_includes/custom/head.html, 将其中的`https://fonts.googleapis.com`改为`http://fonts.useso.com`\n\n\n**Twitter Facebook Google+关闭**\n\n在前面提到的`_config.yml`中相关的例如twitter_tweet_butto改为`false`\n\n### 写博客\n\n要发布一篇新文章，在命令行中输入以下命令：\n\n``` bash\nrake new_post[\"postName\"]\n```\n\n之后在/source/_post/里面就有该博文的markdown文件了，使用Markdown文本编辑器写博客吧\n\n- rake generate 生成静态的博客文件，生成的文件在_deploy中\n- rake preview 在本地预览博客，这与发布到Github Pages后的效果是一样的\n- rake deploy 这是最后一步，就是把Octopress生成的文件（在_deploy）发布到Github上面去。这里的实际是Octopress根据你的配置用sources中的模板，生成网页（HTML，JavaScript, CSS和资源），再把这些资源推送到yourname.github.io这个Repo中去，然后访问https://*yourname*.github.io 就能看到你的博客了\n\n### 发布\n\n执行命令\n\n``` bash\n$ rake generate\n$ rake deploy\n```\n\n第一行命令用来生成页面，第二行命令用来部署页面，上述内容完成，就可以访问 http://[your_username].github.io/看博客了\n\n**Note**: octopress 根目录为`source`分支， `_deploy`目录下为`master`分支，`rake deploy`时候会把`_deploy`下的内容发布到github上的`master`分支。别忘了把源文件（包括配置等）发布到`source`分支下\n\npush时候可用\n\n``` bash\n$ git status\n```\n\n查看状态\n\n执行以下命令，将源文件发布到Github的`source`分支\n\n``` bash\ngit add .\ngit commit -m \"备注内容\"\ngit push origin source\n```\n\n如果遇到类似`error: failed to push some refs to`的错误，参考 [stackoverflow](http://stackoverflow.com/questions/24114676/git-error-failed-to-push-some-refs-to)解决\n","slug":"2015-07-16-Writing Blogs with Github Pages and Octopress","published":1,"updated":"2017-05-27T10:50:00.000Z","photos":[],"link":"","_id":"cjfkkp3n4000dzd6870yujcfo","content":"<h2 id=\"Octopress和Github-Pages是什么？\"><a href=\"#Octopress和Github-Pages是什么？\" class=\"headerlink\" title=\"Octopress和Github Pages是什么？\"></a>Octopress和Github Pages是什么？</h2><p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/octopress_logo.jpg\" alt=\"Octopress_logo\"></p>\n<ul>\n<li>Octopress是一个基于Ruby语言的开源静态网站框架</li>\n<li>Github Pages是Github上的一项服务， 注册用户可以申请一个和自己账号关联的二级域名， 在上面可以托管一个静态网站，网站内容本身就是Github的一个repository也就是项目， 维护这个项目的代码就是在维护自己的网站。简单来说就是 yourname.github.io/</li>\n</ul>\n<p>使用Octopress搭建博客，然后使用Github托管，有以下几个原因：</p>\n<ol>\n<li>免费</li>\n<li>版本控制，可以使用git实现写文章、建网站时候修改的版本控制</li>\n<li>Octopress容易上手，并且这个风格正是我喜欢的，尤其对于一个理工男</li>\n<li>使用Markdown，markdown是世界上最流行的轻量级标记语言</li>\n<li>很酷，能装逼，当然这不是重点</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"搭建Octopress博客系统\"><a href=\"#搭建Octopress博客系统\" class=\"headerlink\" title=\"搭建Octopress博客系统\"></a>搭建Octopress博客系统</h2><p><strong>Note:</strong> <em>在这儿写的是关于在Mac上安装Octopress博客系统，和windows有细微的差别，不过个人觉得还是用Mac，无论写代码还是做黑客都更专业。</em></p>\n<h3 id=\"安装基本工具\"><a href=\"#安装基本工具\" class=\"headerlink\" title=\"安装基本工具\"></a>安装基本工具</h3><p><strong>git</strong></p>\n<p>对于Mac来说，安装XCode之后，自带了git，可以使用下面命令检查本机的git版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git version</span><br></pre></td></tr></table></figure>\n<p><strong>Ruby</strong></p>\n<p>Mac本身自带Ruby，但是也许版本过低，在这儿多说一句：有时候在低版本ruby下搭建好的Octopress，莫名其妙不好用了，原因也许就是Mac升级之后，ruby也升级了，要注意一下</p>\n<p>至于Mac下如何使用Homebrew安装，请查看<del>其他文章</del>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install ruby</span><br><span class=\"line\">$ ruby --version</span><br></pre></td></tr></table></figure>\n<p>Ruby版本在1.9.3以上就可以了，就可以使用<code>gem</code>来安装Ruby的包了</p>\n<p><strong>PS.</strong> <em>gem在Ruby中，相当于Python中的<code>pip</code></em></p>\n<p>由于我们生活在一个伟大的国家，so在下一步安装前，先更改一下<code>gem</code>的更新源，改为淘宝的源</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem sources -a http://ruby.taobao.org/</span><br><span class=\"line\">gem sources -r http://rubygems.org/</span><br><span class=\"line\">gem sources -l</span><br></pre></td></tr></table></figure>\n<p>三行命令的作用分别是：添加淘宝源；删除默认源；显示当前源列表。显示淘宝地址就表示成功。</p>\n<p>安装bundle和bundler，</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem install bundle</span><br><span class=\"line\">gem install bundler</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong> 安装配置完新版本的Ruby后，一定要重新安装bundle和bundler，否则bundle仍会bundler指向旧版本的Ruby，PS. 由于手贱，把MAC升级到最新系统了，结果各种奇妙的事情就发生了，不过处理方法一般都是：安装最新版本的Ruby，然后再安装<code>bundler</code>和<code>bundler</code></p>\n<p><strong>Octopress</strong></p>\n<p>这个就是我们要使用的框架，它是基于Jekyll的一个静态博客生成框架，Jekyll是一个静态网站生成框架，它有很多功能，也可以直接使用，但是就麻烦得多，很多东西要配置和从头写。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> git://github.com/imathis/octopress.git octopress</span><br><span class=\"line\"><span class=\"built_in\">cd</span> octopress</span><br><span class=\"line\">bundle install</span><br><span class=\"line\">rake install</span><br></pre></td></tr></table></figure>\n<p><strong>创建Github账号和Github Pages</strong></p>\n<p>大多数人都已经有了Github帐号了，访问<a href=\"http://github.com/\" title=\"Github\" target=\"_blank\" rel=\"noopener\">Github</a>来注册帐号，然后访问Github Pages来创建博客空间，唯一需要注意的是Repo必须是Github帐号.github.io，否则不会起作用。 然后运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rake setup_github_pages</span><br></pre></td></tr></table></figure>\n<p>输入Github Page的Repo的地址，例如：<a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:username/username.github.io.git，就可以了</p>\n<h3 id=\"测试一下\"><a href=\"#测试一下\" class=\"headerlink\" title=\"测试一下\"></a>测试一下</h3><p>输入命令生成页面</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rake generate</span><br></pre></td></tr></table></figure>\n<p>生成完毕后，使用以下命令启动网站进程，默认占用4000端口， preview一下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rake preview</span><br></pre></td></tr></table></figure>\n<p>可以使用 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a> 访问你的博客页面了</p>\n<h3 id=\"配置博客\"><a href=\"#配置博客\" class=\"headerlink\" title=\"配置博客\"></a>配置博客</h3><p>配置文件是根目录下的 _config.yml文件，使用vim或者其他文本编辑器编辑它吧</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ----------------------- #</span></span><br><span class=\"line\"><span class=\"comment\">#      Main Configs       #</span></span><br><span class=\"line\"><span class=\"comment\"># ----------------------- #</span></span><br><span class=\"line\"></span><br><span class=\"line\">url: http://lvraikkonen.github.io</span><br><span class=\"line\">title: My Data Science Path</span><br><span class=\"line\">subtitle: Shut up, just coding</span><br><span class=\"line\">author: Claus Lv</span><br><span class=\"line\">simple_search: https://www.google.com/search</span><br><span class=\"line\">description:</span><br></pre></td></tr></table></figure>\n<h3 id=\"语法高亮\"><a href=\"#语法高亮\" class=\"headerlink\" title=\"语法高亮\"></a>语法高亮</h3><p>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(<span class=\"string\">\"欢迎\"</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">lst = range(<span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> lst.map(<span class=\"keyword\">lambda</span> x: x**<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- mathjax config similar to math.stackexchange --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/x-mathjax-config\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">\tMathJax.Hub.Config(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\"> \t\tjax: [<span class=\"string\">\"input/TeX\"</span>, <span class=\"string\">\"output/HTML-CSS\"</span>],</span></span><br><span class=\"line\"><span class=\"undefined\"> \t\ttex2jax: &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">   \t\tinlineMath: [ [<span class=\"string\">'$'</span>, <span class=\"string\">'$'</span>] ],</span></span><br><span class=\"line\"><span class=\"javascript\">   \t\tdisplayMath: [ [<span class=\"string\">'$$'</span>, <span class=\"string\">'$$'</span>]],</span></span><br><span class=\"line\"><span class=\"javascript\">   \t\tprocessEscapes: <span class=\"literal\">true</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">   \t\tskipTags: [<span class=\"string\">'script'</span>, <span class=\"string\">'noscript'</span>, <span class=\"string\">'style'</span>, <span class=\"string\">'textarea'</span>, <span class=\"string\">'pre'</span>, <span class=\"string\">'code'</span>]</span></span><br><span class=\"line\"><span class=\"undefined\"> \t\t&#125;,</span></span><br><span class=\"line\"><span class=\"javascript\"> \t\tmessageStyle: <span class=\"string\">\"none\"</span>,</span></span><br><span class=\"line\"><span class=\"javascript\"> \t\t<span class=\"string\">\"HTML-CSS\"</span>: &#123; <span class=\"attr\">preferredFont</span>: <span class=\"string\">\"TeX\"</span>, <span class=\"attr\">availableFonts</span>: [<span class=\"string\">\"STIX\"</span>,<span class=\"string\">\"TeX\"</span>] &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">\t&#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"添加社交分享\"><a href=\"#添加社交分享\" class=\"headerlink\" title=\"添加社交分享\"></a>添加社交分享</h3><p>Octopress默认是带有社交分享功能的，比如Twitter, Facebook, Google Plus等，但这些全世界都通用的东西在我大天朝就是不好使。</p>\n<p>网站页的分享有很多第三方的库，这里用<a href=\"http://www.jiathis.com/\" target=\"_blank\" rel=\"noopener\">jiathis</a></p>\n<ol>\n<li><p>在<code>_config.yml</code>中加入social_share: true</p>\n</li>\n<li><p>修改/source/_includes/post/sharing.html</p>\n</li>\n<li><p>访问<a href=\"http://www.jiathis.com/\" target=\"_blank\" rel=\"noopener\">jiathis</a>获取分享的代码，放入新建的/source/_includes/post/social_media.html</p>\n</li>\n</ol>\n<h3 id=\"添加博客评论\"><a href=\"#添加博客评论\" class=\"headerlink\" title=\"添加博客评论\"></a>添加博客评论</h3><p>Octopress也默认集成有评论系统Disqus，这个是国外最大的第三方评论平台，世界都在用，除了我大天朝。这里使用<a href=\"http://www.duoshuo.com\" target=\"_blank\" rel=\"noopener\">多说</a></p>\n<ol>\n<li>到多说注册，获取用户名，也就是在多说上添的youname.duoshuo.com中的yourname</li>\n<li><p>在<code>_config.yml</code>中添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">duoshuo_comments: true</span><br><span class=\"line\">duoshuo_short_name: yourname</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在/source/_layouts/post.html中把评论模版添加到网页中 </p>\n</li>\n<li><p>创建/source/_includes/post/duoshuo.html，将上步获取的HTML代码放进去</p>\n</li>\n</ol>\n<h3 id=\"国内访问加速\"><a href=\"#国内访问加速\" class=\"headerlink\" title=\"国内访问加速\"></a>国内访问加速</h3><p><strong>jQuery源</strong></p>\n<p>修改jQuery的源 打开source/_includes/head.html，找到如下</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>改为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.9.1.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>字体源</strong></p>\n<p>Octopress的英文字体是加载的Google Fonts，我们将其改成国内的CDN源， 打开source/_includes/custom/head.html, 将其中的<code>https://fonts.googleapis.com</code>改为<code>http://fonts.useso.com</code></p>\n<p><strong>Twitter Facebook Google+关闭</strong></p>\n<p>在前面提到的<code>_config.yml</code>中相关的例如twitter_tweet_butto改为<code>false</code></p>\n<h3 id=\"写博客\"><a href=\"#写博客\" class=\"headerlink\" title=\"写博客\"></a>写博客</h3><p>要发布一篇新文章，在命令行中输入以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rake new_post[<span class=\"string\">\"postName\"</span>]</span><br></pre></td></tr></table></figure>\n<p>之后在/source/_post/里面就有该博文的markdown文件了，使用Markdown文本编辑器写博客吧</p>\n<ul>\n<li>rake generate 生成静态的博客文件，生成的文件在_deploy中</li>\n<li>rake preview 在本地预览博客，这与发布到Github Pages后的效果是一样的</li>\n<li>rake deploy 这是最后一步，就是把Octopress生成的文件（在_deploy）发布到Github上面去。这里的实际是Octopress根据你的配置用sources中的模板，生成网页（HTML，JavaScript, CSS和资源），再把这些资源推送到yourname.github.io这个Repo中去，然后访问https://<em>yourname</em>.github.io 就能看到你的博客了</li>\n</ul>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h3><p>执行命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rake generate</span><br><span class=\"line\">$ rake deploy</span><br></pre></td></tr></table></figure>\n<p>第一行命令用来生成页面，第二行命令用来部署页面，上述内容完成，就可以访问 http://[your_username].github.io/看博客了</p>\n<p><strong>Note</strong>: octopress 根目录为<code>source</code>分支， <code>_deploy</code>目录下为<code>master</code>分支，<code>rake deploy</code>时候会把<code>_deploy</code>下的内容发布到github上的<code>master</code>分支。别忘了把源文件（包括配置等）发布到<code>source</code>分支下</p>\n<p>push时候可用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>查看状态</p>\n<p>执行以下命令，将源文件发布到Github的<code>source</code>分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"备注内容\"</span></span><br><span class=\"line\">git push origin <span class=\"built_in\">source</span></span><br></pre></td></tr></table></figure>\n<p>如果遇到类似<code>error: failed to push some refs to</code>的错误，参考 <a href=\"http://stackoverflow.com/questions/24114676/git-error-failed-to-push-some-refs-to\" target=\"_blank\" rel=\"noopener\">stackoverflow</a>解决</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Octopress和Github-Pages是什么？\"><a href=\"#Octopress和Github-Pages是什么？\" class=\"headerlink\" title=\"Octopress和Github Pages是什么？\"></a>Octopress和Github Pages是什么？</h2><p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/octopress_logo.jpg\" alt=\"Octopress_logo\"></p>\n<ul>\n<li>Octopress是一个基于Ruby语言的开源静态网站框架</li>\n<li>Github Pages是Github上的一项服务， 注册用户可以申请一个和自己账号关联的二级域名， 在上面可以托管一个静态网站，网站内容本身就是Github的一个repository也就是项目， 维护这个项目的代码就是在维护自己的网站。简单来说就是 yourname.github.io/</li>\n</ul>\n<p>使用Octopress搭建博客，然后使用Github托管，有以下几个原因：</p>\n<ol>\n<li>免费</li>\n<li>版本控制，可以使用git实现写文章、建网站时候修改的版本控制</li>\n<li>Octopress容易上手，并且这个风格正是我喜欢的，尤其对于一个理工男</li>\n<li>使用Markdown，markdown是世界上最流行的轻量级标记语言</li>\n<li>很酷，能装逼，当然这不是重点</li>\n</ol>","more":"<h2 id=\"搭建Octopress博客系统\"><a href=\"#搭建Octopress博客系统\" class=\"headerlink\" title=\"搭建Octopress博客系统\"></a>搭建Octopress博客系统</h2><p><strong>Note:</strong> <em>在这儿写的是关于在Mac上安装Octopress博客系统，和windows有细微的差别，不过个人觉得还是用Mac，无论写代码还是做黑客都更专业。</em></p>\n<h3 id=\"安装基本工具\"><a href=\"#安装基本工具\" class=\"headerlink\" title=\"安装基本工具\"></a>安装基本工具</h3><p><strong>git</strong></p>\n<p>对于Mac来说，安装XCode之后，自带了git，可以使用下面命令检查本机的git版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git version</span><br></pre></td></tr></table></figure>\n<p><strong>Ruby</strong></p>\n<p>Mac本身自带Ruby，但是也许版本过低，在这儿多说一句：有时候在低版本ruby下搭建好的Octopress，莫名其妙不好用了，原因也许就是Mac升级之后，ruby也升级了，要注意一下</p>\n<p>至于Mac下如何使用Homebrew安装，请查看<del>其他文章</del>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install ruby</span><br><span class=\"line\">$ ruby --version</span><br></pre></td></tr></table></figure>\n<p>Ruby版本在1.9.3以上就可以了，就可以使用<code>gem</code>来安装Ruby的包了</p>\n<p><strong>PS.</strong> <em>gem在Ruby中，相当于Python中的<code>pip</code></em></p>\n<p>由于我们生活在一个伟大的国家，so在下一步安装前，先更改一下<code>gem</code>的更新源，改为淘宝的源</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem sources -a http://ruby.taobao.org/</span><br><span class=\"line\">gem sources -r http://rubygems.org/</span><br><span class=\"line\">gem sources -l</span><br></pre></td></tr></table></figure>\n<p>三行命令的作用分别是：添加淘宝源；删除默认源；显示当前源列表。显示淘宝地址就表示成功。</p>\n<p>安装bundle和bundler，</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem install bundle</span><br><span class=\"line\">gem install bundler</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong> 安装配置完新版本的Ruby后，一定要重新安装bundle和bundler，否则bundle仍会bundler指向旧版本的Ruby，PS. 由于手贱，把MAC升级到最新系统了，结果各种奇妙的事情就发生了，不过处理方法一般都是：安装最新版本的Ruby，然后再安装<code>bundler</code>和<code>bundler</code></p>\n<p><strong>Octopress</strong></p>\n<p>这个就是我们要使用的框架，它是基于Jekyll的一个静态博客生成框架，Jekyll是一个静态网站生成框架，它有很多功能，也可以直接使用，但是就麻烦得多，很多东西要配置和从头写。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> git://github.com/imathis/octopress.git octopress</span><br><span class=\"line\"><span class=\"built_in\">cd</span> octopress</span><br><span class=\"line\">bundle install</span><br><span class=\"line\">rake install</span><br></pre></td></tr></table></figure>\n<p><strong>创建Github账号和Github Pages</strong></p>\n<p>大多数人都已经有了Github帐号了，访问<a href=\"http://github.com/\" title=\"Github\" target=\"_blank\" rel=\"noopener\">Github</a>来注册帐号，然后访问Github Pages来创建博客空间，唯一需要注意的是Repo必须是Github帐号.github.io，否则不会起作用。 然后运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rake setup_github_pages</span><br></pre></td></tr></table></figure>\n<p>输入Github Page的Repo的地址，例如：<a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:username/username.github.io.git，就可以了</p>\n<h3 id=\"测试一下\"><a href=\"#测试一下\" class=\"headerlink\" title=\"测试一下\"></a>测试一下</h3><p>输入命令生成页面</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rake generate</span><br></pre></td></tr></table></figure>\n<p>生成完毕后，使用以下命令启动网站进程，默认占用4000端口， preview一下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rake preview</span><br></pre></td></tr></table></figure>\n<p>可以使用 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a> 访问你的博客页面了</p>\n<h3 id=\"配置博客\"><a href=\"#配置博客\" class=\"headerlink\" title=\"配置博客\"></a>配置博客</h3><p>配置文件是根目录下的 _config.yml文件，使用vim或者其他文本编辑器编辑它吧</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ----------------------- #</span></span><br><span class=\"line\"><span class=\"comment\">#      Main Configs       #</span></span><br><span class=\"line\"><span class=\"comment\"># ----------------------- #</span></span><br><span class=\"line\"></span><br><span class=\"line\">url: http://lvraikkonen.github.io</span><br><span class=\"line\">title: My Data Science Path</span><br><span class=\"line\">subtitle: Shut up, just coding</span><br><span class=\"line\">author: Claus Lv</span><br><span class=\"line\">simple_search: https://www.google.com/search</span><br><span class=\"line\">description:</span><br></pre></td></tr></table></figure>\n<h3 id=\"语法高亮\"><a href=\"#语法高亮\" class=\"headerlink\" title=\"语法高亮\"></a>语法高亮</h3><p>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(<span class=\"string\">\"欢迎\"</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">lst = range(<span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> lst.map(<span class=\"keyword\">lambda</span> x: x**<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- mathjax config similar to math.stackexchange --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/x-mathjax-config\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">\tMathJax.Hub.Config(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\"> \t\tjax: [<span class=\"string\">\"input/TeX\"</span>, <span class=\"string\">\"output/HTML-CSS\"</span>],</span></span><br><span class=\"line\"><span class=\"undefined\"> \t\ttex2jax: &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">   \t\tinlineMath: [ [<span class=\"string\">'$'</span>, <span class=\"string\">'$'</span>] ],</span></span><br><span class=\"line\"><span class=\"javascript\">   \t\tdisplayMath: [ [<span class=\"string\">'$$'</span>, <span class=\"string\">'$$'</span>]],</span></span><br><span class=\"line\"><span class=\"javascript\">   \t\tprocessEscapes: <span class=\"literal\">true</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">   \t\tskipTags: [<span class=\"string\">'script'</span>, <span class=\"string\">'noscript'</span>, <span class=\"string\">'style'</span>, <span class=\"string\">'textarea'</span>, <span class=\"string\">'pre'</span>, <span class=\"string\">'code'</span>]</span></span><br><span class=\"line\"><span class=\"undefined\"> \t\t&#125;,</span></span><br><span class=\"line\"><span class=\"javascript\"> \t\tmessageStyle: <span class=\"string\">\"none\"</span>,</span></span><br><span class=\"line\"><span class=\"javascript\"> \t\t<span class=\"string\">\"HTML-CSS\"</span>: &#123; <span class=\"attr\">preferredFont</span>: <span class=\"string\">\"TeX\"</span>, <span class=\"attr\">availableFonts</span>: [<span class=\"string\">\"STIX\"</span>,<span class=\"string\">\"TeX\"</span>] &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">\t&#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"添加社交分享\"><a href=\"#添加社交分享\" class=\"headerlink\" title=\"添加社交分享\"></a>添加社交分享</h3><p>Octopress默认是带有社交分享功能的，比如Twitter, Facebook, Google Plus等，但这些全世界都通用的东西在我大天朝就是不好使。</p>\n<p>网站页的分享有很多第三方的库，这里用<a href=\"http://www.jiathis.com/\" target=\"_blank\" rel=\"noopener\">jiathis</a></p>\n<ol>\n<li><p>在<code>_config.yml</code>中加入social_share: true</p>\n</li>\n<li><p>修改/source/_includes/post/sharing.html</p>\n</li>\n<li><p>访问<a href=\"http://www.jiathis.com/\" target=\"_blank\" rel=\"noopener\">jiathis</a>获取分享的代码，放入新建的/source/_includes/post/social_media.html</p>\n</li>\n</ol>\n<h3 id=\"添加博客评论\"><a href=\"#添加博客评论\" class=\"headerlink\" title=\"添加博客评论\"></a>添加博客评论</h3><p>Octopress也默认集成有评论系统Disqus，这个是国外最大的第三方评论平台，世界都在用，除了我大天朝。这里使用<a href=\"http://www.duoshuo.com\" target=\"_blank\" rel=\"noopener\">多说</a></p>\n<ol>\n<li>到多说注册，获取用户名，也就是在多说上添的youname.duoshuo.com中的yourname</li>\n<li><p>在<code>_config.yml</code>中添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">duoshuo_comments: true</span><br><span class=\"line\">duoshuo_short_name: yourname</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在/source/_layouts/post.html中把评论模版添加到网页中 </p>\n</li>\n<li><p>创建/source/_includes/post/duoshuo.html，将上步获取的HTML代码放进去</p>\n</li>\n</ol>\n<h3 id=\"国内访问加速\"><a href=\"#国内访问加速\" class=\"headerlink\" title=\"国内访问加速\"></a>国内访问加速</h3><p><strong>jQuery源</strong></p>\n<p>修改jQuery的源 打开source/_includes/head.html，找到如下</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>改为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.9.1.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>字体源</strong></p>\n<p>Octopress的英文字体是加载的Google Fonts，我们将其改成国内的CDN源， 打开source/_includes/custom/head.html, 将其中的<code>https://fonts.googleapis.com</code>改为<code>http://fonts.useso.com</code></p>\n<p><strong>Twitter Facebook Google+关闭</strong></p>\n<p>在前面提到的<code>_config.yml</code>中相关的例如twitter_tweet_butto改为<code>false</code></p>\n<h3 id=\"写博客\"><a href=\"#写博客\" class=\"headerlink\" title=\"写博客\"></a>写博客</h3><p>要发布一篇新文章，在命令行中输入以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rake new_post[<span class=\"string\">\"postName\"</span>]</span><br></pre></td></tr></table></figure>\n<p>之后在/source/_post/里面就有该博文的markdown文件了，使用Markdown文本编辑器写博客吧</p>\n<ul>\n<li>rake generate 生成静态的博客文件，生成的文件在_deploy中</li>\n<li>rake preview 在本地预览博客，这与发布到Github Pages后的效果是一样的</li>\n<li>rake deploy 这是最后一步，就是把Octopress生成的文件（在_deploy）发布到Github上面去。这里的实际是Octopress根据你的配置用sources中的模板，生成网页（HTML，JavaScript, CSS和资源），再把这些资源推送到yourname.github.io这个Repo中去，然后访问https://<em>yourname</em>.github.io 就能看到你的博客了</li>\n</ul>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h3><p>执行命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rake generate</span><br><span class=\"line\">$ rake deploy</span><br></pre></td></tr></table></figure>\n<p>第一行命令用来生成页面，第二行命令用来部署页面，上述内容完成，就可以访问 http://[your_username].github.io/看博客了</p>\n<p><strong>Note</strong>: octopress 根目录为<code>source</code>分支， <code>_deploy</code>目录下为<code>master</code>分支，<code>rake deploy</code>时候会把<code>_deploy</code>下的内容发布到github上的<code>master</code>分支。别忘了把源文件（包括配置等）发布到<code>source</code>分支下</p>\n<p>push时候可用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>查看状态</p>\n<p>执行以下命令，将源文件发布到Github的<code>source</code>分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"备注内容\"</span></span><br><span class=\"line\">git push origin <span class=\"built_in\">source</span></span><br></pre></td></tr></table></figure>\n<p>如果遇到类似<code>error: failed to push some refs to</code>的错误，参考 <a href=\"http://stackoverflow.com/questions/24114676/git-error-failed-to-push-some-refs-to\" target=\"_blank\" rel=\"noopener\">stackoverflow</a>解决</p>"},{"layout":"post","title":"Install Spark on Mac OSX Yosemite","date":"2015-07-17T10:30:50.000Z","comments":1,"_content":"\n\nSpark是个好东西。\n\n![Spark Logo](http://7xkfga.com1.z0.glb.clouddn.com/spark_logo.jpg)\n\nSpark有以下四种运行模式：\n\n- local: 本地单进程模式，用于本地开发测试Spark代码\n- standalone：分布式集群模式，Master-Worker架构，Master负责调度，Worker负责具体Task的执行\n- on yarn/mesos: ‌运行在yarn/mesos等资源管理框架之上，yarn/mesos提供资源管理，spark提供计算调度，并可与其他计算框架(如MapReduce/MPI/Storm)共同运行在同一个集群之上\n- on cloud(EC2): 运行在AWS的EC2之上\n\n\n在Spark上又有多个应用，尤其是`MLlib`，`Spark SQL`和`DataFrame`，提供给数据科学家们无缝接口去搞所谓Data Science\n\n![spark stack](http://7xkfga.com1.z0.glb.clouddn.com/spark_stack.jpg)\n\n\n本文记录一下我在Mac上安装Spark单机为分布式的过程\n\n\n<!--more-->\n\n## 1.安装环境\n\nSpark依赖JDK 6.0以及Scala 2.9.3以上版本，安装好Java和Scala，然后配置好Java、Scala环境，最后再用`java -version`和`scala -version`验证一下\n\n在`~/.bash_profile`中加入：\n\n``` bash\n# Setting PATH for scala\nexport SCALA_HOME=/usr/local/Cellar/scala/2.11.6\nexport PATH=$SCALA_HOME/bin:$PATH\n```\n\n别忘了\n\n``` bash\nsource ~/.bash_profile\n```\n\n生效\n\n由于在后面学习中主要会用到Spark的Python接口`pyspark`，所以在这儿也需要配置Python的环境变量：\n\n``` bash\n# Setting PATH for Python 2.7\n# The orginal version is saved in .bash_profile.pysave\nPATH=\"/usr/local/Cellar/python/2.7.9/bin:${PATH}\"\nexport PATH\n```\n\n## 2.伪分布式安装\n\nSpark的安装和简单，只需要将Spark的安装包download下来，加入PATH即可。这里我用的是[Spark 1.4.0](http://www.apache.org/dyn/closer.cgi/spark/spark-1.4.1/spark-1.4.1-bin-hadoop2.6.tgz)\n\n当然，这里也可以使用Homebrew安装，那就更轻松了，直接\n\n``` bash\n$ brew install apache-spark\n```\n就搞定了，不过Homebrew安装没办法自己控制箱要安装的版本\n\n这里我使用下载对Hadoop2.6的预编译版本安装\n\n``` bash\ncd /usr/local/Cellar/\nwget http://www.apache.org/dyn/closer.cgi/spark/spark-1.4.0/spark-1.4.0-bin-hadoop2.6.tgz\ntar zxvf spark-1.4.0-bin-hadoop2.6.tgz\n```\n\n设置Spark环境变量，`~/.bash_profile`：\n\n``` bash\n\texport SPARK_MASTER=localhost\n\texport SPARK_LOCAL_IP=localhost\n\texport SPARK_HOME=/usr/local/Cellar/spark-1.4.0-bin-hadoop2.6\n\texport PATH=$PATH:$SCALA_HOME/bin:$SPARK_HOME/bin\n\texport PYTHONPATH=$SPARK_HOME/python:$SPARK_HOME/python/lib/py4j-0.8.2.1-src.zip:$PYTHONPATH\n\texport PATH=\"/usr/local/sbin:$PATH\"\n```\n\n安装完成，貌似也没什么安装哈~\n\n## 跑起来\n执行Spark根目录下的pyspark就可以以交互的模式使用Spark了，这也是他的一个优点\n\n![Spark Run success](http://7xkfga.com1.z0.glb.clouddn.com/SparkRun.jpg)\n\n出现Spark的标志，那就说明安装成功了。下面再小配置下，让画面的log简单一点。在`$SPARK_HOME/conf/`下配置一下`log4j`的设置。\n\n把`log4j.properties.template`文件复制一份，并删掉`.template`的扩展名\n\n把这个文件中的`INFO`内容全部替换成`WARN`\n\n## 在IPython中运行Spark\n说Spark好，那么IPython更是一大杀器，这个以后再介绍。先说设置\n\n首先，创建IPython的Spark配置\n\n``` bash\n$ ipython profile create pyspark\n```\n\n然后创建文件`$HOME/.ipython/profile_spark/startup/00-pyspark-setup.py`并添加：\n\n``` python\nimport os\nimport sys\nspark_home = os.environ.get('SPARK_HOME', None)\nif not spark_home:\n    raise ValueError('SPARK_HOME environment variable is not set')\nsys.path.insert(0, os.path.join(spark_home, 'python'))\nsys.path.insert(0, os.path.join(spark_home, 'python/lib/py4j-0.8.2.1-src.zip'))\nexecfile(os.path.join(spark_home, 'python/pyspark/shell.py'))\n```\n\n在IPython notebook中跑Spark\n\n``` bash\n$ ipython notebook --profile=pyspark\n```\n\n开始学习Spark吧！\n\n参考： [Getting Started with Spark (in Python)](https://districtdatalabs.silvrback.com/getting-started-with-spark-in-python)\n","source":"_posts/2015-07-17-install-spark-on-mac-osx-yosemite.markdown","raw":"---\nlayout: post\ntitle: \"Install Spark on Mac OSX Yosemite\"\ndate: 2015-07-17 18:30:50 +0800\ncomments: true\ntag: [Big Data, Spark]\ncategories: [Big Data, Spark]\n---\n\n\nSpark是个好东西。\n\n![Spark Logo](http://7xkfga.com1.z0.glb.clouddn.com/spark_logo.jpg)\n\nSpark有以下四种运行模式：\n\n- local: 本地单进程模式，用于本地开发测试Spark代码\n- standalone：分布式集群模式，Master-Worker架构，Master负责调度，Worker负责具体Task的执行\n- on yarn/mesos: ‌运行在yarn/mesos等资源管理框架之上，yarn/mesos提供资源管理，spark提供计算调度，并可与其他计算框架(如MapReduce/MPI/Storm)共同运行在同一个集群之上\n- on cloud(EC2): 运行在AWS的EC2之上\n\n\n在Spark上又有多个应用，尤其是`MLlib`，`Spark SQL`和`DataFrame`，提供给数据科学家们无缝接口去搞所谓Data Science\n\n![spark stack](http://7xkfga.com1.z0.glb.clouddn.com/spark_stack.jpg)\n\n\n本文记录一下我在Mac上安装Spark单机为分布式的过程\n\n\n<!--more-->\n\n## 1.安装环境\n\nSpark依赖JDK 6.0以及Scala 2.9.3以上版本，安装好Java和Scala，然后配置好Java、Scala环境，最后再用`java -version`和`scala -version`验证一下\n\n在`~/.bash_profile`中加入：\n\n``` bash\n# Setting PATH for scala\nexport SCALA_HOME=/usr/local/Cellar/scala/2.11.6\nexport PATH=$SCALA_HOME/bin:$PATH\n```\n\n别忘了\n\n``` bash\nsource ~/.bash_profile\n```\n\n生效\n\n由于在后面学习中主要会用到Spark的Python接口`pyspark`，所以在这儿也需要配置Python的环境变量：\n\n``` bash\n# Setting PATH for Python 2.7\n# The orginal version is saved in .bash_profile.pysave\nPATH=\"/usr/local/Cellar/python/2.7.9/bin:${PATH}\"\nexport PATH\n```\n\n## 2.伪分布式安装\n\nSpark的安装和简单，只需要将Spark的安装包download下来，加入PATH即可。这里我用的是[Spark 1.4.0](http://www.apache.org/dyn/closer.cgi/spark/spark-1.4.1/spark-1.4.1-bin-hadoop2.6.tgz)\n\n当然，这里也可以使用Homebrew安装，那就更轻松了，直接\n\n``` bash\n$ brew install apache-spark\n```\n就搞定了，不过Homebrew安装没办法自己控制箱要安装的版本\n\n这里我使用下载对Hadoop2.6的预编译版本安装\n\n``` bash\ncd /usr/local/Cellar/\nwget http://www.apache.org/dyn/closer.cgi/spark/spark-1.4.0/spark-1.4.0-bin-hadoop2.6.tgz\ntar zxvf spark-1.4.0-bin-hadoop2.6.tgz\n```\n\n设置Spark环境变量，`~/.bash_profile`：\n\n``` bash\n\texport SPARK_MASTER=localhost\n\texport SPARK_LOCAL_IP=localhost\n\texport SPARK_HOME=/usr/local/Cellar/spark-1.4.0-bin-hadoop2.6\n\texport PATH=$PATH:$SCALA_HOME/bin:$SPARK_HOME/bin\n\texport PYTHONPATH=$SPARK_HOME/python:$SPARK_HOME/python/lib/py4j-0.8.2.1-src.zip:$PYTHONPATH\n\texport PATH=\"/usr/local/sbin:$PATH\"\n```\n\n安装完成，貌似也没什么安装哈~\n\n## 跑起来\n执行Spark根目录下的pyspark就可以以交互的模式使用Spark了，这也是他的一个优点\n\n![Spark Run success](http://7xkfga.com1.z0.glb.clouddn.com/SparkRun.jpg)\n\n出现Spark的标志，那就说明安装成功了。下面再小配置下，让画面的log简单一点。在`$SPARK_HOME/conf/`下配置一下`log4j`的设置。\n\n把`log4j.properties.template`文件复制一份，并删掉`.template`的扩展名\n\n把这个文件中的`INFO`内容全部替换成`WARN`\n\n## 在IPython中运行Spark\n说Spark好，那么IPython更是一大杀器，这个以后再介绍。先说设置\n\n首先，创建IPython的Spark配置\n\n``` bash\n$ ipython profile create pyspark\n```\n\n然后创建文件`$HOME/.ipython/profile_spark/startup/00-pyspark-setup.py`并添加：\n\n``` python\nimport os\nimport sys\nspark_home = os.environ.get('SPARK_HOME', None)\nif not spark_home:\n    raise ValueError('SPARK_HOME environment variable is not set')\nsys.path.insert(0, os.path.join(spark_home, 'python'))\nsys.path.insert(0, os.path.join(spark_home, 'python/lib/py4j-0.8.2.1-src.zip'))\nexecfile(os.path.join(spark_home, 'python/pyspark/shell.py'))\n```\n\n在IPython notebook中跑Spark\n\n``` bash\n$ ipython notebook --profile=pyspark\n```\n\n开始学习Spark吧！\n\n参考： [Getting Started with Spark (in Python)](https://districtdatalabs.silvrback.com/getting-started-with-spark-in-python)\n","slug":"2015-07-17-install-spark-on-mac-osx-yosemite","published":1,"updated":"2016-09-20T02:07:00.000Z","photos":[],"link":"","_id":"cjfkkp3n5000ezd68wd1l1ul0","content":"<p>Spark是个好东西。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/spark_logo.jpg\" alt=\"Spark Logo\"></p>\n<p>Spark有以下四种运行模式：</p>\n<ul>\n<li>local: 本地单进程模式，用于本地开发测试Spark代码</li>\n<li>standalone：分布式集群模式，Master-Worker架构，Master负责调度，Worker负责具体Task的执行</li>\n<li>on yarn/mesos: ‌运行在yarn/mesos等资源管理框架之上，yarn/mesos提供资源管理，spark提供计算调度，并可与其他计算框架(如MapReduce/MPI/Storm)共同运行在同一个集群之上</li>\n<li>on cloud(EC2): 运行在AWS的EC2之上</li>\n</ul>\n<p>在Spark上又有多个应用，尤其是<code>MLlib</code>，<code>Spark SQL</code>和<code>DataFrame</code>，提供给数据科学家们无缝接口去搞所谓Data Science</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/spark_stack.jpg\" alt=\"spark stack\"></p>\n<p>本文记录一下我在Mac上安装Spark单机为分布式的过程</p>\n<a id=\"more\"></a>\n<h2 id=\"1-安装环境\"><a href=\"#1-安装环境\" class=\"headerlink\" title=\"1.安装环境\"></a>1.安装环境</h2><p>Spark依赖JDK 6.0以及Scala 2.9.3以上版本，安装好Java和Scala，然后配置好Java、Scala环境，最后再用<code>java -version</code>和<code>scala -version</code>验证一下</p>\n<p>在<code>~/.bash_profile</code>中加入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Setting PATH for scala</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> SCALA_HOME=/usr/<span class=\"built_in\">local</span>/Cellar/scala/2.11.6</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$SCALA_HOME</span>/bin:<span class=\"variable\">$PATH</span></span><br></pre></td></tr></table></figure>\n<p>别忘了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>生效</p>\n<p>由于在后面学习中主要会用到Spark的Python接口<code>pyspark</code>，所以在这儿也需要配置Python的环境变量：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Setting PATH for Python 2.7</span></span><br><span class=\"line\"><span class=\"comment\"># The orginal version is saved in .bash_profile.pysave</span></span><br><span class=\"line\">PATH=<span class=\"string\">\"/usr/local/Cellar/python/2.7.9/bin:<span class=\"variable\">$&#123;PATH&#125;</span>\"</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-伪分布式安装\"><a href=\"#2-伪分布式安装\" class=\"headerlink\" title=\"2.伪分布式安装\"></a>2.伪分布式安装</h2><p>Spark的安装和简单，只需要将Spark的安装包download下来，加入PATH即可。这里我用的是<a href=\"http://www.apache.org/dyn/closer.cgi/spark/spark-1.4.1/spark-1.4.1-bin-hadoop2.6.tgz\" target=\"_blank\" rel=\"noopener\">Spark 1.4.0</a></p>\n<p>当然，这里也可以使用Homebrew安装，那就更轻松了，直接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install apache-spark</span><br></pre></td></tr></table></figure>\n<p>就搞定了，不过Homebrew安装没办法自己控制箱要安装的版本</p>\n<p>这里我使用下载对Hadoop2.6的预编译版本安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/</span><br><span class=\"line\">wget http://www.apache.org/dyn/closer.cgi/spark/spark-1.4.0/spark-1.4.0-bin-hadoop2.6.tgz</span><br><span class=\"line\">tar zxvf spark-1.4.0-bin-hadoop2.6.tgz</span><br></pre></td></tr></table></figure>\n<p>设置Spark环境变量，<code>~/.bash_profile</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> SPARK_MASTER=localhost</span><br><span class=\"line\"><span class=\"built_in\">export</span> SPARK_LOCAL_IP=localhost</span><br><span class=\"line\"><span class=\"built_in\">export</span> SPARK_HOME=/usr/<span class=\"built_in\">local</span>/Cellar/spark-1.4.0-bin-hadoop2.6</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$SCALA_HOME</span>/bin:<span class=\"variable\">$SPARK_HOME</span>/bin</span><br><span class=\"line\"><span class=\"built_in\">export</span> PYTHONPATH=<span class=\"variable\">$SPARK_HOME</span>/python:<span class=\"variable\">$SPARK_HOME</span>/python/lib/py4j-0.8.2.1-src.zip:<span class=\"variable\">$PYTHONPATH</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"string\">\"/usr/local/sbin:<span class=\"variable\">$PATH</span>\"</span></span><br></pre></td></tr></table></figure>\n<p>安装完成，貌似也没什么安装哈~</p>\n<h2 id=\"跑起来\"><a href=\"#跑起来\" class=\"headerlink\" title=\"跑起来\"></a>跑起来</h2><p>执行Spark根目录下的pyspark就可以以交互的模式使用Spark了，这也是他的一个优点</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/SparkRun.jpg\" alt=\"Spark Run success\"></p>\n<p>出现Spark的标志，那就说明安装成功了。下面再小配置下，让画面的log简单一点。在<code>$SPARK_HOME/conf/</code>下配置一下<code>log4j</code>的设置。</p>\n<p>把<code>log4j.properties.template</code>文件复制一份，并删掉<code>.template</code>的扩展名</p>\n<p>把这个文件中的<code>INFO</code>内容全部替换成<code>WARN</code></p>\n<h2 id=\"在IPython中运行Spark\"><a href=\"#在IPython中运行Spark\" class=\"headerlink\" title=\"在IPython中运行Spark\"></a>在IPython中运行Spark</h2><p>说Spark好，那么IPython更是一大杀器，这个以后再介绍。先说设置</p>\n<p>首先，创建IPython的Spark配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ipython profile create pyspark</span><br></pre></td></tr></table></figure>\n<p>然后创建文件<code>$HOME/.ipython/profile_spark/startup/00-pyspark-setup.py</code>并添加：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\">spark_home = os.environ.get(<span class=\"string\">'SPARK_HOME'</span>, <span class=\"keyword\">None</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> spark_home:</span><br><span class=\"line\">    <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'SPARK_HOME environment variable is not set'</span>)</span><br><span class=\"line\">sys.path.insert(<span class=\"number\">0</span>, os.path.join(spark_home, <span class=\"string\">'python'</span>))</span><br><span class=\"line\">sys.path.insert(<span class=\"number\">0</span>, os.path.join(spark_home, <span class=\"string\">'python/lib/py4j-0.8.2.1-src.zip'</span>))</span><br><span class=\"line\">execfile(os.path.join(spark_home, <span class=\"string\">'python/pyspark/shell.py'</span>))</span><br></pre></td></tr></table></figure>\n<p>在IPython notebook中跑Spark</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ipython notebook --profile=pyspark</span><br></pre></td></tr></table></figure>\n<p>开始学习Spark吧！</p>\n<p>参考： <a href=\"https://districtdatalabs.silvrback.com/getting-started-with-spark-in-python\" target=\"_blank\" rel=\"noopener\">Getting Started with Spark (in Python)</a></p>\n","site":{"data":{}},"excerpt":"<p>Spark是个好东西。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/spark_logo.jpg\" alt=\"Spark Logo\"></p>\n<p>Spark有以下四种运行模式：</p>\n<ul>\n<li>local: 本地单进程模式，用于本地开发测试Spark代码</li>\n<li>standalone：分布式集群模式，Master-Worker架构，Master负责调度，Worker负责具体Task的执行</li>\n<li>on yarn/mesos: ‌运行在yarn/mesos等资源管理框架之上，yarn/mesos提供资源管理，spark提供计算调度，并可与其他计算框架(如MapReduce/MPI/Storm)共同运行在同一个集群之上</li>\n<li>on cloud(EC2): 运行在AWS的EC2之上</li>\n</ul>\n<p>在Spark上又有多个应用，尤其是<code>MLlib</code>，<code>Spark SQL</code>和<code>DataFrame</code>，提供给数据科学家们无缝接口去搞所谓Data Science</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/spark_stack.jpg\" alt=\"spark stack\"></p>\n<p>本文记录一下我在Mac上安装Spark单机为分布式的过程</p>","more":"<h2 id=\"1-安装环境\"><a href=\"#1-安装环境\" class=\"headerlink\" title=\"1.安装环境\"></a>1.安装环境</h2><p>Spark依赖JDK 6.0以及Scala 2.9.3以上版本，安装好Java和Scala，然后配置好Java、Scala环境，最后再用<code>java -version</code>和<code>scala -version</code>验证一下</p>\n<p>在<code>~/.bash_profile</code>中加入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Setting PATH for scala</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> SCALA_HOME=/usr/<span class=\"built_in\">local</span>/Cellar/scala/2.11.6</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$SCALA_HOME</span>/bin:<span class=\"variable\">$PATH</span></span><br></pre></td></tr></table></figure>\n<p>别忘了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>生效</p>\n<p>由于在后面学习中主要会用到Spark的Python接口<code>pyspark</code>，所以在这儿也需要配置Python的环境变量：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Setting PATH for Python 2.7</span></span><br><span class=\"line\"><span class=\"comment\"># The orginal version is saved in .bash_profile.pysave</span></span><br><span class=\"line\">PATH=<span class=\"string\">\"/usr/local/Cellar/python/2.7.9/bin:<span class=\"variable\">$&#123;PATH&#125;</span>\"</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-伪分布式安装\"><a href=\"#2-伪分布式安装\" class=\"headerlink\" title=\"2.伪分布式安装\"></a>2.伪分布式安装</h2><p>Spark的安装和简单，只需要将Spark的安装包download下来，加入PATH即可。这里我用的是<a href=\"http://www.apache.org/dyn/closer.cgi/spark/spark-1.4.1/spark-1.4.1-bin-hadoop2.6.tgz\" target=\"_blank\" rel=\"noopener\">Spark 1.4.0</a></p>\n<p>当然，这里也可以使用Homebrew安装，那就更轻松了，直接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install apache-spark</span><br></pre></td></tr></table></figure>\n<p>就搞定了，不过Homebrew安装没办法自己控制箱要安装的版本</p>\n<p>这里我使用下载对Hadoop2.6的预编译版本安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/</span><br><span class=\"line\">wget http://www.apache.org/dyn/closer.cgi/spark/spark-1.4.0/spark-1.4.0-bin-hadoop2.6.tgz</span><br><span class=\"line\">tar zxvf spark-1.4.0-bin-hadoop2.6.tgz</span><br></pre></td></tr></table></figure>\n<p>设置Spark环境变量，<code>~/.bash_profile</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> SPARK_MASTER=localhost</span><br><span class=\"line\"><span class=\"built_in\">export</span> SPARK_LOCAL_IP=localhost</span><br><span class=\"line\"><span class=\"built_in\">export</span> SPARK_HOME=/usr/<span class=\"built_in\">local</span>/Cellar/spark-1.4.0-bin-hadoop2.6</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$SCALA_HOME</span>/bin:<span class=\"variable\">$SPARK_HOME</span>/bin</span><br><span class=\"line\"><span class=\"built_in\">export</span> PYTHONPATH=<span class=\"variable\">$SPARK_HOME</span>/python:<span class=\"variable\">$SPARK_HOME</span>/python/lib/py4j-0.8.2.1-src.zip:<span class=\"variable\">$PYTHONPATH</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"string\">\"/usr/local/sbin:<span class=\"variable\">$PATH</span>\"</span></span><br></pre></td></tr></table></figure>\n<p>安装完成，貌似也没什么安装哈~</p>\n<h2 id=\"跑起来\"><a href=\"#跑起来\" class=\"headerlink\" title=\"跑起来\"></a>跑起来</h2><p>执行Spark根目录下的pyspark就可以以交互的模式使用Spark了，这也是他的一个优点</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/SparkRun.jpg\" alt=\"Spark Run success\"></p>\n<p>出现Spark的标志，那就说明安装成功了。下面再小配置下，让画面的log简单一点。在<code>$SPARK_HOME/conf/</code>下配置一下<code>log4j</code>的设置。</p>\n<p>把<code>log4j.properties.template</code>文件复制一份，并删掉<code>.template</code>的扩展名</p>\n<p>把这个文件中的<code>INFO</code>内容全部替换成<code>WARN</code></p>\n<h2 id=\"在IPython中运行Spark\"><a href=\"#在IPython中运行Spark\" class=\"headerlink\" title=\"在IPython中运行Spark\"></a>在IPython中运行Spark</h2><p>说Spark好，那么IPython更是一大杀器，这个以后再介绍。先说设置</p>\n<p>首先，创建IPython的Spark配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ipython profile create pyspark</span><br></pre></td></tr></table></figure>\n<p>然后创建文件<code>$HOME/.ipython/profile_spark/startup/00-pyspark-setup.py</code>并添加：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\">spark_home = os.environ.get(<span class=\"string\">'SPARK_HOME'</span>, <span class=\"keyword\">None</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> spark_home:</span><br><span class=\"line\">    <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'SPARK_HOME environment variable is not set'</span>)</span><br><span class=\"line\">sys.path.insert(<span class=\"number\">0</span>, os.path.join(spark_home, <span class=\"string\">'python'</span>))</span><br><span class=\"line\">sys.path.insert(<span class=\"number\">0</span>, os.path.join(spark_home, <span class=\"string\">'python/lib/py4j-0.8.2.1-src.zip'</span>))</span><br><span class=\"line\">execfile(os.path.join(spark_home, <span class=\"string\">'python/pyspark/shell.py'</span>))</span><br></pre></td></tr></table></figure>\n<p>在IPython notebook中跑Spark</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ipython notebook --profile=pyspark</span><br></pre></td></tr></table></figure>\n<p>开始学习Spark吧！</p>\n<p>参考： <a href=\"https://districtdatalabs.silvrback.com/getting-started-with-spark-in-python\" target=\"_blank\" rel=\"noopener\">Getting Started with Spark (in Python)</a></p>"},{"layout":"post","title":"Install Hadoop on Yosemite","date":"2015-07-17T09:20:58.000Z","comments":1,"_content":"\n\n\n终于进入正题，开始写一写我在大数据方面走过的路，自认为被其他人甩下了，所以一定要紧追而上。 首先现在我的Mac上装上单节点的Hadoop玩玩，个人感觉Apache系列的项目，只要download下来，再配置以下参数就能玩了。\n\n![Hadoop Logo](http://7xkfga.com1.z0.glb.clouddn.com/hadooplogo-e1434684861708.png)\n\n在这里感谢如下教程：\n\n[INSTALLING HADOOP ON MAC](http://amodernstory.com/2014/09/23/installing-hadoop-on-mac-osx-yosemite/)\n\n[Writing an Hadoop MapReduce Program in Python](http://www.michael-noll.com/tutorials/writing-an-hadoop-mapreduce-program-in-python/)\n\n下面开始吧\n\n<!--more-->\n\n## 准备\n这个阶段主要就是准备一下JAVA的环境，Mac默认是安装了Java的，不过版本就不知道了，这个还是自己安装一下并且写到环境变量里来得踏实\n\n[Java Download](http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html#jdk-7u80-oth-JPR)\n\n安装完之后，Java被装到了这个位置\n```\n/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home\n```\n，把这个地址写到系统的环境变量文件`.bash_profile`里\n\n``` bash\n# Setting PATH for java\nexport JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home\nexport PATH=$JAVA_HOME/bin:$PATH\n```\n\n\n**配置SSH**\n\nNothing needs to be done here if you have already generated ssh keys. To verify just check for the existance of ~/.ssh/id_rsa and the ~/.ssh/id_rsa.pub files. If not the keys can be generated using\n\n``` bash\n$ ssh-keygen -t rsa\n```\n\nEnable Remote Login\n\n“System Preferences” -> “Sharing”. Check “Remote Login”\nAuthorize SSH Keys\nTo allow your system to accept login, we have to make it aware of the keys that will be used\n\n``` bash\n$ cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\n```\nLet’s try to login.\n\n``` bash\n$ ssh localhost\nLast login: Fri Mar  6 20:30:53 2015\n$ exit\n```\n\n## 安装Homebrew\n在Mac上，最好的包安装工具就是Homebrew，执行下面代码安装：\n\n``` bash\n$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n## 安装Hadoop\n我去，这么简单，直接\n\n``` bash\n$ brew install hadoop\n```\n\n就搞定了。。。\n这样，Hadoop会被安装在`/usr/local/Cellar/hadoop`目录下\n\n下面才是重点，配置Hadoop\n\n## 配置Hadoop\n### hadoop-env.sh\n\n该文件在`/usr/local/Cellar/hadoop/2.6.0/libexec/etc/hadoop/hadoop-env.sh`\n\n找到如下这行：\n\n``` bash\nexport HADOOP_OPTS=\"$HADOOP_OPTS -Djava.net.preferIPv4Stack=true\"\n```\n\n改为：\n\n``` bash\nexport HADOOP_OPTS=\"$HADOOP_OPTS -Djava.net.preferIPv4Stack=true -Djava.security.krb5.realm= -Djava.security.krb5.kdc=\"\n```\n\n### Core-site.xml\n\n该文件在`/usr/local/Cellar/hadoop/2.6.0/libexec/etc/hadoop/core-site.xml`\n\n``` xml\n  <property>\n     <name>hadoop.tmp.dir</name>\n     <value>/usr/local/Cellar/hadoop/hdfs/tmp</value>\n     <description>A base for other temporary directories.</description>\n  </property>\n  <property>\n     <name>fs.default.name</name>                                     \n     <value>hdfs://localhost:9000</value>                             \n  </property> \n```\n\n### mapred-site.xml\n\n文件在`/usr/local/Cellar/hadoop/2.6.0/libexec/etc/hadoop/mapred-site.xml`\n\n``` xml\n<configuration>\n    <property>\n        <name>mapred.job.tracker</name>\n        <value>localhost:9010</value>\n    </property>\n</configuration>\n```\n\n### hdfs-site.xml\n\n文件在`/usr/local/Cellar/hadoop/2.6.0/libexec/etc/hadoop/hdfs-site.xml`\n\n``` xml\n<configuration>\n    <property>\n        <name>dfs.replication</name>\n        <value>1</value>\n    </property>\n</configuration>\n```\n\n这就配置好了\n\n### 添加启动关闭Hadoop快捷命令\n\n为了以后方便使用Hadoop，在`.bash_profile`中添加\n\n``` bash\nalias hstart=\"/usr/local/Cellar/hadoop/2.6.0/sbin/start-dfs.sh;/usr/local/Cellar/hadoop/2.6.0/sbin/start-yarn.sh\"\nalias hstop=\"/usr/local/Cellar/hadoop/2.6.0/sbin/stop-yarn.sh;/usr/local/Cellar/hadoop/2.6.0/sbin/stop-dfs.sh\"\n```\n\n执行下面命令将配置生效：\n\n``` bash\nsource ~/.bash_profile\n```\n\n以后就能使用命令`hstart`启动Hadoop服务，`hstop`关闭Hadoop\n\n### 格式化HDFS\n\n在使用Hadoop之前，还需要将HDFS格式化\n\n``` bash\n$ hdfs namenode -format\n```\n\n## Running Hadoop\n奔跑吧Hadoop\n\n```\n$ hstart\n```\n\n使用`jps`命令查看Hadoop运行状态\n\n```\n$ jps\n18065 SecondaryNameNode\n18283 Jps\n17965 DataNode\n18258 NodeManager\n18171 ResourceManager\n17885 NameNode\n```\n\n下面是几个很有用的监控Hadoop地址：\n\n- Resource Manager: [http://localhost:50070](http://localhost:50070)\n- JobTracker: [http://localhost:8088](http://localhost:8088)\n- Specific Node Information: [http://localhost:8042](http://localhost:8042)\n\n停止Hadoop：\n\n```\n$ hstop\n```\n\n## 添加Hadoop环境变量\n为了以后安装Spark等方便，在`~/.bash_profile`配置中添加Hadoop环境变量\n\n``` bash\n\t# Setting PATH for hadoop\n\texport HADOOP_HOME=/usr/local/Cellar/hadoop/2.6.0/libexec\n\texport PATH=$HADOOP_HOME/bin:$PATH\n\n\texport HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop\n```\n\n## 可能遇到的问题\n跑起来之后，或者在跑起来的过程中，可能会遇到各种问题，由于控制台命令太多，很难知道到底是哪儿出的问题，所以我总结出几个我遇到的问题和解决方法，分享给大家。\nTBD\n\n1. NameNode启动失败\n2. \n\n大功告成！可以在Hadoop上跑几个MapReduce任务了。","source":"_posts/2015-07-17-install-hadoop-on-mac-osx-yosemite.markdown","raw":"---\nlayout: post\ntitle: \"Install Hadoop on Yosemite\"\ndate: 2015-07-17 17:20:58 +0800\ncomments: true\ncategories: [Big Data, Hadoop]\ntag: [Big Data, Hadoop]\n---\n\n\n\n终于进入正题，开始写一写我在大数据方面走过的路，自认为被其他人甩下了，所以一定要紧追而上。 首先现在我的Mac上装上单节点的Hadoop玩玩，个人感觉Apache系列的项目，只要download下来，再配置以下参数就能玩了。\n\n![Hadoop Logo](http://7xkfga.com1.z0.glb.clouddn.com/hadooplogo-e1434684861708.png)\n\n在这里感谢如下教程：\n\n[INSTALLING HADOOP ON MAC](http://amodernstory.com/2014/09/23/installing-hadoop-on-mac-osx-yosemite/)\n\n[Writing an Hadoop MapReduce Program in Python](http://www.michael-noll.com/tutorials/writing-an-hadoop-mapreduce-program-in-python/)\n\n下面开始吧\n\n<!--more-->\n\n## 准备\n这个阶段主要就是准备一下JAVA的环境，Mac默认是安装了Java的，不过版本就不知道了，这个还是自己安装一下并且写到环境变量里来得踏实\n\n[Java Download](http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html#jdk-7u80-oth-JPR)\n\n安装完之后，Java被装到了这个位置\n```\n/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home\n```\n，把这个地址写到系统的环境变量文件`.bash_profile`里\n\n``` bash\n# Setting PATH for java\nexport JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home\nexport PATH=$JAVA_HOME/bin:$PATH\n```\n\n\n**配置SSH**\n\nNothing needs to be done here if you have already generated ssh keys. To verify just check for the existance of ~/.ssh/id_rsa and the ~/.ssh/id_rsa.pub files. If not the keys can be generated using\n\n``` bash\n$ ssh-keygen -t rsa\n```\n\nEnable Remote Login\n\n“System Preferences” -> “Sharing”. Check “Remote Login”\nAuthorize SSH Keys\nTo allow your system to accept login, we have to make it aware of the keys that will be used\n\n``` bash\n$ cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\n```\nLet’s try to login.\n\n``` bash\n$ ssh localhost\nLast login: Fri Mar  6 20:30:53 2015\n$ exit\n```\n\n## 安装Homebrew\n在Mac上，最好的包安装工具就是Homebrew，执行下面代码安装：\n\n``` bash\n$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n## 安装Hadoop\n我去，这么简单，直接\n\n``` bash\n$ brew install hadoop\n```\n\n就搞定了。。。\n这样，Hadoop会被安装在`/usr/local/Cellar/hadoop`目录下\n\n下面才是重点，配置Hadoop\n\n## 配置Hadoop\n### hadoop-env.sh\n\n该文件在`/usr/local/Cellar/hadoop/2.6.0/libexec/etc/hadoop/hadoop-env.sh`\n\n找到如下这行：\n\n``` bash\nexport HADOOP_OPTS=\"$HADOOP_OPTS -Djava.net.preferIPv4Stack=true\"\n```\n\n改为：\n\n``` bash\nexport HADOOP_OPTS=\"$HADOOP_OPTS -Djava.net.preferIPv4Stack=true -Djava.security.krb5.realm= -Djava.security.krb5.kdc=\"\n```\n\n### Core-site.xml\n\n该文件在`/usr/local/Cellar/hadoop/2.6.0/libexec/etc/hadoop/core-site.xml`\n\n``` xml\n  <property>\n     <name>hadoop.tmp.dir</name>\n     <value>/usr/local/Cellar/hadoop/hdfs/tmp</value>\n     <description>A base for other temporary directories.</description>\n  </property>\n  <property>\n     <name>fs.default.name</name>                                     \n     <value>hdfs://localhost:9000</value>                             \n  </property> \n```\n\n### mapred-site.xml\n\n文件在`/usr/local/Cellar/hadoop/2.6.0/libexec/etc/hadoop/mapred-site.xml`\n\n``` xml\n<configuration>\n    <property>\n        <name>mapred.job.tracker</name>\n        <value>localhost:9010</value>\n    </property>\n</configuration>\n```\n\n### hdfs-site.xml\n\n文件在`/usr/local/Cellar/hadoop/2.6.0/libexec/etc/hadoop/hdfs-site.xml`\n\n``` xml\n<configuration>\n    <property>\n        <name>dfs.replication</name>\n        <value>1</value>\n    </property>\n</configuration>\n```\n\n这就配置好了\n\n### 添加启动关闭Hadoop快捷命令\n\n为了以后方便使用Hadoop，在`.bash_profile`中添加\n\n``` bash\nalias hstart=\"/usr/local/Cellar/hadoop/2.6.0/sbin/start-dfs.sh;/usr/local/Cellar/hadoop/2.6.0/sbin/start-yarn.sh\"\nalias hstop=\"/usr/local/Cellar/hadoop/2.6.0/sbin/stop-yarn.sh;/usr/local/Cellar/hadoop/2.6.0/sbin/stop-dfs.sh\"\n```\n\n执行下面命令将配置生效：\n\n``` bash\nsource ~/.bash_profile\n```\n\n以后就能使用命令`hstart`启动Hadoop服务，`hstop`关闭Hadoop\n\n### 格式化HDFS\n\n在使用Hadoop之前，还需要将HDFS格式化\n\n``` bash\n$ hdfs namenode -format\n```\n\n## Running Hadoop\n奔跑吧Hadoop\n\n```\n$ hstart\n```\n\n使用`jps`命令查看Hadoop运行状态\n\n```\n$ jps\n18065 SecondaryNameNode\n18283 Jps\n17965 DataNode\n18258 NodeManager\n18171 ResourceManager\n17885 NameNode\n```\n\n下面是几个很有用的监控Hadoop地址：\n\n- Resource Manager: [http://localhost:50070](http://localhost:50070)\n- JobTracker: [http://localhost:8088](http://localhost:8088)\n- Specific Node Information: [http://localhost:8042](http://localhost:8042)\n\n停止Hadoop：\n\n```\n$ hstop\n```\n\n## 添加Hadoop环境变量\n为了以后安装Spark等方便，在`~/.bash_profile`配置中添加Hadoop环境变量\n\n``` bash\n\t# Setting PATH for hadoop\n\texport HADOOP_HOME=/usr/local/Cellar/hadoop/2.6.0/libexec\n\texport PATH=$HADOOP_HOME/bin:$PATH\n\n\texport HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop\n```\n\n## 可能遇到的问题\n跑起来之后，或者在跑起来的过程中，可能会遇到各种问题，由于控制台命令太多，很难知道到底是哪儿出的问题，所以我总结出几个我遇到的问题和解决方法，分享给大家。\nTBD\n\n1. NameNode启动失败\n2. \n\n大功告成！可以在Hadoop上跑几个MapReduce任务了。","slug":"2015-07-17-install-hadoop-on-mac-osx-yosemite","published":1,"updated":"2016-09-20T02:07:00.000Z","photos":[],"link":"","_id":"cjfkkp3n7000izd6897q3n5r7","content":"<p>终于进入正题，开始写一写我在大数据方面走过的路，自认为被其他人甩下了，所以一定要紧追而上。 首先现在我的Mac上装上单节点的Hadoop玩玩，个人感觉Apache系列的项目，只要download下来，再配置以下参数就能玩了。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/hadooplogo-e1434684861708.png\" alt=\"Hadoop Logo\"></p>\n<p>在这里感谢如下教程：</p>\n<p><a href=\"http://amodernstory.com/2014/09/23/installing-hadoop-on-mac-osx-yosemite/\" target=\"_blank\" rel=\"noopener\">INSTALLING HADOOP ON MAC</a></p>\n<p><a href=\"http://www.michael-noll.com/tutorials/writing-an-hadoop-mapreduce-program-in-python/\" target=\"_blank\" rel=\"noopener\">Writing an Hadoop MapReduce Program in Python</a></p>\n<p>下面开始吧</p>\n<a id=\"more\"></a>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>这个阶段主要就是准备一下JAVA的环境，Mac默认是安装了Java的，不过版本就不知道了，这个还是自己安装一下并且写到环境变量里来得踏实</p>\n<p><a href=\"http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html#jdk-7u80-oth-JPR\" target=\"_blank\" rel=\"noopener\">Java Download</a></p>\n<p>安装完之后，Java被装到了这个位置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home</span><br></pre></td></tr></table></figure></p>\n<p>，把这个地址写到系统的环境变量文件<code>.bash_profile</code>里</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Setting PATH for java</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$JAVA_HOME</span>/bin:<span class=\"variable\">$PATH</span></span><br></pre></td></tr></table></figure>\n<p><strong>配置SSH</strong></p>\n<p>Nothing needs to be done here if you have already generated ssh keys. To verify just check for the existance of ~/.ssh/id_rsa and the ~/.ssh/id_rsa.pub files. If not the keys can be generated using</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>\n<p>Enable Remote Login</p>\n<p>“System Preferences” -&gt; “Sharing”. Check “Remote Login”<br>Authorize SSH Keys<br>To allow your system to accept login, we have to make it aware of the keys that will be used</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>\n<p>Let’s try to login.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh localhost</span><br><span class=\"line\">Last login: Fri Mar  6 20:30:53 2015</span><br><span class=\"line\">$ <span class=\"built_in\">exit</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"安装Homebrew\"><a href=\"#安装Homebrew\" class=\"headerlink\" title=\"安装Homebrew\"></a>安装Homebrew</h2><p>在Mac上，最好的包安装工具就是Homebrew，执行下面代码安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ruby -e <span class=\"string\">\"<span class=\"variable\">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"安装Hadoop\"><a href=\"#安装Hadoop\" class=\"headerlink\" title=\"安装Hadoop\"></a>安装Hadoop</h2><p>我去，这么简单，直接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install hadoop</span><br></pre></td></tr></table></figure>\n<p>就搞定了。。。<br>这样，Hadoop会被安装在<code>/usr/local/Cellar/hadoop</code>目录下</p>\n<p>下面才是重点，配置Hadoop</p>\n<h2 id=\"配置Hadoop\"><a href=\"#配置Hadoop\" class=\"headerlink\" title=\"配置Hadoop\"></a>配置Hadoop</h2><h3 id=\"hadoop-env-sh\"><a href=\"#hadoop-env-sh\" class=\"headerlink\" title=\"hadoop-env.sh\"></a>hadoop-env.sh</h3><p>该文件在<code>/usr/local/Cellar/hadoop/2.6.0/libexec/etc/hadoop/hadoop-env.sh</code></p>\n<p>找到如下这行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_OPTS=<span class=\"string\">\"<span class=\"variable\">$HADOOP_OPTS</span> -Djava.net.preferIPv4Stack=true\"</span></span><br></pre></td></tr></table></figure>\n<p>改为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_OPTS=<span class=\"string\">\"<span class=\"variable\">$HADOOP_OPTS</span> -Djava.net.preferIPv4Stack=true -Djava.security.krb5.realm= -Djava.security.krb5.kdc=\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Core-site-xml\"><a href=\"#Core-site-xml\" class=\"headerlink\" title=\"Core-site.xml\"></a>Core-site.xml</h3><p>该文件在<code>/usr/local/Cellar/hadoop/2.6.0/libexec/etc/hadoop/core-site.xml</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.tmp.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/usr/local/Cellar/hadoop/hdfs/tmp<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>A base for other temporary directories.<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>fs.default.name<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span>                                     </span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>hdfs://localhost:9000<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span>                             </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"mapred-site-xml\"><a href=\"#mapred-site-xml\" class=\"headerlink\" title=\"mapred-site.xml\"></a>mapred-site.xml</h3><p>文件在<code>/usr/local/Cellar/hadoop/2.6.0/libexec/etc/hadoop/mapred-site.xml</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>mapred.job.tracker<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>localhost:9010<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"hdfs-site-xml\"><a href=\"#hdfs-site-xml\" class=\"headerlink\" title=\"hdfs-site.xml\"></a>hdfs-site.xml</h3><p>文件在<code>/usr/local/Cellar/hadoop/2.6.0/libexec/etc/hadoop/hdfs-site.xml</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.replication<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这就配置好了</p>\n<h3 id=\"添加启动关闭Hadoop快捷命令\"><a href=\"#添加启动关闭Hadoop快捷命令\" class=\"headerlink\" title=\"添加启动关闭Hadoop快捷命令\"></a>添加启动关闭Hadoop快捷命令</h3><p>为了以后方便使用Hadoop，在<code>.bash_profile</code>中添加</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> hstart=<span class=\"string\">\"/usr/local/Cellar/hadoop/2.6.0/sbin/start-dfs.sh;/usr/local/Cellar/hadoop/2.6.0/sbin/start-yarn.sh\"</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> hstop=<span class=\"string\">\"/usr/local/Cellar/hadoop/2.6.0/sbin/stop-yarn.sh;/usr/local/Cellar/hadoop/2.6.0/sbin/stop-dfs.sh\"</span></span><br></pre></td></tr></table></figure>\n<p>执行下面命令将配置生效：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>以后就能使用命令<code>hstart</code>启动Hadoop服务，<code>hstop</code>关闭Hadoop</p>\n<h3 id=\"格式化HDFS\"><a href=\"#格式化HDFS\" class=\"headerlink\" title=\"格式化HDFS\"></a>格式化HDFS</h3><p>在使用Hadoop之前，还需要将HDFS格式化</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hdfs namenode -format</span><br></pre></td></tr></table></figure>\n<h2 id=\"Running-Hadoop\"><a href=\"#Running-Hadoop\" class=\"headerlink\" title=\"Running Hadoop\"></a>Running Hadoop</h2><p>奔跑吧Hadoop</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hstart</span><br></pre></td></tr></table></figure>\n<p>使用<code>jps</code>命令查看Hadoop运行状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jps</span><br><span class=\"line\">18065 SecondaryNameNode</span><br><span class=\"line\">18283 Jps</span><br><span class=\"line\">17965 DataNode</span><br><span class=\"line\">18258 NodeManager</span><br><span class=\"line\">18171 ResourceManager</span><br><span class=\"line\">17885 NameNode</span><br></pre></td></tr></table></figure>\n<p>下面是几个很有用的监控Hadoop地址：</p>\n<ul>\n<li>Resource Manager: <a href=\"http://localhost:50070\" target=\"_blank\" rel=\"noopener\">http://localhost:50070</a></li>\n<li>JobTracker: <a href=\"http://localhost:8088\" target=\"_blank\" rel=\"noopener\">http://localhost:8088</a></li>\n<li>Specific Node Information: <a href=\"http://localhost:8042\" target=\"_blank\" rel=\"noopener\">http://localhost:8042</a></li>\n</ul>\n<p>停止Hadoop：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hstop</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加Hadoop环境变量\"><a href=\"#添加Hadoop环境变量\" class=\"headerlink\" title=\"添加Hadoop环境变量\"></a>添加Hadoop环境变量</h2><p>为了以后安装Spark等方便，在<code>~/.bash_profile</code>配置中添加Hadoop环境变量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Setting PATH for hadoop</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_HOME=/usr/<span class=\"built_in\">local</span>/Cellar/hadoop/2.6.0/libexec</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$HADOOP_HOME</span>/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_CONF_DIR=<span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop</span><br></pre></td></tr></table></figure>\n<h2 id=\"可能遇到的问题\"><a href=\"#可能遇到的问题\" class=\"headerlink\" title=\"可能遇到的问题\"></a>可能遇到的问题</h2><p>跑起来之后，或者在跑起来的过程中，可能会遇到各种问题，由于控制台命令太多，很难知道到底是哪儿出的问题，所以我总结出几个我遇到的问题和解决方法，分享给大家。<br>TBD</p>\n<ol>\n<li>NameNode启动失败</li>\n<li></li>\n</ol>\n<p>大功告成！可以在Hadoop上跑几个MapReduce任务了。</p>\n","site":{"data":{}},"excerpt":"<p>终于进入正题，开始写一写我在大数据方面走过的路，自认为被其他人甩下了，所以一定要紧追而上。 首先现在我的Mac上装上单节点的Hadoop玩玩，个人感觉Apache系列的项目，只要download下来，再配置以下参数就能玩了。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/hadooplogo-e1434684861708.png\" alt=\"Hadoop Logo\"></p>\n<p>在这里感谢如下教程：</p>\n<p><a href=\"http://amodernstory.com/2014/09/23/installing-hadoop-on-mac-osx-yosemite/\" target=\"_blank\" rel=\"noopener\">INSTALLING HADOOP ON MAC</a></p>\n<p><a href=\"http://www.michael-noll.com/tutorials/writing-an-hadoop-mapreduce-program-in-python/\" target=\"_blank\" rel=\"noopener\">Writing an Hadoop MapReduce Program in Python</a></p>\n<p>下面开始吧</p>","more":"<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>这个阶段主要就是准备一下JAVA的环境，Mac默认是安装了Java的，不过版本就不知道了，这个还是自己安装一下并且写到环境变量里来得踏实</p>\n<p><a href=\"http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html#jdk-7u80-oth-JPR\" target=\"_blank\" rel=\"noopener\">Java Download</a></p>\n<p>安装完之后，Java被装到了这个位置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home</span><br></pre></td></tr></table></figure></p>\n<p>，把这个地址写到系统的环境变量文件<code>.bash_profile</code>里</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Setting PATH for java</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$JAVA_HOME</span>/bin:<span class=\"variable\">$PATH</span></span><br></pre></td></tr></table></figure>\n<p><strong>配置SSH</strong></p>\n<p>Nothing needs to be done here if you have already generated ssh keys. To verify just check for the existance of ~/.ssh/id_rsa and the ~/.ssh/id_rsa.pub files. If not the keys can be generated using</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>\n<p>Enable Remote Login</p>\n<p>“System Preferences” -&gt; “Sharing”. Check “Remote Login”<br>Authorize SSH Keys<br>To allow your system to accept login, we have to make it aware of the keys that will be used</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>\n<p>Let’s try to login.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh localhost</span><br><span class=\"line\">Last login: Fri Mar  6 20:30:53 2015</span><br><span class=\"line\">$ <span class=\"built_in\">exit</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"安装Homebrew\"><a href=\"#安装Homebrew\" class=\"headerlink\" title=\"安装Homebrew\"></a>安装Homebrew</h2><p>在Mac上，最好的包安装工具就是Homebrew，执行下面代码安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ruby -e <span class=\"string\">\"<span class=\"variable\">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"安装Hadoop\"><a href=\"#安装Hadoop\" class=\"headerlink\" title=\"安装Hadoop\"></a>安装Hadoop</h2><p>我去，这么简单，直接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install hadoop</span><br></pre></td></tr></table></figure>\n<p>就搞定了。。。<br>这样，Hadoop会被安装在<code>/usr/local/Cellar/hadoop</code>目录下</p>\n<p>下面才是重点，配置Hadoop</p>\n<h2 id=\"配置Hadoop\"><a href=\"#配置Hadoop\" class=\"headerlink\" title=\"配置Hadoop\"></a>配置Hadoop</h2><h3 id=\"hadoop-env-sh\"><a href=\"#hadoop-env-sh\" class=\"headerlink\" title=\"hadoop-env.sh\"></a>hadoop-env.sh</h3><p>该文件在<code>/usr/local/Cellar/hadoop/2.6.0/libexec/etc/hadoop/hadoop-env.sh</code></p>\n<p>找到如下这行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_OPTS=<span class=\"string\">\"<span class=\"variable\">$HADOOP_OPTS</span> -Djava.net.preferIPv4Stack=true\"</span></span><br></pre></td></tr></table></figure>\n<p>改为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_OPTS=<span class=\"string\">\"<span class=\"variable\">$HADOOP_OPTS</span> -Djava.net.preferIPv4Stack=true -Djava.security.krb5.realm= -Djava.security.krb5.kdc=\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Core-site-xml\"><a href=\"#Core-site-xml\" class=\"headerlink\" title=\"Core-site.xml\"></a>Core-site.xml</h3><p>该文件在<code>/usr/local/Cellar/hadoop/2.6.0/libexec/etc/hadoop/core-site.xml</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.tmp.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/usr/local/Cellar/hadoop/hdfs/tmp<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>A base for other temporary directories.<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>fs.default.name<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span>                                     </span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>hdfs://localhost:9000<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span>                             </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"mapred-site-xml\"><a href=\"#mapred-site-xml\" class=\"headerlink\" title=\"mapred-site.xml\"></a>mapred-site.xml</h3><p>文件在<code>/usr/local/Cellar/hadoop/2.6.0/libexec/etc/hadoop/mapred-site.xml</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>mapred.job.tracker<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>localhost:9010<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"hdfs-site-xml\"><a href=\"#hdfs-site-xml\" class=\"headerlink\" title=\"hdfs-site.xml\"></a>hdfs-site.xml</h3><p>文件在<code>/usr/local/Cellar/hadoop/2.6.0/libexec/etc/hadoop/hdfs-site.xml</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.replication<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这就配置好了</p>\n<h3 id=\"添加启动关闭Hadoop快捷命令\"><a href=\"#添加启动关闭Hadoop快捷命令\" class=\"headerlink\" title=\"添加启动关闭Hadoop快捷命令\"></a>添加启动关闭Hadoop快捷命令</h3><p>为了以后方便使用Hadoop，在<code>.bash_profile</code>中添加</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> hstart=<span class=\"string\">\"/usr/local/Cellar/hadoop/2.6.0/sbin/start-dfs.sh;/usr/local/Cellar/hadoop/2.6.0/sbin/start-yarn.sh\"</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> hstop=<span class=\"string\">\"/usr/local/Cellar/hadoop/2.6.0/sbin/stop-yarn.sh;/usr/local/Cellar/hadoop/2.6.0/sbin/stop-dfs.sh\"</span></span><br></pre></td></tr></table></figure>\n<p>执行下面命令将配置生效：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>以后就能使用命令<code>hstart</code>启动Hadoop服务，<code>hstop</code>关闭Hadoop</p>\n<h3 id=\"格式化HDFS\"><a href=\"#格式化HDFS\" class=\"headerlink\" title=\"格式化HDFS\"></a>格式化HDFS</h3><p>在使用Hadoop之前，还需要将HDFS格式化</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hdfs namenode -format</span><br></pre></td></tr></table></figure>\n<h2 id=\"Running-Hadoop\"><a href=\"#Running-Hadoop\" class=\"headerlink\" title=\"Running Hadoop\"></a>Running Hadoop</h2><p>奔跑吧Hadoop</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hstart</span><br></pre></td></tr></table></figure>\n<p>使用<code>jps</code>命令查看Hadoop运行状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jps</span><br><span class=\"line\">18065 SecondaryNameNode</span><br><span class=\"line\">18283 Jps</span><br><span class=\"line\">17965 DataNode</span><br><span class=\"line\">18258 NodeManager</span><br><span class=\"line\">18171 ResourceManager</span><br><span class=\"line\">17885 NameNode</span><br></pre></td></tr></table></figure>\n<p>下面是几个很有用的监控Hadoop地址：</p>\n<ul>\n<li>Resource Manager: <a href=\"http://localhost:50070\" target=\"_blank\" rel=\"noopener\">http://localhost:50070</a></li>\n<li>JobTracker: <a href=\"http://localhost:8088\" target=\"_blank\" rel=\"noopener\">http://localhost:8088</a></li>\n<li>Specific Node Information: <a href=\"http://localhost:8042\" target=\"_blank\" rel=\"noopener\">http://localhost:8042</a></li>\n</ul>\n<p>停止Hadoop：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hstop</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加Hadoop环境变量\"><a href=\"#添加Hadoop环境变量\" class=\"headerlink\" title=\"添加Hadoop环境变量\"></a>添加Hadoop环境变量</h2><p>为了以后安装Spark等方便，在<code>~/.bash_profile</code>配置中添加Hadoop环境变量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Setting PATH for hadoop</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_HOME=/usr/<span class=\"built_in\">local</span>/Cellar/hadoop/2.6.0/libexec</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$HADOOP_HOME</span>/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_CONF_DIR=<span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop</span><br></pre></td></tr></table></figure>\n<h2 id=\"可能遇到的问题\"><a href=\"#可能遇到的问题\" class=\"headerlink\" title=\"可能遇到的问题\"></a>可能遇到的问题</h2><p>跑起来之后，或者在跑起来的过程中，可能会遇到各种问题，由于控制台命令太多，很难知道到底是哪儿出的问题，所以我总结出几个我遇到的问题和解决方法，分享给大家。<br>TBD</p>\n<ol>\n<li>NameNode启动失败</li>\n<li></li>\n</ol>\n<p>大功告成！可以在Hadoop上跑几个MapReduce任务了。</p>"},{"layout":"post","title":"开始使用Scikit-Learn","date":"2015-07-23T10:14:35.000Z","comments":1,"_content":"\n\nPython和R是做数据分析、数据挖掘、机器学习非常好的两门语言，在这儿不去讨论谁更好这个问题，没有最好，只有合适上手。对于码农出身，非科班统计学的我来说，使用Python相当习惯和顺手。\n\n## Python数据科学栈\n\nPython有很多做数据的类库，先列出常用的几个：\n\n- Numpy、Scipy 基础数据类型\n- Matplotlib 绘图库\n- Pandas\n- Ipython notebook\n- Scikit-learn、MLlib 机器学习库\n\n\n\n<!--more-->\n\n\n\n## 使用Scikit-learn的过程\n\n### 数据加载\n\n首先，将数据加载到内存中\n\n```python\n\timport numpy as np\n\timport urllib\n\turl = \"http://archive.ics.uci.edu/ml/machine-learning-databases/pima-indians-diabetes/pima-indians-diabetes.data\"\n\t# download the file\n\traw_data = urllib.urlopen(url)\n\tdataset = np.loadtxt(raw_data, delimiter=',')\n\tX = dataset[:, 0:7]\n\ty = dataset[:, 8]\n```\n\n`X`为特征数组，`y`为目标变量\n\n### 数据标准化 (Data Normalization)\n\n大多数的梯度算法对数据的缩放很敏感，比如列A是体重数据(50kg等等)，列B是身高数据(170cm等等)，简单地说就是两个属性尺度不一样，所以在运行算法前要进行标准化或者叫归一化。\n\n```python\n\tfrom sklearn import preprocessing\n\t# normalize the data attributes\n\tnormalized_X = preprocessing.normalize(X)\n```\n\n### 特征选取\n\n虽然特征工程是一个相当有创造性的过程，有时候更多的是靠直觉和专业的知识，但对于特征的选取，已经有很多的算法可供直接使用。Scikit-Learn中的`Recursive Feature Elimination Algorithm`算法：\n\n```python\nfrom sklearn.feature_selection import RFE\nfrom sklearn.linear_model import LogisticRegression\nmodel = LogisticRegression()\n# create RFE model and select 3 attributes\nrfe = RFE(model, 3)\nrfe = rfe.fit(X, y)\nprint rfe.support_\nprint rfe.ranking_\n```\n\n### 机器学习算法\n\n看一看Scikit-learn库中所带的算法：\n\n- 逻辑回归算法 Logistic Regression\n- 朴素贝叶斯算法 Naive Bayes\n- k-最邻算法 KNN\n- 决策树 Decision Tree\n- 支持向量机 SVM\n\n**逻辑回归**\n\n大多数情况下被用来解决分类问题（二元分类），但多类的分类（所谓的一对多方法）也适用。这个算法的优点是对于每一个输出的对象都有一个对应类别的概率。\n\n```python\nfrom sklearn import metrics\nfrom sklearn.linear_model import LogisticRegression\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(model)\n# make predictions\nexpected = y\npredicted = model.predict(X)\n# summarize the fit of the model\nprint(metrics.classification_report(expected, predicted))\nprint(metrics.confusion_matrix(expected, predicted))\n```\n\n**朴素贝叶斯**\n\n它也是最有名的机器学习的算法之一，它的主要任务是恢复训练样本的数据分布密度。这个方法通常在多类的分类问题上表现的很好。\n\n```python\nfrom sklearn import metrics\nfrom sklearn.naive_bayes import GaussianNB\nmodel = GaussianNB()\nmodel.fit(X, y)\nprint(model)\n# make predictions\nexpected = y\npredicted = model.predict(X)\n# summarize the fit of the model\nprint(metrics.classification_report(expected, predicted))\nprint(metrics.confusion_matrix(expected, predicted))\n```\n\n**k-最近邻**\n\nkNN（k-最近邻）方法通常用于一个更复杂分类算法的一部分。例如，我们可以用它的估计值做为一个对象的特征。有时候，一个简单的kNN算法在良好选择的特征上会有很出色的表现。当参数（主要是metrics）被设置得当，这个算法在回归问题中通常表现出最好的质量。\n\n```python\nfrom sklearn import metrics\nfrom sklearn.neighbors import KNeighborsClassifier\n# fit a k-nearest neighbor model to the data\nmodel = KNeighborsClassifier()\nmodel.fit(X, y)\nprint(model)\n# make predictions\nexpected = y\npredicted = model.predict(X)\n# summarize the fit of the model\nprint(metrics.classification_report(expected, predicted))\nprint(metrics.confusion_matrix(expected, predicted))\n```\n\n**决策树**\n\n分类和回归树（CART）经常被用于这么一类问题，在这类问题中对象有可分类的特征且被用于回归和分类问题。决策树很适用于多类分类。\n\n```python\nfrom sklearn import metrics\nfrom sklearn.tree import DecisionTreeClassifier\n# fit a CART model to the data\nmodel = DecisionTreeClassifier()\nmodel.fit(X, y)\nprint(model)\n# make predictions\nexpected = y\npredicted = model.predict(X)\n# summarize the fit of the model\nprint(metrics.classification_report(expected, predicted))\nprint(metrics.confusion_matrix(expected, predicted))\n```\n\n**支持向量机SVM**\n\nSVM（支持向量机）是最流行的机器学习算法之一，它主要用于分类问题。同样也用于逻辑回归，SVM在一对多方法的帮助下可以实现多类分类。\n\n```python\nfrom sklearn import metrics\nfrom sklearn.svm import SVC\n# fit a SVM model to the data\nmodel = SVC()\nmodel.fit(X, y)\nprint(model)\n# make predictions\nexpected = y\npredicted = model.predict(X)\n# summarize the fit of the model\nprint(metrics.classification_report(expected, predicted))\nprint(metrics.confusion_matrix(expected, predicted))\n```\n\n## 评价算法\n\nTBD\n\n评价算法的好坏大约有几个方面：\n\n- precision\n- recall\n- F1 score\n\n## 优化算法的参数\n\nTBD\n\n","source":"_posts/2015-07-23-start-to-use-scikit-learn.markdown","raw":"---\nlayout: post\ntitle: \"开始使用Scikit-Learn\"\ndate: 2015-07-23 18:14:35 +0800\ncomments: true\ntag: [Machine Learning, Python, Scikit-Learn]\ncategories: [算法, Python]\n---\n\n\nPython和R是做数据分析、数据挖掘、机器学习非常好的两门语言，在这儿不去讨论谁更好这个问题，没有最好，只有合适上手。对于码农出身，非科班统计学的我来说，使用Python相当习惯和顺手。\n\n## Python数据科学栈\n\nPython有很多做数据的类库，先列出常用的几个：\n\n- Numpy、Scipy 基础数据类型\n- Matplotlib 绘图库\n- Pandas\n- Ipython notebook\n- Scikit-learn、MLlib 机器学习库\n\n\n\n<!--more-->\n\n\n\n## 使用Scikit-learn的过程\n\n### 数据加载\n\n首先，将数据加载到内存中\n\n```python\n\timport numpy as np\n\timport urllib\n\turl = \"http://archive.ics.uci.edu/ml/machine-learning-databases/pima-indians-diabetes/pima-indians-diabetes.data\"\n\t# download the file\n\traw_data = urllib.urlopen(url)\n\tdataset = np.loadtxt(raw_data, delimiter=',')\n\tX = dataset[:, 0:7]\n\ty = dataset[:, 8]\n```\n\n`X`为特征数组，`y`为目标变量\n\n### 数据标准化 (Data Normalization)\n\n大多数的梯度算法对数据的缩放很敏感，比如列A是体重数据(50kg等等)，列B是身高数据(170cm等等)，简单地说就是两个属性尺度不一样，所以在运行算法前要进行标准化或者叫归一化。\n\n```python\n\tfrom sklearn import preprocessing\n\t# normalize the data attributes\n\tnormalized_X = preprocessing.normalize(X)\n```\n\n### 特征选取\n\n虽然特征工程是一个相当有创造性的过程，有时候更多的是靠直觉和专业的知识，但对于特征的选取，已经有很多的算法可供直接使用。Scikit-Learn中的`Recursive Feature Elimination Algorithm`算法：\n\n```python\nfrom sklearn.feature_selection import RFE\nfrom sklearn.linear_model import LogisticRegression\nmodel = LogisticRegression()\n# create RFE model and select 3 attributes\nrfe = RFE(model, 3)\nrfe = rfe.fit(X, y)\nprint rfe.support_\nprint rfe.ranking_\n```\n\n### 机器学习算法\n\n看一看Scikit-learn库中所带的算法：\n\n- 逻辑回归算法 Logistic Regression\n- 朴素贝叶斯算法 Naive Bayes\n- k-最邻算法 KNN\n- 决策树 Decision Tree\n- 支持向量机 SVM\n\n**逻辑回归**\n\n大多数情况下被用来解决分类问题（二元分类），但多类的分类（所谓的一对多方法）也适用。这个算法的优点是对于每一个输出的对象都有一个对应类别的概率。\n\n```python\nfrom sklearn import metrics\nfrom sklearn.linear_model import LogisticRegression\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(model)\n# make predictions\nexpected = y\npredicted = model.predict(X)\n# summarize the fit of the model\nprint(metrics.classification_report(expected, predicted))\nprint(metrics.confusion_matrix(expected, predicted))\n```\n\n**朴素贝叶斯**\n\n它也是最有名的机器学习的算法之一，它的主要任务是恢复训练样本的数据分布密度。这个方法通常在多类的分类问题上表现的很好。\n\n```python\nfrom sklearn import metrics\nfrom sklearn.naive_bayes import GaussianNB\nmodel = GaussianNB()\nmodel.fit(X, y)\nprint(model)\n# make predictions\nexpected = y\npredicted = model.predict(X)\n# summarize the fit of the model\nprint(metrics.classification_report(expected, predicted))\nprint(metrics.confusion_matrix(expected, predicted))\n```\n\n**k-最近邻**\n\nkNN（k-最近邻）方法通常用于一个更复杂分类算法的一部分。例如，我们可以用它的估计值做为一个对象的特征。有时候，一个简单的kNN算法在良好选择的特征上会有很出色的表现。当参数（主要是metrics）被设置得当，这个算法在回归问题中通常表现出最好的质量。\n\n```python\nfrom sklearn import metrics\nfrom sklearn.neighbors import KNeighborsClassifier\n# fit a k-nearest neighbor model to the data\nmodel = KNeighborsClassifier()\nmodel.fit(X, y)\nprint(model)\n# make predictions\nexpected = y\npredicted = model.predict(X)\n# summarize the fit of the model\nprint(metrics.classification_report(expected, predicted))\nprint(metrics.confusion_matrix(expected, predicted))\n```\n\n**决策树**\n\n分类和回归树（CART）经常被用于这么一类问题，在这类问题中对象有可分类的特征且被用于回归和分类问题。决策树很适用于多类分类。\n\n```python\nfrom sklearn import metrics\nfrom sklearn.tree import DecisionTreeClassifier\n# fit a CART model to the data\nmodel = DecisionTreeClassifier()\nmodel.fit(X, y)\nprint(model)\n# make predictions\nexpected = y\npredicted = model.predict(X)\n# summarize the fit of the model\nprint(metrics.classification_report(expected, predicted))\nprint(metrics.confusion_matrix(expected, predicted))\n```\n\n**支持向量机SVM**\n\nSVM（支持向量机）是最流行的机器学习算法之一，它主要用于分类问题。同样也用于逻辑回归，SVM在一对多方法的帮助下可以实现多类分类。\n\n```python\nfrom sklearn import metrics\nfrom sklearn.svm import SVC\n# fit a SVM model to the data\nmodel = SVC()\nmodel.fit(X, y)\nprint(model)\n# make predictions\nexpected = y\npredicted = model.predict(X)\n# summarize the fit of the model\nprint(metrics.classification_report(expected, predicted))\nprint(metrics.confusion_matrix(expected, predicted))\n```\n\n## 评价算法\n\nTBD\n\n评价算法的好坏大约有几个方面：\n\n- precision\n- recall\n- F1 score\n\n## 优化算法的参数\n\nTBD\n\n","slug":"2015-07-23-start-to-use-scikit-learn","published":1,"updated":"2016-09-20T02:07:00.000Z","photos":[],"link":"","_id":"cjfkkp3n8000kzd68qohnumgw","content":"<p>Python和R是做数据分析、数据挖掘、机器学习非常好的两门语言，在这儿不去讨论谁更好这个问题，没有最好，只有合适上手。对于码农出身，非科班统计学的我来说，使用Python相当习惯和顺手。</p>\n<h2 id=\"Python数据科学栈\"><a href=\"#Python数据科学栈\" class=\"headerlink\" title=\"Python数据科学栈\"></a>Python数据科学栈</h2><p>Python有很多做数据的类库，先列出常用的几个：</p>\n<ul>\n<li>Numpy、Scipy 基础数据类型</li>\n<li>Matplotlib 绘图库</li>\n<li>Pandas</li>\n<li>Ipython notebook</li>\n<li>Scikit-learn、MLlib 机器学习库</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"使用Scikit-learn的过程\"><a href=\"#使用Scikit-learn的过程\" class=\"headerlink\" title=\"使用Scikit-learn的过程\"></a>使用Scikit-learn的过程</h2><h3 id=\"数据加载\"><a href=\"#数据加载\" class=\"headerlink\" title=\"数据加载\"></a>数据加载</h3><p>首先，将数据加载到内存中</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib</span><br><span class=\"line\">url = <span class=\"string\">\"http://archive.ics.uci.edu/ml/machine-learning-databases/pima-indians-diabetes/pima-indians-diabetes.data\"</span></span><br><span class=\"line\"><span class=\"comment\"># download the file</span></span><br><span class=\"line\">raw_data = urllib.urlopen(url)</span><br><span class=\"line\">dataset = np.loadtxt(raw_data, delimiter=<span class=\"string\">','</span>)</span><br><span class=\"line\">X = dataset[:, <span class=\"number\">0</span>:<span class=\"number\">7</span>]</span><br><span class=\"line\">y = dataset[:, <span class=\"number\">8</span>]</span><br></pre></td></tr></table></figure>\n<p><code>X</code>为特征数组，<code>y</code>为目标变量</p>\n<h3 id=\"数据标准化-Data-Normalization\"><a href=\"#数据标准化-Data-Normalization\" class=\"headerlink\" title=\"数据标准化 (Data Normalization)\"></a>数据标准化 (Data Normalization)</h3><p>大多数的梯度算法对数据的缩放很敏感，比如列A是体重数据(50kg等等)，列B是身高数据(170cm等等)，简单地说就是两个属性尺度不一样，所以在运行算法前要进行标准化或者叫归一化。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> preprocessing</span><br><span class=\"line\"><span class=\"comment\"># normalize the data attributes</span></span><br><span class=\"line\">normalized_X = preprocessing.normalize(X)</span><br></pre></td></tr></table></figure>\n<h3 id=\"特征选取\"><a href=\"#特征选取\" class=\"headerlink\" title=\"特征选取\"></a>特征选取</h3><p>虽然特征工程是一个相当有创造性的过程，有时候更多的是靠直觉和专业的知识，但对于特征的选取，已经有很多的算法可供直接使用。Scikit-Learn中的<code>Recursive Feature Elimination Algorithm</code>算法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.feature_selection <span class=\"keyword\">import</span> RFE</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.linear_model <span class=\"keyword\">import</span> LogisticRegression</span><br><span class=\"line\">model = LogisticRegression()</span><br><span class=\"line\"><span class=\"comment\"># create RFE model and select 3 attributes</span></span><br><span class=\"line\">rfe = RFE(model, <span class=\"number\">3</span>)</span><br><span class=\"line\">rfe = rfe.fit(X, y)</span><br><span class=\"line\"><span class=\"keyword\">print</span> rfe.support_</span><br><span class=\"line\"><span class=\"keyword\">print</span> rfe.ranking_</span><br></pre></td></tr></table></figure>\n<h3 id=\"机器学习算法\"><a href=\"#机器学习算法\" class=\"headerlink\" title=\"机器学习算法\"></a>机器学习算法</h3><p>看一看Scikit-learn库中所带的算法：</p>\n<ul>\n<li>逻辑回归算法 Logistic Regression</li>\n<li>朴素贝叶斯算法 Naive Bayes</li>\n<li>k-最邻算法 KNN</li>\n<li>决策树 Decision Tree</li>\n<li>支持向量机 SVM</li>\n</ul>\n<p><strong>逻辑回归</strong></p>\n<p>大多数情况下被用来解决分类问题（二元分类），但多类的分类（所谓的一对多方法）也适用。这个算法的优点是对于每一个输出的对象都有一个对应类别的概率。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> metrics</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.linear_model <span class=\"keyword\">import</span> LogisticRegression</span><br><span class=\"line\">model = LogisticRegression()</span><br><span class=\"line\">model.fit(X, y)</span><br><span class=\"line\">print(model)</span><br><span class=\"line\"><span class=\"comment\"># make predictions</span></span><br><span class=\"line\">expected = y</span><br><span class=\"line\">predicted = model.predict(X)</span><br><span class=\"line\"><span class=\"comment\"># summarize the fit of the model</span></span><br><span class=\"line\">print(metrics.classification_report(expected, predicted))</span><br><span class=\"line\">print(metrics.confusion_matrix(expected, predicted))</span><br></pre></td></tr></table></figure>\n<p><strong>朴素贝叶斯</strong></p>\n<p>它也是最有名的机器学习的算法之一，它的主要任务是恢复训练样本的数据分布密度。这个方法通常在多类的分类问题上表现的很好。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> metrics</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.naive_bayes <span class=\"keyword\">import</span> GaussianNB</span><br><span class=\"line\">model = GaussianNB()</span><br><span class=\"line\">model.fit(X, y)</span><br><span class=\"line\">print(model)</span><br><span class=\"line\"><span class=\"comment\"># make predictions</span></span><br><span class=\"line\">expected = y</span><br><span class=\"line\">predicted = model.predict(X)</span><br><span class=\"line\"><span class=\"comment\"># summarize the fit of the model</span></span><br><span class=\"line\">print(metrics.classification_report(expected, predicted))</span><br><span class=\"line\">print(metrics.confusion_matrix(expected, predicted))</span><br></pre></td></tr></table></figure>\n<p><strong>k-最近邻</strong></p>\n<p>kNN（k-最近邻）方法通常用于一个更复杂分类算法的一部分。例如，我们可以用它的估计值做为一个对象的特征。有时候，一个简单的kNN算法在良好选择的特征上会有很出色的表现。当参数（主要是metrics）被设置得当，这个算法在回归问题中通常表现出最好的质量。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> metrics</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.neighbors <span class=\"keyword\">import</span> KNeighborsClassifier</span><br><span class=\"line\"><span class=\"comment\"># fit a k-nearest neighbor model to the data</span></span><br><span class=\"line\">model = KNeighborsClassifier()</span><br><span class=\"line\">model.fit(X, y)</span><br><span class=\"line\">print(model)</span><br><span class=\"line\"><span class=\"comment\"># make predictions</span></span><br><span class=\"line\">expected = y</span><br><span class=\"line\">predicted = model.predict(X)</span><br><span class=\"line\"><span class=\"comment\"># summarize the fit of the model</span></span><br><span class=\"line\">print(metrics.classification_report(expected, predicted))</span><br><span class=\"line\">print(metrics.confusion_matrix(expected, predicted))</span><br></pre></td></tr></table></figure>\n<p><strong>决策树</strong></p>\n<p>分类和回归树（CART）经常被用于这么一类问题，在这类问题中对象有可分类的特征且被用于回归和分类问题。决策树很适用于多类分类。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> metrics</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.tree <span class=\"keyword\">import</span> DecisionTreeClassifier</span><br><span class=\"line\"><span class=\"comment\"># fit a CART model to the data</span></span><br><span class=\"line\">model = DecisionTreeClassifier()</span><br><span class=\"line\">model.fit(X, y)</span><br><span class=\"line\">print(model)</span><br><span class=\"line\"><span class=\"comment\"># make predictions</span></span><br><span class=\"line\">expected = y</span><br><span class=\"line\">predicted = model.predict(X)</span><br><span class=\"line\"><span class=\"comment\"># summarize the fit of the model</span></span><br><span class=\"line\">print(metrics.classification_report(expected, predicted))</span><br><span class=\"line\">print(metrics.confusion_matrix(expected, predicted))</span><br></pre></td></tr></table></figure>\n<p><strong>支持向量机SVM</strong></p>\n<p>SVM（支持向量机）是最流行的机器学习算法之一，它主要用于分类问题。同样也用于逻辑回归，SVM在一对多方法的帮助下可以实现多类分类。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> metrics</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.svm <span class=\"keyword\">import</span> SVC</span><br><span class=\"line\"><span class=\"comment\"># fit a SVM model to the data</span></span><br><span class=\"line\">model = SVC()</span><br><span class=\"line\">model.fit(X, y)</span><br><span class=\"line\">print(model)</span><br><span class=\"line\"><span class=\"comment\"># make predictions</span></span><br><span class=\"line\">expected = y</span><br><span class=\"line\">predicted = model.predict(X)</span><br><span class=\"line\"><span class=\"comment\"># summarize the fit of the model</span></span><br><span class=\"line\">print(metrics.classification_report(expected, predicted))</span><br><span class=\"line\">print(metrics.confusion_matrix(expected, predicted))</span><br></pre></td></tr></table></figure>\n<h2 id=\"评价算法\"><a href=\"#评价算法\" class=\"headerlink\" title=\"评价算法\"></a>评价算法</h2><p>TBD</p>\n<p>评价算法的好坏大约有几个方面：</p>\n<ul>\n<li>precision</li>\n<li>recall</li>\n<li>F1 score</li>\n</ul>\n<h2 id=\"优化算法的参数\"><a href=\"#优化算法的参数\" class=\"headerlink\" title=\"优化算法的参数\"></a>优化算法的参数</h2><p>TBD</p>\n","site":{"data":{}},"excerpt":"<p>Python和R是做数据分析、数据挖掘、机器学习非常好的两门语言，在这儿不去讨论谁更好这个问题，没有最好，只有合适上手。对于码农出身，非科班统计学的我来说，使用Python相当习惯和顺手。</p>\n<h2 id=\"Python数据科学栈\"><a href=\"#Python数据科学栈\" class=\"headerlink\" title=\"Python数据科学栈\"></a>Python数据科学栈</h2><p>Python有很多做数据的类库，先列出常用的几个：</p>\n<ul>\n<li>Numpy、Scipy 基础数据类型</li>\n<li>Matplotlib 绘图库</li>\n<li>Pandas</li>\n<li>Ipython notebook</li>\n<li>Scikit-learn、MLlib 机器学习库</li>\n</ul>","more":"<h2 id=\"使用Scikit-learn的过程\"><a href=\"#使用Scikit-learn的过程\" class=\"headerlink\" title=\"使用Scikit-learn的过程\"></a>使用Scikit-learn的过程</h2><h3 id=\"数据加载\"><a href=\"#数据加载\" class=\"headerlink\" title=\"数据加载\"></a>数据加载</h3><p>首先，将数据加载到内存中</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib</span><br><span class=\"line\">url = <span class=\"string\">\"http://archive.ics.uci.edu/ml/machine-learning-databases/pima-indians-diabetes/pima-indians-diabetes.data\"</span></span><br><span class=\"line\"><span class=\"comment\"># download the file</span></span><br><span class=\"line\">raw_data = urllib.urlopen(url)</span><br><span class=\"line\">dataset = np.loadtxt(raw_data, delimiter=<span class=\"string\">','</span>)</span><br><span class=\"line\">X = dataset[:, <span class=\"number\">0</span>:<span class=\"number\">7</span>]</span><br><span class=\"line\">y = dataset[:, <span class=\"number\">8</span>]</span><br></pre></td></tr></table></figure>\n<p><code>X</code>为特征数组，<code>y</code>为目标变量</p>\n<h3 id=\"数据标准化-Data-Normalization\"><a href=\"#数据标准化-Data-Normalization\" class=\"headerlink\" title=\"数据标准化 (Data Normalization)\"></a>数据标准化 (Data Normalization)</h3><p>大多数的梯度算法对数据的缩放很敏感，比如列A是体重数据(50kg等等)，列B是身高数据(170cm等等)，简单地说就是两个属性尺度不一样，所以在运行算法前要进行标准化或者叫归一化。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> preprocessing</span><br><span class=\"line\"><span class=\"comment\"># normalize the data attributes</span></span><br><span class=\"line\">normalized_X = preprocessing.normalize(X)</span><br></pre></td></tr></table></figure>\n<h3 id=\"特征选取\"><a href=\"#特征选取\" class=\"headerlink\" title=\"特征选取\"></a>特征选取</h3><p>虽然特征工程是一个相当有创造性的过程，有时候更多的是靠直觉和专业的知识，但对于特征的选取，已经有很多的算法可供直接使用。Scikit-Learn中的<code>Recursive Feature Elimination Algorithm</code>算法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.feature_selection <span class=\"keyword\">import</span> RFE</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.linear_model <span class=\"keyword\">import</span> LogisticRegression</span><br><span class=\"line\">model = LogisticRegression()</span><br><span class=\"line\"><span class=\"comment\"># create RFE model and select 3 attributes</span></span><br><span class=\"line\">rfe = RFE(model, <span class=\"number\">3</span>)</span><br><span class=\"line\">rfe = rfe.fit(X, y)</span><br><span class=\"line\"><span class=\"keyword\">print</span> rfe.support_</span><br><span class=\"line\"><span class=\"keyword\">print</span> rfe.ranking_</span><br></pre></td></tr></table></figure>\n<h3 id=\"机器学习算法\"><a href=\"#机器学习算法\" class=\"headerlink\" title=\"机器学习算法\"></a>机器学习算法</h3><p>看一看Scikit-learn库中所带的算法：</p>\n<ul>\n<li>逻辑回归算法 Logistic Regression</li>\n<li>朴素贝叶斯算法 Naive Bayes</li>\n<li>k-最邻算法 KNN</li>\n<li>决策树 Decision Tree</li>\n<li>支持向量机 SVM</li>\n</ul>\n<p><strong>逻辑回归</strong></p>\n<p>大多数情况下被用来解决分类问题（二元分类），但多类的分类（所谓的一对多方法）也适用。这个算法的优点是对于每一个输出的对象都有一个对应类别的概率。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> metrics</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.linear_model <span class=\"keyword\">import</span> LogisticRegression</span><br><span class=\"line\">model = LogisticRegression()</span><br><span class=\"line\">model.fit(X, y)</span><br><span class=\"line\">print(model)</span><br><span class=\"line\"><span class=\"comment\"># make predictions</span></span><br><span class=\"line\">expected = y</span><br><span class=\"line\">predicted = model.predict(X)</span><br><span class=\"line\"><span class=\"comment\"># summarize the fit of the model</span></span><br><span class=\"line\">print(metrics.classification_report(expected, predicted))</span><br><span class=\"line\">print(metrics.confusion_matrix(expected, predicted))</span><br></pre></td></tr></table></figure>\n<p><strong>朴素贝叶斯</strong></p>\n<p>它也是最有名的机器学习的算法之一，它的主要任务是恢复训练样本的数据分布密度。这个方法通常在多类的分类问题上表现的很好。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> metrics</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.naive_bayes <span class=\"keyword\">import</span> GaussianNB</span><br><span class=\"line\">model = GaussianNB()</span><br><span class=\"line\">model.fit(X, y)</span><br><span class=\"line\">print(model)</span><br><span class=\"line\"><span class=\"comment\"># make predictions</span></span><br><span class=\"line\">expected = y</span><br><span class=\"line\">predicted = model.predict(X)</span><br><span class=\"line\"><span class=\"comment\"># summarize the fit of the model</span></span><br><span class=\"line\">print(metrics.classification_report(expected, predicted))</span><br><span class=\"line\">print(metrics.confusion_matrix(expected, predicted))</span><br></pre></td></tr></table></figure>\n<p><strong>k-最近邻</strong></p>\n<p>kNN（k-最近邻）方法通常用于一个更复杂分类算法的一部分。例如，我们可以用它的估计值做为一个对象的特征。有时候，一个简单的kNN算法在良好选择的特征上会有很出色的表现。当参数（主要是metrics）被设置得当，这个算法在回归问题中通常表现出最好的质量。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> metrics</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.neighbors <span class=\"keyword\">import</span> KNeighborsClassifier</span><br><span class=\"line\"><span class=\"comment\"># fit a k-nearest neighbor model to the data</span></span><br><span class=\"line\">model = KNeighborsClassifier()</span><br><span class=\"line\">model.fit(X, y)</span><br><span class=\"line\">print(model)</span><br><span class=\"line\"><span class=\"comment\"># make predictions</span></span><br><span class=\"line\">expected = y</span><br><span class=\"line\">predicted = model.predict(X)</span><br><span class=\"line\"><span class=\"comment\"># summarize the fit of the model</span></span><br><span class=\"line\">print(metrics.classification_report(expected, predicted))</span><br><span class=\"line\">print(metrics.confusion_matrix(expected, predicted))</span><br></pre></td></tr></table></figure>\n<p><strong>决策树</strong></p>\n<p>分类和回归树（CART）经常被用于这么一类问题，在这类问题中对象有可分类的特征且被用于回归和分类问题。决策树很适用于多类分类。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> metrics</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.tree <span class=\"keyword\">import</span> DecisionTreeClassifier</span><br><span class=\"line\"><span class=\"comment\"># fit a CART model to the data</span></span><br><span class=\"line\">model = DecisionTreeClassifier()</span><br><span class=\"line\">model.fit(X, y)</span><br><span class=\"line\">print(model)</span><br><span class=\"line\"><span class=\"comment\"># make predictions</span></span><br><span class=\"line\">expected = y</span><br><span class=\"line\">predicted = model.predict(X)</span><br><span class=\"line\"><span class=\"comment\"># summarize the fit of the model</span></span><br><span class=\"line\">print(metrics.classification_report(expected, predicted))</span><br><span class=\"line\">print(metrics.confusion_matrix(expected, predicted))</span><br></pre></td></tr></table></figure>\n<p><strong>支持向量机SVM</strong></p>\n<p>SVM（支持向量机）是最流行的机器学习算法之一，它主要用于分类问题。同样也用于逻辑回归，SVM在一对多方法的帮助下可以实现多类分类。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> metrics</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.svm <span class=\"keyword\">import</span> SVC</span><br><span class=\"line\"><span class=\"comment\"># fit a SVM model to the data</span></span><br><span class=\"line\">model = SVC()</span><br><span class=\"line\">model.fit(X, y)</span><br><span class=\"line\">print(model)</span><br><span class=\"line\"><span class=\"comment\"># make predictions</span></span><br><span class=\"line\">expected = y</span><br><span class=\"line\">predicted = model.predict(X)</span><br><span class=\"line\"><span class=\"comment\"># summarize the fit of the model</span></span><br><span class=\"line\">print(metrics.classification_report(expected, predicted))</span><br><span class=\"line\">print(metrics.confusion_matrix(expected, predicted))</span><br></pre></td></tr></table></figure>\n<h2 id=\"评价算法\"><a href=\"#评价算法\" class=\"headerlink\" title=\"评价算法\"></a>评价算法</h2><p>TBD</p>\n<p>评价算法的好坏大约有几个方面：</p>\n<ul>\n<li>precision</li>\n<li>recall</li>\n<li>F1 score</li>\n</ul>\n<h2 id=\"优化算法的参数\"><a href=\"#优化算法的参数\" class=\"headerlink\" title=\"优化算法的参数\"></a>优化算法的参数</h2><p>TBD</p>"},{"layout":"post","title":"在不同的机器上写博客","date":"2015-07-17T08:48:40.000Z","comments":1,"_content":"\n\n在家的Mac上配置好了Octopress，上班到公司还是要面对大Windows，这时候，想写一篇博客记录一下遇到的问题，怎么办？\n\n## Octopress原理\n\nOctopress的git仓库(repository)有两个分支，分别是`master`和`source`。`master`存储的是博客网站本身（html静态页面），而`source`存储的是生成博客的源文件（包括配置等）。`master`的内容放在根目录的`_deploy`文件夹内，当你`push`源文件时会忽略，它使用的是`rake deploy`命令来更新的。\n\n下面开始在一台新机器上搞\n\n<!--more-->\n\n## 创建一个本地Octopress仓库\n\n将博客的源文件，也就是`source`分支clone到本地的Octopress文件夹内\n\n``` bash\n$ git clone -b source git@github.com:username/username.github.com.git octopress\n```\n\n然后将博客文件也就是`master`分支clone到Octopress文件夹的`_deploy`文件夹内\n\n``` bash\n$ cd octopress\n$ git clone git@github.com:username/username.github.com.git _deploy\n```\n\n然后安装博客\n\n``` bash\n$ gem install bundler\n$ bundle install\n$ rake setup_github_pages\n```\n\nOK了\n\n## 继续写博客\n\n当你要在一台电脑写博客或做更改时，首先更新`source`仓库\n\n``` bash\n$ cd octopress\n$ git pull origin source  # update the local source branch\n$ cd ./_deploy\n$ git pull origin master  # update the local master branch\n```\n\n**写完博客之后不要忘了push，下面的步骤在每次更改之后都必须做一遍。**\n\n``` bash\n$ rake generate\n$ git add .\n$ git commit -am \"Some comment here.\" \n$ git push origin source  # update the remote source branch \n$ rake deploy             # update the remote master branch\n```","source":"_posts/2015-07-17-write-blog-from-different-machine.markdown","raw":"---\nlayout: post\ntitle: \"在不同的机器上写博客\"\ndate: 2015-07-17 16:48:40 +0800\ncomments: true\ntag: Octopress\ncategories: 备忘\n---\n\n\n在家的Mac上配置好了Octopress，上班到公司还是要面对大Windows，这时候，想写一篇博客记录一下遇到的问题，怎么办？\n\n## Octopress原理\n\nOctopress的git仓库(repository)有两个分支，分别是`master`和`source`。`master`存储的是博客网站本身（html静态页面），而`source`存储的是生成博客的源文件（包括配置等）。`master`的内容放在根目录的`_deploy`文件夹内，当你`push`源文件时会忽略，它使用的是`rake deploy`命令来更新的。\n\n下面开始在一台新机器上搞\n\n<!--more-->\n\n## 创建一个本地Octopress仓库\n\n将博客的源文件，也就是`source`分支clone到本地的Octopress文件夹内\n\n``` bash\n$ git clone -b source git@github.com:username/username.github.com.git octopress\n```\n\n然后将博客文件也就是`master`分支clone到Octopress文件夹的`_deploy`文件夹内\n\n``` bash\n$ cd octopress\n$ git clone git@github.com:username/username.github.com.git _deploy\n```\n\n然后安装博客\n\n``` bash\n$ gem install bundler\n$ bundle install\n$ rake setup_github_pages\n```\n\nOK了\n\n## 继续写博客\n\n当你要在一台电脑写博客或做更改时，首先更新`source`仓库\n\n``` bash\n$ cd octopress\n$ git pull origin source  # update the local source branch\n$ cd ./_deploy\n$ git pull origin master  # update the local master branch\n```\n\n**写完博客之后不要忘了push，下面的步骤在每次更改之后都必须做一遍。**\n\n``` bash\n$ rake generate\n$ git add .\n$ git commit -am \"Some comment here.\" \n$ git push origin source  # update the remote source branch \n$ rake deploy             # update the remote master branch\n```","slug":"2015-07-17-write-blog-from-different-machine","published":1,"updated":"2016-09-20T02:07:00.000Z","photos":[],"link":"","_id":"cjfkkp3na000lzd680z97zvbc","content":"<p>在家的Mac上配置好了Octopress，上班到公司还是要面对大Windows，这时候，想写一篇博客记录一下遇到的问题，怎么办？</p>\n<h2 id=\"Octopress原理\"><a href=\"#Octopress原理\" class=\"headerlink\" title=\"Octopress原理\"></a>Octopress原理</h2><p>Octopress的git仓库(repository)有两个分支，分别是<code>master</code>和<code>source</code>。<code>master</code>存储的是博客网站本身（html静态页面），而<code>source</code>存储的是生成博客的源文件（包括配置等）。<code>master</code>的内容放在根目录的<code>_deploy</code>文件夹内，当你<code>push</code>源文件时会忽略，它使用的是<code>rake deploy</code>命令来更新的。</p>\n<p>下面开始在一台新机器上搞</p>\n<a id=\"more\"></a>\n<h2 id=\"创建一个本地Octopress仓库\"><a href=\"#创建一个本地Octopress仓库\" class=\"headerlink\" title=\"创建一个本地Octopress仓库\"></a>创建一个本地Octopress仓库</h2><p>将博客的源文件，也就是<code>source</code>分支clone到本地的Octopress文件夹内</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> -b <span class=\"built_in\">source</span> git@github.com:username/username.github.com.git octopress</span><br></pre></td></tr></table></figure>\n<p>然后将博客文件也就是<code>master</code>分支clone到Octopress文件夹的<code>_deploy</code>文件夹内</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> octopress</span><br><span class=\"line\">$ git <span class=\"built_in\">clone</span> git@github.com:username/username.github.com.git _deploy</span><br></pre></td></tr></table></figure>\n<p>然后安装博客</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gem install bundler</span><br><span class=\"line\">$ bundle install</span><br><span class=\"line\">$ rake setup_github_pages</span><br></pre></td></tr></table></figure>\n<p>OK了</p>\n<h2 id=\"继续写博客\"><a href=\"#继续写博客\" class=\"headerlink\" title=\"继续写博客\"></a>继续写博客</h2><p>当你要在一台电脑写博客或做更改时，首先更新<code>source</code>仓库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> octopress</span><br><span class=\"line\">$ git pull origin <span class=\"built_in\">source</span>  <span class=\"comment\"># update the local source branch</span></span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> ./_deploy</span><br><span class=\"line\">$ git pull origin master  <span class=\"comment\"># update the local master branch</span></span><br></pre></td></tr></table></figure>\n<p><strong>写完博客之后不要忘了push，下面的步骤在每次更改之后都必须做一遍。</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rake generate</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -am <span class=\"string\">\"Some comment here.\"</span> </span><br><span class=\"line\">$ git push origin <span class=\"built_in\">source</span>  <span class=\"comment\"># update the remote source branch </span></span><br><span class=\"line\">$ rake deploy             <span class=\"comment\"># update the remote master branch</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>在家的Mac上配置好了Octopress，上班到公司还是要面对大Windows，这时候，想写一篇博客记录一下遇到的问题，怎么办？</p>\n<h2 id=\"Octopress原理\"><a href=\"#Octopress原理\" class=\"headerlink\" title=\"Octopress原理\"></a>Octopress原理</h2><p>Octopress的git仓库(repository)有两个分支，分别是<code>master</code>和<code>source</code>。<code>master</code>存储的是博客网站本身（html静态页面），而<code>source</code>存储的是生成博客的源文件（包括配置等）。<code>master</code>的内容放在根目录的<code>_deploy</code>文件夹内，当你<code>push</code>源文件时会忽略，它使用的是<code>rake deploy</code>命令来更新的。</p>\n<p>下面开始在一台新机器上搞</p>","more":"<h2 id=\"创建一个本地Octopress仓库\"><a href=\"#创建一个本地Octopress仓库\" class=\"headerlink\" title=\"创建一个本地Octopress仓库\"></a>创建一个本地Octopress仓库</h2><p>将博客的源文件，也就是<code>source</code>分支clone到本地的Octopress文件夹内</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> -b <span class=\"built_in\">source</span> git@github.com:username/username.github.com.git octopress</span><br></pre></td></tr></table></figure>\n<p>然后将博客文件也就是<code>master</code>分支clone到Octopress文件夹的<code>_deploy</code>文件夹内</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> octopress</span><br><span class=\"line\">$ git <span class=\"built_in\">clone</span> git@github.com:username/username.github.com.git _deploy</span><br></pre></td></tr></table></figure>\n<p>然后安装博客</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gem install bundler</span><br><span class=\"line\">$ bundle install</span><br><span class=\"line\">$ rake setup_github_pages</span><br></pre></td></tr></table></figure>\n<p>OK了</p>\n<h2 id=\"继续写博客\"><a href=\"#继续写博客\" class=\"headerlink\" title=\"继续写博客\"></a>继续写博客</h2><p>当你要在一台电脑写博客或做更改时，首先更新<code>source</code>仓库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> octopress</span><br><span class=\"line\">$ git pull origin <span class=\"built_in\">source</span>  <span class=\"comment\"># update the local source branch</span></span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> ./_deploy</span><br><span class=\"line\">$ git pull origin master  <span class=\"comment\"># update the local master branch</span></span><br></pre></td></tr></table></figure>\n<p><strong>写完博客之后不要忘了push，下面的步骤在每次更改之后都必须做一遍。</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rake generate</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -am <span class=\"string\">\"Some comment here.\"</span> </span><br><span class=\"line\">$ git push origin <span class=\"built_in\">source</span>  <span class=\"comment\"># update the remote source branch </span></span><br><span class=\"line\">$ rake deploy             <span class=\"comment\"># update the remote master branch</span></span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"朴素贝叶斯分类器实践","date":"2015-08-07T08:48:32.000Z","comments":1,"_content":"\n\n## 实际案例\n举个运动员的例子：\n\n> 如果我问你Brittney Griner的运动项目是什么，她有6尺8寸高，207磅重，你会说“篮球”；我再问你对此分类的准确度有多少信心，你会回答“非常有信心”。\n> 我再问你Heather Zurich，6尺1寸高，重176磅，你可能就不能确定地说她是打篮球的了，至少不会像之前判定Brittney那样肯定。因为从Heather的身高体重来看她也有可能是跑马拉松的。\n> 最后，我再问你Yumiko Hara的运动项目，她5尺4寸高，95磅重，你也许会说她是跳体操的，但也不太敢肯定，因为有些马拉松运动员也是类似的身高体重。   \n>       ——选自[A Programmer's Guide to Data Mining](http://guidetodatamining.com/)\n\n这里所说的分类，就用到了所谓的概率模型。\n\n## 朴素贝叶斯算法\n朴素贝叶斯算法使用每个属性(特征)属于某个类的概率做出预测，这是一个监督性学习算法，对一个预测性问题进行概率建模。**训练模型的过程可以看做是对条件概率的计算，何以计算每个类别的相应条件概率来估计分类结果。** 这个算法基于一个假设：所有特征相互独立，任意特征的值和其他特征的值没有关联关系，这种假设在实际生活中几乎不存在，但是朴素贝叶斯算法在很多领域，尤其是自然语言处理领域很成功。其他的典型应用还有垃圾邮件过滤等等。\n\n<!--more-->\n\n## 贝叶斯分类器的基本原理\n![bayes theory](http://7xkfga.com1.z0.glb.clouddn.com/bayes.jpg)\n\n图片引用自[Matt Buck](https://www.flickr.com/photos/mattbuck007/3676624894)\n\n### 贝叶斯定理\n\n给出贝叶斯定理：\n\n$$p\\left( h|D\\right) =\\dfrac {p\\left( D|h\\right) .p\\left( h\\right) } {p\\left( D\\right) }$$\n\n这个公式是贝叶斯方法论的基石。拿分类问题来说，h代表分类的类别，D代表已知的特征d1, d2, d3...，朴素贝叶斯算法的朴素之处在于，假设了特征d1, d2, d3...相互独立，所以贝叶斯定理又能写成：\n\n$$p\\left( h|f\\_{1},f\\_{2}...f\\_{n}\\right) =\\dfrac {p\\left( h\\right) \\prod\\_{i=1}^n p\\left( f\\_{i}|h\\right) } {p\\left( f\\_{1},f\\_{2}...f\\_{n}\\right) }$$\n\n由于$P\\left( f\\_{1},\\ldots f\\_{n}\\right) $ 可视作常数，类变量$h$的条件概率分布就可以表达为：\n\n$$p\\left( h|f\\_{1},...,f\\_{n}\\right) =\\dfrac {1} {Z}.p\\left( h\\right) \\prod \\_{i=1}^{n}p\\left( F\\_{i}|h\\right)$$\n\n### 从概率模型中构造分类器\n\n以上，就导出了独立分布的特征模型，也就是朴素贝叶斯模型，使用[最大后验概率](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87)MAP(Maximum A Posteriori estimation)选出条件概率最大的那个分类，这就是朴素贝叶斯分类器：\n\n$$\\widehat {y}=\\arg \\max\\_{y}p\\left( y\\right) \\prod\\_{i=1}^{n}p\\left( x\\_{i}|y\\right) $$\n\n### 参数估计\n\n所有的模型参数都可以通过训练集的相关频率来估计。常用方法是概率的最大似然估计，类的先验概率可以通过假设各类等概率来计算（先验概率 = 1 / (类的数量)），或者通过训练集的各类样本出现的次数来估计（A类先验概率=（A类样本的数量）/(样本总数)）。为了估计特征的分布参数，我们要先假设训练集数据满足某种分布或者非参数模型。\n\n常见的分布模型：高斯分布(Gaussian naive Bayes)、多项分布(Multinomial naive Bayes)、伯努利分布(Bernoulli naive Bayes)等.\n\n## 使用Scikit-learn进行文本分类\n目的：使用Scikit-learn库自带的新闻信息数据来进行试验，该数据集有19,000个新闻信息组成，通过新闻文本的内容，使用scikit-learn中的朴素贝叶斯算法，来判断新闻属于什么主题类别。参考：[Scikit-learn Totorial](http://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html#building-a-pipeline)\n\n### 数据集\n\n```python\nfrom sklearn.datesets import fetch_20newsgroups\nnews = fetch_20newsgroups(subset='all')\nprint news.keys()\n```\n\n查看一下第一条新闻的内容和分组\n\n> ['description', 'DESCR', 'filenames', 'target_names', 'data', 'target']\n\n> From: Mamatha Devineni Ratnam <mr47+@andrew.cmu.edu>\nSubject: Pens fans reactions\nOrganization: Post Office, Carnegie Mellon, Pittsburgh, PA\n...\n\n> 10 rec.sport.hockey\n\n划分训练集和测试集，分为80%训练集，20%测试集\n\n```python\nsplit_rate = 0.8\nsplit_size = int(len(news.data) * split_rate)\nX_train = news.data[:split_size]\ny_train = news.target[:split_size]\nX_test  = news.data[split_size:]\ny_test  = news.target[split_size:]\n```\n\n### 特征提取\n\n为了使机器学习算法应用在文本内容上，首先应该把文本内容装换为数字特征。这里使用词袋模型([Bags of words](https://en.wikipedia.org/wiki/Bag-of-words_model))\n\n#### 词袋模型\n\n在信息检索中，Bag of words model假定对于一个文本，忽略其词序和语法，句法，将其仅仅看做是一个词集合，或者说是词的一个组合，文本中每个词的出现都是独立的，不依赖于其他词是否出现，或者说当这篇文章的作者在任意一个位置选择一个词汇都不受前面句子的影响而独立选择的。\n\nScikit-learn提供了一些实用工具(`sklearn.feature_extraction.text`)可以从文本内容中提取数值特征\n\n![Scikit-learn feature extraction from text tool](http://7xkfga.com1.z0.glb.clouddn.com/feature_extraction_from_text.jpg)\n\n```python\n\tfrom sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer, HashingVectorizer\n\tfrom sklearn.feature_extraction.text import TfidfTransformer\n\t# Tokenizing text\n\tcount_vect = CountVectorizer()\n\tX_train_counts = count_vect.fit_transform(X_train)\n\t# Tf\n\ttf_transformer = TfidfTransformer(use_idf=False).fit(X_train_counts)\n\tX_train_tf = tf_transformer.transform(X_train_counts)\n\t# Tf_idf\n\ttfidf_transformer = TfidfTransformer()\n\tX_train_tfidf = tfidf_transformer.fit_transform(X_train_counts)\n```\n\n#### 稀疏性\n\n大多数文档通常只会使用语料库中所有词的一个子集，因而产生的矩阵将有许多特征值是0（通常99%以上都是0）。\n例如，一组10,000个短文本（比如email）会使用100,000的词汇总量，而每个文档会使用100到1,000个唯一的词。\n为了能够在内存中存储这个矩阵，同时也提供矩阵/向量代数运算的速度，通常会使用稀疏表征例如在`scipy.sparse`包中提供的表征。\n\n### 训练模型\n\n上面使用文本中词的出现次数作为数值特征，可以使用多项分布估计这个特征，使用`sklearn.naive_bayes`模块的`MultinomialNB`类来训练模型。\n\n```python\n\tfrom sklearn.naive_bayes import MultinomialNB\n\t# create classifier\n\tclf = MultinomialNB().fit(X_train_tfidf, y_train)\n\tdocs_new = ['God is love', 'OpenGL on the GPU is fast']\n\tX_new_counts = count_vect.transform(docs_new)\n\tX_new_tfidf = tfidf_transformer.transform(X_new_counts)\n\t# using classifier to predict\n\tpredicted = clf.predict(X_new_tfidf)\n\tfor doc, category in zip(docs_new, predicted):\n        print('%r => %s' % (doc, news.target_names[category]))\n```\n\n### 使用`Pipline`这个类构建复合分类器\n\nScikit-learn为了使向量化 => 转换 => 分类这个过程更容易，提供了`Pipeline`类来构建复合分类器，例如：\n\n```python\nfrom sklearn.pipeline import Pipeline\ntext_clf = Pipeline([('vect', CountVectorizer()),\n                     ('tfidf', TfidfTransformer()),\n])\n```\n\n创建新的训练模型\n\n```python\n\tfrom sklearn.naive_bayes import MultinomialNB\n\tfrom sklearn.pipeline import Pipeline\n\tfrom sklearn.feature_extraction.text import TfidfVectorizer, HashingVectorizer, CountVectorizer\t#nbc means naive bayes classifier\n\tnbc_1 = Pipeline([\n\t        ('vect', CountVectorizer()),\n\t        ('clf', MultinomialNB()),\n\t])\n\tnbc_2 = Pipeline([\n            ('vect', HashingVectorizer(non_negative=True)),\n            ('clf', MultinomialNB()),\n\t])\n\tnbc_3 = Pipeline([\t   \n\t        ('vect', TfidfVectorizer()),\n\t        ('clf', MultinomialNB()),\n\t])\n\t# classifier\n\tnbcs = [nbc_1, nbc_2, nbc_3]\n```\n\n### 交叉验证\n\n下面是一个交叉验证函数：\n\n```python\n\tfrom sklearn.cross_validation import cross_val_score, KFold\n\tfrom scipy.stats import sem\n\timport numpy as np\n\t# cross validation function\n\tdef evaluate_cross_validation(clf, X, y, K):\n\t    # create a k-fold croos validation iterator of k folds\n\t    cv = KFold(len(y), K, shuffle=True, random_state=0)\n\t    # by default the score used is the one returned by score method of the estimator (accuracy)\n\t    scores = cross_val_score(clf, X, y, cv=cv)\n\t    print scores\n\t    print (\"Mean score: {0:.3f} (+/-{1:.3f})\").format(np.mean(scores), sem(scores))\n```\n\n将训练集分为10份，输出验证分数：\n\n```python\nfor nbc in nbcs:\n\tevaluate_cross_validation(nbc, X_train, y_train, 10)\n```\n\n结果为：\n\n> CountVectorizer Mean score: 0.849 (+/-0.002)\n\n> HashingVectorizer Mean score: 0.765 (+/-0.006)\n\n> TfidfVectorizer Mean score: 0.848 (+/-0.004)\n\n可以看出：CountVectorizer和TfidfVectorizer特征提取的方法要比HashingVectorizer效果好。\n\n### 优化模型\n\n#### 优化单词提取\n\n在使用TfidfVectorizer特征提取时候，使用正则表达式，默认的正则表达式是`u'(?u)\\b\\w\\w+\\b'`，使用新的正则表达式`ur\"\\b[a-z0-9_\\-\\.]+[a-z][a-z0-9_\\-\\.]+\\b\"`\n\n```python\nnbc_4 = Pipeline([\n    ('vect', TfidfVectorizer(\n                token_pattern=ur\"\\b[a-z0-9_\\-\\.]+[a-z][a-z0-9_\\-\\.]+\\b\",)\n    ),\n    ('clf', MultinomialNB()),\n])\nevaluate_cross_validation(nbc_4, X_train, y_train, 10)\n```\n\n分数是：Mean score: 0.861 (+/-0.004) ，结果好了一点\n\n#### 排除停止词\n\nTfidfVectorizer的一个参数stop_words，这个参数指定的词将被省略不计入到标记词的列表中，这里使用鼎鼎有名的NLTK语料库。\n\n```python\n\timport nltk\n\t# nltk.download()\n\tstopwords = nltk.corpus.stopwords.words('english')\n\tnbc_5 = Pipeline([\n    ('vect', TfidfVectorizer(\n                stop_words=stop_words,\n                token_pattern=ur\"\\b[a-z0-9_\\-\\.]+[a-z][a-z0-9_\\-\\.]+\\b\",    \n    )),\n    ('clf', MultinomialNB()),\n\t])\n\tevaluate_cross_validation(nbc_5, X_train, Y_train, 10)\n```\n\n分数是：Mean score: 0.879 (+/-0.003)，结果又提高了\n\n\n#### 调整贝叶斯分类器的alpha参数\n\nMultinomialNB有一个alpha参数，该参数是一个平滑参数，默认是1.0，我们将其设为0.01\n\n```python\nnbc_6 = Pipeline([\n    ('vect', TfidfVectorizer(\n                stop_words=stopwords,\n                token_pattern=ur\"\\b[a-z0-9_\\-\\.]+[a-z][a-z0-9_\\-\\.]+\\b\",         \n    )),\n    ('clf', MultinomialNB(alpha=0.01)),\n])\nevaluate_cross_validation(nbc_6, X_train, y_train, 10)\n```\n\n分数为：Mean score: 0.917 (+/-0.002)，哎呦，好像不错哦！不过问题来了，调整参数优化不能靠蒙，如何寻找最好的参数，使得交叉验证的分数最高呢？\n\n#### 使用Grid Search优化参数\n\n使用GridSearch寻找vectorizer词频统计, tfidftransformer特征变换和MultinomialNB classifier的最优参数\n\nScikit-learn上关于[GridSearch的介绍](http://scikit-learn.org/stable/modules/classes.html#module-sklearn.grid_search)\n![Grid Search](http://7xkfga.com1.z0.glb.clouddn.com/Grid_Search.jpg)\n\n```python\npipeline = Pipeline([\n('vect',CountVectorizer()),\n('tfidf',TfidfTransformer()),\n('clf',MultinomialNB()),\n]);\nparameters = {\n    'vect__max_df': (0.5, 0.75),\n    'vect__max_features': (None, 5000, 10000),\n    'tfidf__use_idf': (True, False),\n    'clf__alpha': (1, 0.1, 0.01, 0.001, 0.0001),\n}\ngrid_search = GridSearchCV(pipeline, parameters, n_jobs=1)\nfrom time import time\nt0 = time()\ngrid_search.fit(X_train, y_train)\nprint \"done in %0.3fs\" % (time() - t0)\nprint \"Best score: %0.3f\" % grid_search.best_score_\n```\n\n#### 输出最优参数\n\n```python\nfrom sklearn import metrics\nbest_parameters = dict()\nbest_parameters = grid_search.best_estimator_.get_params()\nfor param_name in sorted(parameters.keys()):\n    print \"\\t%s: %r\" % (param_name, best_parameters[param_name])\npipeline.set_params(clf__alpha = 1e-05,  \n                    tfidf__use_idf = True,\n                    vect__max_df = 0.5,\n                    vect__max_features = None)\npipeline.fit(X_train, y_train)\npred = pipeline.predict(X_test)\n```\n\n经过漫长的等待，终于找出了最优参数：\n\ndone in 1578.965s\nBest score: 0.902\n\nclf__alpha: 0.01\ntfidf__use_idf: True\nvect__max_df: 0.5\nvect__max_features: None\n\n在测试集上的准确率为：0.915，分类效果还是不错的\n\n```python\nprint np.mean(pred == y_test)\n```\n\n### 评价分类效果\n\n在测试集上测试朴素贝叶斯分类器的分类效果\n\n```python\n\tfrom sklearn import metrics\n\timport numpy as np\n\t#print X_test[0], y_test[0]\n\tfor i in range(20):\n\t    print str(i) + \": \" + news.target_names[i]\n\tpredicted = pipeline.fit(X_train, y_train).predict(X_test)\n\tprint np.mean(predicted == y_test)\n\tprint metrics.classification_report(y_test, predicted)\n```\n\n结果是这样的：\n\nid | groupname\n-- | ----------------\n0  | alt.atheism\n1  | comp.graphics\n2  | comp.os.ms-windows.misc\n3  | comp.sys.ibm.pc.hardware\n4  | comp.sys.mac.hardware\n5  | comp.windows.x\n6  | misc.forsale\n7  | rec.autos\n8  | rec.motorcycles\n9  | rec.sport.baseball\n10 | rec.sport.hockey\n11 | sci.crypt\n12 | sci.electronics\n13 | sci.med\n14 |sci.space\n15 | soc.religion.christian\n16 | talk.politics.guns\n17 | talk.politics.mideast\n18 | talk.politics.misc\n19 | talk.religion.misc\n   |\n\n准确率：0.922811671088\n\nid  | precision  |  recall | f1-score |  support \n--  | ---------- | ------- | -------- | --------------\n0   |    0.94    |  0.87   |   0.91   |    175\n1   |    0.85    |  0.87   |   0.86   |    199\n2   |    0.91    |  0.84   |   0.88   |    221\n3   |    0.81    |  0.87   |   0.84   |    179\n4   |    0.87    |  0.92   |   0.89   |    177\n5   |    0.91    |  0.92   |   0.91   |    179\n6   |    0.88    |  0.79   |   0.83   |    205\n7   |    0.94    |  0.95   |   0.94   |    228\n8   |    0.96    |  0.98   |   0.97   |    183\n9   |    0.96    |  0.95   |   0.96   |    197\n10  |    0.98    |  1.00   |   0.99   |    204\n11  |    0.96    |  0.98   |   0.97   |    218\n12  |    0.93    |  0.92   |   0.92   |    172\n13  |    0.93    |  0.95   |   0.94   |    200\n14  |    0.96    |  0.96   |   0.96   |    198\n15  |    0.93    |  0.97   |   0.95   |    191\n16  |    0.92    |  0.97   |   0.94   |    173\n17  |    0.98    |  0.99   |   0.98   |    184\n18  |    0.95    |  0.92   |   0.94   |    172\n19  |    0.83    |  0.78   |   0.81   |    115\navg / total   |    0.92   |   0.92   |   0.92   |   3770\n    |         |           |          |          |\n\n\n\n\n#### 参考\n\n1. JasonDing的 [【机器学习实验】使用朴素贝叶斯进行文本的分类](http://www.jianshu.com/p/845b16559431)；\n2. [Scikit-Learn Totorial](http://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html#building-a-pipeline)\n\n\n","source":"_posts/2015-08-07-naive-bayes-classifier.markdown","raw":"---\nlayout: post\ntitle: \"朴素贝叶斯分类器实践\"\ndate: 2015-08-07 16:48:32 +0800\ncomments: true\ncategories: [算法, Python]\ntag: [Machine Learning, Algorithm, Python]\n---\n\n\n## 实际案例\n举个运动员的例子：\n\n> 如果我问你Brittney Griner的运动项目是什么，她有6尺8寸高，207磅重，你会说“篮球”；我再问你对此分类的准确度有多少信心，你会回答“非常有信心”。\n> 我再问你Heather Zurich，6尺1寸高，重176磅，你可能就不能确定地说她是打篮球的了，至少不会像之前判定Brittney那样肯定。因为从Heather的身高体重来看她也有可能是跑马拉松的。\n> 最后，我再问你Yumiko Hara的运动项目，她5尺4寸高，95磅重，你也许会说她是跳体操的，但也不太敢肯定，因为有些马拉松运动员也是类似的身高体重。   \n>       ——选自[A Programmer's Guide to Data Mining](http://guidetodatamining.com/)\n\n这里所说的分类，就用到了所谓的概率模型。\n\n## 朴素贝叶斯算法\n朴素贝叶斯算法使用每个属性(特征)属于某个类的概率做出预测，这是一个监督性学习算法，对一个预测性问题进行概率建模。**训练模型的过程可以看做是对条件概率的计算，何以计算每个类别的相应条件概率来估计分类结果。** 这个算法基于一个假设：所有特征相互独立，任意特征的值和其他特征的值没有关联关系，这种假设在实际生活中几乎不存在，但是朴素贝叶斯算法在很多领域，尤其是自然语言处理领域很成功。其他的典型应用还有垃圾邮件过滤等等。\n\n<!--more-->\n\n## 贝叶斯分类器的基本原理\n![bayes theory](http://7xkfga.com1.z0.glb.clouddn.com/bayes.jpg)\n\n图片引用自[Matt Buck](https://www.flickr.com/photos/mattbuck007/3676624894)\n\n### 贝叶斯定理\n\n给出贝叶斯定理：\n\n$$p\\left( h|D\\right) =\\dfrac {p\\left( D|h\\right) .p\\left( h\\right) } {p\\left( D\\right) }$$\n\n这个公式是贝叶斯方法论的基石。拿分类问题来说，h代表分类的类别，D代表已知的特征d1, d2, d3...，朴素贝叶斯算法的朴素之处在于，假设了特征d1, d2, d3...相互独立，所以贝叶斯定理又能写成：\n\n$$p\\left( h|f\\_{1},f\\_{2}...f\\_{n}\\right) =\\dfrac {p\\left( h\\right) \\prod\\_{i=1}^n p\\left( f\\_{i}|h\\right) } {p\\left( f\\_{1},f\\_{2}...f\\_{n}\\right) }$$\n\n由于$P\\left( f\\_{1},\\ldots f\\_{n}\\right) $ 可视作常数，类变量$h$的条件概率分布就可以表达为：\n\n$$p\\left( h|f\\_{1},...,f\\_{n}\\right) =\\dfrac {1} {Z}.p\\left( h\\right) \\prod \\_{i=1}^{n}p\\left( F\\_{i}|h\\right)$$\n\n### 从概率模型中构造分类器\n\n以上，就导出了独立分布的特征模型，也就是朴素贝叶斯模型，使用[最大后验概率](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87)MAP(Maximum A Posteriori estimation)选出条件概率最大的那个分类，这就是朴素贝叶斯分类器：\n\n$$\\widehat {y}=\\arg \\max\\_{y}p\\left( y\\right) \\prod\\_{i=1}^{n}p\\left( x\\_{i}|y\\right) $$\n\n### 参数估计\n\n所有的模型参数都可以通过训练集的相关频率来估计。常用方法是概率的最大似然估计，类的先验概率可以通过假设各类等概率来计算（先验概率 = 1 / (类的数量)），或者通过训练集的各类样本出现的次数来估计（A类先验概率=（A类样本的数量）/(样本总数)）。为了估计特征的分布参数，我们要先假设训练集数据满足某种分布或者非参数模型。\n\n常见的分布模型：高斯分布(Gaussian naive Bayes)、多项分布(Multinomial naive Bayes)、伯努利分布(Bernoulli naive Bayes)等.\n\n## 使用Scikit-learn进行文本分类\n目的：使用Scikit-learn库自带的新闻信息数据来进行试验，该数据集有19,000个新闻信息组成，通过新闻文本的内容，使用scikit-learn中的朴素贝叶斯算法，来判断新闻属于什么主题类别。参考：[Scikit-learn Totorial](http://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html#building-a-pipeline)\n\n### 数据集\n\n```python\nfrom sklearn.datesets import fetch_20newsgroups\nnews = fetch_20newsgroups(subset='all')\nprint news.keys()\n```\n\n查看一下第一条新闻的内容和分组\n\n> ['description', 'DESCR', 'filenames', 'target_names', 'data', 'target']\n\n> From: Mamatha Devineni Ratnam <mr47+@andrew.cmu.edu>\nSubject: Pens fans reactions\nOrganization: Post Office, Carnegie Mellon, Pittsburgh, PA\n...\n\n> 10 rec.sport.hockey\n\n划分训练集和测试集，分为80%训练集，20%测试集\n\n```python\nsplit_rate = 0.8\nsplit_size = int(len(news.data) * split_rate)\nX_train = news.data[:split_size]\ny_train = news.target[:split_size]\nX_test  = news.data[split_size:]\ny_test  = news.target[split_size:]\n```\n\n### 特征提取\n\n为了使机器学习算法应用在文本内容上，首先应该把文本内容装换为数字特征。这里使用词袋模型([Bags of words](https://en.wikipedia.org/wiki/Bag-of-words_model))\n\n#### 词袋模型\n\n在信息检索中，Bag of words model假定对于一个文本，忽略其词序和语法，句法，将其仅仅看做是一个词集合，或者说是词的一个组合，文本中每个词的出现都是独立的，不依赖于其他词是否出现，或者说当这篇文章的作者在任意一个位置选择一个词汇都不受前面句子的影响而独立选择的。\n\nScikit-learn提供了一些实用工具(`sklearn.feature_extraction.text`)可以从文本内容中提取数值特征\n\n![Scikit-learn feature extraction from text tool](http://7xkfga.com1.z0.glb.clouddn.com/feature_extraction_from_text.jpg)\n\n```python\n\tfrom sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer, HashingVectorizer\n\tfrom sklearn.feature_extraction.text import TfidfTransformer\n\t# Tokenizing text\n\tcount_vect = CountVectorizer()\n\tX_train_counts = count_vect.fit_transform(X_train)\n\t# Tf\n\ttf_transformer = TfidfTransformer(use_idf=False).fit(X_train_counts)\n\tX_train_tf = tf_transformer.transform(X_train_counts)\n\t# Tf_idf\n\ttfidf_transformer = TfidfTransformer()\n\tX_train_tfidf = tfidf_transformer.fit_transform(X_train_counts)\n```\n\n#### 稀疏性\n\n大多数文档通常只会使用语料库中所有词的一个子集，因而产生的矩阵将有许多特征值是0（通常99%以上都是0）。\n例如，一组10,000个短文本（比如email）会使用100,000的词汇总量，而每个文档会使用100到1,000个唯一的词。\n为了能够在内存中存储这个矩阵，同时也提供矩阵/向量代数运算的速度，通常会使用稀疏表征例如在`scipy.sparse`包中提供的表征。\n\n### 训练模型\n\n上面使用文本中词的出现次数作为数值特征，可以使用多项分布估计这个特征，使用`sklearn.naive_bayes`模块的`MultinomialNB`类来训练模型。\n\n```python\n\tfrom sklearn.naive_bayes import MultinomialNB\n\t# create classifier\n\tclf = MultinomialNB().fit(X_train_tfidf, y_train)\n\tdocs_new = ['God is love', 'OpenGL on the GPU is fast']\n\tX_new_counts = count_vect.transform(docs_new)\n\tX_new_tfidf = tfidf_transformer.transform(X_new_counts)\n\t# using classifier to predict\n\tpredicted = clf.predict(X_new_tfidf)\n\tfor doc, category in zip(docs_new, predicted):\n        print('%r => %s' % (doc, news.target_names[category]))\n```\n\n### 使用`Pipline`这个类构建复合分类器\n\nScikit-learn为了使向量化 => 转换 => 分类这个过程更容易，提供了`Pipeline`类来构建复合分类器，例如：\n\n```python\nfrom sklearn.pipeline import Pipeline\ntext_clf = Pipeline([('vect', CountVectorizer()),\n                     ('tfidf', TfidfTransformer()),\n])\n```\n\n创建新的训练模型\n\n```python\n\tfrom sklearn.naive_bayes import MultinomialNB\n\tfrom sklearn.pipeline import Pipeline\n\tfrom sklearn.feature_extraction.text import TfidfVectorizer, HashingVectorizer, CountVectorizer\t#nbc means naive bayes classifier\n\tnbc_1 = Pipeline([\n\t        ('vect', CountVectorizer()),\n\t        ('clf', MultinomialNB()),\n\t])\n\tnbc_2 = Pipeline([\n            ('vect', HashingVectorizer(non_negative=True)),\n            ('clf', MultinomialNB()),\n\t])\n\tnbc_3 = Pipeline([\t   \n\t        ('vect', TfidfVectorizer()),\n\t        ('clf', MultinomialNB()),\n\t])\n\t# classifier\n\tnbcs = [nbc_1, nbc_2, nbc_3]\n```\n\n### 交叉验证\n\n下面是一个交叉验证函数：\n\n```python\n\tfrom sklearn.cross_validation import cross_val_score, KFold\n\tfrom scipy.stats import sem\n\timport numpy as np\n\t# cross validation function\n\tdef evaluate_cross_validation(clf, X, y, K):\n\t    # create a k-fold croos validation iterator of k folds\n\t    cv = KFold(len(y), K, shuffle=True, random_state=0)\n\t    # by default the score used is the one returned by score method of the estimator (accuracy)\n\t    scores = cross_val_score(clf, X, y, cv=cv)\n\t    print scores\n\t    print (\"Mean score: {0:.3f} (+/-{1:.3f})\").format(np.mean(scores), sem(scores))\n```\n\n将训练集分为10份，输出验证分数：\n\n```python\nfor nbc in nbcs:\n\tevaluate_cross_validation(nbc, X_train, y_train, 10)\n```\n\n结果为：\n\n> CountVectorizer Mean score: 0.849 (+/-0.002)\n\n> HashingVectorizer Mean score: 0.765 (+/-0.006)\n\n> TfidfVectorizer Mean score: 0.848 (+/-0.004)\n\n可以看出：CountVectorizer和TfidfVectorizer特征提取的方法要比HashingVectorizer效果好。\n\n### 优化模型\n\n#### 优化单词提取\n\n在使用TfidfVectorizer特征提取时候，使用正则表达式，默认的正则表达式是`u'(?u)\\b\\w\\w+\\b'`，使用新的正则表达式`ur\"\\b[a-z0-9_\\-\\.]+[a-z][a-z0-9_\\-\\.]+\\b\"`\n\n```python\nnbc_4 = Pipeline([\n    ('vect', TfidfVectorizer(\n                token_pattern=ur\"\\b[a-z0-9_\\-\\.]+[a-z][a-z0-9_\\-\\.]+\\b\",)\n    ),\n    ('clf', MultinomialNB()),\n])\nevaluate_cross_validation(nbc_4, X_train, y_train, 10)\n```\n\n分数是：Mean score: 0.861 (+/-0.004) ，结果好了一点\n\n#### 排除停止词\n\nTfidfVectorizer的一个参数stop_words，这个参数指定的词将被省略不计入到标记词的列表中，这里使用鼎鼎有名的NLTK语料库。\n\n```python\n\timport nltk\n\t# nltk.download()\n\tstopwords = nltk.corpus.stopwords.words('english')\n\tnbc_5 = Pipeline([\n    ('vect', TfidfVectorizer(\n                stop_words=stop_words,\n                token_pattern=ur\"\\b[a-z0-9_\\-\\.]+[a-z][a-z0-9_\\-\\.]+\\b\",    \n    )),\n    ('clf', MultinomialNB()),\n\t])\n\tevaluate_cross_validation(nbc_5, X_train, Y_train, 10)\n```\n\n分数是：Mean score: 0.879 (+/-0.003)，结果又提高了\n\n\n#### 调整贝叶斯分类器的alpha参数\n\nMultinomialNB有一个alpha参数，该参数是一个平滑参数，默认是1.0，我们将其设为0.01\n\n```python\nnbc_6 = Pipeline([\n    ('vect', TfidfVectorizer(\n                stop_words=stopwords,\n                token_pattern=ur\"\\b[a-z0-9_\\-\\.]+[a-z][a-z0-9_\\-\\.]+\\b\",         \n    )),\n    ('clf', MultinomialNB(alpha=0.01)),\n])\nevaluate_cross_validation(nbc_6, X_train, y_train, 10)\n```\n\n分数为：Mean score: 0.917 (+/-0.002)，哎呦，好像不错哦！不过问题来了，调整参数优化不能靠蒙，如何寻找最好的参数，使得交叉验证的分数最高呢？\n\n#### 使用Grid Search优化参数\n\n使用GridSearch寻找vectorizer词频统计, tfidftransformer特征变换和MultinomialNB classifier的最优参数\n\nScikit-learn上关于[GridSearch的介绍](http://scikit-learn.org/stable/modules/classes.html#module-sklearn.grid_search)\n![Grid Search](http://7xkfga.com1.z0.glb.clouddn.com/Grid_Search.jpg)\n\n```python\npipeline = Pipeline([\n('vect',CountVectorizer()),\n('tfidf',TfidfTransformer()),\n('clf',MultinomialNB()),\n]);\nparameters = {\n    'vect__max_df': (0.5, 0.75),\n    'vect__max_features': (None, 5000, 10000),\n    'tfidf__use_idf': (True, False),\n    'clf__alpha': (1, 0.1, 0.01, 0.001, 0.0001),\n}\ngrid_search = GridSearchCV(pipeline, parameters, n_jobs=1)\nfrom time import time\nt0 = time()\ngrid_search.fit(X_train, y_train)\nprint \"done in %0.3fs\" % (time() - t0)\nprint \"Best score: %0.3f\" % grid_search.best_score_\n```\n\n#### 输出最优参数\n\n```python\nfrom sklearn import metrics\nbest_parameters = dict()\nbest_parameters = grid_search.best_estimator_.get_params()\nfor param_name in sorted(parameters.keys()):\n    print \"\\t%s: %r\" % (param_name, best_parameters[param_name])\npipeline.set_params(clf__alpha = 1e-05,  \n                    tfidf__use_idf = True,\n                    vect__max_df = 0.5,\n                    vect__max_features = None)\npipeline.fit(X_train, y_train)\npred = pipeline.predict(X_test)\n```\n\n经过漫长的等待，终于找出了最优参数：\n\ndone in 1578.965s\nBest score: 0.902\n\nclf__alpha: 0.01\ntfidf__use_idf: True\nvect__max_df: 0.5\nvect__max_features: None\n\n在测试集上的准确率为：0.915，分类效果还是不错的\n\n```python\nprint np.mean(pred == y_test)\n```\n\n### 评价分类效果\n\n在测试集上测试朴素贝叶斯分类器的分类效果\n\n```python\n\tfrom sklearn import metrics\n\timport numpy as np\n\t#print X_test[0], y_test[0]\n\tfor i in range(20):\n\t    print str(i) + \": \" + news.target_names[i]\n\tpredicted = pipeline.fit(X_train, y_train).predict(X_test)\n\tprint np.mean(predicted == y_test)\n\tprint metrics.classification_report(y_test, predicted)\n```\n\n结果是这样的：\n\nid | groupname\n-- | ----------------\n0  | alt.atheism\n1  | comp.graphics\n2  | comp.os.ms-windows.misc\n3  | comp.sys.ibm.pc.hardware\n4  | comp.sys.mac.hardware\n5  | comp.windows.x\n6  | misc.forsale\n7  | rec.autos\n8  | rec.motorcycles\n9  | rec.sport.baseball\n10 | rec.sport.hockey\n11 | sci.crypt\n12 | sci.electronics\n13 | sci.med\n14 |sci.space\n15 | soc.religion.christian\n16 | talk.politics.guns\n17 | talk.politics.mideast\n18 | talk.politics.misc\n19 | talk.religion.misc\n   |\n\n准确率：0.922811671088\n\nid  | precision  |  recall | f1-score |  support \n--  | ---------- | ------- | -------- | --------------\n0   |    0.94    |  0.87   |   0.91   |    175\n1   |    0.85    |  0.87   |   0.86   |    199\n2   |    0.91    |  0.84   |   0.88   |    221\n3   |    0.81    |  0.87   |   0.84   |    179\n4   |    0.87    |  0.92   |   0.89   |    177\n5   |    0.91    |  0.92   |   0.91   |    179\n6   |    0.88    |  0.79   |   0.83   |    205\n7   |    0.94    |  0.95   |   0.94   |    228\n8   |    0.96    |  0.98   |   0.97   |    183\n9   |    0.96    |  0.95   |   0.96   |    197\n10  |    0.98    |  1.00   |   0.99   |    204\n11  |    0.96    |  0.98   |   0.97   |    218\n12  |    0.93    |  0.92   |   0.92   |    172\n13  |    0.93    |  0.95   |   0.94   |    200\n14  |    0.96    |  0.96   |   0.96   |    198\n15  |    0.93    |  0.97   |   0.95   |    191\n16  |    0.92    |  0.97   |   0.94   |    173\n17  |    0.98    |  0.99   |   0.98   |    184\n18  |    0.95    |  0.92   |   0.94   |    172\n19  |    0.83    |  0.78   |   0.81   |    115\navg / total   |    0.92   |   0.92   |   0.92   |   3770\n    |         |           |          |          |\n\n\n\n\n#### 参考\n\n1. JasonDing的 [【机器学习实验】使用朴素贝叶斯进行文本的分类](http://www.jianshu.com/p/845b16559431)；\n2. [Scikit-Learn Totorial](http://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html#building-a-pipeline)\n\n\n","slug":"2015-08-07-naive-bayes-classifier","published":1,"updated":"2016-09-20T02:07:00.000Z","photos":[],"link":"","_id":"cjfkkp3nb000pzd68bd7tuqhe","content":"<h2 id=\"实际案例\"><a href=\"#实际案例\" class=\"headerlink\" title=\"实际案例\"></a>实际案例</h2><p>举个运动员的例子：</p>\n<blockquote>\n<p>如果我问你Brittney Griner的运动项目是什么，她有6尺8寸高，207磅重，你会说“篮球”；我再问你对此分类的准确度有多少信心，你会回答“非常有信心”。<br>我再问你Heather Zurich，6尺1寸高，重176磅，你可能就不能确定地说她是打篮球的了，至少不会像之前判定Brittney那样肯定。因为从Heather的身高体重来看她也有可能是跑马拉松的。<br>最后，我再问你Yumiko Hara的运动项目，她5尺4寸高，95磅重，你也许会说她是跳体操的，但也不太敢肯定，因为有些马拉松运动员也是类似的身高体重。<br>      ——选自<a href=\"http://guidetodatamining.com/\" target=\"_blank\" rel=\"noopener\">A Programmer’s Guide to Data Mining</a></p>\n</blockquote>\n<p>这里所说的分类，就用到了所谓的概率模型。</p>\n<h2 id=\"朴素贝叶斯算法\"><a href=\"#朴素贝叶斯算法\" class=\"headerlink\" title=\"朴素贝叶斯算法\"></a>朴素贝叶斯算法</h2><p>朴素贝叶斯算法使用每个属性(特征)属于某个类的概率做出预测，这是一个监督性学习算法，对一个预测性问题进行概率建模。<strong>训练模型的过程可以看做是对条件概率的计算，何以计算每个类别的相应条件概率来估计分类结果。</strong> 这个算法基于一个假设：所有特征相互独立，任意特征的值和其他特征的值没有关联关系，这种假设在实际生活中几乎不存在，但是朴素贝叶斯算法在很多领域，尤其是自然语言处理领域很成功。其他的典型应用还有垃圾邮件过滤等等。</p>\n<a id=\"more\"></a>\n<h2 id=\"贝叶斯分类器的基本原理\"><a href=\"#贝叶斯分类器的基本原理\" class=\"headerlink\" title=\"贝叶斯分类器的基本原理\"></a>贝叶斯分类器的基本原理</h2><p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/bayes.jpg\" alt=\"bayes theory\"></p>\n<p>图片引用自<a href=\"https://www.flickr.com/photos/mattbuck007/3676624894\" target=\"_blank\" rel=\"noopener\">Matt Buck</a></p>\n<h3 id=\"贝叶斯定理\"><a href=\"#贝叶斯定理\" class=\"headerlink\" title=\"贝叶斯定理\"></a>贝叶斯定理</h3><p>给出贝叶斯定理：</p>\n<p>$$p\\left( h|D\\right) =\\dfrac {p\\left( D|h\\right) .p\\left( h\\right) } {p\\left( D\\right) }$$</p>\n<p>这个公式是贝叶斯方法论的基石。拿分类问题来说，h代表分类的类别，D代表已知的特征d1, d2, d3…，朴素贝叶斯算法的朴素之处在于，假设了特征d1, d2, d3…相互独立，所以贝叶斯定理又能写成：</p>\n<p>$$p\\left( h|f_{1},f_{2}…f_{n}\\right) =\\dfrac {p\\left( h\\right) \\prod_{i=1}^n p\\left( f_{i}|h\\right) } {p\\left( f_{1},f_{2}…f_{n}\\right) }$$</p>\n<p>由于$P\\left( f_{1},\\ldots f_{n}\\right) $ 可视作常数，类变量$h$的条件概率分布就可以表达为：</p>\n<p>$$p\\left( h|f_{1},…,f_{n}\\right) =\\dfrac {1} {Z}.p\\left( h\\right) \\prod _{i=1}^{n}p\\left( F_{i}|h\\right)$$</p>\n<h3 id=\"从概率模型中构造分类器\"><a href=\"#从概率模型中构造分类器\" class=\"headerlink\" title=\"从概率模型中构造分类器\"></a>从概率模型中构造分类器</h3><p>以上，就导出了独立分布的特征模型，也就是朴素贝叶斯模型，使用<a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87\" target=\"_blank\" rel=\"noopener\">最大后验概率</a>MAP(Maximum A Posteriori estimation)选出条件概率最大的那个分类，这就是朴素贝叶斯分类器：</p>\n<p>$$\\widehat {y}=\\arg \\max_{y}p\\left( y\\right) \\prod_{i=1}^{n}p\\left( x_{i}|y\\right) $$</p>\n<h3 id=\"参数估计\"><a href=\"#参数估计\" class=\"headerlink\" title=\"参数估计\"></a>参数估计</h3><p>所有的模型参数都可以通过训练集的相关频率来估计。常用方法是概率的最大似然估计，类的先验概率可以通过假设各类等概率来计算（先验概率 = 1 / (类的数量)），或者通过训练集的各类样本出现的次数来估计（A类先验概率=（A类样本的数量）/(样本总数)）。为了估计特征的分布参数，我们要先假设训练集数据满足某种分布或者非参数模型。</p>\n<p>常见的分布模型：高斯分布(Gaussian naive Bayes)、多项分布(Multinomial naive Bayes)、伯努利分布(Bernoulli naive Bayes)等.</p>\n<h2 id=\"使用Scikit-learn进行文本分类\"><a href=\"#使用Scikit-learn进行文本分类\" class=\"headerlink\" title=\"使用Scikit-learn进行文本分类\"></a>使用Scikit-learn进行文本分类</h2><p>目的：使用Scikit-learn库自带的新闻信息数据来进行试验，该数据集有19,000个新闻信息组成，通过新闻文本的内容，使用scikit-learn中的朴素贝叶斯算法，来判断新闻属于什么主题类别。参考：<a href=\"http://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html#building-a-pipeline\" target=\"_blank\" rel=\"noopener\">Scikit-learn Totorial</a></p>\n<h3 id=\"数据集\"><a href=\"#数据集\" class=\"headerlink\" title=\"数据集\"></a>数据集</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.datesets <span class=\"keyword\">import</span> fetch_20newsgroups</span><br><span class=\"line\">news = fetch_20newsgroups(subset=<span class=\"string\">'all'</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> news.keys()</span><br></pre></td></tr></table></figure>\n<p>查看一下第一条新闻的内容和分组</p>\n<blockquote>\n<p>[‘description’, ‘DESCR’, ‘filenames’, ‘target_names’, ‘data’, ‘target’]</p>\n</blockquote>\n<blockquote>\n<p>From: Mamatha Devineni Ratnam <a href=\"mailto:&#109;&#x72;&#52;&#55;&#x2b;&#x40;&#97;&#110;&#x64;&#x72;&#101;&#x77;&#46;&#x63;&#x6d;&#x75;&#46;&#101;&#100;&#117;\" target=\"_blank\" rel=\"noopener\">&#109;&#x72;&#52;&#55;&#x2b;&#x40;&#97;&#110;&#x64;&#x72;&#101;&#x77;&#46;&#x63;&#x6d;&#x75;&#46;&#101;&#100;&#117;</a><br>Subject: Pens fans reactions<br>Organization: Post Office, Carnegie Mellon, Pittsburgh, PA<br>…</p>\n</blockquote>\n<blockquote>\n<p>10 rec.sport.hockey</p>\n</blockquote>\n<p>划分训练集和测试集，分为80%训练集，20%测试集</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">split_rate = <span class=\"number\">0.8</span></span><br><span class=\"line\">split_size = int(len(news.data) * split_rate)</span><br><span class=\"line\">X_train = news.data[:split_size]</span><br><span class=\"line\">y_train = news.target[:split_size]</span><br><span class=\"line\">X_test  = news.data[split_size:]</span><br><span class=\"line\">y_test  = news.target[split_size:]</span><br></pre></td></tr></table></figure>\n<h3 id=\"特征提取\"><a href=\"#特征提取\" class=\"headerlink\" title=\"特征提取\"></a>特征提取</h3><p>为了使机器学习算法应用在文本内容上，首先应该把文本内容装换为数字特征。这里使用词袋模型(<a href=\"https://en.wikipedia.org/wiki/Bag-of-words_model\" target=\"_blank\" rel=\"noopener\">Bags of words</a>)</p>\n<h4 id=\"词袋模型\"><a href=\"#词袋模型\" class=\"headerlink\" title=\"词袋模型\"></a>词袋模型</h4><p>在信息检索中，Bag of words model假定对于一个文本，忽略其词序和语法，句法，将其仅仅看做是一个词集合，或者说是词的一个组合，文本中每个词的出现都是独立的，不依赖于其他词是否出现，或者说当这篇文章的作者在任意一个位置选择一个词汇都不受前面句子的影响而独立选择的。</p>\n<p>Scikit-learn提供了一些实用工具(<code>sklearn.feature_extraction.text</code>)可以从文本内容中提取数值特征</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/feature_extraction_from_text.jpg\" alt=\"Scikit-learn feature extraction from text tool\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.feature_extraction.text <span class=\"keyword\">import</span> CountVectorizer, TfidfVectorizer, HashingVectorizer</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.feature_extraction.text <span class=\"keyword\">import</span> TfidfTransformer</span><br><span class=\"line\"><span class=\"comment\"># Tokenizing text</span></span><br><span class=\"line\">count_vect = CountVectorizer()</span><br><span class=\"line\">X_train_counts = count_vect.fit_transform(X_train)</span><br><span class=\"line\"><span class=\"comment\"># Tf</span></span><br><span class=\"line\">tf_transformer = TfidfTransformer(use_idf=<span class=\"keyword\">False</span>).fit(X_train_counts)</span><br><span class=\"line\">X_train_tf = tf_transformer.transform(X_train_counts)</span><br><span class=\"line\"><span class=\"comment\"># Tf_idf</span></span><br><span class=\"line\">tfidf_transformer = TfidfTransformer()</span><br><span class=\"line\">X_train_tfidf = tfidf_transformer.fit_transform(X_train_counts)</span><br></pre></td></tr></table></figure>\n<h4 id=\"稀疏性\"><a href=\"#稀疏性\" class=\"headerlink\" title=\"稀疏性\"></a>稀疏性</h4><p>大多数文档通常只会使用语料库中所有词的一个子集，因而产生的矩阵将有许多特征值是0（通常99%以上都是0）。<br>例如，一组10,000个短文本（比如email）会使用100,000的词汇总量，而每个文档会使用100到1,000个唯一的词。<br>为了能够在内存中存储这个矩阵，同时也提供矩阵/向量代数运算的速度，通常会使用稀疏表征例如在<code>scipy.sparse</code>包中提供的表征。</p>\n<h3 id=\"训练模型\"><a href=\"#训练模型\" class=\"headerlink\" title=\"训练模型\"></a>训练模型</h3><p>上面使用文本中词的出现次数作为数值特征，可以使用多项分布估计这个特征，使用<code>sklearn.naive_bayes</code>模块的<code>MultinomialNB</code>类来训练模型。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.naive_bayes <span class=\"keyword\">import</span> MultinomialNB</span><br><span class=\"line\"><span class=\"comment\"># create classifier</span></span><br><span class=\"line\">clf = MultinomialNB().fit(X_train_tfidf, y_train)</span><br><span class=\"line\">docs_new = [<span class=\"string\">'God is love'</span>, <span class=\"string\">'OpenGL on the GPU is fast'</span>]</span><br><span class=\"line\">X_new_counts = count_vect.transform(docs_new)</span><br><span class=\"line\">X_new_tfidf = tfidf_transformer.transform(X_new_counts)</span><br><span class=\"line\"><span class=\"comment\"># using classifier to predict</span></span><br><span class=\"line\">predicted = clf.predict(X_new_tfidf)</span><br><span class=\"line\"><span class=\"keyword\">for</span> doc, category <span class=\"keyword\">in</span> zip(docs_new, predicted):</span><br><span class=\"line\">       print(<span class=\"string\">'%r =&gt; %s'</span> % (doc, news.target_names[category]))</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用Pipline这个类构建复合分类器\"><a href=\"#使用Pipline这个类构建复合分类器\" class=\"headerlink\" title=\"使用Pipline这个类构建复合分类器\"></a>使用<code>Pipline</code>这个类构建复合分类器</h3><p>Scikit-learn为了使向量化 =&gt; 转换 =&gt; 分类这个过程更容易，提供了<code>Pipeline</code>类来构建复合分类器，例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.pipeline <span class=\"keyword\">import</span> Pipeline</span><br><span class=\"line\">text_clf = Pipeline([(<span class=\"string\">'vect'</span>, CountVectorizer()),</span><br><span class=\"line\">                     (<span class=\"string\">'tfidf'</span>, TfidfTransformer()),</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n<p>创建新的训练模型</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.naive_bayes <span class=\"keyword\">import</span> MultinomialNB</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.pipeline <span class=\"keyword\">import</span> Pipeline</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.feature_extraction.text <span class=\"keyword\">import</span> TfidfVectorizer, HashingVectorizer, CountVectorizer\t<span class=\"comment\">#nbc means naive bayes classifier</span></span><br><span class=\"line\">nbc_1 = Pipeline([</span><br><span class=\"line\">        (<span class=\"string\">'vect'</span>, CountVectorizer()),</span><br><span class=\"line\">        (<span class=\"string\">'clf'</span>, MultinomialNB()),</span><br><span class=\"line\">])</span><br><span class=\"line\">nbc_2 = Pipeline([</span><br><span class=\"line\">           (<span class=\"string\">'vect'</span>, HashingVectorizer(non_negative=<span class=\"keyword\">True</span>)),</span><br><span class=\"line\">           (<span class=\"string\">'clf'</span>, MultinomialNB()),</span><br><span class=\"line\">])</span><br><span class=\"line\">nbc_3 = Pipeline([\t   </span><br><span class=\"line\">        (<span class=\"string\">'vect'</span>, TfidfVectorizer()),</span><br><span class=\"line\">        (<span class=\"string\">'clf'</span>, MultinomialNB()),</span><br><span class=\"line\">])</span><br><span class=\"line\"><span class=\"comment\"># classifier</span></span><br><span class=\"line\">nbcs = [nbc_1, nbc_2, nbc_3]</span><br></pre></td></tr></table></figure>\n<h3 id=\"交叉验证\"><a href=\"#交叉验证\" class=\"headerlink\" title=\"交叉验证\"></a>交叉验证</h3><p>下面是一个交叉验证函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.cross_validation <span class=\"keyword\">import</span> cross_val_score, KFold</span><br><span class=\"line\"><span class=\"keyword\">from</span> scipy.stats <span class=\"keyword\">import</span> sem</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"comment\"># cross validation function</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">evaluate_cross_validation</span><span class=\"params\">(clf, X, y, K)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># create a k-fold croos validation iterator of k folds</span></span><br><span class=\"line\">    cv = KFold(len(y), K, shuffle=<span class=\"keyword\">True</span>, random_state=<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\"># by default the score used is the one returned by score method of the estimator (accuracy)</span></span><br><span class=\"line\">    scores = cross_val_score(clf, X, y, cv=cv)</span><br><span class=\"line\">    <span class=\"keyword\">print</span> scores</span><br><span class=\"line\">    <span class=\"keyword\">print</span> (<span class=\"string\">\"Mean score: &#123;0:.3f&#125; (+/-&#123;1:.3f&#125;)\"</span>).format(np.mean(scores), sem(scores))</span><br></pre></td></tr></table></figure>\n<p>将训练集分为10份，输出验证分数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> nbc <span class=\"keyword\">in</span> nbcs:</span><br><span class=\"line\">\tevaluate_cross_validation(nbc, X_train, y_train, <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>结果为：</p>\n<blockquote>\n<p>CountVectorizer Mean score: 0.849 (+/-0.002)</p>\n</blockquote>\n<blockquote>\n<p>HashingVectorizer Mean score: 0.765 (+/-0.006)</p>\n</blockquote>\n<blockquote>\n<p>TfidfVectorizer Mean score: 0.848 (+/-0.004)</p>\n</blockquote>\n<p>可以看出：CountVectorizer和TfidfVectorizer特征提取的方法要比HashingVectorizer效果好。</p>\n<h3 id=\"优化模型\"><a href=\"#优化模型\" class=\"headerlink\" title=\"优化模型\"></a>优化模型</h3><h4 id=\"优化单词提取\"><a href=\"#优化单词提取\" class=\"headerlink\" title=\"优化单词提取\"></a>优化单词提取</h4><p>在使用TfidfVectorizer特征提取时候，使用正则表达式，默认的正则表达式是<code>u&#39;(?u)\\b\\w\\w+\\b&#39;</code>，使用新的正则表达式<code>ur&quot;\\b[a-z0-9_\\-\\.]+[a-z][a-z0-9_\\-\\.]+\\b&quot;</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nbc_4 = Pipeline([</span><br><span class=\"line\">    (<span class=\"string\">'vect'</span>, TfidfVectorizer(</span><br><span class=\"line\">                token_pattern=<span class=\"string\">ur\"\\b[a-z0-9_\\-\\.]+[a-z][a-z0-9_\\-\\.]+\\b\"</span>,)</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    (<span class=\"string\">'clf'</span>, MultinomialNB()),</span><br><span class=\"line\">])</span><br><span class=\"line\">evaluate_cross_validation(nbc_4, X_train, y_train, <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>分数是：Mean score: 0.861 (+/-0.004) ，结果好了一点</p>\n<h4 id=\"排除停止词\"><a href=\"#排除停止词\" class=\"headerlink\" title=\"排除停止词\"></a>排除停止词</h4><p>TfidfVectorizer的一个参数stop_words，这个参数指定的词将被省略不计入到标记词的列表中，这里使用鼎鼎有名的NLTK语料库。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> nltk</span><br><span class=\"line\"><span class=\"comment\"># nltk.download()</span></span><br><span class=\"line\">stopwords = nltk.corpus.stopwords.words(<span class=\"string\">'english'</span>)</span><br><span class=\"line\">nbc_5 = Pipeline([</span><br><span class=\"line\">   (<span class=\"string\">'vect'</span>, TfidfVectorizer(</span><br><span class=\"line\">               stop_words=stop_words,</span><br><span class=\"line\">               token_pattern=<span class=\"string\">ur\"\\b[a-z0-9_\\-\\.]+[a-z][a-z0-9_\\-\\.]+\\b\"</span>,    </span><br><span class=\"line\">   )),</span><br><span class=\"line\">   (<span class=\"string\">'clf'</span>, MultinomialNB()),</span><br><span class=\"line\">])</span><br><span class=\"line\">evaluate_cross_validation(nbc_5, X_train, Y_train, <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>分数是：Mean score: 0.879 (+/-0.003)，结果又提高了</p>\n<h4 id=\"调整贝叶斯分类器的alpha参数\"><a href=\"#调整贝叶斯分类器的alpha参数\" class=\"headerlink\" title=\"调整贝叶斯分类器的alpha参数\"></a>调整贝叶斯分类器的alpha参数</h4><p>MultinomialNB有一个alpha参数，该参数是一个平滑参数，默认是1.0，我们将其设为0.01</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nbc_6 = Pipeline([</span><br><span class=\"line\">    (<span class=\"string\">'vect'</span>, TfidfVectorizer(</span><br><span class=\"line\">                stop_words=stopwords,</span><br><span class=\"line\">                token_pattern=<span class=\"string\">ur\"\\b[a-z0-9_\\-\\.]+[a-z][a-z0-9_\\-\\.]+\\b\"</span>,         </span><br><span class=\"line\">    )),</span><br><span class=\"line\">    (<span class=\"string\">'clf'</span>, MultinomialNB(alpha=<span class=\"number\">0.01</span>)),</span><br><span class=\"line\">])</span><br><span class=\"line\">evaluate_cross_validation(nbc_6, X_train, y_train, <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>分数为：Mean score: 0.917 (+/-0.002)，哎呦，好像不错哦！不过问题来了，调整参数优化不能靠蒙，如何寻找最好的参数，使得交叉验证的分数最高呢？</p>\n<h4 id=\"使用Grid-Search优化参数\"><a href=\"#使用Grid-Search优化参数\" class=\"headerlink\" title=\"使用Grid Search优化参数\"></a>使用Grid Search优化参数</h4><p>使用GridSearch寻找vectorizer词频统计, tfidftransformer特征变换和MultinomialNB classifier的最优参数</p>\n<p>Scikit-learn上关于<a href=\"http://scikit-learn.org/stable/modules/classes.html#module-sklearn.grid_search\" target=\"_blank\" rel=\"noopener\">GridSearch的介绍</a><br><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/Grid_Search.jpg\" alt=\"Grid Search\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline = Pipeline([</span><br><span class=\"line\">(<span class=\"string\">'vect'</span>,CountVectorizer()),</span><br><span class=\"line\">(<span class=\"string\">'tfidf'</span>,TfidfTransformer()),</span><br><span class=\"line\">(<span class=\"string\">'clf'</span>,MultinomialNB()),</span><br><span class=\"line\">]);</span><br><span class=\"line\">parameters = &#123;</span><br><span class=\"line\">    <span class=\"string\">'vect__max_df'</span>: (<span class=\"number\">0.5</span>, <span class=\"number\">0.75</span>),</span><br><span class=\"line\">    <span class=\"string\">'vect__max_features'</span>: (<span class=\"keyword\">None</span>, <span class=\"number\">5000</span>, <span class=\"number\">10000</span>),</span><br><span class=\"line\">    <span class=\"string\">'tfidf__use_idf'</span>: (<span class=\"keyword\">True</span>, <span class=\"keyword\">False</span>),</span><br><span class=\"line\">    <span class=\"string\">'clf__alpha'</span>: (<span class=\"number\">1</span>, <span class=\"number\">0.1</span>, <span class=\"number\">0.01</span>, <span class=\"number\">0.001</span>, <span class=\"number\">0.0001</span>),</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">grid_search = GridSearchCV(pipeline, parameters, n_jobs=<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> time</span><br><span class=\"line\">t0 = time()</span><br><span class=\"line\">grid_search.fit(X_train, y_train)</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"done in %0.3fs\"</span> % (time() - t0)</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"Best score: %0.3f\"</span> % grid_search.best_score_</span><br></pre></td></tr></table></figure>\n<h4 id=\"输出最优参数\"><a href=\"#输出最优参数\" class=\"headerlink\" title=\"输出最优参数\"></a>输出最优参数</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> metrics</span><br><span class=\"line\">best_parameters = dict()</span><br><span class=\"line\">best_parameters = grid_search.best_estimator_.get_params()</span><br><span class=\"line\"><span class=\"keyword\">for</span> param_name <span class=\"keyword\">in</span> sorted(parameters.keys()):</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"\\t%s: %r\"</span> % (param_name, best_parameters[param_name])</span><br><span class=\"line\">pipeline.set_params(clf__alpha = <span class=\"number\">1e-05</span>,  </span><br><span class=\"line\">                    tfidf__use_idf = <span class=\"keyword\">True</span>,</span><br><span class=\"line\">                    vect__max_df = <span class=\"number\">0.5</span>,</span><br><span class=\"line\">                    vect__max_features = <span class=\"keyword\">None</span>)</span><br><span class=\"line\">pipeline.fit(X_train, y_train)</span><br><span class=\"line\">pred = pipeline.predict(X_test)</span><br></pre></td></tr></table></figure>\n<p>经过漫长的等待，终于找出了最优参数：</p>\n<p>done in 1578.965s<br>Best score: 0.902</p>\n<p>clf__alpha: 0.01<br>tfidf__use_idf: True<br>vect__max_df: 0.5<br>vect__max_features: None</p>\n<p>在测试集上的准确率为：0.915，分类效果还是不错的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">print</span> np.mean(pred == y_test)</span><br></pre></td></tr></table></figure>\n<h3 id=\"评价分类效果\"><a href=\"#评价分类效果\" class=\"headerlink\" title=\"评价分类效果\"></a>评价分类效果</h3><p>在测试集上测试朴素贝叶斯分类器的分类效果</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> metrics</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"comment\">#print X_test[0], y_test[0]</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">20</span>):</span><br><span class=\"line\">    <span class=\"keyword\">print</span> str(i) + <span class=\"string\">\": \"</span> + news.target_names[i]</span><br><span class=\"line\">predicted = pipeline.fit(X_train, y_train).predict(X_test)</span><br><span class=\"line\"><span class=\"keyword\">print</span> np.mean(predicted == y_test)</span><br><span class=\"line\"><span class=\"keyword\">print</span> metrics.classification_report(y_test, predicted)</span><br></pre></td></tr></table></figure>\n<p>结果是这样的：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>groupname</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>alt.atheism</td>\n</tr>\n<tr>\n<td>1</td>\n<td>comp.graphics</td>\n</tr>\n<tr>\n<td>2</td>\n<td>comp.os.ms-windows.misc</td>\n</tr>\n<tr>\n<td>3</td>\n<td>comp.sys.ibm.pc.hardware</td>\n</tr>\n<tr>\n<td>4</td>\n<td>comp.sys.mac.hardware</td>\n</tr>\n<tr>\n<td>5</td>\n<td>comp.windows.x</td>\n</tr>\n<tr>\n<td>6</td>\n<td>misc.forsale</td>\n</tr>\n<tr>\n<td>7</td>\n<td>rec.autos</td>\n</tr>\n<tr>\n<td>8</td>\n<td>rec.motorcycles</td>\n</tr>\n<tr>\n<td>9</td>\n<td>rec.sport.baseball</td>\n</tr>\n<tr>\n<td>10</td>\n<td>rec.sport.hockey</td>\n</tr>\n<tr>\n<td>11</td>\n<td>sci.crypt</td>\n</tr>\n<tr>\n<td>12</td>\n<td>sci.electronics</td>\n</tr>\n<tr>\n<td>13</td>\n<td>sci.med</td>\n</tr>\n<tr>\n<td>14</td>\n<td>sci.space</td>\n</tr>\n<tr>\n<td>15</td>\n<td>soc.religion.christian</td>\n</tr>\n<tr>\n<td>16</td>\n<td>talk.politics.guns</td>\n</tr>\n<tr>\n<td>17</td>\n<td>talk.politics.mideast</td>\n</tr>\n<tr>\n<td>18</td>\n<td>talk.politics.misc</td>\n</tr>\n<tr>\n<td>19</td>\n<td>talk.religion.misc</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>准确率：0.922811671088</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>precision</th>\n<th>recall</th>\n<th>f1-score</th>\n<th>support </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0.94</td>\n<td>0.87</td>\n<td>0.91</td>\n<td>175</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0.85</td>\n<td>0.87</td>\n<td>0.86</td>\n<td>199</td>\n</tr>\n<tr>\n<td>2</td>\n<td>0.91</td>\n<td>0.84</td>\n<td>0.88</td>\n<td>221</td>\n</tr>\n<tr>\n<td>3</td>\n<td>0.81</td>\n<td>0.87</td>\n<td>0.84</td>\n<td>179</td>\n</tr>\n<tr>\n<td>4</td>\n<td>0.87</td>\n<td>0.92</td>\n<td>0.89</td>\n<td>177</td>\n</tr>\n<tr>\n<td>5</td>\n<td>0.91</td>\n<td>0.92</td>\n<td>0.91</td>\n<td>179</td>\n</tr>\n<tr>\n<td>6</td>\n<td>0.88</td>\n<td>0.79</td>\n<td>0.83</td>\n<td>205</td>\n</tr>\n<tr>\n<td>7</td>\n<td>0.94</td>\n<td>0.95</td>\n<td>0.94</td>\n<td>228</td>\n</tr>\n<tr>\n<td>8</td>\n<td>0.96</td>\n<td>0.98</td>\n<td>0.97</td>\n<td>183</td>\n</tr>\n<tr>\n<td>9</td>\n<td>0.96</td>\n<td>0.95</td>\n<td>0.96</td>\n<td>197</td>\n</tr>\n<tr>\n<td>10</td>\n<td>0.98</td>\n<td>1.00</td>\n<td>0.99</td>\n<td>204</td>\n</tr>\n<tr>\n<td>11</td>\n<td>0.96</td>\n<td>0.98</td>\n<td>0.97</td>\n<td>218</td>\n</tr>\n<tr>\n<td>12</td>\n<td>0.93</td>\n<td>0.92</td>\n<td>0.92</td>\n<td>172</td>\n</tr>\n<tr>\n<td>13</td>\n<td>0.93</td>\n<td>0.95</td>\n<td>0.94</td>\n<td>200</td>\n</tr>\n<tr>\n<td>14</td>\n<td>0.96</td>\n<td>0.96</td>\n<td>0.96</td>\n<td>198</td>\n</tr>\n<tr>\n<td>15</td>\n<td>0.93</td>\n<td>0.97</td>\n<td>0.95</td>\n<td>191</td>\n</tr>\n<tr>\n<td>16</td>\n<td>0.92</td>\n<td>0.97</td>\n<td>0.94</td>\n<td>173</td>\n</tr>\n<tr>\n<td>17</td>\n<td>0.98</td>\n<td>0.99</td>\n<td>0.98</td>\n<td>184</td>\n</tr>\n<tr>\n<td>18</td>\n<td>0.95</td>\n<td>0.92</td>\n<td>0.94</td>\n<td>172</td>\n</tr>\n<tr>\n<td>19</td>\n<td>0.83</td>\n<td>0.78</td>\n<td>0.81</td>\n<td>115</td>\n</tr>\n<tr>\n<td>avg / total</td>\n<td>0.92</td>\n<td>0.92</td>\n<td>0.92</td>\n<td>3770</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><ol>\n<li>JasonDing的 <a href=\"http://www.jianshu.com/p/845b16559431\" target=\"_blank\" rel=\"noopener\">【机器学习实验】使用朴素贝叶斯进行文本的分类</a>；</li>\n<li><a href=\"http://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html#building-a-pipeline\" target=\"_blank\" rel=\"noopener\">Scikit-Learn Totorial</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"实际案例\"><a href=\"#实际案例\" class=\"headerlink\" title=\"实际案例\"></a>实际案例</h2><p>举个运动员的例子：</p>\n<blockquote>\n<p>如果我问你Brittney Griner的运动项目是什么，她有6尺8寸高，207磅重，你会说“篮球”；我再问你对此分类的准确度有多少信心，你会回答“非常有信心”。<br>我再问你Heather Zurich，6尺1寸高，重176磅，你可能就不能确定地说她是打篮球的了，至少不会像之前判定Brittney那样肯定。因为从Heather的身高体重来看她也有可能是跑马拉松的。<br>最后，我再问你Yumiko Hara的运动项目，她5尺4寸高，95磅重，你也许会说她是跳体操的，但也不太敢肯定，因为有些马拉松运动员也是类似的身高体重。<br>      ——选自<a href=\"http://guidetodatamining.com/\" target=\"_blank\" rel=\"noopener\">A Programmer’s Guide to Data Mining</a></p>\n</blockquote>\n<p>这里所说的分类，就用到了所谓的概率模型。</p>\n<h2 id=\"朴素贝叶斯算法\"><a href=\"#朴素贝叶斯算法\" class=\"headerlink\" title=\"朴素贝叶斯算法\"></a>朴素贝叶斯算法</h2><p>朴素贝叶斯算法使用每个属性(特征)属于某个类的概率做出预测，这是一个监督性学习算法，对一个预测性问题进行概率建模。<strong>训练模型的过程可以看做是对条件概率的计算，何以计算每个类别的相应条件概率来估计分类结果。</strong> 这个算法基于一个假设：所有特征相互独立，任意特征的值和其他特征的值没有关联关系，这种假设在实际生活中几乎不存在，但是朴素贝叶斯算法在很多领域，尤其是自然语言处理领域很成功。其他的典型应用还有垃圾邮件过滤等等。</p>","more":"<h2 id=\"贝叶斯分类器的基本原理\"><a href=\"#贝叶斯分类器的基本原理\" class=\"headerlink\" title=\"贝叶斯分类器的基本原理\"></a>贝叶斯分类器的基本原理</h2><p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/bayes.jpg\" alt=\"bayes theory\"></p>\n<p>图片引用自<a href=\"https://www.flickr.com/photos/mattbuck007/3676624894\" target=\"_blank\" rel=\"noopener\">Matt Buck</a></p>\n<h3 id=\"贝叶斯定理\"><a href=\"#贝叶斯定理\" class=\"headerlink\" title=\"贝叶斯定理\"></a>贝叶斯定理</h3><p>给出贝叶斯定理：</p>\n<p>$$p\\left( h|D\\right) =\\dfrac {p\\left( D|h\\right) .p\\left( h\\right) } {p\\left( D\\right) }$$</p>\n<p>这个公式是贝叶斯方法论的基石。拿分类问题来说，h代表分类的类别，D代表已知的特征d1, d2, d3…，朴素贝叶斯算法的朴素之处在于，假设了特征d1, d2, d3…相互独立，所以贝叶斯定理又能写成：</p>\n<p>$$p\\left( h|f_{1},f_{2}…f_{n}\\right) =\\dfrac {p\\left( h\\right) \\prod_{i=1}^n p\\left( f_{i}|h\\right) } {p\\left( f_{1},f_{2}…f_{n}\\right) }$$</p>\n<p>由于$P\\left( f_{1},\\ldots f_{n}\\right) $ 可视作常数，类变量$h$的条件概率分布就可以表达为：</p>\n<p>$$p\\left( h|f_{1},…,f_{n}\\right) =\\dfrac {1} {Z}.p\\left( h\\right) \\prod _{i=1}^{n}p\\left( F_{i}|h\\right)$$</p>\n<h3 id=\"从概率模型中构造分类器\"><a href=\"#从概率模型中构造分类器\" class=\"headerlink\" title=\"从概率模型中构造分类器\"></a>从概率模型中构造分类器</h3><p>以上，就导出了独立分布的特征模型，也就是朴素贝叶斯模型，使用<a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87\" target=\"_blank\" rel=\"noopener\">最大后验概率</a>MAP(Maximum A Posteriori estimation)选出条件概率最大的那个分类，这就是朴素贝叶斯分类器：</p>\n<p>$$\\widehat {y}=\\arg \\max_{y}p\\left( y\\right) \\prod_{i=1}^{n}p\\left( x_{i}|y\\right) $$</p>\n<h3 id=\"参数估计\"><a href=\"#参数估计\" class=\"headerlink\" title=\"参数估计\"></a>参数估计</h3><p>所有的模型参数都可以通过训练集的相关频率来估计。常用方法是概率的最大似然估计，类的先验概率可以通过假设各类等概率来计算（先验概率 = 1 / (类的数量)），或者通过训练集的各类样本出现的次数来估计（A类先验概率=（A类样本的数量）/(样本总数)）。为了估计特征的分布参数，我们要先假设训练集数据满足某种分布或者非参数模型。</p>\n<p>常见的分布模型：高斯分布(Gaussian naive Bayes)、多项分布(Multinomial naive Bayes)、伯努利分布(Bernoulli naive Bayes)等.</p>\n<h2 id=\"使用Scikit-learn进行文本分类\"><a href=\"#使用Scikit-learn进行文本分类\" class=\"headerlink\" title=\"使用Scikit-learn进行文本分类\"></a>使用Scikit-learn进行文本分类</h2><p>目的：使用Scikit-learn库自带的新闻信息数据来进行试验，该数据集有19,000个新闻信息组成，通过新闻文本的内容，使用scikit-learn中的朴素贝叶斯算法，来判断新闻属于什么主题类别。参考：<a href=\"http://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html#building-a-pipeline\" target=\"_blank\" rel=\"noopener\">Scikit-learn Totorial</a></p>\n<h3 id=\"数据集\"><a href=\"#数据集\" class=\"headerlink\" title=\"数据集\"></a>数据集</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.datesets <span class=\"keyword\">import</span> fetch_20newsgroups</span><br><span class=\"line\">news = fetch_20newsgroups(subset=<span class=\"string\">'all'</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> news.keys()</span><br></pre></td></tr></table></figure>\n<p>查看一下第一条新闻的内容和分组</p>\n<blockquote>\n<p>[‘description’, ‘DESCR’, ‘filenames’, ‘target_names’, ‘data’, ‘target’]</p>\n</blockquote>\n<blockquote>\n<p>From: Mamatha Devineni Ratnam <a href=\"mailto:&#109;&#x72;&#52;&#55;&#x2b;&#x40;&#97;&#110;&#x64;&#x72;&#101;&#x77;&#46;&#x63;&#x6d;&#x75;&#46;&#101;&#100;&#117;\" target=\"_blank\" rel=\"noopener\">&#109;&#x72;&#52;&#55;&#x2b;&#x40;&#97;&#110;&#x64;&#x72;&#101;&#x77;&#46;&#x63;&#x6d;&#x75;&#46;&#101;&#100;&#117;</a><br>Subject: Pens fans reactions<br>Organization: Post Office, Carnegie Mellon, Pittsburgh, PA<br>…</p>\n</blockquote>\n<blockquote>\n<p>10 rec.sport.hockey</p>\n</blockquote>\n<p>划分训练集和测试集，分为80%训练集，20%测试集</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">split_rate = <span class=\"number\">0.8</span></span><br><span class=\"line\">split_size = int(len(news.data) * split_rate)</span><br><span class=\"line\">X_train = news.data[:split_size]</span><br><span class=\"line\">y_train = news.target[:split_size]</span><br><span class=\"line\">X_test  = news.data[split_size:]</span><br><span class=\"line\">y_test  = news.target[split_size:]</span><br></pre></td></tr></table></figure>\n<h3 id=\"特征提取\"><a href=\"#特征提取\" class=\"headerlink\" title=\"特征提取\"></a>特征提取</h3><p>为了使机器学习算法应用在文本内容上，首先应该把文本内容装换为数字特征。这里使用词袋模型(<a href=\"https://en.wikipedia.org/wiki/Bag-of-words_model\" target=\"_blank\" rel=\"noopener\">Bags of words</a>)</p>\n<h4 id=\"词袋模型\"><a href=\"#词袋模型\" class=\"headerlink\" title=\"词袋模型\"></a>词袋模型</h4><p>在信息检索中，Bag of words model假定对于一个文本，忽略其词序和语法，句法，将其仅仅看做是一个词集合，或者说是词的一个组合，文本中每个词的出现都是独立的，不依赖于其他词是否出现，或者说当这篇文章的作者在任意一个位置选择一个词汇都不受前面句子的影响而独立选择的。</p>\n<p>Scikit-learn提供了一些实用工具(<code>sklearn.feature_extraction.text</code>)可以从文本内容中提取数值特征</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/feature_extraction_from_text.jpg\" alt=\"Scikit-learn feature extraction from text tool\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.feature_extraction.text <span class=\"keyword\">import</span> CountVectorizer, TfidfVectorizer, HashingVectorizer</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.feature_extraction.text <span class=\"keyword\">import</span> TfidfTransformer</span><br><span class=\"line\"><span class=\"comment\"># Tokenizing text</span></span><br><span class=\"line\">count_vect = CountVectorizer()</span><br><span class=\"line\">X_train_counts = count_vect.fit_transform(X_train)</span><br><span class=\"line\"><span class=\"comment\"># Tf</span></span><br><span class=\"line\">tf_transformer = TfidfTransformer(use_idf=<span class=\"keyword\">False</span>).fit(X_train_counts)</span><br><span class=\"line\">X_train_tf = tf_transformer.transform(X_train_counts)</span><br><span class=\"line\"><span class=\"comment\"># Tf_idf</span></span><br><span class=\"line\">tfidf_transformer = TfidfTransformer()</span><br><span class=\"line\">X_train_tfidf = tfidf_transformer.fit_transform(X_train_counts)</span><br></pre></td></tr></table></figure>\n<h4 id=\"稀疏性\"><a href=\"#稀疏性\" class=\"headerlink\" title=\"稀疏性\"></a>稀疏性</h4><p>大多数文档通常只会使用语料库中所有词的一个子集，因而产生的矩阵将有许多特征值是0（通常99%以上都是0）。<br>例如，一组10,000个短文本（比如email）会使用100,000的词汇总量，而每个文档会使用100到1,000个唯一的词。<br>为了能够在内存中存储这个矩阵，同时也提供矩阵/向量代数运算的速度，通常会使用稀疏表征例如在<code>scipy.sparse</code>包中提供的表征。</p>\n<h3 id=\"训练模型\"><a href=\"#训练模型\" class=\"headerlink\" title=\"训练模型\"></a>训练模型</h3><p>上面使用文本中词的出现次数作为数值特征，可以使用多项分布估计这个特征，使用<code>sklearn.naive_bayes</code>模块的<code>MultinomialNB</code>类来训练模型。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.naive_bayes <span class=\"keyword\">import</span> MultinomialNB</span><br><span class=\"line\"><span class=\"comment\"># create classifier</span></span><br><span class=\"line\">clf = MultinomialNB().fit(X_train_tfidf, y_train)</span><br><span class=\"line\">docs_new = [<span class=\"string\">'God is love'</span>, <span class=\"string\">'OpenGL on the GPU is fast'</span>]</span><br><span class=\"line\">X_new_counts = count_vect.transform(docs_new)</span><br><span class=\"line\">X_new_tfidf = tfidf_transformer.transform(X_new_counts)</span><br><span class=\"line\"><span class=\"comment\"># using classifier to predict</span></span><br><span class=\"line\">predicted = clf.predict(X_new_tfidf)</span><br><span class=\"line\"><span class=\"keyword\">for</span> doc, category <span class=\"keyword\">in</span> zip(docs_new, predicted):</span><br><span class=\"line\">       print(<span class=\"string\">'%r =&gt; %s'</span> % (doc, news.target_names[category]))</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用Pipline这个类构建复合分类器\"><a href=\"#使用Pipline这个类构建复合分类器\" class=\"headerlink\" title=\"使用Pipline这个类构建复合分类器\"></a>使用<code>Pipline</code>这个类构建复合分类器</h3><p>Scikit-learn为了使向量化 =&gt; 转换 =&gt; 分类这个过程更容易，提供了<code>Pipeline</code>类来构建复合分类器，例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.pipeline <span class=\"keyword\">import</span> Pipeline</span><br><span class=\"line\">text_clf = Pipeline([(<span class=\"string\">'vect'</span>, CountVectorizer()),</span><br><span class=\"line\">                     (<span class=\"string\">'tfidf'</span>, TfidfTransformer()),</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n<p>创建新的训练模型</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.naive_bayes <span class=\"keyword\">import</span> MultinomialNB</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.pipeline <span class=\"keyword\">import</span> Pipeline</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.feature_extraction.text <span class=\"keyword\">import</span> TfidfVectorizer, HashingVectorizer, CountVectorizer\t<span class=\"comment\">#nbc means naive bayes classifier</span></span><br><span class=\"line\">nbc_1 = Pipeline([</span><br><span class=\"line\">        (<span class=\"string\">'vect'</span>, CountVectorizer()),</span><br><span class=\"line\">        (<span class=\"string\">'clf'</span>, MultinomialNB()),</span><br><span class=\"line\">])</span><br><span class=\"line\">nbc_2 = Pipeline([</span><br><span class=\"line\">           (<span class=\"string\">'vect'</span>, HashingVectorizer(non_negative=<span class=\"keyword\">True</span>)),</span><br><span class=\"line\">           (<span class=\"string\">'clf'</span>, MultinomialNB()),</span><br><span class=\"line\">])</span><br><span class=\"line\">nbc_3 = Pipeline([\t   </span><br><span class=\"line\">        (<span class=\"string\">'vect'</span>, TfidfVectorizer()),</span><br><span class=\"line\">        (<span class=\"string\">'clf'</span>, MultinomialNB()),</span><br><span class=\"line\">])</span><br><span class=\"line\"><span class=\"comment\"># classifier</span></span><br><span class=\"line\">nbcs = [nbc_1, nbc_2, nbc_3]</span><br></pre></td></tr></table></figure>\n<h3 id=\"交叉验证\"><a href=\"#交叉验证\" class=\"headerlink\" title=\"交叉验证\"></a>交叉验证</h3><p>下面是一个交叉验证函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.cross_validation <span class=\"keyword\">import</span> cross_val_score, KFold</span><br><span class=\"line\"><span class=\"keyword\">from</span> scipy.stats <span class=\"keyword\">import</span> sem</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"comment\"># cross validation function</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">evaluate_cross_validation</span><span class=\"params\">(clf, X, y, K)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># create a k-fold croos validation iterator of k folds</span></span><br><span class=\"line\">    cv = KFold(len(y), K, shuffle=<span class=\"keyword\">True</span>, random_state=<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\"># by default the score used is the one returned by score method of the estimator (accuracy)</span></span><br><span class=\"line\">    scores = cross_val_score(clf, X, y, cv=cv)</span><br><span class=\"line\">    <span class=\"keyword\">print</span> scores</span><br><span class=\"line\">    <span class=\"keyword\">print</span> (<span class=\"string\">\"Mean score: &#123;0:.3f&#125; (+/-&#123;1:.3f&#125;)\"</span>).format(np.mean(scores), sem(scores))</span><br></pre></td></tr></table></figure>\n<p>将训练集分为10份，输出验证分数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> nbc <span class=\"keyword\">in</span> nbcs:</span><br><span class=\"line\">\tevaluate_cross_validation(nbc, X_train, y_train, <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>结果为：</p>\n<blockquote>\n<p>CountVectorizer Mean score: 0.849 (+/-0.002)</p>\n</blockquote>\n<blockquote>\n<p>HashingVectorizer Mean score: 0.765 (+/-0.006)</p>\n</blockquote>\n<blockquote>\n<p>TfidfVectorizer Mean score: 0.848 (+/-0.004)</p>\n</blockquote>\n<p>可以看出：CountVectorizer和TfidfVectorizer特征提取的方法要比HashingVectorizer效果好。</p>\n<h3 id=\"优化模型\"><a href=\"#优化模型\" class=\"headerlink\" title=\"优化模型\"></a>优化模型</h3><h4 id=\"优化单词提取\"><a href=\"#优化单词提取\" class=\"headerlink\" title=\"优化单词提取\"></a>优化单词提取</h4><p>在使用TfidfVectorizer特征提取时候，使用正则表达式，默认的正则表达式是<code>u&#39;(?u)\\b\\w\\w+\\b&#39;</code>，使用新的正则表达式<code>ur&quot;\\b[a-z0-9_\\-\\.]+[a-z][a-z0-9_\\-\\.]+\\b&quot;</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nbc_4 = Pipeline([</span><br><span class=\"line\">    (<span class=\"string\">'vect'</span>, TfidfVectorizer(</span><br><span class=\"line\">                token_pattern=<span class=\"string\">ur\"\\b[a-z0-9_\\-\\.]+[a-z][a-z0-9_\\-\\.]+\\b\"</span>,)</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    (<span class=\"string\">'clf'</span>, MultinomialNB()),</span><br><span class=\"line\">])</span><br><span class=\"line\">evaluate_cross_validation(nbc_4, X_train, y_train, <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>分数是：Mean score: 0.861 (+/-0.004) ，结果好了一点</p>\n<h4 id=\"排除停止词\"><a href=\"#排除停止词\" class=\"headerlink\" title=\"排除停止词\"></a>排除停止词</h4><p>TfidfVectorizer的一个参数stop_words，这个参数指定的词将被省略不计入到标记词的列表中，这里使用鼎鼎有名的NLTK语料库。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> nltk</span><br><span class=\"line\"><span class=\"comment\"># nltk.download()</span></span><br><span class=\"line\">stopwords = nltk.corpus.stopwords.words(<span class=\"string\">'english'</span>)</span><br><span class=\"line\">nbc_5 = Pipeline([</span><br><span class=\"line\">   (<span class=\"string\">'vect'</span>, TfidfVectorizer(</span><br><span class=\"line\">               stop_words=stop_words,</span><br><span class=\"line\">               token_pattern=<span class=\"string\">ur\"\\b[a-z0-9_\\-\\.]+[a-z][a-z0-9_\\-\\.]+\\b\"</span>,    </span><br><span class=\"line\">   )),</span><br><span class=\"line\">   (<span class=\"string\">'clf'</span>, MultinomialNB()),</span><br><span class=\"line\">])</span><br><span class=\"line\">evaluate_cross_validation(nbc_5, X_train, Y_train, <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>分数是：Mean score: 0.879 (+/-0.003)，结果又提高了</p>\n<h4 id=\"调整贝叶斯分类器的alpha参数\"><a href=\"#调整贝叶斯分类器的alpha参数\" class=\"headerlink\" title=\"调整贝叶斯分类器的alpha参数\"></a>调整贝叶斯分类器的alpha参数</h4><p>MultinomialNB有一个alpha参数，该参数是一个平滑参数，默认是1.0，我们将其设为0.01</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nbc_6 = Pipeline([</span><br><span class=\"line\">    (<span class=\"string\">'vect'</span>, TfidfVectorizer(</span><br><span class=\"line\">                stop_words=stopwords,</span><br><span class=\"line\">                token_pattern=<span class=\"string\">ur\"\\b[a-z0-9_\\-\\.]+[a-z][a-z0-9_\\-\\.]+\\b\"</span>,         </span><br><span class=\"line\">    )),</span><br><span class=\"line\">    (<span class=\"string\">'clf'</span>, MultinomialNB(alpha=<span class=\"number\">0.01</span>)),</span><br><span class=\"line\">])</span><br><span class=\"line\">evaluate_cross_validation(nbc_6, X_train, y_train, <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>分数为：Mean score: 0.917 (+/-0.002)，哎呦，好像不错哦！不过问题来了，调整参数优化不能靠蒙，如何寻找最好的参数，使得交叉验证的分数最高呢？</p>\n<h4 id=\"使用Grid-Search优化参数\"><a href=\"#使用Grid-Search优化参数\" class=\"headerlink\" title=\"使用Grid Search优化参数\"></a>使用Grid Search优化参数</h4><p>使用GridSearch寻找vectorizer词频统计, tfidftransformer特征变换和MultinomialNB classifier的最优参数</p>\n<p>Scikit-learn上关于<a href=\"http://scikit-learn.org/stable/modules/classes.html#module-sklearn.grid_search\" target=\"_blank\" rel=\"noopener\">GridSearch的介绍</a><br><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/Grid_Search.jpg\" alt=\"Grid Search\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline = Pipeline([</span><br><span class=\"line\">(<span class=\"string\">'vect'</span>,CountVectorizer()),</span><br><span class=\"line\">(<span class=\"string\">'tfidf'</span>,TfidfTransformer()),</span><br><span class=\"line\">(<span class=\"string\">'clf'</span>,MultinomialNB()),</span><br><span class=\"line\">]);</span><br><span class=\"line\">parameters = &#123;</span><br><span class=\"line\">    <span class=\"string\">'vect__max_df'</span>: (<span class=\"number\">0.5</span>, <span class=\"number\">0.75</span>),</span><br><span class=\"line\">    <span class=\"string\">'vect__max_features'</span>: (<span class=\"keyword\">None</span>, <span class=\"number\">5000</span>, <span class=\"number\">10000</span>),</span><br><span class=\"line\">    <span class=\"string\">'tfidf__use_idf'</span>: (<span class=\"keyword\">True</span>, <span class=\"keyword\">False</span>),</span><br><span class=\"line\">    <span class=\"string\">'clf__alpha'</span>: (<span class=\"number\">1</span>, <span class=\"number\">0.1</span>, <span class=\"number\">0.01</span>, <span class=\"number\">0.001</span>, <span class=\"number\">0.0001</span>),</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">grid_search = GridSearchCV(pipeline, parameters, n_jobs=<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> time</span><br><span class=\"line\">t0 = time()</span><br><span class=\"line\">grid_search.fit(X_train, y_train)</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"done in %0.3fs\"</span> % (time() - t0)</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"Best score: %0.3f\"</span> % grid_search.best_score_</span><br></pre></td></tr></table></figure>\n<h4 id=\"输出最优参数\"><a href=\"#输出最优参数\" class=\"headerlink\" title=\"输出最优参数\"></a>输出最优参数</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> metrics</span><br><span class=\"line\">best_parameters = dict()</span><br><span class=\"line\">best_parameters = grid_search.best_estimator_.get_params()</span><br><span class=\"line\"><span class=\"keyword\">for</span> param_name <span class=\"keyword\">in</span> sorted(parameters.keys()):</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"\\t%s: %r\"</span> % (param_name, best_parameters[param_name])</span><br><span class=\"line\">pipeline.set_params(clf__alpha = <span class=\"number\">1e-05</span>,  </span><br><span class=\"line\">                    tfidf__use_idf = <span class=\"keyword\">True</span>,</span><br><span class=\"line\">                    vect__max_df = <span class=\"number\">0.5</span>,</span><br><span class=\"line\">                    vect__max_features = <span class=\"keyword\">None</span>)</span><br><span class=\"line\">pipeline.fit(X_train, y_train)</span><br><span class=\"line\">pred = pipeline.predict(X_test)</span><br></pre></td></tr></table></figure>\n<p>经过漫长的等待，终于找出了最优参数：</p>\n<p>done in 1578.965s<br>Best score: 0.902</p>\n<p>clf__alpha: 0.01<br>tfidf__use_idf: True<br>vect__max_df: 0.5<br>vect__max_features: None</p>\n<p>在测试集上的准确率为：0.915，分类效果还是不错的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">print</span> np.mean(pred == y_test)</span><br></pre></td></tr></table></figure>\n<h3 id=\"评价分类效果\"><a href=\"#评价分类效果\" class=\"headerlink\" title=\"评价分类效果\"></a>评价分类效果</h3><p>在测试集上测试朴素贝叶斯分类器的分类效果</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> metrics</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"comment\">#print X_test[0], y_test[0]</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">20</span>):</span><br><span class=\"line\">    <span class=\"keyword\">print</span> str(i) + <span class=\"string\">\": \"</span> + news.target_names[i]</span><br><span class=\"line\">predicted = pipeline.fit(X_train, y_train).predict(X_test)</span><br><span class=\"line\"><span class=\"keyword\">print</span> np.mean(predicted == y_test)</span><br><span class=\"line\"><span class=\"keyword\">print</span> metrics.classification_report(y_test, predicted)</span><br></pre></td></tr></table></figure>\n<p>结果是这样的：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>groupname</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>alt.atheism</td>\n</tr>\n<tr>\n<td>1</td>\n<td>comp.graphics</td>\n</tr>\n<tr>\n<td>2</td>\n<td>comp.os.ms-windows.misc</td>\n</tr>\n<tr>\n<td>3</td>\n<td>comp.sys.ibm.pc.hardware</td>\n</tr>\n<tr>\n<td>4</td>\n<td>comp.sys.mac.hardware</td>\n</tr>\n<tr>\n<td>5</td>\n<td>comp.windows.x</td>\n</tr>\n<tr>\n<td>6</td>\n<td>misc.forsale</td>\n</tr>\n<tr>\n<td>7</td>\n<td>rec.autos</td>\n</tr>\n<tr>\n<td>8</td>\n<td>rec.motorcycles</td>\n</tr>\n<tr>\n<td>9</td>\n<td>rec.sport.baseball</td>\n</tr>\n<tr>\n<td>10</td>\n<td>rec.sport.hockey</td>\n</tr>\n<tr>\n<td>11</td>\n<td>sci.crypt</td>\n</tr>\n<tr>\n<td>12</td>\n<td>sci.electronics</td>\n</tr>\n<tr>\n<td>13</td>\n<td>sci.med</td>\n</tr>\n<tr>\n<td>14</td>\n<td>sci.space</td>\n</tr>\n<tr>\n<td>15</td>\n<td>soc.religion.christian</td>\n</tr>\n<tr>\n<td>16</td>\n<td>talk.politics.guns</td>\n</tr>\n<tr>\n<td>17</td>\n<td>talk.politics.mideast</td>\n</tr>\n<tr>\n<td>18</td>\n<td>talk.politics.misc</td>\n</tr>\n<tr>\n<td>19</td>\n<td>talk.religion.misc</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>准确率：0.922811671088</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>precision</th>\n<th>recall</th>\n<th>f1-score</th>\n<th>support </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0.94</td>\n<td>0.87</td>\n<td>0.91</td>\n<td>175</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0.85</td>\n<td>0.87</td>\n<td>0.86</td>\n<td>199</td>\n</tr>\n<tr>\n<td>2</td>\n<td>0.91</td>\n<td>0.84</td>\n<td>0.88</td>\n<td>221</td>\n</tr>\n<tr>\n<td>3</td>\n<td>0.81</td>\n<td>0.87</td>\n<td>0.84</td>\n<td>179</td>\n</tr>\n<tr>\n<td>4</td>\n<td>0.87</td>\n<td>0.92</td>\n<td>0.89</td>\n<td>177</td>\n</tr>\n<tr>\n<td>5</td>\n<td>0.91</td>\n<td>0.92</td>\n<td>0.91</td>\n<td>179</td>\n</tr>\n<tr>\n<td>6</td>\n<td>0.88</td>\n<td>0.79</td>\n<td>0.83</td>\n<td>205</td>\n</tr>\n<tr>\n<td>7</td>\n<td>0.94</td>\n<td>0.95</td>\n<td>0.94</td>\n<td>228</td>\n</tr>\n<tr>\n<td>8</td>\n<td>0.96</td>\n<td>0.98</td>\n<td>0.97</td>\n<td>183</td>\n</tr>\n<tr>\n<td>9</td>\n<td>0.96</td>\n<td>0.95</td>\n<td>0.96</td>\n<td>197</td>\n</tr>\n<tr>\n<td>10</td>\n<td>0.98</td>\n<td>1.00</td>\n<td>0.99</td>\n<td>204</td>\n</tr>\n<tr>\n<td>11</td>\n<td>0.96</td>\n<td>0.98</td>\n<td>0.97</td>\n<td>218</td>\n</tr>\n<tr>\n<td>12</td>\n<td>0.93</td>\n<td>0.92</td>\n<td>0.92</td>\n<td>172</td>\n</tr>\n<tr>\n<td>13</td>\n<td>0.93</td>\n<td>0.95</td>\n<td>0.94</td>\n<td>200</td>\n</tr>\n<tr>\n<td>14</td>\n<td>0.96</td>\n<td>0.96</td>\n<td>0.96</td>\n<td>198</td>\n</tr>\n<tr>\n<td>15</td>\n<td>0.93</td>\n<td>0.97</td>\n<td>0.95</td>\n<td>191</td>\n</tr>\n<tr>\n<td>16</td>\n<td>0.92</td>\n<td>0.97</td>\n<td>0.94</td>\n<td>173</td>\n</tr>\n<tr>\n<td>17</td>\n<td>0.98</td>\n<td>0.99</td>\n<td>0.98</td>\n<td>184</td>\n</tr>\n<tr>\n<td>18</td>\n<td>0.95</td>\n<td>0.92</td>\n<td>0.94</td>\n<td>172</td>\n</tr>\n<tr>\n<td>19</td>\n<td>0.83</td>\n<td>0.78</td>\n<td>0.81</td>\n<td>115</td>\n</tr>\n<tr>\n<td>avg / total</td>\n<td>0.92</td>\n<td>0.92</td>\n<td>0.92</td>\n<td>3770</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><ol>\n<li>JasonDing的 <a href=\"http://www.jianshu.com/p/845b16559431\" target=\"_blank\" rel=\"noopener\">【机器学习实验】使用朴素贝叶斯进行文本的分类</a>；</li>\n<li><a href=\"http://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html#building-a-pipeline\" target=\"_blank\" rel=\"noopener\">Scikit-Learn Totorial</a></li>\n</ol>"},{"layout":"post","title":"配置Octopress支持LaTex数学公式","date":"2015-08-07T16:01:02.000Z","comments":1,"_content":"\nOctopress 默认不支持 LaTex 写数学公式需要更改配置才可以。\n\n## 设置\n需要使用kramdown来支持LaTex写数学公式\n\n<!--more-->\n\n### 用kramdown替换rdiscount\n1. 安装kramdown\n\n\t``` bash\n\t$ sudo gem install kramdown\n\t```\n2. 修改`_config.yml`配置文件，将所有`rdiscount`替换成`kramdown`\n3. 修改`Gemfile`，把`gem 'rdiscount'`换成`gem 'kramdown'`\n\t\n### 添加MathJax配置\n在`/source/_includes/custom/head.html`文件中，添加如下代码：\n\n``` javascript\n<!-- mathjax config similar to math.stackexchange -->\n<script type=\"text/x-mathjax-config\">\nMathJax.Hub.Config({\n  jax: [\"input/TeX\", \"output/HTML-CSS\"],\n  tex2jax: {\n    inlineMath: [ ['$', '$'] ],\n    displayMath: [ ['$$', '$$']],\n    processEscapes: true,\n    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']\n  },\n  messageStyle: \"none\",\n  \"HTML-CSS\": { preferredFont: \"TeX\", availableFonts: [\"STIX\",\"TeX\"] }\n});\n</script>\n<script src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\" type=\"text/javascript\"></script>\n```\n\n### 修复 MathJax 右击页面空白 bug\n修改`~/sass/base/theme.scss`文件，如下代码变为：\n\n``` css\n> div#main {\n     background: $sidebar-bg $noise-bg;\n     border-bottom: 1px solid $page-border-bottom;\n     > div {\n```\n\n## 随之出现的问题，以及解决方法\n将`rdiscount`替换成`kramdown`之后，以前写的博客里面，很多内容都不能正确显示了，并且在`rake generate`时候，会报错，内容大约是：`Error:  Pygments can't parse unknown language: </p>`\n\n原生的语法高亮插件`Pygments`很强大，支持语言也很多，但是这时候报的错误让人一头雾水。\n\n### 找出原因\n报错部分代码在`/plugins/pygments_code.rb`文件中，\n\n``` ruby\ndef self.pygments(code, lang)\n    if defined?(PYGMENTS_CACHE_DIR)\n      path = File.join(PYGMENTS_CACHE_DIR, \"#{lang}-#{Digest::MD5.hexdigest(code)}.html\")\n      if File.exist?(path)\n        highlighted_code = File.read(path)\n      else\n        begin\n          highlighted_code = Pygments.highlight(code, :lexer => lang, :formatter => 'html', :options => {:encoding => 'utf-8', :startinline => true})\n        rescue MentosError\n          raise \"Pygments can't parse unknown language: #{lang}.\"\n        end\n        File.open(path, 'w') {|f| f.print(highlighted_code) }\n      end\n```\n\n修改一下代码，将出问题的代码高亮部分抛出来，\n\n```\nraise \"Pygments can't parse unknown language: #{lang}#{code}.\"\n```\n\nGoogle了一下原因， 原来是因为最新版的`pygments`这个插件对于Markdown的书写要求更严格了：\n\n> 1. Some of my older blog posts did not contain a space between the triple-backtick characters and the name of the language being highlighted. Earlier versions of pygments did not care, but the current version is a stickler.\n2. pygments appears to want a blank line between any triple-backtick line and any other text in the blog post.\n\n好吧，以后写文章要更细心一点了。:)\n\n参考：\n\n- [Octopress中使用Latex写数学公式](http://dreamrunner.org/blog/2014/03/09/octopresszhong-shi-yong-latexxie-shu-xue-gong-shi/)\n- [Pygments Unknown Language](http://www.leexh.com/blog/2014/09/21/pygments-unknown-language/)\n","source":"_posts/2015-08-08-adding-support-for-math-formula.markdown","raw":"---\nlayout: post\ntitle: \"配置Octopress支持LaTex数学公式\"\ndate: 2015-08-08 00:01:02 +0800\ncomments: true\ncategories: [备忘]\ntag: Octopress\n---\n\nOctopress 默认不支持 LaTex 写数学公式需要更改配置才可以。\n\n## 设置\n需要使用kramdown来支持LaTex写数学公式\n\n<!--more-->\n\n### 用kramdown替换rdiscount\n1. 安装kramdown\n\n\t``` bash\n\t$ sudo gem install kramdown\n\t```\n2. 修改`_config.yml`配置文件，将所有`rdiscount`替换成`kramdown`\n3. 修改`Gemfile`，把`gem 'rdiscount'`换成`gem 'kramdown'`\n\t\n### 添加MathJax配置\n在`/source/_includes/custom/head.html`文件中，添加如下代码：\n\n``` javascript\n<!-- mathjax config similar to math.stackexchange -->\n<script type=\"text/x-mathjax-config\">\nMathJax.Hub.Config({\n  jax: [\"input/TeX\", \"output/HTML-CSS\"],\n  tex2jax: {\n    inlineMath: [ ['$', '$'] ],\n    displayMath: [ ['$$', '$$']],\n    processEscapes: true,\n    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']\n  },\n  messageStyle: \"none\",\n  \"HTML-CSS\": { preferredFont: \"TeX\", availableFonts: [\"STIX\",\"TeX\"] }\n});\n</script>\n<script src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\" type=\"text/javascript\"></script>\n```\n\n### 修复 MathJax 右击页面空白 bug\n修改`~/sass/base/theme.scss`文件，如下代码变为：\n\n``` css\n> div#main {\n     background: $sidebar-bg $noise-bg;\n     border-bottom: 1px solid $page-border-bottom;\n     > div {\n```\n\n## 随之出现的问题，以及解决方法\n将`rdiscount`替换成`kramdown`之后，以前写的博客里面，很多内容都不能正确显示了，并且在`rake generate`时候，会报错，内容大约是：`Error:  Pygments can't parse unknown language: </p>`\n\n原生的语法高亮插件`Pygments`很强大，支持语言也很多，但是这时候报的错误让人一头雾水。\n\n### 找出原因\n报错部分代码在`/plugins/pygments_code.rb`文件中，\n\n``` ruby\ndef self.pygments(code, lang)\n    if defined?(PYGMENTS_CACHE_DIR)\n      path = File.join(PYGMENTS_CACHE_DIR, \"#{lang}-#{Digest::MD5.hexdigest(code)}.html\")\n      if File.exist?(path)\n        highlighted_code = File.read(path)\n      else\n        begin\n          highlighted_code = Pygments.highlight(code, :lexer => lang, :formatter => 'html', :options => {:encoding => 'utf-8', :startinline => true})\n        rescue MentosError\n          raise \"Pygments can't parse unknown language: #{lang}.\"\n        end\n        File.open(path, 'w') {|f| f.print(highlighted_code) }\n      end\n```\n\n修改一下代码，将出问题的代码高亮部分抛出来，\n\n```\nraise \"Pygments can't parse unknown language: #{lang}#{code}.\"\n```\n\nGoogle了一下原因， 原来是因为最新版的`pygments`这个插件对于Markdown的书写要求更严格了：\n\n> 1. Some of my older blog posts did not contain a space between the triple-backtick characters and the name of the language being highlighted. Earlier versions of pygments did not care, but the current version is a stickler.\n2. pygments appears to want a blank line between any triple-backtick line and any other text in the blog post.\n\n好吧，以后写文章要更细心一点了。:)\n\n参考：\n\n- [Octopress中使用Latex写数学公式](http://dreamrunner.org/blog/2014/03/09/octopresszhong-shi-yong-latexxie-shu-xue-gong-shi/)\n- [Pygments Unknown Language](http://www.leexh.com/blog/2014/09/21/pygments-unknown-language/)\n","slug":"2015-08-08-adding-support-for-math-formula","published":1,"updated":"2016-09-20T02:07:00.000Z","photos":[],"link":"","_id":"cjfkkp3nc000rzd68b631dzew","content":"<p>Octopress 默认不支持 LaTex 写数学公式需要更改配置才可以。</p>\n<h2 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h2><p>需要使用kramdown来支持LaTex写数学公式</p>\n<a id=\"more\"></a>\n<h3 id=\"用kramdown替换rdiscount\"><a href=\"#用kramdown替换rdiscount\" class=\"headerlink\" title=\"用kramdown替换rdiscount\"></a>用kramdown替换rdiscount</h3><ol>\n<li><p>安装kramdown</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo gem install kramdown</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改<code>_config.yml</code>配置文件，将所有<code>rdiscount</code>替换成<code>kramdown</code></p>\n</li>\n<li>修改<code>Gemfile</code>，把<code>gem &#39;rdiscount&#39;</code>换成<code>gem &#39;kramdown&#39;</code></li>\n</ol>\n<h3 id=\"添加MathJax配置\"><a href=\"#添加MathJax配置\" class=\"headerlink\" title=\"添加MathJax配置\"></a>添加MathJax配置</h3><p>在<code>/source/_includes/custom/head.html</code>文件中，添加如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- mathjax config similar to math.stackexchange --&gt;</span><br><span class=\"line\">&lt;script type=<span class=\"string\">\"text/x-mathjax-config\"</span>&gt;</span><br><span class=\"line\">MathJax.Hub.Config(&#123;</span><br><span class=\"line\">  jax: [<span class=\"string\">\"input/TeX\"</span>, <span class=\"string\">\"output/HTML-CSS\"</span>],</span><br><span class=\"line\">  tex2jax: &#123;</span><br><span class=\"line\">    inlineMath: [ [<span class=\"string\">'$'</span>, <span class=\"string\">'$'</span>] ],</span><br><span class=\"line\">    displayMath: [ [<span class=\"string\">'$$'</span>, <span class=\"string\">'$$'</span>]],</span><br><span class=\"line\">    processEscapes: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    skipTags: [<span class=\"string\">'script'</span>, <span class=\"string\">'noscript'</span>, <span class=\"string\">'style'</span>, <span class=\"string\">'textarea'</span>, <span class=\"string\">'pre'</span>, <span class=\"string\">'code'</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  messageStyle: <span class=\"string\">\"none\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"HTML-CSS\"</span>: &#123; <span class=\"attr\">preferredFont</span>: <span class=\"string\">\"TeX\"</span>, <span class=\"attr\">availableFonts</span>: [<span class=\"string\">\"STIX\"</span>,<span class=\"string\">\"TeX\"</span>] &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script src=\"https:/</span><span class=\"regexp\">/cdn.mathjax.org/m</span>athjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML<span class=\"string\">\" type=\"</span>text/javascript<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"修复-MathJax-右击页面空白-bug\"><a href=\"#修复-MathJax-右击页面空白-bug\" class=\"headerlink\" title=\"修复 MathJax 右击页面空白 bug\"></a>修复 MathJax 右击页面空白 bug</h3><p>修改<code>~/sass/base/theme.scss</code>文件，如下代码变为：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"selector-tag\">div</span><span class=\"selector-id\">#main</span> &#123;</span><br><span class=\"line\">     <span class=\"attribute\">background</span>: $sidebar-bg $noise-bg;</span><br><span class=\"line\">     <span class=\"attribute\">border-bottom</span>: <span class=\"number\">1px</span> solid $page-border-bottom;</span><br><span class=\"line\">     &gt; div &#123;</span><br></pre></td></tr></table></figure>\n<h2 id=\"随之出现的问题，以及解决方法\"><a href=\"#随之出现的问题，以及解决方法\" class=\"headerlink\" title=\"随之出现的问题，以及解决方法\"></a>随之出现的问题，以及解决方法</h2><p>将<code>rdiscount</code>替换成<code>kramdown</code>之后，以前写的博客里面，很多内容都不能正确显示了，并且在<code>rake generate</code>时候，会报错，内容大约是：<code>Error:  Pygments can&#39;t parse unknown language: &lt;/p&gt;</code></p>\n<p>原生的语法高亮插件<code>Pygments</code>很强大，支持语言也很多，但是这时候报的错误让人一头雾水。</p>\n<h3 id=\"找出原因\"><a href=\"#找出原因\" class=\"headerlink\" title=\"找出原因\"></a>找出原因</h3><p>报错部分代码在<code>/plugins/pygments_code.rb</code>文件中，</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">self</span>.<span class=\"title\">pygments</span><span class=\"params\">(code, lang)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">defined</span>?(PYGMENTS_CACHE_DIR)</span><br><span class=\"line\">      path = File.join(PYGMENTS_CACHE_DIR, <span class=\"string\">\"<span class=\"subst\">#&#123;lang&#125;</span>-<span class=\"subst\">#&#123;Digest::MD5.hexdigest(code)&#125;</span>.html\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> File.exist?(path)</span><br><span class=\"line\">        highlighted_code = File.read(path)</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">begin</span></span><br><span class=\"line\">          highlighted_code = Pygments.highlight(code, <span class=\"symbol\">:lexer</span> =&gt; lang, <span class=\"symbol\">:formatter</span> =&gt; <span class=\"string\">'html'</span>, <span class=\"symbol\">:options</span> =&gt; &#123;<span class=\"symbol\">:encoding</span> =&gt; <span class=\"string\">'utf-8'</span>, <span class=\"symbol\">:startinline</span> =&gt; <span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">        <span class=\"keyword\">rescue</span> MentosError</span><br><span class=\"line\">          raise <span class=\"string\">\"Pygments can't parse unknown language: <span class=\"subst\">#&#123;lang&#125;</span>.\"</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        File.open(path, <span class=\"string\">'w'</span>) &#123;<span class=\"params\">|f|</span> f.print(highlighted_code) &#125;</span><br><span class=\"line\">      <span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>修改一下代码，将出问题的代码高亮部分抛出来，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">raise &quot;Pygments can&apos;t parse unknown language: #&#123;lang&#125;#&#123;code&#125;.&quot;</span><br></pre></td></tr></table></figure>\n<p>Google了一下原因， 原来是因为最新版的<code>pygments</code>这个插件对于Markdown的书写要求更严格了：</p>\n<blockquote>\n<ol>\n<li>Some of my older blog posts did not contain a space between the triple-backtick characters and the name of the language being highlighted. Earlier versions of pygments did not care, but the current version is a stickler.</li>\n<li>pygments appears to want a blank line between any triple-backtick line and any other text in the blog post.</li>\n</ol>\n</blockquote>\n<p>好吧，以后写文章要更细心一点了。:)</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://dreamrunner.org/blog/2014/03/09/octopresszhong-shi-yong-latexxie-shu-xue-gong-shi/\" target=\"_blank\" rel=\"noopener\">Octopress中使用Latex写数学公式</a></li>\n<li><a href=\"http://www.leexh.com/blog/2014/09/21/pygments-unknown-language/\" target=\"_blank\" rel=\"noopener\">Pygments Unknown Language</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Octopress 默认不支持 LaTex 写数学公式需要更改配置才可以。</p>\n<h2 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h2><p>需要使用kramdown来支持LaTex写数学公式</p>","more":"<h3 id=\"用kramdown替换rdiscount\"><a href=\"#用kramdown替换rdiscount\" class=\"headerlink\" title=\"用kramdown替换rdiscount\"></a>用kramdown替换rdiscount</h3><ol>\n<li><p>安装kramdown</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo gem install kramdown</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改<code>_config.yml</code>配置文件，将所有<code>rdiscount</code>替换成<code>kramdown</code></p>\n</li>\n<li>修改<code>Gemfile</code>，把<code>gem &#39;rdiscount&#39;</code>换成<code>gem &#39;kramdown&#39;</code></li>\n</ol>\n<h3 id=\"添加MathJax配置\"><a href=\"#添加MathJax配置\" class=\"headerlink\" title=\"添加MathJax配置\"></a>添加MathJax配置</h3><p>在<code>/source/_includes/custom/head.html</code>文件中，添加如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- mathjax config similar to math.stackexchange --&gt;</span><br><span class=\"line\">&lt;script type=<span class=\"string\">\"text/x-mathjax-config\"</span>&gt;</span><br><span class=\"line\">MathJax.Hub.Config(&#123;</span><br><span class=\"line\">  jax: [<span class=\"string\">\"input/TeX\"</span>, <span class=\"string\">\"output/HTML-CSS\"</span>],</span><br><span class=\"line\">  tex2jax: &#123;</span><br><span class=\"line\">    inlineMath: [ [<span class=\"string\">'$'</span>, <span class=\"string\">'$'</span>] ],</span><br><span class=\"line\">    displayMath: [ [<span class=\"string\">'$$'</span>, <span class=\"string\">'$$'</span>]],</span><br><span class=\"line\">    processEscapes: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    skipTags: [<span class=\"string\">'script'</span>, <span class=\"string\">'noscript'</span>, <span class=\"string\">'style'</span>, <span class=\"string\">'textarea'</span>, <span class=\"string\">'pre'</span>, <span class=\"string\">'code'</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  messageStyle: <span class=\"string\">\"none\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"HTML-CSS\"</span>: &#123; <span class=\"attr\">preferredFont</span>: <span class=\"string\">\"TeX\"</span>, <span class=\"attr\">availableFonts</span>: [<span class=\"string\">\"STIX\"</span>,<span class=\"string\">\"TeX\"</span>] &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script src=\"https:/</span><span class=\"regexp\">/cdn.mathjax.org/m</span>athjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML<span class=\"string\">\" type=\"</span>text/javascript<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"修复-MathJax-右击页面空白-bug\"><a href=\"#修复-MathJax-右击页面空白-bug\" class=\"headerlink\" title=\"修复 MathJax 右击页面空白 bug\"></a>修复 MathJax 右击页面空白 bug</h3><p>修改<code>~/sass/base/theme.scss</code>文件，如下代码变为：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"selector-tag\">div</span><span class=\"selector-id\">#main</span> &#123;</span><br><span class=\"line\">     <span class=\"attribute\">background</span>: $sidebar-bg $noise-bg;</span><br><span class=\"line\">     <span class=\"attribute\">border-bottom</span>: <span class=\"number\">1px</span> solid $page-border-bottom;</span><br><span class=\"line\">     &gt; div &#123;</span><br></pre></td></tr></table></figure>\n<h2 id=\"随之出现的问题，以及解决方法\"><a href=\"#随之出现的问题，以及解决方法\" class=\"headerlink\" title=\"随之出现的问题，以及解决方法\"></a>随之出现的问题，以及解决方法</h2><p>将<code>rdiscount</code>替换成<code>kramdown</code>之后，以前写的博客里面，很多内容都不能正确显示了，并且在<code>rake generate</code>时候，会报错，内容大约是：<code>Error:  Pygments can&#39;t parse unknown language: &lt;/p&gt;</code></p>\n<p>原生的语法高亮插件<code>Pygments</code>很强大，支持语言也很多，但是这时候报的错误让人一头雾水。</p>\n<h3 id=\"找出原因\"><a href=\"#找出原因\" class=\"headerlink\" title=\"找出原因\"></a>找出原因</h3><p>报错部分代码在<code>/plugins/pygments_code.rb</code>文件中，</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">self</span>.<span class=\"title\">pygments</span><span class=\"params\">(code, lang)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">defined</span>?(PYGMENTS_CACHE_DIR)</span><br><span class=\"line\">      path = File.join(PYGMENTS_CACHE_DIR, <span class=\"string\">\"<span class=\"subst\">#&#123;lang&#125;</span>-<span class=\"subst\">#&#123;Digest::MD5.hexdigest(code)&#125;</span>.html\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> File.exist?(path)</span><br><span class=\"line\">        highlighted_code = File.read(path)</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">begin</span></span><br><span class=\"line\">          highlighted_code = Pygments.highlight(code, <span class=\"symbol\">:lexer</span> =&gt; lang, <span class=\"symbol\">:formatter</span> =&gt; <span class=\"string\">'html'</span>, <span class=\"symbol\">:options</span> =&gt; &#123;<span class=\"symbol\">:encoding</span> =&gt; <span class=\"string\">'utf-8'</span>, <span class=\"symbol\">:startinline</span> =&gt; <span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">        <span class=\"keyword\">rescue</span> MentosError</span><br><span class=\"line\">          raise <span class=\"string\">\"Pygments can't parse unknown language: <span class=\"subst\">#&#123;lang&#125;</span>.\"</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        File.open(path, <span class=\"string\">'w'</span>) &#123;<span class=\"params\">|f|</span> f.print(highlighted_code) &#125;</span><br><span class=\"line\">      <span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>修改一下代码，将出问题的代码高亮部分抛出来，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">raise &quot;Pygments can&apos;t parse unknown language: #&#123;lang&#125;#&#123;code&#125;.&quot;</span><br></pre></td></tr></table></figure>\n<p>Google了一下原因， 原来是因为最新版的<code>pygments</code>这个插件对于Markdown的书写要求更严格了：</p>\n<blockquote>\n<ol>\n<li>Some of my older blog posts did not contain a space between the triple-backtick characters and the name of the language being highlighted. Earlier versions of pygments did not care, but the current version is a stickler.</li>\n<li>pygments appears to want a blank line between any triple-backtick line and any other text in the blog post.</li>\n</ol>\n</blockquote>\n<p>好吧，以后写文章要更细心一点了。:)</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://dreamrunner.org/blog/2014/03/09/octopresszhong-shi-yong-latexxie-shu-xue-gong-shi/\" target=\"_blank\" rel=\"noopener\">Octopress中使用Latex写数学公式</a></li>\n<li><a href=\"http://www.leexh.com/blog/2014/09/21/pygments-unknown-language/\" target=\"_blank\" rel=\"noopener\">Pygments Unknown Language</a></li>\n</ul>"},{"layout":"post","title":"朴素贝叶斯算法的一些细节和小技巧","date":"2015-08-11T11:57:39.000Z","comments":1,"_content":"\n\n### 某特征属性的条件概率为0\n当特征属性为离散值时，只要统计训练样本中各个划分在每个类别中出现的频率即可用来估计P(a|y)，若某一特征值的概率为0则会使整个概率乘积变为0，这会让分类器的准确性大幅下降。\n\n这时候使用Laplace校准：即假定训练数据库很大，以至于对每个计数加1造成的估计概率的变化忽略不计。\n\n### 连续分布假定值服从高斯分布(正态分布)\n当特征属性为连续值时，通常假定其值服从高斯分布，即：\n\n$$p\\left( x\\_{i}|y\\right) =\\dfrac {1} {\\sqrt {2\\pi \\sigma\\_{y}^{2}}}exp\\left( -\\dfrac {\\left( x\\_{i}-\\mu\\_{y}\\right) ^{2}} {2\\sigma\\_{y}^{2}}\\right)$$\n\n所以，对于连续分布的样本特征的训练就是计算其均值和方差\n\n### 小数连续相乘\n实际项目中，概率P往往是值很小的小数，连续的微小小数相乘容易造成下溢出使乘积为0或者得不到正确答案。一种解决办法就是对乘积取自然对数，将连乘变为连加，$\\ln \\left( AB\\right) =\\ln A+\\ln B$。采用自然对数处理不会带来任何损失，可以避免下溢出或者浮点数舍入导致的错误。\n\n\n<!--more-->\n","source":"_posts/2015-08-11-some-note-about-naive-bayes.markdown","raw":"---\nlayout: post\ntitle: \"朴素贝叶斯算法的一些细节和小技巧\"\ndate: 2015-08-11 19:57:39 +0800\ncomments: true\ncategories: [算法]\ntag: [Algorithm, Machine Learning, Bayes]\n---\n\n\n### 某特征属性的条件概率为0\n当特征属性为离散值时，只要统计训练样本中各个划分在每个类别中出现的频率即可用来估计P(a|y)，若某一特征值的概率为0则会使整个概率乘积变为0，这会让分类器的准确性大幅下降。\n\n这时候使用Laplace校准：即假定训练数据库很大，以至于对每个计数加1造成的估计概率的变化忽略不计。\n\n### 连续分布假定值服从高斯分布(正态分布)\n当特征属性为连续值时，通常假定其值服从高斯分布，即：\n\n$$p\\left( x\\_{i}|y\\right) =\\dfrac {1} {\\sqrt {2\\pi \\sigma\\_{y}^{2}}}exp\\left( -\\dfrac {\\left( x\\_{i}-\\mu\\_{y}\\right) ^{2}} {2\\sigma\\_{y}^{2}}\\right)$$\n\n所以，对于连续分布的样本特征的训练就是计算其均值和方差\n\n### 小数连续相乘\n实际项目中，概率P往往是值很小的小数，连续的微小小数相乘容易造成下溢出使乘积为0或者得不到正确答案。一种解决办法就是对乘积取自然对数，将连乘变为连加，$\\ln \\left( AB\\right) =\\ln A+\\ln B$。采用自然对数处理不会带来任何损失，可以避免下溢出或者浮点数舍入导致的错误。\n\n\n<!--more-->\n","slug":"2015-08-11-some-note-about-naive-bayes","published":1,"updated":"2016-09-20T02:07:00.000Z","photos":[],"link":"","_id":"cjfkkp3ne000vzd68bmchlqpm","content":"<h3 id=\"某特征属性的条件概率为0\"><a href=\"#某特征属性的条件概率为0\" class=\"headerlink\" title=\"某特征属性的条件概率为0\"></a>某特征属性的条件概率为0</h3><p>当特征属性为离散值时，只要统计训练样本中各个划分在每个类别中出现的频率即可用来估计P(a|y)，若某一特征值的概率为0则会使整个概率乘积变为0，这会让分类器的准确性大幅下降。</p>\n<p>这时候使用Laplace校准：即假定训练数据库很大，以至于对每个计数加1造成的估计概率的变化忽略不计。</p>\n<h3 id=\"连续分布假定值服从高斯分布-正态分布\"><a href=\"#连续分布假定值服从高斯分布-正态分布\" class=\"headerlink\" title=\"连续分布假定值服从高斯分布(正态分布)\"></a>连续分布假定值服从高斯分布(正态分布)</h3><p>当特征属性为连续值时，通常假定其值服从高斯分布，即：</p>\n<p>$$p\\left( x_{i}|y\\right) =\\dfrac {1} {\\sqrt {2\\pi \\sigma_{y}^{2}}}exp\\left( -\\dfrac {\\left( x_{i}-\\mu_{y}\\right) ^{2}} {2\\sigma_{y}^{2}}\\right)$$</p>\n<p>所以，对于连续分布的样本特征的训练就是计算其均值和方差</p>\n<h3 id=\"小数连续相乘\"><a href=\"#小数连续相乘\" class=\"headerlink\" title=\"小数连续相乘\"></a>小数连续相乘</h3><p>实际项目中，概率P往往是值很小的小数，连续的微小小数相乘容易造成下溢出使乘积为0或者得不到正确答案。一种解决办法就是对乘积取自然对数，将连乘变为连加，$\\ln \\left( AB\\right) =\\ln A+\\ln B$。采用自然对数处理不会带来任何损失，可以避免下溢出或者浮点数舍入导致的错误。</p>\n<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"<h3 id=\"某特征属性的条件概率为0\"><a href=\"#某特征属性的条件概率为0\" class=\"headerlink\" title=\"某特征属性的条件概率为0\"></a>某特征属性的条件概率为0</h3><p>当特征属性为离散值时，只要统计训练样本中各个划分在每个类别中出现的频率即可用来估计P(a|y)，若某一特征值的概率为0则会使整个概率乘积变为0，这会让分类器的准确性大幅下降。</p>\n<p>这时候使用Laplace校准：即假定训练数据库很大，以至于对每个计数加1造成的估计概率的变化忽略不计。</p>\n<h3 id=\"连续分布假定值服从高斯分布-正态分布\"><a href=\"#连续分布假定值服从高斯分布-正态分布\" class=\"headerlink\" title=\"连续分布假定值服从高斯分布(正态分布)\"></a>连续分布假定值服从高斯分布(正态分布)</h3><p>当特征属性为连续值时，通常假定其值服从高斯分布，即：</p>\n<p>$$p\\left( x_{i}|y\\right) =\\dfrac {1} {\\sqrt {2\\pi \\sigma_{y}^{2}}}exp\\left( -\\dfrac {\\left( x_{i}-\\mu_{y}\\right) ^{2}} {2\\sigma_{y}^{2}}\\right)$$</p>\n<p>所以，对于连续分布的样本特征的训练就是计算其均值和方差</p>\n<h3 id=\"小数连续相乘\"><a href=\"#小数连续相乘\" class=\"headerlink\" title=\"小数连续相乘\"></a>小数连续相乘</h3><p>实际项目中，概率P往往是值很小的小数，连续的微小小数相乘容易造成下溢出使乘积为0或者得不到正确答案。一种解决办法就是对乘积取自然对数，将连乘变为连加，$\\ln \\left( AB\\right) =\\ln A+\\ln B$。采用自然对数处理不会带来任何损失，可以避免下溢出或者浮点数舍入导致的错误。</p>","more":""},{"layout":"post","title":"Logistic Regression原理以及应用","date":"2015-08-19T09:54:09.000Z","comments":1,"_content":"\n逻辑回归算法是一个很有用的分类算法，这篇文章总结一下逻辑回归算法的相关内容。数据使用scikit-learn自带的`Iris`数据集。\n\n## Iris dataset\nIris数据集，里面包含3种鸢尾花品种的4各属性，这个分类问题可以描述成使用鸢尾花的属性，来判断这个品种倒地属于哪个品种类别。为了简单，这里使用两个类别：`Setosa`和`Versicolor`，两个属性：`Length`和`Width`\n\n```python\nfrom sklearn import datasets\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\ndata = datasets.load_iris()\nX = data.data[:100, : 2]\ny = data.target[:100]\nsetosa = plt.scatter(X[:50, 0], X[:50, 1], c='b')\nversicolor = plt.scatter(X[50:, 0], X[50:, 1], c='r')\nplt.xlabel(\"Sepal Length\")\nplt.ylabel(\"Seqal Width\")\nplt.legend((setosa, versicolor), (\"Setosa\", \"Versicolor\"))\n```\n\n![Iris dataset](http://7xkfga.com1.z0.glb.clouddn.com/iris_data.JPG)\n\n可以看出来，两个品种可以被区分开，接下来要使用一种算法，让计算机把这两个类别区分开。可以想象，可以使用线性回归，也就是画一条线来把两个类别分开，但是这种分割很粗暴，准确性也不高，所以接下来要使用的算法要使用概率的方法区分两个类别，比如，算法返回0.9，那么代表属于类别A的概率是90%\n\n<!--more-->\n\n## 逻辑函数 Logistic Function\n这里使用的逻辑函数正好符合概率的定义，即函数返回值在[0, 1]区间内，函数又被称作sigmod函数：\n\n$$y=\\dfrac {1} {1+e^{-x}}$$\n\n```python\nx_values = np.linspace(-5, 5, 100)\ny_values = [1 / (1 + np.exp(-x)) for x in x_values]\nplt.plot(x_values, y_values)\nplt.xlabel(\"X\")\nplt.ylabel(\"y\")\n```\n\n![sigmod function](http://7xkfga.com1.z0.glb.clouddn.com/sigmod.png)\n\n### 将逻辑函数应用到数据上\n现在，数据集有两个属性`Sepal Length`和`Sepal Width`，这两个属性可以写到如下的等式中：\n\n$$x=\\theta\\_{0}+\\theta\\_{1}SW +\\theta\\_{2}SL$$\n\nSL代表`Sepal Length`这个特征，SW代表`Sepal Width`这个特征，假如神告诉我们 $\\theta\\_{0} = 1$，$\\theta\\_{1} = 2$，$\\theta\\_{2} = 4$，那么，长度为5并且宽度为3.5的这个品种，$x=1+\\left\\( 2\\ast 3.5\\right) +\\left( 4\\ast 5\\right) = 28 $，代入逻辑函数：\n\n$$\\dfrac\\{1} {1+e^{-28}}=0.99$$\n\n说明这个品种数据Setosa的概率为99%。那么，告诉我们 $\\theta$的取值的神是谁呢？\n\n## 算法学习\n\n### Cost Function\n在学习线性回归时候，当时使用的是`Square Error`作为损失函数，那么在逻辑回归中能不能也用这种损失函数呢？当然可以，不过在逻辑回归算法中，使用`Square Error`作为损失函数是非凸函数，也就是说有多个局部最小值，不能取到全局最小值，所以这里应该使用其他的损失函数。\n\n想象一下，我们假设求出来一个属性的结果值是1，也就是预测为`Setosa`类别，那么预测为`Versicolor`类别的概率为0，在全部的数据集上，假设数据都是独立分布的，那么我们的目标就是：把每个单独类别的概率结果值累乘起来，并求最大值：\n\n$$\\prod\\_{Setosa}\\frac{1}{1 + e^{-(\\theta\\_{0} + \\theta{1}SW + \\theta\\_{2}SL)}}\\prod\\_{Versicolor}1 - \\frac{1}{1 + e^{-(\\theta\\_{0} + \\theta{1}SW + \\theta_{2}SL)}}$$\n\n参考上面定义的逻辑函数：\n\n$$h(x) = \\frac{1}{1 + e^{-x}}$$\n\n那么我们的目标函数就是求下面函数的最大值：\n\n$$\\prod\\_{Setosa}h(x)\\prod_{Versicolor}1 - h(x)$$\n\n解释一下，加入类别分别为0和1，回归结果$h\\_\\theta(x)$表示样本属于类别1的概率，那么样本属于类别0的概率为 $1-h_\\theta(x)$，则有\n\n$$p(y=1|x,\\theta)=h_\\theta(x)$$\n\n$$p(y=0|x,\\theta)=1-h_\\theta(x)$$\n\n可以写为下面公式，含义为：某一个观测值的概率\n\n$$p(y|x,\\theta)=h\\_\\theta(x)^y(1-h_\\theta(x))^{1-y}$$\n\n由于各个观测值相互独立，那么联合分布可以表示成各个观测值概率的乘积：\n\n$$L(\\theta)=\\prod\\_{i=1}^m{h\\_\\theta(x^{(i)})^{y^{(i)}}(1-h_\\theta(x^{(i)}))^{1-y^{(i)}}}$$\n\n上式称为n个观测的似然函数。我们的目标是能够求出使这一似然函数的值最大的参数估计。对上面的似然函数取对数\n\n$$\\begin{aligned} l(\\theta)=log(L(\\theta))=log(\\prod\\_{i=1}^m{h\\_\\theta(x^{(i)})^{y^{(i)}}(1-h\\_\\theta(x^{(i)}))^{1-y^{(i)}}})\n=\\sum\\_{i=1}^m{(y^{(i)}log(h\\_\\theta(x^{(i)}))+(1-y^{(i)})log(1-h\\_\\theta(x^{(i)})))} \\end{aligned}$$\n\n最大化似然函数，使用梯度下降法，求出$\\theta$值，稍微变换一下，那就是求下面式子的最小值\n\n$$J\\left( \\theta \\right) = -\\sum_{i=1}^{m}y^{(i)}log(h(x^{(i)})) + (1-y^{(i)})log(1-h(x^{(i)}))$$\n\n### 梯度下降算法\n\n梯度下降算法为：\n\n$$\\begin{aligned} \\theta_j:=\\theta_j-\\alpha\\frac{\\partial J(\\theta)}{\\partial\\theta_j} \\end{aligned}$$\n\n### 梯度下降算法的推导\n对$\\theta$参数求导，可得\n\n$$\\begin{aligned} \\frac{\\partial logh\\_\\theta(x^{(i)})}{\\partial\\theta_j}&=\\frac{\\partial log(g(\\theta^T x^{(i)}))}{\\partial\\theta\\_j}\\\\&=\\frac{1}{g(\\theta^T x^{(i)})}{ g(\\theta^T x^{(i)})) (1-g(\\theta^T x^{(i)}))x\\_j^{(i)}}\\\\&=(1- g(\\theta^T x^{(i)}))) x\\_j^{(i)}\\\\&=(1-h\\_\\theta(x^{(i)}))x_j^{(i)} \\end{aligned}$$\n\n同理可得，\n\n$$\\begin{aligned} \\frac{\\partial(1-logh\\_\\theta(x^{(i)}))}{\\partial\\theta\\_j}=-h\\_\\theta(x^{(i)})x_j^{(i)} \\end{aligned}$$\n\n所以\n\n$$\\begin{aligned} \\frac{\\partial l(\\theta)}{\\partial\\theta\\_j}&=\\sum\\_{i=1}^m{(y^{(i)}(1-h\\_\\theta(x^{(i)}))x\\_j^{(i)}+(1-y^{(i)})(-h\\_\\theta(x^{(i)})x\\_j^{(i)}))}\\\\&=\\sum\\_{i=1}^m{(y^{(i)}-h\\_\\theta(x^{(i)}))x\\_j^{(i)}} \\end{aligned}$$\n\n那么，最终梯度下降算法为：\n\n$$\\begin{aligned} \\theta\\_j:=\\theta\\_j-\\alpha\\sum\\_{i=1}^m{(y^{(i)}-h\\_\\theta(x^{(i)}))x\\_j^{(i)}} \\end{aligned}$$\n\n注：虽然得到的梯度下降算法表面上看去与线性回归一样，但是这里 的 $h\\_{\\theta }\\left( x\\right) =\\dfrac {1} {1+e^{-\\theta ^{T}x}}$ 与线性回归中不同。\n\n### 梯度下降算法的技巧\n\n- 变量缩放 (Normalize Variable)\n- $\\alpha$选择\n- 设定收敛条件\n\n## 实现Logigtic Regrssion算法\n以上，介绍了Logistic Regression算法的详细推导过程，下面就用Python来实现这个算法\n\n首先是逻辑回归函数，也就是sigmoid函数\n\n```python\ndef sigmoid(theta, x):\n    return 1.0 / (1 + np.exp(-x.dot(theta)))\n```\n\n然后使用梯度下降算法估算$\\theta$值，首先是gradient值\n\n$$(y^{(i)}-h_\\theta(x^{(i)}))x_j^{(i)}$$\n\n```python\ndef gradient(theta, x, y):\n    first_part = sigmoid(theta, x) - np.squeeze(y)\n    return first_part.T.dot(x)\n```\n\n损失函数cost function\n\n$$-\\sum_{i=1}^{m}y^{(i)}log(h(x^{(i)})) + (1-y^{(i)})log(1-h(x^{(i)}))$$\n\n```python\ndef cost_function(theta, x, y):\n    h_theta = sigmoid(theta, x)\n    y = np.squeeze(y)\n    first = y * np.log(h_theta)\n    second = (1 - y) * np.log(1 - h_theta)\n    return np.mean(-first - second)\n```\n\n梯度下降算法，这种梯度下降算法也叫批量梯度下降(Batch gradient descent)\n\n$$\\begin{aligned} \\theta_j:=\\theta\\_j-\\alpha\\sum\\_{i=1}^m{(y^{(i)}-h\\_\\theta(x^{(i)}))x\\_j^{(i)}} \\end{aligned}$$\n\n```python\ndef gradient_descent(theta, X, y, alpha=0.001, converge):\n    X = (X - np.mean(X, axis=0)) / np.std(X, axis=0)\n    cost_iter = []\n    cost = cost_function(theta, X, y)\n    cost_iter.append([0, cost])\n    i = 1\n    while(change_cost > converge):\n        theta = theta - (alpha * gradient(theta, X, y))\n        cost = cost_function(theta, X, y)\n        cost_iter.append([i, cost])\n        i += 1\n    return theta, np.array(cost_iter)\n```\n\n预测方法\n\n```python\ndef predict_function(theta, x):\n    x = (x - np.mean(x, axis=0)) / np.std(x, axis=0)\n    pred_prob = sigmoid(theta, x)\n    pred_value = np.where(pred_prob >= 0.5, 1, 0)\n    return pred_value\n```\n\n### 损失函数变化趋势\n画出cost function的变化趋势，看看是不是已经收敛了\n\n![cost_trend](http://7xkfga.com1.z0.glb.clouddn.com/cost_trend.png)\n\n看来梯度下降算法已经收敛了。\n\n\n## 使用Scikit-Learn中的Logistic Regression算法\nScikit-Learn库中，已经包含了逻辑回归算法，下面用这个工具集来体验一下这个算法。\n\n```python\nfrom sklearn import linear_model\nmodel = linear_model.LogisticRegression()\nmodel.fit(X, y)\nmodel.predict(X_test)\n```\n\n### 其他优化算法\n\n- BFGS\n- 随机梯度下降 Stochastic gradient descent\n- L-BFGS\n- Conjugate Gradient\n\n","source":"_posts/2015-08-12-logistic-regression-classifier-on-hands.markdown","raw":"---\nlayout: post\ntitle: \"Logistic Regression原理以及应用\"\ndate: 2015-08-19 17:54:09 +0800\ncomments: true\ntag: [Algorithm, Machine Learning, Logistic Regression, Python, Scikit-Learn]\ncategories: [算法, Python]\n---\n\n逻辑回归算法是一个很有用的分类算法，这篇文章总结一下逻辑回归算法的相关内容。数据使用scikit-learn自带的`Iris`数据集。\n\n## Iris dataset\nIris数据集，里面包含3种鸢尾花品种的4各属性，这个分类问题可以描述成使用鸢尾花的属性，来判断这个品种倒地属于哪个品种类别。为了简单，这里使用两个类别：`Setosa`和`Versicolor`，两个属性：`Length`和`Width`\n\n```python\nfrom sklearn import datasets\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\ndata = datasets.load_iris()\nX = data.data[:100, : 2]\ny = data.target[:100]\nsetosa = plt.scatter(X[:50, 0], X[:50, 1], c='b')\nversicolor = plt.scatter(X[50:, 0], X[50:, 1], c='r')\nplt.xlabel(\"Sepal Length\")\nplt.ylabel(\"Seqal Width\")\nplt.legend((setosa, versicolor), (\"Setosa\", \"Versicolor\"))\n```\n\n![Iris dataset](http://7xkfga.com1.z0.glb.clouddn.com/iris_data.JPG)\n\n可以看出来，两个品种可以被区分开，接下来要使用一种算法，让计算机把这两个类别区分开。可以想象，可以使用线性回归，也就是画一条线来把两个类别分开，但是这种分割很粗暴，准确性也不高，所以接下来要使用的算法要使用概率的方法区分两个类别，比如，算法返回0.9，那么代表属于类别A的概率是90%\n\n<!--more-->\n\n## 逻辑函数 Logistic Function\n这里使用的逻辑函数正好符合概率的定义，即函数返回值在[0, 1]区间内，函数又被称作sigmod函数：\n\n$$y=\\dfrac {1} {1+e^{-x}}$$\n\n```python\nx_values = np.linspace(-5, 5, 100)\ny_values = [1 / (1 + np.exp(-x)) for x in x_values]\nplt.plot(x_values, y_values)\nplt.xlabel(\"X\")\nplt.ylabel(\"y\")\n```\n\n![sigmod function](http://7xkfga.com1.z0.glb.clouddn.com/sigmod.png)\n\n### 将逻辑函数应用到数据上\n现在，数据集有两个属性`Sepal Length`和`Sepal Width`，这两个属性可以写到如下的等式中：\n\n$$x=\\theta\\_{0}+\\theta\\_{1}SW +\\theta\\_{2}SL$$\n\nSL代表`Sepal Length`这个特征，SW代表`Sepal Width`这个特征，假如神告诉我们 $\\theta\\_{0} = 1$，$\\theta\\_{1} = 2$，$\\theta\\_{2} = 4$，那么，长度为5并且宽度为3.5的这个品种，$x=1+\\left\\( 2\\ast 3.5\\right) +\\left( 4\\ast 5\\right) = 28 $，代入逻辑函数：\n\n$$\\dfrac\\{1} {1+e^{-28}}=0.99$$\n\n说明这个品种数据Setosa的概率为99%。那么，告诉我们 $\\theta$的取值的神是谁呢？\n\n## 算法学习\n\n### Cost Function\n在学习线性回归时候，当时使用的是`Square Error`作为损失函数，那么在逻辑回归中能不能也用这种损失函数呢？当然可以，不过在逻辑回归算法中，使用`Square Error`作为损失函数是非凸函数，也就是说有多个局部最小值，不能取到全局最小值，所以这里应该使用其他的损失函数。\n\n想象一下，我们假设求出来一个属性的结果值是1，也就是预测为`Setosa`类别，那么预测为`Versicolor`类别的概率为0，在全部的数据集上，假设数据都是独立分布的，那么我们的目标就是：把每个单独类别的概率结果值累乘起来，并求最大值：\n\n$$\\prod\\_{Setosa}\\frac{1}{1 + e^{-(\\theta\\_{0} + \\theta{1}SW + \\theta\\_{2}SL)}}\\prod\\_{Versicolor}1 - \\frac{1}{1 + e^{-(\\theta\\_{0} + \\theta{1}SW + \\theta_{2}SL)}}$$\n\n参考上面定义的逻辑函数：\n\n$$h(x) = \\frac{1}{1 + e^{-x}}$$\n\n那么我们的目标函数就是求下面函数的最大值：\n\n$$\\prod\\_{Setosa}h(x)\\prod_{Versicolor}1 - h(x)$$\n\n解释一下，加入类别分别为0和1，回归结果$h\\_\\theta(x)$表示样本属于类别1的概率，那么样本属于类别0的概率为 $1-h_\\theta(x)$，则有\n\n$$p(y=1|x,\\theta)=h_\\theta(x)$$\n\n$$p(y=0|x,\\theta)=1-h_\\theta(x)$$\n\n可以写为下面公式，含义为：某一个观测值的概率\n\n$$p(y|x,\\theta)=h\\_\\theta(x)^y(1-h_\\theta(x))^{1-y}$$\n\n由于各个观测值相互独立，那么联合分布可以表示成各个观测值概率的乘积：\n\n$$L(\\theta)=\\prod\\_{i=1}^m{h\\_\\theta(x^{(i)})^{y^{(i)}}(1-h_\\theta(x^{(i)}))^{1-y^{(i)}}}$$\n\n上式称为n个观测的似然函数。我们的目标是能够求出使这一似然函数的值最大的参数估计。对上面的似然函数取对数\n\n$$\\begin{aligned} l(\\theta)=log(L(\\theta))=log(\\prod\\_{i=1}^m{h\\_\\theta(x^{(i)})^{y^{(i)}}(1-h\\_\\theta(x^{(i)}))^{1-y^{(i)}}})\n=\\sum\\_{i=1}^m{(y^{(i)}log(h\\_\\theta(x^{(i)}))+(1-y^{(i)})log(1-h\\_\\theta(x^{(i)})))} \\end{aligned}$$\n\n最大化似然函数，使用梯度下降法，求出$\\theta$值，稍微变换一下，那就是求下面式子的最小值\n\n$$J\\left( \\theta \\right) = -\\sum_{i=1}^{m}y^{(i)}log(h(x^{(i)})) + (1-y^{(i)})log(1-h(x^{(i)}))$$\n\n### 梯度下降算法\n\n梯度下降算法为：\n\n$$\\begin{aligned} \\theta_j:=\\theta_j-\\alpha\\frac{\\partial J(\\theta)}{\\partial\\theta_j} \\end{aligned}$$\n\n### 梯度下降算法的推导\n对$\\theta$参数求导，可得\n\n$$\\begin{aligned} \\frac{\\partial logh\\_\\theta(x^{(i)})}{\\partial\\theta_j}&=\\frac{\\partial log(g(\\theta^T x^{(i)}))}{\\partial\\theta\\_j}\\\\&=\\frac{1}{g(\\theta^T x^{(i)})}{ g(\\theta^T x^{(i)})) (1-g(\\theta^T x^{(i)}))x\\_j^{(i)}}\\\\&=(1- g(\\theta^T x^{(i)}))) x\\_j^{(i)}\\\\&=(1-h\\_\\theta(x^{(i)}))x_j^{(i)} \\end{aligned}$$\n\n同理可得，\n\n$$\\begin{aligned} \\frac{\\partial(1-logh\\_\\theta(x^{(i)}))}{\\partial\\theta\\_j}=-h\\_\\theta(x^{(i)})x_j^{(i)} \\end{aligned}$$\n\n所以\n\n$$\\begin{aligned} \\frac{\\partial l(\\theta)}{\\partial\\theta\\_j}&=\\sum\\_{i=1}^m{(y^{(i)}(1-h\\_\\theta(x^{(i)}))x\\_j^{(i)}+(1-y^{(i)})(-h\\_\\theta(x^{(i)})x\\_j^{(i)}))}\\\\&=\\sum\\_{i=1}^m{(y^{(i)}-h\\_\\theta(x^{(i)}))x\\_j^{(i)}} \\end{aligned}$$\n\n那么，最终梯度下降算法为：\n\n$$\\begin{aligned} \\theta\\_j:=\\theta\\_j-\\alpha\\sum\\_{i=1}^m{(y^{(i)}-h\\_\\theta(x^{(i)}))x\\_j^{(i)}} \\end{aligned}$$\n\n注：虽然得到的梯度下降算法表面上看去与线性回归一样，但是这里 的 $h\\_{\\theta }\\left( x\\right) =\\dfrac {1} {1+e^{-\\theta ^{T}x}}$ 与线性回归中不同。\n\n### 梯度下降算法的技巧\n\n- 变量缩放 (Normalize Variable)\n- $\\alpha$选择\n- 设定收敛条件\n\n## 实现Logigtic Regrssion算法\n以上，介绍了Logistic Regression算法的详细推导过程，下面就用Python来实现这个算法\n\n首先是逻辑回归函数，也就是sigmoid函数\n\n```python\ndef sigmoid(theta, x):\n    return 1.0 / (1 + np.exp(-x.dot(theta)))\n```\n\n然后使用梯度下降算法估算$\\theta$值，首先是gradient值\n\n$$(y^{(i)}-h_\\theta(x^{(i)}))x_j^{(i)}$$\n\n```python\ndef gradient(theta, x, y):\n    first_part = sigmoid(theta, x) - np.squeeze(y)\n    return first_part.T.dot(x)\n```\n\n损失函数cost function\n\n$$-\\sum_{i=1}^{m}y^{(i)}log(h(x^{(i)})) + (1-y^{(i)})log(1-h(x^{(i)}))$$\n\n```python\ndef cost_function(theta, x, y):\n    h_theta = sigmoid(theta, x)\n    y = np.squeeze(y)\n    first = y * np.log(h_theta)\n    second = (1 - y) * np.log(1 - h_theta)\n    return np.mean(-first - second)\n```\n\n梯度下降算法，这种梯度下降算法也叫批量梯度下降(Batch gradient descent)\n\n$$\\begin{aligned} \\theta_j:=\\theta\\_j-\\alpha\\sum\\_{i=1}^m{(y^{(i)}-h\\_\\theta(x^{(i)}))x\\_j^{(i)}} \\end{aligned}$$\n\n```python\ndef gradient_descent(theta, X, y, alpha=0.001, converge):\n    X = (X - np.mean(X, axis=0)) / np.std(X, axis=0)\n    cost_iter = []\n    cost = cost_function(theta, X, y)\n    cost_iter.append([0, cost])\n    i = 1\n    while(change_cost > converge):\n        theta = theta - (alpha * gradient(theta, X, y))\n        cost = cost_function(theta, X, y)\n        cost_iter.append([i, cost])\n        i += 1\n    return theta, np.array(cost_iter)\n```\n\n预测方法\n\n```python\ndef predict_function(theta, x):\n    x = (x - np.mean(x, axis=0)) / np.std(x, axis=0)\n    pred_prob = sigmoid(theta, x)\n    pred_value = np.where(pred_prob >= 0.5, 1, 0)\n    return pred_value\n```\n\n### 损失函数变化趋势\n画出cost function的变化趋势，看看是不是已经收敛了\n\n![cost_trend](http://7xkfga.com1.z0.glb.clouddn.com/cost_trend.png)\n\n看来梯度下降算法已经收敛了。\n\n\n## 使用Scikit-Learn中的Logistic Regression算法\nScikit-Learn库中，已经包含了逻辑回归算法，下面用这个工具集来体验一下这个算法。\n\n```python\nfrom sklearn import linear_model\nmodel = linear_model.LogisticRegression()\nmodel.fit(X, y)\nmodel.predict(X_test)\n```\n\n### 其他优化算法\n\n- BFGS\n- 随机梯度下降 Stochastic gradient descent\n- L-BFGS\n- Conjugate Gradient\n\n","slug":"2015-08-12-logistic-regression-classifier-on-hands","published":1,"updated":"2016-09-20T02:07:00.000Z","photos":[],"link":"","_id":"cjfkkp3ng000yzd68y49naw54","content":"<p>逻辑回归算法是一个很有用的分类算法，这篇文章总结一下逻辑回归算法的相关内容。数据使用scikit-learn自带的<code>Iris</code>数据集。</p>\n<h2 id=\"Iris-dataset\"><a href=\"#Iris-dataset\" class=\"headerlink\" title=\"Iris dataset\"></a>Iris dataset</h2><p>Iris数据集，里面包含3种鸢尾花品种的4各属性，这个分类问题可以描述成使用鸢尾花的属性，来判断这个品种倒地属于哪个品种类别。为了简单，这里使用两个类别：<code>Setosa</code>和<code>Versicolor</code>，两个属性：<code>Length</code>和<code>Width</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> datasets</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">data = datasets.load_iris()</span><br><span class=\"line\">X = data.data[:<span class=\"number\">100</span>, : <span class=\"number\">2</span>]</span><br><span class=\"line\">y = data.target[:<span class=\"number\">100</span>]</span><br><span class=\"line\">setosa = plt.scatter(X[:<span class=\"number\">50</span>, <span class=\"number\">0</span>], X[:<span class=\"number\">50</span>, <span class=\"number\">1</span>], c=<span class=\"string\">'b'</span>)</span><br><span class=\"line\">versicolor = plt.scatter(X[<span class=\"number\">50</span>:, <span class=\"number\">0</span>], X[<span class=\"number\">50</span>:, <span class=\"number\">1</span>], c=<span class=\"string\">'r'</span>)</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">\"Sepal Length\"</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">\"Seqal Width\"</span>)</span><br><span class=\"line\">plt.legend((setosa, versicolor), (<span class=\"string\">\"Setosa\"</span>, <span class=\"string\">\"Versicolor\"</span>))</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/iris_data.JPG\" alt=\"Iris dataset\"></p>\n<p>可以看出来，两个品种可以被区分开，接下来要使用一种算法，让计算机把这两个类别区分开。可以想象，可以使用线性回归，也就是画一条线来把两个类别分开，但是这种分割很粗暴，准确性也不高，所以接下来要使用的算法要使用概率的方法区分两个类别，比如，算法返回0.9，那么代表属于类别A的概率是90%</p>\n<a id=\"more\"></a>\n<h2 id=\"逻辑函数-Logistic-Function\"><a href=\"#逻辑函数-Logistic-Function\" class=\"headerlink\" title=\"逻辑函数 Logistic Function\"></a>逻辑函数 Logistic Function</h2><p>这里使用的逻辑函数正好符合概率的定义，即函数返回值在[0, 1]区间内，函数又被称作sigmod函数：</p>\n<p>$$y=\\dfrac {1} {1+e^{-x}}$$</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x_values = np.linspace(<span class=\"number\">-5</span>, <span class=\"number\">5</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">y_values = [<span class=\"number\">1</span> / (<span class=\"number\">1</span> + np.exp(-x)) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> x_values]</span><br><span class=\"line\">plt.plot(x_values, y_values)</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">\"X\"</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">\"y\"</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/sigmod.png\" alt=\"sigmod function\"></p>\n<h3 id=\"将逻辑函数应用到数据上\"><a href=\"#将逻辑函数应用到数据上\" class=\"headerlink\" title=\"将逻辑函数应用到数据上\"></a>将逻辑函数应用到数据上</h3><p>现在，数据集有两个属性<code>Sepal Length</code>和<code>Sepal Width</code>，这两个属性可以写到如下的等式中：</p>\n<p>$$x=\\theta_{0}+\\theta_{1}SW +\\theta_{2}SL$$</p>\n<p>SL代表<code>Sepal Length</code>这个特征，SW代表<code>Sepal Width</code>这个特征，假如神告诉我们 $\\theta_{0} = 1$，$\\theta_{1} = 2$，$\\theta_{2} = 4$，那么，长度为5并且宽度为3.5的这个品种，$x=1+\\left( 2\\ast 3.5\\right) +\\left( 4\\ast 5\\right) = 28 $，代入逻辑函数：</p>\n<p>$$\\dfrac{1} {1+e^{-28}}=0.99$$</p>\n<p>说明这个品种数据Setosa的概率为99%。那么，告诉我们 $\\theta$的取值的神是谁呢？</p>\n<h2 id=\"算法学习\"><a href=\"#算法学习\" class=\"headerlink\" title=\"算法学习\"></a>算法学习</h2><h3 id=\"Cost-Function\"><a href=\"#Cost-Function\" class=\"headerlink\" title=\"Cost Function\"></a>Cost Function</h3><p>在学习线性回归时候，当时使用的是<code>Square Error</code>作为损失函数，那么在逻辑回归中能不能也用这种损失函数呢？当然可以，不过在逻辑回归算法中，使用<code>Square Error</code>作为损失函数是非凸函数，也就是说有多个局部最小值，不能取到全局最小值，所以这里应该使用其他的损失函数。</p>\n<p>想象一下，我们假设求出来一个属性的结果值是1，也就是预测为<code>Setosa</code>类别，那么预测为<code>Versicolor</code>类别的概率为0，在全部的数据集上，假设数据都是独立分布的，那么我们的目标就是：把每个单独类别的概率结果值累乘起来，并求最大值：</p>\n<p>$$\\prod_{Setosa}\\frac{1}{1 + e^{-(\\theta_{0} + \\theta{1}SW + \\theta_{2}SL)}}\\prod_{Versicolor}1 - \\frac{1}{1 + e^{-(\\theta_{0} + \\theta{1}SW + \\theta_{2}SL)}}$$</p>\n<p>参考上面定义的逻辑函数：</p>\n<p>$$h(x) = \\frac{1}{1 + e^{-x}}$$</p>\n<p>那么我们的目标函数就是求下面函数的最大值：</p>\n<p>$$\\prod_{Setosa}h(x)\\prod_{Versicolor}1 - h(x)$$</p>\n<p>解释一下，加入类别分别为0和1，回归结果$h_\\theta(x)$表示样本属于类别1的概率，那么样本属于类别0的概率为 $1-h_\\theta(x)$，则有</p>\n<p>$$p(y=1|x,\\theta)=h_\\theta(x)$$</p>\n<p>$$p(y=0|x,\\theta)=1-h_\\theta(x)$$</p>\n<p>可以写为下面公式，含义为：某一个观测值的概率</p>\n<p>$$p(y|x,\\theta)=h_\\theta(x)^y(1-h_\\theta(x))^{1-y}$$</p>\n<p>由于各个观测值相互独立，那么联合分布可以表示成各个观测值概率的乘积：</p>\n<p>$$L(\\theta)=\\prod_{i=1}^m{h_\\theta(x^{(i)})^{y^{(i)}}(1-h_\\theta(x^{(i)}))^{1-y^{(i)}}}$$</p>\n<p>上式称为n个观测的似然函数。我们的目标是能够求出使这一似然函数的值最大的参数估计。对上面的似然函数取对数</p>\n<p>$$\\begin{aligned} l(\\theta)=log(L(\\theta))=log(\\prod_{i=1}^m{h_\\theta(x^{(i)})^{y^{(i)}}(1-h_\\theta(x^{(i)}))^{1-y^{(i)}}})<br>=\\sum_{i=1}^m{(y^{(i)}log(h_\\theta(x^{(i)}))+(1-y^{(i)})log(1-h_\\theta(x^{(i)})))} \\end{aligned}$$</p>\n<p>最大化似然函数，使用梯度下降法，求出$\\theta$值，稍微变换一下，那就是求下面式子的最小值</p>\n<p>$$J\\left( \\theta \\right) = -\\sum_{i=1}^{m}y^{(i)}log(h(x^{(i)})) + (1-y^{(i)})log(1-h(x^{(i)}))$$</p>\n<h3 id=\"梯度下降算法\"><a href=\"#梯度下降算法\" class=\"headerlink\" title=\"梯度下降算法\"></a>梯度下降算法</h3><p>梯度下降算法为：</p>\n<p>$$\\begin{aligned} \\theta_j:=\\theta_j-\\alpha\\frac{\\partial J(\\theta)}{\\partial\\theta_j} \\end{aligned}$$</p>\n<h3 id=\"梯度下降算法的推导\"><a href=\"#梯度下降算法的推导\" class=\"headerlink\" title=\"梯度下降算法的推导\"></a>梯度下降算法的推导</h3><p>对$\\theta$参数求导，可得</p>\n<p>$$\\begin{aligned} \\frac{\\partial logh_\\theta(x^{(i)})}{\\partial\\theta_j}&amp;=\\frac{\\partial log(g(\\theta^T x^{(i)}))}{\\partial\\theta_j}\\&amp;=\\frac{1}{g(\\theta^T x^{(i)})}{ g(\\theta^T x^{(i)})) (1-g(\\theta^T x^{(i)}))x_j^{(i)}}\\&amp;=(1- g(\\theta^T x^{(i)}))) x_j^{(i)}\\&amp;=(1-h_\\theta(x^{(i)}))x_j^{(i)} \\end{aligned}$$</p>\n<p>同理可得，</p>\n<p>$$\\begin{aligned} \\frac{\\partial(1-logh_\\theta(x^{(i)}))}{\\partial\\theta_j}=-h_\\theta(x^{(i)})x_j^{(i)} \\end{aligned}$$</p>\n<p>所以</p>\n<p>$$\\begin{aligned} \\frac{\\partial l(\\theta)}{\\partial\\theta_j}&amp;=\\sum_{i=1}^m{(y^{(i)}(1-h_\\theta(x^{(i)}))x_j^{(i)}+(1-y^{(i)})(-h_\\theta(x^{(i)})x_j^{(i)}))}\\&amp;=\\sum_{i=1}^m{(y^{(i)}-h_\\theta(x^{(i)}))x_j^{(i)}} \\end{aligned}$$</p>\n<p>那么，最终梯度下降算法为：</p>\n<p>$$\\begin{aligned} \\theta_j:=\\theta_j-\\alpha\\sum_{i=1}^m{(y^{(i)}-h_\\theta(x^{(i)}))x_j^{(i)}} \\end{aligned}$$</p>\n<p>注：虽然得到的梯度下降算法表面上看去与线性回归一样，但是这里 的 $h_{\\theta }\\left( x\\right) =\\dfrac {1} {1+e^{-\\theta ^{T}x}}$ 与线性回归中不同。</p>\n<h3 id=\"梯度下降算法的技巧\"><a href=\"#梯度下降算法的技巧\" class=\"headerlink\" title=\"梯度下降算法的技巧\"></a>梯度下降算法的技巧</h3><ul>\n<li>变量缩放 (Normalize Variable)</li>\n<li>$\\alpha$选择</li>\n<li>设定收敛条件</li>\n</ul>\n<h2 id=\"实现Logigtic-Regrssion算法\"><a href=\"#实现Logigtic-Regrssion算法\" class=\"headerlink\" title=\"实现Logigtic Regrssion算法\"></a>实现Logigtic Regrssion算法</h2><p>以上，介绍了Logistic Regression算法的详细推导过程，下面就用Python来实现这个算法</p>\n<p>首先是逻辑回归函数，也就是sigmoid函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sigmoid</span><span class=\"params\">(theta, x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1.0</span> / (<span class=\"number\">1</span> + np.exp(-x.dot(theta)))</span><br></pre></td></tr></table></figure>\n<p>然后使用梯度下降算法估算$\\theta$值，首先是gradient值</p>\n<p>$$(y^{(i)}-h_\\theta(x^{(i)}))x_j^{(i)}$$</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gradient</span><span class=\"params\">(theta, x, y)</span>:</span></span><br><span class=\"line\">    first_part = sigmoid(theta, x) - np.squeeze(y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> first_part.T.dot(x)</span><br></pre></td></tr></table></figure>\n<p>损失函数cost function</p>\n<p>$$-\\sum_{i=1}^{m}y^{(i)}log(h(x^{(i)})) + (1-y^{(i)})log(1-h(x^{(i)}))$$</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cost_function</span><span class=\"params\">(theta, x, y)</span>:</span></span><br><span class=\"line\">    h_theta = sigmoid(theta, x)</span><br><span class=\"line\">    y = np.squeeze(y)</span><br><span class=\"line\">    first = y * np.log(h_theta)</span><br><span class=\"line\">    second = (<span class=\"number\">1</span> - y) * np.log(<span class=\"number\">1</span> - h_theta)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.mean(-first - second)</span><br></pre></td></tr></table></figure>\n<p>梯度下降算法，这种梯度下降算法也叫批量梯度下降(Batch gradient descent)</p>\n<p>$$\\begin{aligned} \\theta_j:=\\theta_j-\\alpha\\sum_{i=1}^m{(y^{(i)}-h_\\theta(x^{(i)}))x_j^{(i)}} \\end{aligned}$$</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gradient_descent</span><span class=\"params\">(theta, X, y, alpha=<span class=\"number\">0.001</span>, converge)</span>:</span></span><br><span class=\"line\">    X = (X - np.mean(X, axis=<span class=\"number\">0</span>)) / np.std(X, axis=<span class=\"number\">0</span>)</span><br><span class=\"line\">    cost_iter = []</span><br><span class=\"line\">    cost = cost_function(theta, X, y)</span><br><span class=\"line\">    cost_iter.append([<span class=\"number\">0</span>, cost])</span><br><span class=\"line\">    i = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(change_cost &gt; converge):</span><br><span class=\"line\">        theta = theta - (alpha * gradient(theta, X, y))</span><br><span class=\"line\">        cost = cost_function(theta, X, y)</span><br><span class=\"line\">        cost_iter.append([i, cost])</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> theta, np.array(cost_iter)</span><br></pre></td></tr></table></figure>\n<p>预测方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">predict_function</span><span class=\"params\">(theta, x)</span>:</span></span><br><span class=\"line\">    x = (x - np.mean(x, axis=<span class=\"number\">0</span>)) / np.std(x, axis=<span class=\"number\">0</span>)</span><br><span class=\"line\">    pred_prob = sigmoid(theta, x)</span><br><span class=\"line\">    pred_value = np.where(pred_prob &gt;= <span class=\"number\">0.5</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pred_value</span><br></pre></td></tr></table></figure>\n<h3 id=\"损失函数变化趋势\"><a href=\"#损失函数变化趋势\" class=\"headerlink\" title=\"损失函数变化趋势\"></a>损失函数变化趋势</h3><p>画出cost function的变化趋势，看看是不是已经收敛了</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/cost_trend.png\" alt=\"cost_trend\"></p>\n<p>看来梯度下降算法已经收敛了。</p>\n<h2 id=\"使用Scikit-Learn中的Logistic-Regression算法\"><a href=\"#使用Scikit-Learn中的Logistic-Regression算法\" class=\"headerlink\" title=\"使用Scikit-Learn中的Logistic Regression算法\"></a>使用Scikit-Learn中的Logistic Regression算法</h2><p>Scikit-Learn库中，已经包含了逻辑回归算法，下面用这个工具集来体验一下这个算法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> linear_model</span><br><span class=\"line\">model = linear_model.LogisticRegression()</span><br><span class=\"line\">model.fit(X, y)</span><br><span class=\"line\">model.predict(X_test)</span><br></pre></td></tr></table></figure>\n<h3 id=\"其他优化算法\"><a href=\"#其他优化算法\" class=\"headerlink\" title=\"其他优化算法\"></a>其他优化算法</h3><ul>\n<li>BFGS</li>\n<li>随机梯度下降 Stochastic gradient descent</li>\n<li>L-BFGS</li>\n<li>Conjugate Gradient</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>逻辑回归算法是一个很有用的分类算法，这篇文章总结一下逻辑回归算法的相关内容。数据使用scikit-learn自带的<code>Iris</code>数据集。</p>\n<h2 id=\"Iris-dataset\"><a href=\"#Iris-dataset\" class=\"headerlink\" title=\"Iris dataset\"></a>Iris dataset</h2><p>Iris数据集，里面包含3种鸢尾花品种的4各属性，这个分类问题可以描述成使用鸢尾花的属性，来判断这个品种倒地属于哪个品种类别。为了简单，这里使用两个类别：<code>Setosa</code>和<code>Versicolor</code>，两个属性：<code>Length</code>和<code>Width</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> datasets</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">data = datasets.load_iris()</span><br><span class=\"line\">X = data.data[:<span class=\"number\">100</span>, : <span class=\"number\">2</span>]</span><br><span class=\"line\">y = data.target[:<span class=\"number\">100</span>]</span><br><span class=\"line\">setosa = plt.scatter(X[:<span class=\"number\">50</span>, <span class=\"number\">0</span>], X[:<span class=\"number\">50</span>, <span class=\"number\">1</span>], c=<span class=\"string\">'b'</span>)</span><br><span class=\"line\">versicolor = plt.scatter(X[<span class=\"number\">50</span>:, <span class=\"number\">0</span>], X[<span class=\"number\">50</span>:, <span class=\"number\">1</span>], c=<span class=\"string\">'r'</span>)</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">\"Sepal Length\"</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">\"Seqal Width\"</span>)</span><br><span class=\"line\">plt.legend((setosa, versicolor), (<span class=\"string\">\"Setosa\"</span>, <span class=\"string\">\"Versicolor\"</span>))</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/iris_data.JPG\" alt=\"Iris dataset\"></p>\n<p>可以看出来，两个品种可以被区分开，接下来要使用一种算法，让计算机把这两个类别区分开。可以想象，可以使用线性回归，也就是画一条线来把两个类别分开，但是这种分割很粗暴，准确性也不高，所以接下来要使用的算法要使用概率的方法区分两个类别，比如，算法返回0.9，那么代表属于类别A的概率是90%</p>","more":"<h2 id=\"逻辑函数-Logistic-Function\"><a href=\"#逻辑函数-Logistic-Function\" class=\"headerlink\" title=\"逻辑函数 Logistic Function\"></a>逻辑函数 Logistic Function</h2><p>这里使用的逻辑函数正好符合概率的定义，即函数返回值在[0, 1]区间内，函数又被称作sigmod函数：</p>\n<p>$$y=\\dfrac {1} {1+e^{-x}}$$</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x_values = np.linspace(<span class=\"number\">-5</span>, <span class=\"number\">5</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">y_values = [<span class=\"number\">1</span> / (<span class=\"number\">1</span> + np.exp(-x)) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> x_values]</span><br><span class=\"line\">plt.plot(x_values, y_values)</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">\"X\"</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">\"y\"</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/sigmod.png\" alt=\"sigmod function\"></p>\n<h3 id=\"将逻辑函数应用到数据上\"><a href=\"#将逻辑函数应用到数据上\" class=\"headerlink\" title=\"将逻辑函数应用到数据上\"></a>将逻辑函数应用到数据上</h3><p>现在，数据集有两个属性<code>Sepal Length</code>和<code>Sepal Width</code>，这两个属性可以写到如下的等式中：</p>\n<p>$$x=\\theta_{0}+\\theta_{1}SW +\\theta_{2}SL$$</p>\n<p>SL代表<code>Sepal Length</code>这个特征，SW代表<code>Sepal Width</code>这个特征，假如神告诉我们 $\\theta_{0} = 1$，$\\theta_{1} = 2$，$\\theta_{2} = 4$，那么，长度为5并且宽度为3.5的这个品种，$x=1+\\left( 2\\ast 3.5\\right) +\\left( 4\\ast 5\\right) = 28 $，代入逻辑函数：</p>\n<p>$$\\dfrac{1} {1+e^{-28}}=0.99$$</p>\n<p>说明这个品种数据Setosa的概率为99%。那么，告诉我们 $\\theta$的取值的神是谁呢？</p>\n<h2 id=\"算法学习\"><a href=\"#算法学习\" class=\"headerlink\" title=\"算法学习\"></a>算法学习</h2><h3 id=\"Cost-Function\"><a href=\"#Cost-Function\" class=\"headerlink\" title=\"Cost Function\"></a>Cost Function</h3><p>在学习线性回归时候，当时使用的是<code>Square Error</code>作为损失函数，那么在逻辑回归中能不能也用这种损失函数呢？当然可以，不过在逻辑回归算法中，使用<code>Square Error</code>作为损失函数是非凸函数，也就是说有多个局部最小值，不能取到全局最小值，所以这里应该使用其他的损失函数。</p>\n<p>想象一下，我们假设求出来一个属性的结果值是1，也就是预测为<code>Setosa</code>类别，那么预测为<code>Versicolor</code>类别的概率为0，在全部的数据集上，假设数据都是独立分布的，那么我们的目标就是：把每个单独类别的概率结果值累乘起来，并求最大值：</p>\n<p>$$\\prod_{Setosa}\\frac{1}{1 + e^{-(\\theta_{0} + \\theta{1}SW + \\theta_{2}SL)}}\\prod_{Versicolor}1 - \\frac{1}{1 + e^{-(\\theta_{0} + \\theta{1}SW + \\theta_{2}SL)}}$$</p>\n<p>参考上面定义的逻辑函数：</p>\n<p>$$h(x) = \\frac{1}{1 + e^{-x}}$$</p>\n<p>那么我们的目标函数就是求下面函数的最大值：</p>\n<p>$$\\prod_{Setosa}h(x)\\prod_{Versicolor}1 - h(x)$$</p>\n<p>解释一下，加入类别分别为0和1，回归结果$h_\\theta(x)$表示样本属于类别1的概率，那么样本属于类别0的概率为 $1-h_\\theta(x)$，则有</p>\n<p>$$p(y=1|x,\\theta)=h_\\theta(x)$$</p>\n<p>$$p(y=0|x,\\theta)=1-h_\\theta(x)$$</p>\n<p>可以写为下面公式，含义为：某一个观测值的概率</p>\n<p>$$p(y|x,\\theta)=h_\\theta(x)^y(1-h_\\theta(x))^{1-y}$$</p>\n<p>由于各个观测值相互独立，那么联合分布可以表示成各个观测值概率的乘积：</p>\n<p>$$L(\\theta)=\\prod_{i=1}^m{h_\\theta(x^{(i)})^{y^{(i)}}(1-h_\\theta(x^{(i)}))^{1-y^{(i)}}}$$</p>\n<p>上式称为n个观测的似然函数。我们的目标是能够求出使这一似然函数的值最大的参数估计。对上面的似然函数取对数</p>\n<p>$$\\begin{aligned} l(\\theta)=log(L(\\theta))=log(\\prod_{i=1}^m{h_\\theta(x^{(i)})^{y^{(i)}}(1-h_\\theta(x^{(i)}))^{1-y^{(i)}}})<br>=\\sum_{i=1}^m{(y^{(i)}log(h_\\theta(x^{(i)}))+(1-y^{(i)})log(1-h_\\theta(x^{(i)})))} \\end{aligned}$$</p>\n<p>最大化似然函数，使用梯度下降法，求出$\\theta$值，稍微变换一下，那就是求下面式子的最小值</p>\n<p>$$J\\left( \\theta \\right) = -\\sum_{i=1}^{m}y^{(i)}log(h(x^{(i)})) + (1-y^{(i)})log(1-h(x^{(i)}))$$</p>\n<h3 id=\"梯度下降算法\"><a href=\"#梯度下降算法\" class=\"headerlink\" title=\"梯度下降算法\"></a>梯度下降算法</h3><p>梯度下降算法为：</p>\n<p>$$\\begin{aligned} \\theta_j:=\\theta_j-\\alpha\\frac{\\partial J(\\theta)}{\\partial\\theta_j} \\end{aligned}$$</p>\n<h3 id=\"梯度下降算法的推导\"><a href=\"#梯度下降算法的推导\" class=\"headerlink\" title=\"梯度下降算法的推导\"></a>梯度下降算法的推导</h3><p>对$\\theta$参数求导，可得</p>\n<p>$$\\begin{aligned} \\frac{\\partial logh_\\theta(x^{(i)})}{\\partial\\theta_j}&amp;=\\frac{\\partial log(g(\\theta^T x^{(i)}))}{\\partial\\theta_j}\\&amp;=\\frac{1}{g(\\theta^T x^{(i)})}{ g(\\theta^T x^{(i)})) (1-g(\\theta^T x^{(i)}))x_j^{(i)}}\\&amp;=(1- g(\\theta^T x^{(i)}))) x_j^{(i)}\\&amp;=(1-h_\\theta(x^{(i)}))x_j^{(i)} \\end{aligned}$$</p>\n<p>同理可得，</p>\n<p>$$\\begin{aligned} \\frac{\\partial(1-logh_\\theta(x^{(i)}))}{\\partial\\theta_j}=-h_\\theta(x^{(i)})x_j^{(i)} \\end{aligned}$$</p>\n<p>所以</p>\n<p>$$\\begin{aligned} \\frac{\\partial l(\\theta)}{\\partial\\theta_j}&amp;=\\sum_{i=1}^m{(y^{(i)}(1-h_\\theta(x^{(i)}))x_j^{(i)}+(1-y^{(i)})(-h_\\theta(x^{(i)})x_j^{(i)}))}\\&amp;=\\sum_{i=1}^m{(y^{(i)}-h_\\theta(x^{(i)}))x_j^{(i)}} \\end{aligned}$$</p>\n<p>那么，最终梯度下降算法为：</p>\n<p>$$\\begin{aligned} \\theta_j:=\\theta_j-\\alpha\\sum_{i=1}^m{(y^{(i)}-h_\\theta(x^{(i)}))x_j^{(i)}} \\end{aligned}$$</p>\n<p>注：虽然得到的梯度下降算法表面上看去与线性回归一样，但是这里 的 $h_{\\theta }\\left( x\\right) =\\dfrac {1} {1+e^{-\\theta ^{T}x}}$ 与线性回归中不同。</p>\n<h3 id=\"梯度下降算法的技巧\"><a href=\"#梯度下降算法的技巧\" class=\"headerlink\" title=\"梯度下降算法的技巧\"></a>梯度下降算法的技巧</h3><ul>\n<li>变量缩放 (Normalize Variable)</li>\n<li>$\\alpha$选择</li>\n<li>设定收敛条件</li>\n</ul>\n<h2 id=\"实现Logigtic-Regrssion算法\"><a href=\"#实现Logigtic-Regrssion算法\" class=\"headerlink\" title=\"实现Logigtic Regrssion算法\"></a>实现Logigtic Regrssion算法</h2><p>以上，介绍了Logistic Regression算法的详细推导过程，下面就用Python来实现这个算法</p>\n<p>首先是逻辑回归函数，也就是sigmoid函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sigmoid</span><span class=\"params\">(theta, x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1.0</span> / (<span class=\"number\">1</span> + np.exp(-x.dot(theta)))</span><br></pre></td></tr></table></figure>\n<p>然后使用梯度下降算法估算$\\theta$值，首先是gradient值</p>\n<p>$$(y^{(i)}-h_\\theta(x^{(i)}))x_j^{(i)}$$</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gradient</span><span class=\"params\">(theta, x, y)</span>:</span></span><br><span class=\"line\">    first_part = sigmoid(theta, x) - np.squeeze(y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> first_part.T.dot(x)</span><br></pre></td></tr></table></figure>\n<p>损失函数cost function</p>\n<p>$$-\\sum_{i=1}^{m}y^{(i)}log(h(x^{(i)})) + (1-y^{(i)})log(1-h(x^{(i)}))$$</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cost_function</span><span class=\"params\">(theta, x, y)</span>:</span></span><br><span class=\"line\">    h_theta = sigmoid(theta, x)</span><br><span class=\"line\">    y = np.squeeze(y)</span><br><span class=\"line\">    first = y * np.log(h_theta)</span><br><span class=\"line\">    second = (<span class=\"number\">1</span> - y) * np.log(<span class=\"number\">1</span> - h_theta)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.mean(-first - second)</span><br></pre></td></tr></table></figure>\n<p>梯度下降算法，这种梯度下降算法也叫批量梯度下降(Batch gradient descent)</p>\n<p>$$\\begin{aligned} \\theta_j:=\\theta_j-\\alpha\\sum_{i=1}^m{(y^{(i)}-h_\\theta(x^{(i)}))x_j^{(i)}} \\end{aligned}$$</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gradient_descent</span><span class=\"params\">(theta, X, y, alpha=<span class=\"number\">0.001</span>, converge)</span>:</span></span><br><span class=\"line\">    X = (X - np.mean(X, axis=<span class=\"number\">0</span>)) / np.std(X, axis=<span class=\"number\">0</span>)</span><br><span class=\"line\">    cost_iter = []</span><br><span class=\"line\">    cost = cost_function(theta, X, y)</span><br><span class=\"line\">    cost_iter.append([<span class=\"number\">0</span>, cost])</span><br><span class=\"line\">    i = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(change_cost &gt; converge):</span><br><span class=\"line\">        theta = theta - (alpha * gradient(theta, X, y))</span><br><span class=\"line\">        cost = cost_function(theta, X, y)</span><br><span class=\"line\">        cost_iter.append([i, cost])</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> theta, np.array(cost_iter)</span><br></pre></td></tr></table></figure>\n<p>预测方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">predict_function</span><span class=\"params\">(theta, x)</span>:</span></span><br><span class=\"line\">    x = (x - np.mean(x, axis=<span class=\"number\">0</span>)) / np.std(x, axis=<span class=\"number\">0</span>)</span><br><span class=\"line\">    pred_prob = sigmoid(theta, x)</span><br><span class=\"line\">    pred_value = np.where(pred_prob &gt;= <span class=\"number\">0.5</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pred_value</span><br></pre></td></tr></table></figure>\n<h3 id=\"损失函数变化趋势\"><a href=\"#损失函数变化趋势\" class=\"headerlink\" title=\"损失函数变化趋势\"></a>损失函数变化趋势</h3><p>画出cost function的变化趋势，看看是不是已经收敛了</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/cost_trend.png\" alt=\"cost_trend\"></p>\n<p>看来梯度下降算法已经收敛了。</p>\n<h2 id=\"使用Scikit-Learn中的Logistic-Regression算法\"><a href=\"#使用Scikit-Learn中的Logistic-Regression算法\" class=\"headerlink\" title=\"使用Scikit-Learn中的Logistic Regression算法\"></a>使用Scikit-Learn中的Logistic Regression算法</h2><p>Scikit-Learn库中，已经包含了逻辑回归算法，下面用这个工具集来体验一下这个算法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> linear_model</span><br><span class=\"line\">model = linear_model.LogisticRegression()</span><br><span class=\"line\">model.fit(X, y)</span><br><span class=\"line\">model.predict(X_test)</span><br></pre></td></tr></table></figure>\n<h3 id=\"其他优化算法\"><a href=\"#其他优化算法\" class=\"headerlink\" title=\"其他优化算法\"></a>其他优化算法</h3><ul>\n<li>BFGS</li>\n<li>随机梯度下降 Stochastic gradient descent</li>\n<li>L-BFGS</li>\n<li>Conjugate Gradient</li>\n</ul>"},{"layout":"post","title":"利用Spark进行单词计数","date":"2015-08-12T05:38:08.000Z","comments":1,"_content":"\n这里就不再介绍Spark了，这篇文章主要记录一下关于Spark的核心`RDD`的相关操作以及以单词计数这个简单的例子，描述一下Spark的处理流程。\n\n## Spark RDD\nSpark是以RDD概念为中心运行的。RDD是一个容错的、可以被并行操作的元素集合。创建一个RDD有两个方法：在你的驱动程序中并行化一个已经存在的集合；从外部存储系统中引用一个数据集，这个存储系统可以是一个共享文件系统，比如HDFS、HBase或任意提供了Hadoop输入格式的数据来源。\n\nRDD支持两类操作：\n\n- 转换(Transform)\n- 动作(Action)\n\n还是不翻译的好，下面都用英文描述。`Transform`：用于从已有的数据集转换产生新的数据集，Transform的操作是`Lazy Evaluation`的，也就是说这条语句过后，转换并没有发生，而是在下一个`Action`调用的时候才会返回结果。`Action`：用于计算结果并向驱动程序返回结果。\n\n<!--more-->\n\n演示一下上面两种基本操作：\n\n```python\nlines = sc.textFile(\"data.txt\")\nlineLength = line.map(lambda x: len(x))\ntotalLength = lineLength.reduce(lambda x, y: x + y)\n```\n\n第一行是有外部存储系统中创建一个RDD对象，第二行定义map操作，是一个`Transform`操作，由于`Lazy Evaluation`，对象`lineLength`并没有立即计算得到。第三行，`reduce`是一个`Action`操作，这时，Spark将整个计算过程划分成许多任务在多台机器上并行执行，每台机器运行自己部分的map操作和reduce操作，最终将自己部分的运算结果返回给驱动程序。\n\n```python\n\tlineLength.persist()\n\t# lineLength.cache()\n```\n\n这一行，Spark将`lineLength`对象保存在内存中，以便后面计算中使用。Spark的一个重要功能就是在将数据集持久化（或缓存）到内存中以便在多个操作中重复使用。\n\n以上就是RDD的一些基本操作，API文档中写的都很清楚，我就不多说了。\n\n## 统计一篇文档中单词的个数\n首先，写一个函数，用来计算单词个数\n\n```python\ndef wordCount(wordListRDD):\n    wordCountsCollected = wordListRDD\n                                .map(lambda x: (x, 1))\n                                .reduceByKey(lambda x, y: x + y)\n    return wordCountsCollected\n```\n\n使用正则表达式清理原始文本\n\n```python\n\timport re\n\timport string\n\tdef removePunctuation(text):\n\t    regex = re.compile('[%s]' % re.escape(string.punctuation))\n\t    return regex.sub('', text).lower().strip()\n\tprint removePunctuation(' No under_score!')\n```\n\n去读文件内容到RDD中\n\n```python\n\timport os.path\n\tbaseDir = os.path.join('data')\n\tinputPath = os.path.join('cs100', 'lab1', 'shakespeare.txt')\n\tfileName = os.path.join(baseDir, inputPath)\n\t# \n\tshakespeareRDD = (sc.textFile(fileName, 8).map(removePunctuation))\n\tprint '\\n'.join(shakespeareRDD.zipWithIndex().map(lambda (l, num): '{0}: {1}'.format(num,l)).take(15))\n```\n\n这时候，需要把单词通过空格隔开，然后过滤掉为空的内容\n\n```python\nshakespeareWordsRDD = shakespeareRDD.flatMap(lambda x: x.split())\nshakespeareWordCount = shakespeareWordsRDD.count()\nprint shakespeareWordsRDD.top(5)\nshakeWordsRDD = shakespeareWordsRDD\n```\n\n统计出出现次数前15多的单词以及个数：\n\n```python\ntop15WordAndCounts = wordCount(shakeWordsRDD).takeOrdered(15, key=lambda (k, v): -v)\nprint '\\n'.join(map(lambda (w, c): '{0}: {1}'.format(w, c), top15WordsAndCounts))\n```\n\n输出结果为：\n\nword | count\n---- | ------\nthe: | 27361\nand: | 26028\ni:   | 20681\nto:  | 19150\nof:  | 17463\na:   | 14593\nyou: | 13615\nmy:  | 12481\nin:  | 10956\nthat:| 10890\nis:  | 9134\nnot: | 8497\nwith:| 7771\nme:  | 7769\nit:  | 7678\n     |\n\n\nSpark是用Scala写出来的，所以可想而知如果用Scala写的效率会比Python高一些，在这儿顺便贴一个Scala版写的WordCount：\n\n```scala\nval wordCounts = textFile.flatMap(line => line.split(\" \"))\n                         .map(word => (word, 1))\n                         .reduceByKey((a, b) => a + b)\n```\n\n真是简洁，Spark真好，嘿嘿~\n","source":"_posts/2015-08-12-word-count-example-in-spark.markdown","raw":"---\nlayout: post\ntitle: \"利用Spark进行单词计数\"\ndate: 2015-08-12 13:38:08 +0800\ncomments: true\ncategories: [Big Data, Spark]\ntag: [Spark, Big Data]\n---\n\n这里就不再介绍Spark了，这篇文章主要记录一下关于Spark的核心`RDD`的相关操作以及以单词计数这个简单的例子，描述一下Spark的处理流程。\n\n## Spark RDD\nSpark是以RDD概念为中心运行的。RDD是一个容错的、可以被并行操作的元素集合。创建一个RDD有两个方法：在你的驱动程序中并行化一个已经存在的集合；从外部存储系统中引用一个数据集，这个存储系统可以是一个共享文件系统，比如HDFS、HBase或任意提供了Hadoop输入格式的数据来源。\n\nRDD支持两类操作：\n\n- 转换(Transform)\n- 动作(Action)\n\n还是不翻译的好，下面都用英文描述。`Transform`：用于从已有的数据集转换产生新的数据集，Transform的操作是`Lazy Evaluation`的，也就是说这条语句过后，转换并没有发生，而是在下一个`Action`调用的时候才会返回结果。`Action`：用于计算结果并向驱动程序返回结果。\n\n<!--more-->\n\n演示一下上面两种基本操作：\n\n```python\nlines = sc.textFile(\"data.txt\")\nlineLength = line.map(lambda x: len(x))\ntotalLength = lineLength.reduce(lambda x, y: x + y)\n```\n\n第一行是有外部存储系统中创建一个RDD对象，第二行定义map操作，是一个`Transform`操作，由于`Lazy Evaluation`，对象`lineLength`并没有立即计算得到。第三行，`reduce`是一个`Action`操作，这时，Spark将整个计算过程划分成许多任务在多台机器上并行执行，每台机器运行自己部分的map操作和reduce操作，最终将自己部分的运算结果返回给驱动程序。\n\n```python\n\tlineLength.persist()\n\t# lineLength.cache()\n```\n\n这一行，Spark将`lineLength`对象保存在内存中，以便后面计算中使用。Spark的一个重要功能就是在将数据集持久化（或缓存）到内存中以便在多个操作中重复使用。\n\n以上就是RDD的一些基本操作，API文档中写的都很清楚，我就不多说了。\n\n## 统计一篇文档中单词的个数\n首先，写一个函数，用来计算单词个数\n\n```python\ndef wordCount(wordListRDD):\n    wordCountsCollected = wordListRDD\n                                .map(lambda x: (x, 1))\n                                .reduceByKey(lambda x, y: x + y)\n    return wordCountsCollected\n```\n\n使用正则表达式清理原始文本\n\n```python\n\timport re\n\timport string\n\tdef removePunctuation(text):\n\t    regex = re.compile('[%s]' % re.escape(string.punctuation))\n\t    return regex.sub('', text).lower().strip()\n\tprint removePunctuation(' No under_score!')\n```\n\n去读文件内容到RDD中\n\n```python\n\timport os.path\n\tbaseDir = os.path.join('data')\n\tinputPath = os.path.join('cs100', 'lab1', 'shakespeare.txt')\n\tfileName = os.path.join(baseDir, inputPath)\n\t# \n\tshakespeareRDD = (sc.textFile(fileName, 8).map(removePunctuation))\n\tprint '\\n'.join(shakespeareRDD.zipWithIndex().map(lambda (l, num): '{0}: {1}'.format(num,l)).take(15))\n```\n\n这时候，需要把单词通过空格隔开，然后过滤掉为空的内容\n\n```python\nshakespeareWordsRDD = shakespeareRDD.flatMap(lambda x: x.split())\nshakespeareWordCount = shakespeareWordsRDD.count()\nprint shakespeareWordsRDD.top(5)\nshakeWordsRDD = shakespeareWordsRDD\n```\n\n统计出出现次数前15多的单词以及个数：\n\n```python\ntop15WordAndCounts = wordCount(shakeWordsRDD).takeOrdered(15, key=lambda (k, v): -v)\nprint '\\n'.join(map(lambda (w, c): '{0}: {1}'.format(w, c), top15WordsAndCounts))\n```\n\n输出结果为：\n\nword | count\n---- | ------\nthe: | 27361\nand: | 26028\ni:   | 20681\nto:  | 19150\nof:  | 17463\na:   | 14593\nyou: | 13615\nmy:  | 12481\nin:  | 10956\nthat:| 10890\nis:  | 9134\nnot: | 8497\nwith:| 7771\nme:  | 7769\nit:  | 7678\n     |\n\n\nSpark是用Scala写出来的，所以可想而知如果用Scala写的效率会比Python高一些，在这儿顺便贴一个Scala版写的WordCount：\n\n```scala\nval wordCounts = textFile.flatMap(line => line.split(\" \"))\n                         .map(word => (word, 1))\n                         .reduceByKey((a, b) => a + b)\n```\n\n真是简洁，Spark真好，嘿嘿~\n","slug":"2015-08-12-word-count-example-in-spark","published":1,"updated":"2016-09-20T02:07:00.000Z","photos":[],"link":"","_id":"cjfkkp3nk0011zd680q1xzux7","content":"<p>这里就不再介绍Spark了，这篇文章主要记录一下关于Spark的核心<code>RDD</code>的相关操作以及以单词计数这个简单的例子，描述一下Spark的处理流程。</p>\n<h2 id=\"Spark-RDD\"><a href=\"#Spark-RDD\" class=\"headerlink\" title=\"Spark RDD\"></a>Spark RDD</h2><p>Spark是以RDD概念为中心运行的。RDD是一个容错的、可以被并行操作的元素集合。创建一个RDD有两个方法：在你的驱动程序中并行化一个已经存在的集合；从外部存储系统中引用一个数据集，这个存储系统可以是一个共享文件系统，比如HDFS、HBase或任意提供了Hadoop输入格式的数据来源。</p>\n<p>RDD支持两类操作：</p>\n<ul>\n<li>转换(Transform)</li>\n<li>动作(Action)</li>\n</ul>\n<p>还是不翻译的好，下面都用英文描述。<code>Transform</code>：用于从已有的数据集转换产生新的数据集，Transform的操作是<code>Lazy Evaluation</code>的，也就是说这条语句过后，转换并没有发生，而是在下一个<code>Action</code>调用的时候才会返回结果。<code>Action</code>：用于计算结果并向驱动程序返回结果。</p>\n<a id=\"more\"></a>\n<p>演示一下上面两种基本操作：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lines = sc.textFile(<span class=\"string\">\"data.txt\"</span>)</span><br><span class=\"line\">lineLength = line.map(<span class=\"keyword\">lambda</span> x: len(x))</span><br><span class=\"line\">totalLength = lineLength.reduce(<span class=\"keyword\">lambda</span> x, y: x + y)</span><br></pre></td></tr></table></figure>\n<p>第一行是有外部存储系统中创建一个RDD对象，第二行定义map操作，是一个<code>Transform</code>操作，由于<code>Lazy Evaluation</code>，对象<code>lineLength</code>并没有立即计算得到。第三行，<code>reduce</code>是一个<code>Action</code>操作，这时，Spark将整个计算过程划分成许多任务在多台机器上并行执行，每台机器运行自己部分的map操作和reduce操作，最终将自己部分的运算结果返回给驱动程序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lineLength.persist()</span><br><span class=\"line\"><span class=\"comment\"># lineLength.cache()</span></span><br></pre></td></tr></table></figure>\n<p>这一行，Spark将<code>lineLength</code>对象保存在内存中，以便后面计算中使用。Spark的一个重要功能就是在将数据集持久化（或缓存）到内存中以便在多个操作中重复使用。</p>\n<p>以上就是RDD的一些基本操作，API文档中写的都很清楚，我就不多说了。</p>\n<h2 id=\"统计一篇文档中单词的个数\"><a href=\"#统计一篇文档中单词的个数\" class=\"headerlink\" title=\"统计一篇文档中单词的个数\"></a>统计一篇文档中单词的个数</h2><p>首先，写一个函数，用来计算单词个数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wordCount</span><span class=\"params\">(wordListRDD)</span>:</span></span><br><span class=\"line\">    wordCountsCollected = wordListRDD</span><br><span class=\"line\">                                .map(<span class=\"keyword\">lambda</span> x: (x, <span class=\"number\">1</span>))</span><br><span class=\"line\">                                .reduceByKey(<span class=\"keyword\">lambda</span> x, y: x + y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wordCountsCollected</span><br></pre></td></tr></table></figure>\n<p>使用正则表达式清理原始文本</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> string</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removePunctuation</span><span class=\"params\">(text)</span>:</span></span><br><span class=\"line\">    regex = re.compile(<span class=\"string\">'[%s]'</span> % re.escape(string.punctuation))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> regex.sub(<span class=\"string\">''</span>, text).lower().strip()</span><br><span class=\"line\"><span class=\"keyword\">print</span> removePunctuation(<span class=\"string\">' No under_score!'</span>)</span><br></pre></td></tr></table></figure>\n<p>去读文件内容到RDD中</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os.path</span><br><span class=\"line\">baseDir = os.path.join(<span class=\"string\">'data'</span>)</span><br><span class=\"line\">inputPath = os.path.join(<span class=\"string\">'cs100'</span>, <span class=\"string\">'lab1'</span>, <span class=\"string\">'shakespeare.txt'</span>)</span><br><span class=\"line\">fileName = os.path.join(baseDir, inputPath)</span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\">shakespeareRDD = (sc.textFile(fileName, <span class=\"number\">8</span>).map(removePunctuation))</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'\\n'</span>.join(shakespeareRDD.zipWithIndex().map(<span class=\"keyword\">lambda</span> (l, num): <span class=\"string\">'&#123;0&#125;: &#123;1&#125;'</span>.format(num,l)).take(<span class=\"number\">15</span>))</span><br></pre></td></tr></table></figure>\n<p>这时候，需要把单词通过空格隔开，然后过滤掉为空的内容</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shakespeareWordsRDD = shakespeareRDD.flatMap(<span class=\"keyword\">lambda</span> x: x.split())</span><br><span class=\"line\">shakespeareWordCount = shakespeareWordsRDD.count()</span><br><span class=\"line\"><span class=\"keyword\">print</span> shakespeareWordsRDD.top(<span class=\"number\">5</span>)</span><br><span class=\"line\">shakeWordsRDD = shakespeareWordsRDD</span><br></pre></td></tr></table></figure>\n<p>统计出出现次数前15多的单词以及个数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top15WordAndCounts = wordCount(shakeWordsRDD).takeOrdered(<span class=\"number\">15</span>, key=<span class=\"keyword\">lambda</span> (k, v): -v)</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'\\n'</span>.join(map(<span class=\"keyword\">lambda</span> (w, c): <span class=\"string\">'&#123;0&#125;: &#123;1&#125;'</span>.format(w, c), top15WordsAndCounts))</span><br></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<table>\n<thead>\n<tr>\n<th>word</th>\n<th>count</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>the:</td>\n<td>27361</td>\n</tr>\n<tr>\n<td>and:</td>\n<td>26028</td>\n</tr>\n<tr>\n<td>i:</td>\n<td>20681</td>\n</tr>\n<tr>\n<td>to:</td>\n<td>19150</td>\n</tr>\n<tr>\n<td>of:</td>\n<td>17463</td>\n</tr>\n<tr>\n<td>a:</td>\n<td>14593</td>\n</tr>\n<tr>\n<td>you:</td>\n<td>13615</td>\n</tr>\n<tr>\n<td>my:</td>\n<td>12481</td>\n</tr>\n<tr>\n<td>in:</td>\n<td>10956</td>\n</tr>\n<tr>\n<td>that:</td>\n<td>10890</td>\n</tr>\n<tr>\n<td>is:</td>\n<td>9134</td>\n</tr>\n<tr>\n<td>not:</td>\n<td>8497</td>\n</tr>\n<tr>\n<td>with:</td>\n<td>7771</td>\n</tr>\n<tr>\n<td>me:</td>\n<td>7769</td>\n</tr>\n<tr>\n<td>it:</td>\n<td>7678</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>Spark是用Scala写出来的，所以可想而知如果用Scala写的效率会比Python高一些，在这儿顺便贴一个Scala版写的WordCount：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> wordCounts = textFile.flatMap(line =&gt; line.split(<span class=\"string\">\" \"</span>))</span><br><span class=\"line\">                         .map(word =&gt; (word, <span class=\"number\">1</span>))</span><br><span class=\"line\">                         .reduceByKey((a, b) =&gt; a + b)</span><br></pre></td></tr></table></figure>\n<p>真是简洁，Spark真好，嘿嘿~</p>\n","site":{"data":{}},"excerpt":"<p>这里就不再介绍Spark了，这篇文章主要记录一下关于Spark的核心<code>RDD</code>的相关操作以及以单词计数这个简单的例子，描述一下Spark的处理流程。</p>\n<h2 id=\"Spark-RDD\"><a href=\"#Spark-RDD\" class=\"headerlink\" title=\"Spark RDD\"></a>Spark RDD</h2><p>Spark是以RDD概念为中心运行的。RDD是一个容错的、可以被并行操作的元素集合。创建一个RDD有两个方法：在你的驱动程序中并行化一个已经存在的集合；从外部存储系统中引用一个数据集，这个存储系统可以是一个共享文件系统，比如HDFS、HBase或任意提供了Hadoop输入格式的数据来源。</p>\n<p>RDD支持两类操作：</p>\n<ul>\n<li>转换(Transform)</li>\n<li>动作(Action)</li>\n</ul>\n<p>还是不翻译的好，下面都用英文描述。<code>Transform</code>：用于从已有的数据集转换产生新的数据集，Transform的操作是<code>Lazy Evaluation</code>的，也就是说这条语句过后，转换并没有发生，而是在下一个<code>Action</code>调用的时候才会返回结果。<code>Action</code>：用于计算结果并向驱动程序返回结果。</p>","more":"<p>演示一下上面两种基本操作：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lines = sc.textFile(<span class=\"string\">\"data.txt\"</span>)</span><br><span class=\"line\">lineLength = line.map(<span class=\"keyword\">lambda</span> x: len(x))</span><br><span class=\"line\">totalLength = lineLength.reduce(<span class=\"keyword\">lambda</span> x, y: x + y)</span><br></pre></td></tr></table></figure>\n<p>第一行是有外部存储系统中创建一个RDD对象，第二行定义map操作，是一个<code>Transform</code>操作，由于<code>Lazy Evaluation</code>，对象<code>lineLength</code>并没有立即计算得到。第三行，<code>reduce</code>是一个<code>Action</code>操作，这时，Spark将整个计算过程划分成许多任务在多台机器上并行执行，每台机器运行自己部分的map操作和reduce操作，最终将自己部分的运算结果返回给驱动程序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lineLength.persist()</span><br><span class=\"line\"><span class=\"comment\"># lineLength.cache()</span></span><br></pre></td></tr></table></figure>\n<p>这一行，Spark将<code>lineLength</code>对象保存在内存中，以便后面计算中使用。Spark的一个重要功能就是在将数据集持久化（或缓存）到内存中以便在多个操作中重复使用。</p>\n<p>以上就是RDD的一些基本操作，API文档中写的都很清楚，我就不多说了。</p>\n<h2 id=\"统计一篇文档中单词的个数\"><a href=\"#统计一篇文档中单词的个数\" class=\"headerlink\" title=\"统计一篇文档中单词的个数\"></a>统计一篇文档中单词的个数</h2><p>首先，写一个函数，用来计算单词个数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wordCount</span><span class=\"params\">(wordListRDD)</span>:</span></span><br><span class=\"line\">    wordCountsCollected = wordListRDD</span><br><span class=\"line\">                                .map(<span class=\"keyword\">lambda</span> x: (x, <span class=\"number\">1</span>))</span><br><span class=\"line\">                                .reduceByKey(<span class=\"keyword\">lambda</span> x, y: x + y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wordCountsCollected</span><br></pre></td></tr></table></figure>\n<p>使用正则表达式清理原始文本</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> string</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removePunctuation</span><span class=\"params\">(text)</span>:</span></span><br><span class=\"line\">    regex = re.compile(<span class=\"string\">'[%s]'</span> % re.escape(string.punctuation))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> regex.sub(<span class=\"string\">''</span>, text).lower().strip()</span><br><span class=\"line\"><span class=\"keyword\">print</span> removePunctuation(<span class=\"string\">' No under_score!'</span>)</span><br></pre></td></tr></table></figure>\n<p>去读文件内容到RDD中</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os.path</span><br><span class=\"line\">baseDir = os.path.join(<span class=\"string\">'data'</span>)</span><br><span class=\"line\">inputPath = os.path.join(<span class=\"string\">'cs100'</span>, <span class=\"string\">'lab1'</span>, <span class=\"string\">'shakespeare.txt'</span>)</span><br><span class=\"line\">fileName = os.path.join(baseDir, inputPath)</span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\">shakespeareRDD = (sc.textFile(fileName, <span class=\"number\">8</span>).map(removePunctuation))</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'\\n'</span>.join(shakespeareRDD.zipWithIndex().map(<span class=\"keyword\">lambda</span> (l, num): <span class=\"string\">'&#123;0&#125;: &#123;1&#125;'</span>.format(num,l)).take(<span class=\"number\">15</span>))</span><br></pre></td></tr></table></figure>\n<p>这时候，需要把单词通过空格隔开，然后过滤掉为空的内容</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shakespeareWordsRDD = shakespeareRDD.flatMap(<span class=\"keyword\">lambda</span> x: x.split())</span><br><span class=\"line\">shakespeareWordCount = shakespeareWordsRDD.count()</span><br><span class=\"line\"><span class=\"keyword\">print</span> shakespeareWordsRDD.top(<span class=\"number\">5</span>)</span><br><span class=\"line\">shakeWordsRDD = shakespeareWordsRDD</span><br></pre></td></tr></table></figure>\n<p>统计出出现次数前15多的单词以及个数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top15WordAndCounts = wordCount(shakeWordsRDD).takeOrdered(<span class=\"number\">15</span>, key=<span class=\"keyword\">lambda</span> (k, v): -v)</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'\\n'</span>.join(map(<span class=\"keyword\">lambda</span> (w, c): <span class=\"string\">'&#123;0&#125;: &#123;1&#125;'</span>.format(w, c), top15WordsAndCounts))</span><br></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<table>\n<thead>\n<tr>\n<th>word</th>\n<th>count</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>the:</td>\n<td>27361</td>\n</tr>\n<tr>\n<td>and:</td>\n<td>26028</td>\n</tr>\n<tr>\n<td>i:</td>\n<td>20681</td>\n</tr>\n<tr>\n<td>to:</td>\n<td>19150</td>\n</tr>\n<tr>\n<td>of:</td>\n<td>17463</td>\n</tr>\n<tr>\n<td>a:</td>\n<td>14593</td>\n</tr>\n<tr>\n<td>you:</td>\n<td>13615</td>\n</tr>\n<tr>\n<td>my:</td>\n<td>12481</td>\n</tr>\n<tr>\n<td>in:</td>\n<td>10956</td>\n</tr>\n<tr>\n<td>that:</td>\n<td>10890</td>\n</tr>\n<tr>\n<td>is:</td>\n<td>9134</td>\n</tr>\n<tr>\n<td>not:</td>\n<td>8497</td>\n</tr>\n<tr>\n<td>with:</td>\n<td>7771</td>\n</tr>\n<tr>\n<td>me:</td>\n<td>7769</td>\n</tr>\n<tr>\n<td>it:</td>\n<td>7678</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>Spark是用Scala写出来的，所以可想而知如果用Scala写的效率会比Python高一些，在这儿顺便贴一个Scala版写的WordCount：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> wordCounts = textFile.flatMap(line =&gt; line.split(<span class=\"string\">\" \"</span>))</span><br><span class=\"line\">                         .map(word =&gt; (word, <span class=\"number\">1</span>))</span><br><span class=\"line\">                         .reduceByKey((a, b) =&gt; a + b)</span><br></pre></td></tr></table></figure>\n<p>真是简洁，Spark真好，嘿嘿~</p>"},{"layout":"post","title":"单变量线性回归","date":"2015-08-13T07:10:52.000Z","comments":1,"_content":"\n1月份的时候，参加了Coursera上面Andrew Ng的[Machine Learning](https://www.coursera.org/learn/machine-learning/home/welcome)课程，课程断断续续的学，没有透彻的理解、推导，再加上作业使用Octave完成，并且还是有模版的，不是从头到尾做出来的，所以效果很差，虽然拿到了完成证书，但是过后即忘。我觉得是时候从头学习一遍，并且用Python实现所有的作业内容了。\n\n这里写个系列，就当作为这门课程的课程笔记。\n\n<!--more-->\n\n机器学习的本质是首先将训练集“喂给”学习算法，进而学习到一个假设(Hypothesis)，然后将特征值作为输入变量输入给Hypothesis，得出输出结果。\n\n![process](http://7xkfga.com1.z0.glb.clouddn.com/process.png)\n\n## 线性回归\n\n先说一元线性回归，这里只有一个特征值x，Hypothesis可以写为\n\n$$h\\_{\\theta }\\left( x\\right) =\\theta\\_{0}+\\theta\\_{1}x$$\n\n### 代价函数 Cost Function\n\n现在假设已经有了这个假设，那么如何评价这个假设的准确性呢，这里用模型预测的值减去训练集中实际值来衡量，这个叫建模误差。线性回归的目标就是使建模误差最小化，从而找出能使建模误差最小化的模型参数。代价函数为：\n\n$$J(\\theta) = \\frac{1}{2m}\\sum\\_{i=1}^m (h_\\theta(x^{(i)})-y^{(i)})^2$$\n\n则目标为求出使得$J(\\theta)$最小的$\\theta$参数\n\n### 梯度下降算法\n\n现在使用梯度下降算法来求出$\\theta$参数，梯度下降算法的推导如下：\n\n$$\\begin{aligned} \\theta_j:=\\theta_j-\\alpha\\frac{\\partial J(\\theta)}{\\partial\\theta_j} \\end{aligned}$$\n\n对$\\theta_0$的偏导数为：\n\n$$\\begin{aligned}\n        \\frac{\\partial}{\\partial \\theta_0}J(\\theta_0, \\theta\\_1) = \\frac\\{1}{m} \\sum\\_{i=1}^m (h_\\theta(x^{(i)})-y^{(i)})\n\\end{aligned}$$\n\n对$\\theta_1$的偏导数为：\n\n$$\\begin{aligned}\n        \\frac{\\partial}{\\partial \\theta_1}J(\\theta_0, \\theta\\_1) = \\frac\\{1}{m} \\sum\\_{i=1}^m (h_\\theta(x^{(i)})-y^{(i)})x^{(i)}\n\\end{aligned}$$\n\n## 使用Python实现一元线性回归\n\n为了提高性能，使用 `numpy` 包来实现向量化计算，\n\n```python\nimport numpy as np\n\ndef hypothesis(theta, x):\n    return np.dot(x, theta)\n\ndef cost_function(theta, x, y):\n    loss = hypothesis(theta, x) - y\n    return np.sum(loss ** 2) / (2 * len(y))\n```\n\n实现梯度下降算法，需要计算下面四个部分：\n1. 计算假设Hypothesis\n2. 计算损失 loss = hypothesis - y，然后求出square root\n3. 计算Gradient = X' * loss / m\n4. 更新参数theta -= alpha * gradient\n\n```python\ndef gradient_descent(alpha, x, y, iters):\n    # number of training dataset\n    m = x.shape[0]\n    theta = np.zeros(2)\n    cost_iter = []\n    for iter in range(iters):\n        h_theta = hypothesis(theta, x)\n        loss = h_theta - y\n        J = np.sum(loss ** 2) / (2 * m)\n        cost_iter.append([iter, J])\n        # print \"iter %s | J: %.3f\" % (iter, J)\n        gradient = np.dot(x.T, loss) / m\n        theta -= alpha * gradient\n    return theta, cost_iter\n```\n\n接下来造一些假数据试验一下\n\n```python\nfrom sklearn.datasets.samples_generator import make_regression\nx, y = make_regression(n_samples=100, n_features=1, n_informative=1, random_state=0, noise=35)\nm, n = np.shape(x)\nx = np.c_[np.ones(m), x] ## add column value 1 as x0\nalpha = 0.01\ntheta, cost_iter = gradient_descent(alpha, x, y, 1000)\nprint theta\n```\n\n求出的参数值为[-2.8484052 , 43.202331]\n\n将训练集数据和Hypothesis函数画出来\n\n```python\nfor i in range(x.shape[1]):\n    y_predict = theta[0] + theta[1] * x\nplt.plot(x[:, 1], y, 'o')\nplt.plot(x, y_predict, 'k-')\n```\n\n![linear_regression_plot](http://7xkfga.com1.z0.glb.clouddn.com/linear_reg_plot.png)\n\n接下来画出代价函数在每次迭代过程中的变化趋势，可以看出算法是否收敛\n\n```python\nplt.plot(cost_iter[:500, 0], cost_iter[:500, 1])\nplt.xlabel(\"Iteration Number\")\nplt.ylabel(\"Cost\")\n```\n\n![cost_trend](http://7xkfga.com1.z0.glb.clouddn.com/cost_trend.png)\n\n接下来有必要好好复习一下线性代数、numpy和向量化计算。\n","source":"_posts/2015-08-19-linear-regression-with-one-variable.markdown","raw":"---\nlayout: post\ntitle: \"单变量线性回归\"\ndate: 2015-08-13 15:10:52 +0800\ncomments: true\ncategories: [算法, Python]\ntag: [Algorithm, Coursera, Machine Learning, Python]\n---\n\n1月份的时候，参加了Coursera上面Andrew Ng的[Machine Learning](https://www.coursera.org/learn/machine-learning/home/welcome)课程，课程断断续续的学，没有透彻的理解、推导，再加上作业使用Octave完成，并且还是有模版的，不是从头到尾做出来的，所以效果很差，虽然拿到了完成证书，但是过后即忘。我觉得是时候从头学习一遍，并且用Python实现所有的作业内容了。\n\n这里写个系列，就当作为这门课程的课程笔记。\n\n<!--more-->\n\n机器学习的本质是首先将训练集“喂给”学习算法，进而学习到一个假设(Hypothesis)，然后将特征值作为输入变量输入给Hypothesis，得出输出结果。\n\n![process](http://7xkfga.com1.z0.glb.clouddn.com/process.png)\n\n## 线性回归\n\n先说一元线性回归，这里只有一个特征值x，Hypothesis可以写为\n\n$$h\\_{\\theta }\\left( x\\right) =\\theta\\_{0}+\\theta\\_{1}x$$\n\n### 代价函数 Cost Function\n\n现在假设已经有了这个假设，那么如何评价这个假设的准确性呢，这里用模型预测的值减去训练集中实际值来衡量，这个叫建模误差。线性回归的目标就是使建模误差最小化，从而找出能使建模误差最小化的模型参数。代价函数为：\n\n$$J(\\theta) = \\frac{1}{2m}\\sum\\_{i=1}^m (h_\\theta(x^{(i)})-y^{(i)})^2$$\n\n则目标为求出使得$J(\\theta)$最小的$\\theta$参数\n\n### 梯度下降算法\n\n现在使用梯度下降算法来求出$\\theta$参数，梯度下降算法的推导如下：\n\n$$\\begin{aligned} \\theta_j:=\\theta_j-\\alpha\\frac{\\partial J(\\theta)}{\\partial\\theta_j} \\end{aligned}$$\n\n对$\\theta_0$的偏导数为：\n\n$$\\begin{aligned}\n        \\frac{\\partial}{\\partial \\theta_0}J(\\theta_0, \\theta\\_1) = \\frac\\{1}{m} \\sum\\_{i=1}^m (h_\\theta(x^{(i)})-y^{(i)})\n\\end{aligned}$$\n\n对$\\theta_1$的偏导数为：\n\n$$\\begin{aligned}\n        \\frac{\\partial}{\\partial \\theta_1}J(\\theta_0, \\theta\\_1) = \\frac\\{1}{m} \\sum\\_{i=1}^m (h_\\theta(x^{(i)})-y^{(i)})x^{(i)}\n\\end{aligned}$$\n\n## 使用Python实现一元线性回归\n\n为了提高性能，使用 `numpy` 包来实现向量化计算，\n\n```python\nimport numpy as np\n\ndef hypothesis(theta, x):\n    return np.dot(x, theta)\n\ndef cost_function(theta, x, y):\n    loss = hypothesis(theta, x) - y\n    return np.sum(loss ** 2) / (2 * len(y))\n```\n\n实现梯度下降算法，需要计算下面四个部分：\n1. 计算假设Hypothesis\n2. 计算损失 loss = hypothesis - y，然后求出square root\n3. 计算Gradient = X' * loss / m\n4. 更新参数theta -= alpha * gradient\n\n```python\ndef gradient_descent(alpha, x, y, iters):\n    # number of training dataset\n    m = x.shape[0]\n    theta = np.zeros(2)\n    cost_iter = []\n    for iter in range(iters):\n        h_theta = hypothesis(theta, x)\n        loss = h_theta - y\n        J = np.sum(loss ** 2) / (2 * m)\n        cost_iter.append([iter, J])\n        # print \"iter %s | J: %.3f\" % (iter, J)\n        gradient = np.dot(x.T, loss) / m\n        theta -= alpha * gradient\n    return theta, cost_iter\n```\n\n接下来造一些假数据试验一下\n\n```python\nfrom sklearn.datasets.samples_generator import make_regression\nx, y = make_regression(n_samples=100, n_features=1, n_informative=1, random_state=0, noise=35)\nm, n = np.shape(x)\nx = np.c_[np.ones(m), x] ## add column value 1 as x0\nalpha = 0.01\ntheta, cost_iter = gradient_descent(alpha, x, y, 1000)\nprint theta\n```\n\n求出的参数值为[-2.8484052 , 43.202331]\n\n将训练集数据和Hypothesis函数画出来\n\n```python\nfor i in range(x.shape[1]):\n    y_predict = theta[0] + theta[1] * x\nplt.plot(x[:, 1], y, 'o')\nplt.plot(x, y_predict, 'k-')\n```\n\n![linear_regression_plot](http://7xkfga.com1.z0.glb.clouddn.com/linear_reg_plot.png)\n\n接下来画出代价函数在每次迭代过程中的变化趋势，可以看出算法是否收敛\n\n```python\nplt.plot(cost_iter[:500, 0], cost_iter[:500, 1])\nplt.xlabel(\"Iteration Number\")\nplt.ylabel(\"Cost\")\n```\n\n![cost_trend](http://7xkfga.com1.z0.glb.clouddn.com/cost_trend.png)\n\n接下来有必要好好复习一下线性代数、numpy和向量化计算。\n","slug":"2015-08-19-linear-regression-with-one-variable","published":1,"updated":"2016-09-20T02:07:00.000Z","photos":[],"link":"","_id":"cjfkkp3nl0014zd68uhpxd9ms","content":"<p>1月份的时候，参加了Coursera上面Andrew Ng的<a href=\"https://www.coursera.org/learn/machine-learning/home/welcome\" target=\"_blank\" rel=\"noopener\">Machine Learning</a>课程，课程断断续续的学，没有透彻的理解、推导，再加上作业使用Octave完成，并且还是有模版的，不是从头到尾做出来的，所以效果很差，虽然拿到了完成证书，但是过后即忘。我觉得是时候从头学习一遍，并且用Python实现所有的作业内容了。</p>\n<p>这里写个系列，就当作为这门课程的课程笔记。</p>\n<a id=\"more\"></a>\n<p>机器学习的本质是首先将训练集“喂给”学习算法，进而学习到一个假设(Hypothesis)，然后将特征值作为输入变量输入给Hypothesis，得出输出结果。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/process.png\" alt=\"process\"></p>\n<h2 id=\"线性回归\"><a href=\"#线性回归\" class=\"headerlink\" title=\"线性回归\"></a>线性回归</h2><p>先说一元线性回归，这里只有一个特征值x，Hypothesis可以写为</p>\n<p>$$h_{\\theta }\\left( x\\right) =\\theta_{0}+\\theta_{1}x$$</p>\n<h3 id=\"代价函数-Cost-Function\"><a href=\"#代价函数-Cost-Function\" class=\"headerlink\" title=\"代价函数 Cost Function\"></a>代价函数 Cost Function</h3><p>现在假设已经有了这个假设，那么如何评价这个假设的准确性呢，这里用模型预测的值减去训练集中实际值来衡量，这个叫建模误差。线性回归的目标就是使建模误差最小化，从而找出能使建模误差最小化的模型参数。代价函数为：</p>\n<p>$$J(\\theta) = \\frac{1}{2m}\\sum_{i=1}^m (h_\\theta(x^{(i)})-y^{(i)})^2$$</p>\n<p>则目标为求出使得$J(\\theta)$最小的$\\theta$参数</p>\n<h3 id=\"梯度下降算法\"><a href=\"#梯度下降算法\" class=\"headerlink\" title=\"梯度下降算法\"></a>梯度下降算法</h3><p>现在使用梯度下降算法来求出$\\theta$参数，梯度下降算法的推导如下：</p>\n<p>$$\\begin{aligned} \\theta_j:=\\theta_j-\\alpha\\frac{\\partial J(\\theta)}{\\partial\\theta_j} \\end{aligned}$$</p>\n<p>对$\\theta_0$的偏导数为：</p>\n<p>$$\\begin{aligned}<br>        \\frac{\\partial}{\\partial \\theta_0}J(\\theta_0, \\theta_1) = \\frac{1}{m} \\sum_{i=1}^m (h_\\theta(x^{(i)})-y^{(i)})<br>\\end{aligned}$$</p>\n<p>对$\\theta_1$的偏导数为：</p>\n<p>$$\\begin{aligned}<br>        \\frac{\\partial}{\\partial \\theta_1}J(\\theta_0, \\theta_1) = \\frac{1}{m} \\sum_{i=1}^m (h_\\theta(x^{(i)})-y^{(i)})x^{(i)}<br>\\end{aligned}$$</p>\n<h2 id=\"使用Python实现一元线性回归\"><a href=\"#使用Python实现一元线性回归\" class=\"headerlink\" title=\"使用Python实现一元线性回归\"></a>使用Python实现一元线性回归</h2><p>为了提高性能，使用 <code>numpy</code> 包来实现向量化计算，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hypothesis</span><span class=\"params\">(theta, x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.dot(x, theta)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cost_function</span><span class=\"params\">(theta, x, y)</span>:</span></span><br><span class=\"line\">    loss = hypothesis(theta, x) - y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.sum(loss ** <span class=\"number\">2</span>) / (<span class=\"number\">2</span> * len(y))</span><br></pre></td></tr></table></figure>\n<p>实现梯度下降算法，需要计算下面四个部分：</p>\n<ol>\n<li>计算假设Hypothesis</li>\n<li>计算损失 loss = hypothesis - y，然后求出square root</li>\n<li>计算Gradient = X’ * loss / m</li>\n<li>更新参数theta -= alpha * gradient</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gradient_descent</span><span class=\"params\">(alpha, x, y, iters)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># number of training dataset</span></span><br><span class=\"line\">    m = x.shape[<span class=\"number\">0</span>]</span><br><span class=\"line\">    theta = np.zeros(<span class=\"number\">2</span>)</span><br><span class=\"line\">    cost_iter = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> iter <span class=\"keyword\">in</span> range(iters):</span><br><span class=\"line\">        h_theta = hypothesis(theta, x)</span><br><span class=\"line\">        loss = h_theta - y</span><br><span class=\"line\">        J = np.sum(loss ** <span class=\"number\">2</span>) / (<span class=\"number\">2</span> * m)</span><br><span class=\"line\">        cost_iter.append([iter, J])</span><br><span class=\"line\">        <span class=\"comment\"># print \"iter %s | J: %.3f\" % (iter, J)</span></span><br><span class=\"line\">        gradient = np.dot(x.T, loss) / m</span><br><span class=\"line\">        theta -= alpha * gradient</span><br><span class=\"line\">    <span class=\"keyword\">return</span> theta, cost_iter</span><br></pre></td></tr></table></figure>\n<p>接下来造一些假数据试验一下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.datasets.samples_generator <span class=\"keyword\">import</span> make_regression</span><br><span class=\"line\">x, y = make_regression(n_samples=<span class=\"number\">100</span>, n_features=<span class=\"number\">1</span>, n_informative=<span class=\"number\">1</span>, random_state=<span class=\"number\">0</span>, noise=<span class=\"number\">35</span>)</span><br><span class=\"line\">m, n = np.shape(x)</span><br><span class=\"line\">x = np.c_[np.ones(m), x] <span class=\"comment\">## add column value 1 as x0</span></span><br><span class=\"line\">alpha = <span class=\"number\">0.01</span></span><br><span class=\"line\">theta, cost_iter = gradient_descent(alpha, x, y, <span class=\"number\">1000</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> theta</span><br></pre></td></tr></table></figure>\n<p>求出的参数值为[-2.8484052 , 43.202331]</p>\n<p>将训练集数据和Hypothesis函数画出来</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(x.shape[<span class=\"number\">1</span>]):</span><br><span class=\"line\">    y_predict = theta[<span class=\"number\">0</span>] + theta[<span class=\"number\">1</span>] * x</span><br><span class=\"line\">plt.plot(x[:, <span class=\"number\">1</span>], y, <span class=\"string\">'o'</span>)</span><br><span class=\"line\">plt.plot(x, y_predict, <span class=\"string\">'k-'</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/linear_reg_plot.png\" alt=\"linear_regression_plot\"></p>\n<p>接下来画出代价函数在每次迭代过程中的变化趋势，可以看出算法是否收敛</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plt.plot(cost_iter[:<span class=\"number\">500</span>, <span class=\"number\">0</span>], cost_iter[:<span class=\"number\">500</span>, <span class=\"number\">1</span>])</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">\"Iteration Number\"</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">\"Cost\"</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/cost_trend.png\" alt=\"cost_trend\"></p>\n<p>接下来有必要好好复习一下线性代数、numpy和向量化计算。</p>\n","site":{"data":{}},"excerpt":"<p>1月份的时候，参加了Coursera上面Andrew Ng的<a href=\"https://www.coursera.org/learn/machine-learning/home/welcome\" target=\"_blank\" rel=\"noopener\">Machine Learning</a>课程，课程断断续续的学，没有透彻的理解、推导，再加上作业使用Octave完成，并且还是有模版的，不是从头到尾做出来的，所以效果很差，虽然拿到了完成证书，但是过后即忘。我觉得是时候从头学习一遍，并且用Python实现所有的作业内容了。</p>\n<p>这里写个系列，就当作为这门课程的课程笔记。</p>","more":"<p>机器学习的本质是首先将训练集“喂给”学习算法，进而学习到一个假设(Hypothesis)，然后将特征值作为输入变量输入给Hypothesis，得出输出结果。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/process.png\" alt=\"process\"></p>\n<h2 id=\"线性回归\"><a href=\"#线性回归\" class=\"headerlink\" title=\"线性回归\"></a>线性回归</h2><p>先说一元线性回归，这里只有一个特征值x，Hypothesis可以写为</p>\n<p>$$h_{\\theta }\\left( x\\right) =\\theta_{0}+\\theta_{1}x$$</p>\n<h3 id=\"代价函数-Cost-Function\"><a href=\"#代价函数-Cost-Function\" class=\"headerlink\" title=\"代价函数 Cost Function\"></a>代价函数 Cost Function</h3><p>现在假设已经有了这个假设，那么如何评价这个假设的准确性呢，这里用模型预测的值减去训练集中实际值来衡量，这个叫建模误差。线性回归的目标就是使建模误差最小化，从而找出能使建模误差最小化的模型参数。代价函数为：</p>\n<p>$$J(\\theta) = \\frac{1}{2m}\\sum_{i=1}^m (h_\\theta(x^{(i)})-y^{(i)})^2$$</p>\n<p>则目标为求出使得$J(\\theta)$最小的$\\theta$参数</p>\n<h3 id=\"梯度下降算法\"><a href=\"#梯度下降算法\" class=\"headerlink\" title=\"梯度下降算法\"></a>梯度下降算法</h3><p>现在使用梯度下降算法来求出$\\theta$参数，梯度下降算法的推导如下：</p>\n<p>$$\\begin{aligned} \\theta_j:=\\theta_j-\\alpha\\frac{\\partial J(\\theta)}{\\partial\\theta_j} \\end{aligned}$$</p>\n<p>对$\\theta_0$的偏导数为：</p>\n<p>$$\\begin{aligned}<br>        \\frac{\\partial}{\\partial \\theta_0}J(\\theta_0, \\theta_1) = \\frac{1}{m} \\sum_{i=1}^m (h_\\theta(x^{(i)})-y^{(i)})<br>\\end{aligned}$$</p>\n<p>对$\\theta_1$的偏导数为：</p>\n<p>$$\\begin{aligned}<br>        \\frac{\\partial}{\\partial \\theta_1}J(\\theta_0, \\theta_1) = \\frac{1}{m} \\sum_{i=1}^m (h_\\theta(x^{(i)})-y^{(i)})x^{(i)}<br>\\end{aligned}$$</p>\n<h2 id=\"使用Python实现一元线性回归\"><a href=\"#使用Python实现一元线性回归\" class=\"headerlink\" title=\"使用Python实现一元线性回归\"></a>使用Python实现一元线性回归</h2><p>为了提高性能，使用 <code>numpy</code> 包来实现向量化计算，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hypothesis</span><span class=\"params\">(theta, x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.dot(x, theta)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cost_function</span><span class=\"params\">(theta, x, y)</span>:</span></span><br><span class=\"line\">    loss = hypothesis(theta, x) - y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.sum(loss ** <span class=\"number\">2</span>) / (<span class=\"number\">2</span> * len(y))</span><br></pre></td></tr></table></figure>\n<p>实现梯度下降算法，需要计算下面四个部分：</p>\n<ol>\n<li>计算假设Hypothesis</li>\n<li>计算损失 loss = hypothesis - y，然后求出square root</li>\n<li>计算Gradient = X’ * loss / m</li>\n<li>更新参数theta -= alpha * gradient</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gradient_descent</span><span class=\"params\">(alpha, x, y, iters)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># number of training dataset</span></span><br><span class=\"line\">    m = x.shape[<span class=\"number\">0</span>]</span><br><span class=\"line\">    theta = np.zeros(<span class=\"number\">2</span>)</span><br><span class=\"line\">    cost_iter = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> iter <span class=\"keyword\">in</span> range(iters):</span><br><span class=\"line\">        h_theta = hypothesis(theta, x)</span><br><span class=\"line\">        loss = h_theta - y</span><br><span class=\"line\">        J = np.sum(loss ** <span class=\"number\">2</span>) / (<span class=\"number\">2</span> * m)</span><br><span class=\"line\">        cost_iter.append([iter, J])</span><br><span class=\"line\">        <span class=\"comment\"># print \"iter %s | J: %.3f\" % (iter, J)</span></span><br><span class=\"line\">        gradient = np.dot(x.T, loss) / m</span><br><span class=\"line\">        theta -= alpha * gradient</span><br><span class=\"line\">    <span class=\"keyword\">return</span> theta, cost_iter</span><br></pre></td></tr></table></figure>\n<p>接下来造一些假数据试验一下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.datasets.samples_generator <span class=\"keyword\">import</span> make_regression</span><br><span class=\"line\">x, y = make_regression(n_samples=<span class=\"number\">100</span>, n_features=<span class=\"number\">1</span>, n_informative=<span class=\"number\">1</span>, random_state=<span class=\"number\">0</span>, noise=<span class=\"number\">35</span>)</span><br><span class=\"line\">m, n = np.shape(x)</span><br><span class=\"line\">x = np.c_[np.ones(m), x] <span class=\"comment\">## add column value 1 as x0</span></span><br><span class=\"line\">alpha = <span class=\"number\">0.01</span></span><br><span class=\"line\">theta, cost_iter = gradient_descent(alpha, x, y, <span class=\"number\">1000</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> theta</span><br></pre></td></tr></table></figure>\n<p>求出的参数值为[-2.8484052 , 43.202331]</p>\n<p>将训练集数据和Hypothesis函数画出来</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(x.shape[<span class=\"number\">1</span>]):</span><br><span class=\"line\">    y_predict = theta[<span class=\"number\">0</span>] + theta[<span class=\"number\">1</span>] * x</span><br><span class=\"line\">plt.plot(x[:, <span class=\"number\">1</span>], y, <span class=\"string\">'o'</span>)</span><br><span class=\"line\">plt.plot(x, y_predict, <span class=\"string\">'k-'</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/linear_reg_plot.png\" alt=\"linear_regression_plot\"></p>\n<p>接下来画出代价函数在每次迭代过程中的变化趋势，可以看出算法是否收敛</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plt.plot(cost_iter[:<span class=\"number\">500</span>, <span class=\"number\">0</span>], cost_iter[:<span class=\"number\">500</span>, <span class=\"number\">1</span>])</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">\"Iteration Number\"</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">\"Cost\"</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/cost_trend.png\" alt=\"cost_trend\"></p>\n<p>接下来有必要好好复习一下线性代数、numpy和向量化计算。</p>"},{"layout":"post","title":"About Regularization","date":"2015-09-18T05:26:10.000Z","comments":1,"published":1,"_content":"\n正则化防止过拟合\n","source":"_posts/2015-09-18-about-regularization.markdown","raw":"---\nlayout: post\ntitle: \"About Regularization\"\ndate: 2015-09-18 13:26:10 +0800\ncomments: true\npublished: true\ncategories: [算法]\ntag: [Machine Learning, Algorithm, Scikit-Learn]\n---\n\n正则化防止过拟合\n","slug":"2015-09-18-about-regularization","updated":"2016-09-20T02:07:00.000Z","photos":[],"link":"","_id":"cjfkkp3nn0018zd68uxbfrbzc","content":"<p>正则化防止过拟合</p>\n","site":{"data":{}},"excerpt":"","more":"<p>正则化防止过拟合</p>\n"},{"layout":"post","title":"How to Evaluate Algorithm","date":"2015-09-18T08:24:58.000Z","comments":1,"published":0,"_content":"","source":"_posts/2015-09-18-how-to-evaluate-algorithm.markdown","raw":"---\nlayout: post\ntitle: \"How to Evaluate Algorithm\"\ndate: 2015-09-18 16:24:58 +0800\ncomments: true\npublished: false\ncategories: [Machine Learning, Scikit-Learn, Python]\n---\n","slug":"2015-09-18-how-to-evaluate-algorithm","updated":"2016-09-20T02:07:00.000Z","photos":[],"link":"","_id":"cjfkkp3no001azd68yv852244","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"post","title":"Bag of Words Model","date":"2015-11-26T13:34:28.000Z","comments":1,"_content":"","source":"_posts/2015-11-26-bag-of-words-model.markdown","raw":"---\nlayout: post\ntitle: \"Bag of Words Model\"\ndate: 2015-11-26 21:34:28 +0800\ncomments: true\ncategories: [算法, Kaggle]\ntag: [Kaggle, Scikit-Learn, Text Mining]\n---\n","slug":"2015-11-26-bag-of-words-model","published":1,"updated":"2016-09-20T02:07:00.000Z","photos":[],"link":"","_id":"cjfkkp3nq001ezd68vwc6ht9b","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"post","title":"Cross-Validation in Scikit-Learn","date":"2015-09-21T11:55:14.000Z","comments":1,"published":1,"_content":"","source":"_posts/2015-09-21-cross-validation-in-scikit-learn.markdown","raw":"---\nlayout: post\ntitle: \"Cross-Validation in Scikit-Learn\"\ndate: 2015-09-21 19:55:14 +0800\ncomments: true\npublished: true\ncategories: [算法]\ntag: [Machine Learning, Python, Scikit-Learn]\n---\n","slug":"2015-09-21-cross-validation-in-scikit-learn","updated":"2016-09-20T02:07:00.000Z","photos":[],"link":"","_id":"cjfkkp3nr001gzd68ihb95g9y","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"post","title":"Understanding TF-IDF","date":"2015-11-27T07:31:50.000Z","comments":1,"_content":"","source":"_posts/2015-11-27-understanding-tf-idf.markdown","raw":"---\nlayout: post\ntitle: \"Understanding TF-IDF\"\ndate: 2015-11-27 15:31:50 +0800\ncomments: true\ncategories: [算法]\ntag: [Scikit-Learn, Feature Extraction, NLP, Text Mining]\n---\n","slug":"2015-11-27-understanding-tf-idf","published":1,"updated":"2016-09-20T02:07:00.000Z","photos":[],"link":"","_id":"cjfkkp3ns001kzd68e6v6vxwh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Anaconda解决python包管理与环境管理","date":"2017-06-08T07:24:29.000Z","_content":"\n\n\nAnaconda是一个用于科学计算的Python发行版，支持 Linux, Mac, Windows系统，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。\n\nconda可以理解为一个工具，也是一个可执行命令，其核心功能是包管理与环境管理\n\n- 提供包管理，功能类似于 pip，Windows 平台安装第三方包经常失败的场景得以解决。\n- 提供虚拟环境管理，功能类似于 virtualenv，解决了多版本Python并存问题\n\nAnaconda具有跨平台、包管理、环境管理的特点，因此很适合快速在新的机器上部署Python环境。\n\nAnaconda的下载页参见 [官网下载](https://www.continuum.io/downloads)\n\n<!-- more -->\n\nAnaconda安装成功之后，可以检查所安装的版本\n\n``` bash\nconda --version\n```\n\n由于不可名状的原因，需要修改其包管理镜像为国内源\n\n\n``` bash\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --set show_channel_urls yes\n```\n\n## Conda的环境管理\n\nConda的环境管理功能允许我们同时安装若干不同版本的Python，并能自由切换。对于上述安装过程，假设我们采用的是Python 2.7对应的安装包，那么Python 2.7就是默认的环境\n\n现在，创建一个自定义的Python环境\n\n``` bash\nconda create -n py27 python=2.7\n```\n\n其中py27是新添加环境的名字，可以自定义修改。\n\n之后通过activate py27和deactivate py27命令激活、退出该环境\n\n``` bash\nactivate py27\n```\n\n现在把创建的环境都列出来，其中当前使用的环境前面用*号标注\n\n``` bash\nconda info --envs\n```\n\n![Change&ShowEnvs](http://7xkfga.com1.z0.glb.clouddn.com/changeEnv.png)\n\n``` bash\n# 创建一个名为py3的环境，指定Python版本是3.4（不用管是3.4.x，conda会为我们自动寻找3.4.x中的最新版本）\nconda create --name py3 python=3.4\n \n# 安装好后，使用activate激活某个环境\nactivate py3 # for Windows\nsource activate py3 # for Linux & Mac\n# 激活后，会发现terminal输入的地方多了py3的字样，实际上，此时系统做的事情就是把默认2.7环境从PATH中去除，再把3.4对应的命令加入PATH\n \n# 此时，再次输入\npython --version\n# 可以得到`Python 3.4.5 :: Anaconda 4.1.1 (64-bit)`，即系统已经切换到了3.4的环境\n \n# 如果想返回默认的python 2.7环境，运行\ndeactivate py3 # for Windows\nsource deactivate py3 # for Linux & Mac\n \n# 删除一个已有的环境\nconda remove --name py3 --all\n```\n\n\n## Conda的包管理\n\n现在要使用conda来管理包了，以前常用的是Python的pip包管理工具。\n\n``` bash\n# 安装scipy\nconda install scipy\n# conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库）\n \n# 查看已经安装的packages\nconda list\n# 最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包\n```\n\n\n### 实例：让Python2和3在Jupyter Notebook中共存\n\n多版本的Python或者R等语言，在Jupyter中被称作kernel。\n\n如果这个Python版本已经存在（比如我们刚才添加的py27环境），那么你可以直接为这个环境安装 `ipykernel`包\n\n``` bash\nconda install -n py27 ipykernel\n```\n\nnote:\n\n> -n 后面的名字为所要安装到的环境名\n\n\n然后激活这个环境\n\n``` bash\npython -m ipykernel install --user\n```\n\n如果所需版本并不是已有的环境，可以直接在创建环境时便为其预装 `ipykernel`。\n\n``` bash\nconda create -n py27 python=2.7 ipykernel\n```\n\n打开jupyter notebook\n\n``` bash\njupyter notebook\n```\n\n![jupyterNotebook](http://7xkfga.com1.z0.glb.clouddn.com/jupyterNotebook.png)\n\n\n\n## 最后\n\n两个字：**省心**\n\n附： [conda cheat sheet](http://conda.pydata.org/docs/_downloads/conda-cheatsheet.pdf)","source":"_posts/AnacondaΩ‚æˆpython∞¸π‹¿Ì”Îª∑æ≥π‹¿Ì.md","raw":"---\ntitle: Anaconda解决python包管理与环境管理\ndate: 2017-06-08 15:24:29\ntags:\n  - Anaconda\n  - Python\n\n---\n\n\n\nAnaconda是一个用于科学计算的Python发行版，支持 Linux, Mac, Windows系统，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。\n\nconda可以理解为一个工具，也是一个可执行命令，其核心功能是包管理与环境管理\n\n- 提供包管理，功能类似于 pip，Windows 平台安装第三方包经常失败的场景得以解决。\n- 提供虚拟环境管理，功能类似于 virtualenv，解决了多版本Python并存问题\n\nAnaconda具有跨平台、包管理、环境管理的特点，因此很适合快速在新的机器上部署Python环境。\n\nAnaconda的下载页参见 [官网下载](https://www.continuum.io/downloads)\n\n<!-- more -->\n\nAnaconda安装成功之后，可以检查所安装的版本\n\n``` bash\nconda --version\n```\n\n由于不可名状的原因，需要修改其包管理镜像为国内源\n\n\n``` bash\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --set show_channel_urls yes\n```\n\n## Conda的环境管理\n\nConda的环境管理功能允许我们同时安装若干不同版本的Python，并能自由切换。对于上述安装过程，假设我们采用的是Python 2.7对应的安装包，那么Python 2.7就是默认的环境\n\n现在，创建一个自定义的Python环境\n\n``` bash\nconda create -n py27 python=2.7\n```\n\n其中py27是新添加环境的名字，可以自定义修改。\n\n之后通过activate py27和deactivate py27命令激活、退出该环境\n\n``` bash\nactivate py27\n```\n\n现在把创建的环境都列出来，其中当前使用的环境前面用*号标注\n\n``` bash\nconda info --envs\n```\n\n![Change&ShowEnvs](http://7xkfga.com1.z0.glb.clouddn.com/changeEnv.png)\n\n``` bash\n# 创建一个名为py3的环境，指定Python版本是3.4（不用管是3.4.x，conda会为我们自动寻找3.4.x中的最新版本）\nconda create --name py3 python=3.4\n \n# 安装好后，使用activate激活某个环境\nactivate py3 # for Windows\nsource activate py3 # for Linux & Mac\n# 激活后，会发现terminal输入的地方多了py3的字样，实际上，此时系统做的事情就是把默认2.7环境从PATH中去除，再把3.4对应的命令加入PATH\n \n# 此时，再次输入\npython --version\n# 可以得到`Python 3.4.5 :: Anaconda 4.1.1 (64-bit)`，即系统已经切换到了3.4的环境\n \n# 如果想返回默认的python 2.7环境，运行\ndeactivate py3 # for Windows\nsource deactivate py3 # for Linux & Mac\n \n# 删除一个已有的环境\nconda remove --name py3 --all\n```\n\n\n## Conda的包管理\n\n现在要使用conda来管理包了，以前常用的是Python的pip包管理工具。\n\n``` bash\n# 安装scipy\nconda install scipy\n# conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库）\n \n# 查看已经安装的packages\nconda list\n# 最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包\n```\n\n\n### 实例：让Python2和3在Jupyter Notebook中共存\n\n多版本的Python或者R等语言，在Jupyter中被称作kernel。\n\n如果这个Python版本已经存在（比如我们刚才添加的py27环境），那么你可以直接为这个环境安装 `ipykernel`包\n\n``` bash\nconda install -n py27 ipykernel\n```\n\nnote:\n\n> -n 后面的名字为所要安装到的环境名\n\n\n然后激活这个环境\n\n``` bash\npython -m ipykernel install --user\n```\n\n如果所需版本并不是已有的环境，可以直接在创建环境时便为其预装 `ipykernel`。\n\n``` bash\nconda create -n py27 python=2.7 ipykernel\n```\n\n打开jupyter notebook\n\n``` bash\njupyter notebook\n```\n\n![jupyterNotebook](http://7xkfga.com1.z0.glb.clouddn.com/jupyterNotebook.png)\n\n\n\n## 最后\n\n两个字：**省心**\n\n附： [conda cheat sheet](http://conda.pydata.org/docs/_downloads/conda-cheatsheet.pdf)","slug":"AnacondaΩ‚æˆpython∞¸π‹¿Ì”Îª∑æ≥π‹¿Ì","published":1,"updated":"2017-06-08T07:41:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3nt001mzd68n01srzou","content":"<p>Anaconda是一个用于科学计算的Python发行版，支持 Linux, Mac, Windows系统，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。</p>\n<p>conda可以理解为一个工具，也是一个可执行命令，其核心功能是包管理与环境管理</p>\n<ul>\n<li>提供包管理，功能类似于 pip，Windows 平台安装第三方包经常失败的场景得以解决。</li>\n<li>提供虚拟环境管理，功能类似于 virtualenv，解决了多版本Python并存问题</li>\n</ul>\n<p>Anaconda具有跨平台、包管理、环境管理的特点，因此很适合快速在新的机器上部署Python环境。</p>\n<p>Anaconda的下载页参见 <a href=\"https://www.continuum.io/downloads\" target=\"_blank\" rel=\"noopener\">官网下载</a></p>\n<a id=\"more\"></a>\n<p>Anaconda安装成功之后，可以检查所安装的版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda --version</span><br></pre></td></tr></table></figure>\n<p>由于不可名状的原因，需要修改其包管理镜像为国内源</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class=\"line\">conda config --<span class=\"built_in\">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure>\n<h2 id=\"Conda的环境管理\"><a href=\"#Conda的环境管理\" class=\"headerlink\" title=\"Conda的环境管理\"></a>Conda的环境管理</h2><p>Conda的环境管理功能允许我们同时安装若干不同版本的Python，并能自由切换。对于上述安装过程，假设我们采用的是Python 2.7对应的安装包，那么Python 2.7就是默认的环境</p>\n<p>现在，创建一个自定义的Python环境</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create -n py27 python=2.7</span><br></pre></td></tr></table></figure>\n<p>其中py27是新添加环境的名字，可以自定义修改。</p>\n<p>之后通过activate py27和deactivate py27命令激活、退出该环境</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">activate py27</span><br></pre></td></tr></table></figure>\n<p>现在把创建的环境都列出来，其中当前使用的环境前面用*号标注</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda info --envs</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/changeEnv.png\" alt=\"Change&amp;ShowEnvs\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个名为py3的环境，指定Python版本是3.4（不用管是3.4.x，conda会为我们自动寻找3.4.x中的最新版本）</span></span><br><span class=\"line\">conda create --name py3 python=3.4</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 安装好后，使用activate激活某个环境</span></span><br><span class=\"line\">activate py3 <span class=\"comment\"># for Windows</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> activate py3 <span class=\"comment\"># for Linux &amp; Mac</span></span><br><span class=\"line\"><span class=\"comment\"># 激活后，会发现terminal输入的地方多了py3的字样，实际上，此时系统做的事情就是把默认2.7环境从PATH中去除，再把3.4对应的命令加入PATH</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 此时，再次输入</span></span><br><span class=\"line\">python --version</span><br><span class=\"line\"><span class=\"comment\"># 可以得到`Python 3.4.5 :: Anaconda 4.1.1 (64-bit)`，即系统已经切换到了3.4的环境</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 如果想返回默认的python 2.7环境，运行</span></span><br><span class=\"line\">deactivate py3 <span class=\"comment\"># for Windows</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> deactivate py3 <span class=\"comment\"># for Linux &amp; Mac</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 删除一个已有的环境</span></span><br><span class=\"line\">conda remove --name py3 --all</span><br></pre></td></tr></table></figure>\n<h2 id=\"Conda的包管理\"><a href=\"#Conda的包管理\" class=\"headerlink\" title=\"Conda的包管理\"></a>Conda的包管理</h2><p>现在要使用conda来管理包了，以前常用的是Python的pip包管理工具。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装scipy</span></span><br><span class=\"line\">conda install scipy</span><br><span class=\"line\"><span class=\"comment\"># conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库）</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 查看已经安装的packages</span></span><br><span class=\"line\">conda list</span><br><span class=\"line\"><span class=\"comment\"># 最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"实例：让Python2和3在Jupyter-Notebook中共存\"><a href=\"#实例：让Python2和3在Jupyter-Notebook中共存\" class=\"headerlink\" title=\"实例：让Python2和3在Jupyter Notebook中共存\"></a>实例：让Python2和3在Jupyter Notebook中共存</h3><p>多版本的Python或者R等语言，在Jupyter中被称作kernel。</p>\n<p>如果这个Python版本已经存在（比如我们刚才添加的py27环境），那么你可以直接为这个环境安装 <code>ipykernel</code>包</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install -n py27 ipykernel</span><br></pre></td></tr></table></figure>\n<p>note:</p>\n<blockquote>\n<p>-n 后面的名字为所要安装到的环境名</p>\n</blockquote>\n<p>然后激活这个环境</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m ipykernel install --user</span><br></pre></td></tr></table></figure>\n<p>如果所需版本并不是已有的环境，可以直接在创建环境时便为其预装 <code>ipykernel</code>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create -n py27 python=2.7 ipykernel</span><br></pre></td></tr></table></figure>\n<p>打开jupyter notebook</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jupyter notebook</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/jupyterNotebook.png\" alt=\"jupyterNotebook\"></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>两个字：<strong>省心</strong></p>\n<p>附： <a href=\"http://conda.pydata.org/docs/_downloads/conda-cheatsheet.pdf\" target=\"_blank\" rel=\"noopener\">conda cheat sheet</a></p>\n","site":{"data":{}},"excerpt":"<p>Anaconda是一个用于科学计算的Python发行版，支持 Linux, Mac, Windows系统，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。</p>\n<p>conda可以理解为一个工具，也是一个可执行命令，其核心功能是包管理与环境管理</p>\n<ul>\n<li>提供包管理，功能类似于 pip，Windows 平台安装第三方包经常失败的场景得以解决。</li>\n<li>提供虚拟环境管理，功能类似于 virtualenv，解决了多版本Python并存问题</li>\n</ul>\n<p>Anaconda具有跨平台、包管理、环境管理的特点，因此很适合快速在新的机器上部署Python环境。</p>\n<p>Anaconda的下载页参见 <a href=\"https://www.continuum.io/downloads\" target=\"_blank\" rel=\"noopener\">官网下载</a></p>","more":"<p>Anaconda安装成功之后，可以检查所安装的版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda --version</span><br></pre></td></tr></table></figure>\n<p>由于不可名状的原因，需要修改其包管理镜像为国内源</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class=\"line\">conda config --<span class=\"built_in\">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure>\n<h2 id=\"Conda的环境管理\"><a href=\"#Conda的环境管理\" class=\"headerlink\" title=\"Conda的环境管理\"></a>Conda的环境管理</h2><p>Conda的环境管理功能允许我们同时安装若干不同版本的Python，并能自由切换。对于上述安装过程，假设我们采用的是Python 2.7对应的安装包，那么Python 2.7就是默认的环境</p>\n<p>现在，创建一个自定义的Python环境</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create -n py27 python=2.7</span><br></pre></td></tr></table></figure>\n<p>其中py27是新添加环境的名字，可以自定义修改。</p>\n<p>之后通过activate py27和deactivate py27命令激活、退出该环境</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">activate py27</span><br></pre></td></tr></table></figure>\n<p>现在把创建的环境都列出来，其中当前使用的环境前面用*号标注</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda info --envs</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/changeEnv.png\" alt=\"Change&amp;ShowEnvs\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个名为py3的环境，指定Python版本是3.4（不用管是3.4.x，conda会为我们自动寻找3.4.x中的最新版本）</span></span><br><span class=\"line\">conda create --name py3 python=3.4</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 安装好后，使用activate激活某个环境</span></span><br><span class=\"line\">activate py3 <span class=\"comment\"># for Windows</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> activate py3 <span class=\"comment\"># for Linux &amp; Mac</span></span><br><span class=\"line\"><span class=\"comment\"># 激活后，会发现terminal输入的地方多了py3的字样，实际上，此时系统做的事情就是把默认2.7环境从PATH中去除，再把3.4对应的命令加入PATH</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 此时，再次输入</span></span><br><span class=\"line\">python --version</span><br><span class=\"line\"><span class=\"comment\"># 可以得到`Python 3.4.5 :: Anaconda 4.1.1 (64-bit)`，即系统已经切换到了3.4的环境</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 如果想返回默认的python 2.7环境，运行</span></span><br><span class=\"line\">deactivate py3 <span class=\"comment\"># for Windows</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> deactivate py3 <span class=\"comment\"># for Linux &amp; Mac</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 删除一个已有的环境</span></span><br><span class=\"line\">conda remove --name py3 --all</span><br></pre></td></tr></table></figure>\n<h2 id=\"Conda的包管理\"><a href=\"#Conda的包管理\" class=\"headerlink\" title=\"Conda的包管理\"></a>Conda的包管理</h2><p>现在要使用conda来管理包了，以前常用的是Python的pip包管理工具。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装scipy</span></span><br><span class=\"line\">conda install scipy</span><br><span class=\"line\"><span class=\"comment\"># conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库）</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 查看已经安装的packages</span></span><br><span class=\"line\">conda list</span><br><span class=\"line\"><span class=\"comment\"># 最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"实例：让Python2和3在Jupyter-Notebook中共存\"><a href=\"#实例：让Python2和3在Jupyter-Notebook中共存\" class=\"headerlink\" title=\"实例：让Python2和3在Jupyter Notebook中共存\"></a>实例：让Python2和3在Jupyter Notebook中共存</h3><p>多版本的Python或者R等语言，在Jupyter中被称作kernel。</p>\n<p>如果这个Python版本已经存在（比如我们刚才添加的py27环境），那么你可以直接为这个环境安装 <code>ipykernel</code>包</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install -n py27 ipykernel</span><br></pre></td></tr></table></figure>\n<p>note:</p>\n<blockquote>\n<p>-n 后面的名字为所要安装到的环境名</p>\n</blockquote>\n<p>然后激活这个环境</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m ipykernel install --user</span><br></pre></td></tr></table></figure>\n<p>如果所需版本并不是已有的环境，可以直接在创建环境时便为其预装 <code>ipykernel</code>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create -n py27 python=2.7 ipykernel</span><br></pre></td></tr></table></figure>\n<p>打开jupyter notebook</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jupyter notebook</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/jupyterNotebook.png\" alt=\"jupyterNotebook\"></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>两个字：<strong>省心</strong></p>\n<p>附： <a href=\"http://conda.pydata.org/docs/_downloads/conda-cheatsheet.pdf\" target=\"_blank\" rel=\"noopener\">conda cheat sheet</a></p>"},{"title":"Flask 从入门到放弃1: Hello World","date":"2017-07-25T08:25:46.000Z","_content":"\n除了Flask，常见的Python Web框架还有：\n\n- Django：全能型Web框架；\n- web.py：一个小巧的Web框架；\n- Bottle：和Flask类似的Web框架；\n- Tornado：Facebook的开源异步Web框架。\n\n## Flask简介\n\nFlask 是一个用于 Python 的微型网络开发框架，依赖两个外部库： Jinja2 模板引擎和 Werkzeug WSGI 套件。Flask也被称为microframework，因为它使用简单的核心，用加载扩展的方式增加其他功能。\n\nFlask 没有默认使用的数据库、窗体验证工具。但是，Flask 保留了扩增的弹性，可以用Flask扩展加入这些功能：ORM、窗体验证工具、文件上传、开放式身份验证技术。\n\n![FlaskLogo](http://docs.jinkan.org/docs/flask/_images/logo-full.png)\n\n<!-- more -->\n\n## 准备环境\n\n对于Python来说，有相当数量的外部包，如果管理不当，会让人崩溃，创建一个Flask的Web项目更是这样，所以推荐一个项目一套环境。这里使用 `virtualenv` 在项目的目录中创建这个项目的虚拟环境。\n\n``` shell\n$ sudo pip install virtualenv\n$ mkdir myproject\n$ cd myproject\n$ virtualenv venv\n$ . venv/bin/activate\n$ pip install Flask\n```\n\n## Hello World 应用\n\n官方文档上给出的hello world例子很小，但是也基本说明了一个Flask应用都包含了什么\n\n``` python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n    return 'Hello World!'\n\nif __name__ == '__main__':\n    app.run()\n```\n\n保存代码为 `hello.py`，在命令行运行\n\n``` shell\npython hello.py\n```\n\n这时候访问 http://127.0.0.1:5000/ 可以看见页面输出 Hello World!\n\n## 程序都干了啥\n\n1. 首先导入了 `Flask` 类，这个类的实例会是WSGI应用程序\n2. 接下来创建了这个类的实例 `app`\n3. 然后，使用 `route()` 装饰器进行路由绑定，通过路由来绑定URL和Python函数的映射关系。\n4. 最后使用 `run()` 函数来让应用运行在本地服务器上。 其中 `if __name__ == '__main__':` 确保服务器只会在该脚本被 Python 解释器直接执行的时候才会运行，而不是作为模块导入的时候。\n\n好了，Ctrl+C关闭服务器。到这里一个麻雀虽小五脏俱全的小Flask应用就创建好了。\n","source":"_posts/Flask-¥”»Î√≈µΩ∑≈∆˙1-Hello-World.md","raw":"---\ntitle: 'Flask 从入门到放弃1: Hello World'\ntags:\n  - Python\n  - Flask\ncategories: Flask从入门到放弃\ndate: 2017-07-25 16:25:46\n---\n\n除了Flask，常见的Python Web框架还有：\n\n- Django：全能型Web框架；\n- web.py：一个小巧的Web框架；\n- Bottle：和Flask类似的Web框架；\n- Tornado：Facebook的开源异步Web框架。\n\n## Flask简介\n\nFlask 是一个用于 Python 的微型网络开发框架，依赖两个外部库： Jinja2 模板引擎和 Werkzeug WSGI 套件。Flask也被称为microframework，因为它使用简单的核心，用加载扩展的方式增加其他功能。\n\nFlask 没有默认使用的数据库、窗体验证工具。但是，Flask 保留了扩增的弹性，可以用Flask扩展加入这些功能：ORM、窗体验证工具、文件上传、开放式身份验证技术。\n\n![FlaskLogo](http://docs.jinkan.org/docs/flask/_images/logo-full.png)\n\n<!-- more -->\n\n## 准备环境\n\n对于Python来说，有相当数量的外部包，如果管理不当，会让人崩溃，创建一个Flask的Web项目更是这样，所以推荐一个项目一套环境。这里使用 `virtualenv` 在项目的目录中创建这个项目的虚拟环境。\n\n``` shell\n$ sudo pip install virtualenv\n$ mkdir myproject\n$ cd myproject\n$ virtualenv venv\n$ . venv/bin/activate\n$ pip install Flask\n```\n\n## Hello World 应用\n\n官方文档上给出的hello world例子很小，但是也基本说明了一个Flask应用都包含了什么\n\n``` python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n    return 'Hello World!'\n\nif __name__ == '__main__':\n    app.run()\n```\n\n保存代码为 `hello.py`，在命令行运行\n\n``` shell\npython hello.py\n```\n\n这时候访问 http://127.0.0.1:5000/ 可以看见页面输出 Hello World!\n\n## 程序都干了啥\n\n1. 首先导入了 `Flask` 类，这个类的实例会是WSGI应用程序\n2. 接下来创建了这个类的实例 `app`\n3. 然后，使用 `route()` 装饰器进行路由绑定，通过路由来绑定URL和Python函数的映射关系。\n4. 最后使用 `run()` 函数来让应用运行在本地服务器上。 其中 `if __name__ == '__main__':` 确保服务器只会在该脚本被 Python 解释器直接执行的时候才会运行，而不是作为模块导入的时候。\n\n好了，Ctrl+C关闭服务器。到这里一个麻雀虽小五脏俱全的小Flask应用就创建好了。\n","slug":"Flask-¥”»Î√≈µΩ∑≈∆˙1-Hello-World","published":1,"updated":"2017-07-26T04:17:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3nv001pzd68q48nsiie","content":"<p>除了Flask，常见的Python Web框架还有：</p>\n<ul>\n<li>Django：全能型Web框架；</li>\n<li>web.py：一个小巧的Web框架；</li>\n<li>Bottle：和Flask类似的Web框架；</li>\n<li>Tornado：Facebook的开源异步Web框架。</li>\n</ul>\n<h2 id=\"Flask简介\"><a href=\"#Flask简介\" class=\"headerlink\" title=\"Flask简介\"></a>Flask简介</h2><p>Flask 是一个用于 Python 的微型网络开发框架，依赖两个外部库： Jinja2 模板引擎和 Werkzeug WSGI 套件。Flask也被称为microframework，因为它使用简单的核心，用加载扩展的方式增加其他功能。</p>\n<p>Flask 没有默认使用的数据库、窗体验证工具。但是，Flask 保留了扩增的弹性，可以用Flask扩展加入这些功能：ORM、窗体验证工具、文件上传、开放式身份验证技术。</p>\n<p><img src=\"http://docs.jinkan.org/docs/flask/_images/logo-full.png\" alt=\"FlaskLogo\"></p>\n<a id=\"more\"></a>\n<h2 id=\"准备环境\"><a href=\"#准备环境\" class=\"headerlink\" title=\"准备环境\"></a>准备环境</h2><p>对于Python来说，有相当数量的外部包，如果管理不当，会让人崩溃，创建一个Flask的Web项目更是这样，所以推荐一个项目一套环境。这里使用 <code>virtualenv</code> 在项目的目录中创建这个项目的虚拟环境。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo pip install virtualenv</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mkdir myproject</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> myproject</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> virtualenv venv</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> . venv/bin/activate</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> pip install Flask</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Hello-World-应用\"><a href=\"#Hello-World-应用\" class=\"headerlink\" title=\"Hello World 应用\"></a>Hello World 应用</h2><p>官方文档上给出的hello world例子很小，但是也基本说明了一个Flask应用都包含了什么</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello_world</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hello World!'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p>保存代码为 <code>hello.py</code>，在命令行运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python hello.py</span><br></pre></td></tr></table></figure>\n<p>这时候访问 <a href=\"http://127.0.0.1:5000/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:5000/</a> 可以看见页面输出 Hello World!</p>\n<h2 id=\"程序都干了啥\"><a href=\"#程序都干了啥\" class=\"headerlink\" title=\"程序都干了啥\"></a>程序都干了啥</h2><ol>\n<li>首先导入了 <code>Flask</code> 类，这个类的实例会是WSGI应用程序</li>\n<li>接下来创建了这个类的实例 <code>app</code></li>\n<li>然后，使用 <code>route()</code> 装饰器进行路由绑定，通过路由来绑定URL和Python函数的映射关系。</li>\n<li>最后使用 <code>run()</code> 函数来让应用运行在本地服务器上。 其中 <code>if __name__ == &#39;__main__&#39;:</code> 确保服务器只会在该脚本被 Python 解释器直接执行的时候才会运行，而不是作为模块导入的时候。</li>\n</ol>\n<p>好了，Ctrl+C关闭服务器。到这里一个麻雀虽小五脏俱全的小Flask应用就创建好了。</p>\n","site":{"data":{}},"excerpt":"<p>除了Flask，常见的Python Web框架还有：</p>\n<ul>\n<li>Django：全能型Web框架；</li>\n<li>web.py：一个小巧的Web框架；</li>\n<li>Bottle：和Flask类似的Web框架；</li>\n<li>Tornado：Facebook的开源异步Web框架。</li>\n</ul>\n<h2 id=\"Flask简介\"><a href=\"#Flask简介\" class=\"headerlink\" title=\"Flask简介\"></a>Flask简介</h2><p>Flask 是一个用于 Python 的微型网络开发框架，依赖两个外部库： Jinja2 模板引擎和 Werkzeug WSGI 套件。Flask也被称为microframework，因为它使用简单的核心，用加载扩展的方式增加其他功能。</p>\n<p>Flask 没有默认使用的数据库、窗体验证工具。但是，Flask 保留了扩增的弹性，可以用Flask扩展加入这些功能：ORM、窗体验证工具、文件上传、开放式身份验证技术。</p>\n<p><img src=\"http://docs.jinkan.org/docs/flask/_images/logo-full.png\" alt=\"FlaskLogo\"></p>","more":"<h2 id=\"准备环境\"><a href=\"#准备环境\" class=\"headerlink\" title=\"准备环境\"></a>准备环境</h2><p>对于Python来说，有相当数量的外部包，如果管理不当，会让人崩溃，创建一个Flask的Web项目更是这样，所以推荐一个项目一套环境。这里使用 <code>virtualenv</code> 在项目的目录中创建这个项目的虚拟环境。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo pip install virtualenv</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mkdir myproject</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> myproject</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> virtualenv venv</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> . venv/bin/activate</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> pip install Flask</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Hello-World-应用\"><a href=\"#Hello-World-应用\" class=\"headerlink\" title=\"Hello World 应用\"></a>Hello World 应用</h2><p>官方文档上给出的hello world例子很小，但是也基本说明了一个Flask应用都包含了什么</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello_world</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hello World!'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p>保存代码为 <code>hello.py</code>，在命令行运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python hello.py</span><br></pre></td></tr></table></figure>\n<p>这时候访问 <a href=\"http://127.0.0.1:5000/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:5000/</a> 可以看见页面输出 Hello World!</p>\n<h2 id=\"程序都干了啥\"><a href=\"#程序都干了啥\" class=\"headerlink\" title=\"程序都干了啥\"></a>程序都干了啥</h2><ol>\n<li>首先导入了 <code>Flask</code> 类，这个类的实例会是WSGI应用程序</li>\n<li>接下来创建了这个类的实例 <code>app</code></li>\n<li>然后，使用 <code>route()</code> 装饰器进行路由绑定，通过路由来绑定URL和Python函数的映射关系。</li>\n<li>最后使用 <code>run()</code> 函数来让应用运行在本地服务器上。 其中 <code>if __name__ == &#39;__main__&#39;:</code> 确保服务器只会在该脚本被 Python 解释器直接执行的时候才会运行，而不是作为模块导入的时候。</li>\n</ol>\n<p>好了，Ctrl+C关闭服务器。到这里一个麻雀虽小五脏俱全的小Flask应用就创建好了。</p>"},{"title":"Flask 从入门到放弃2: 深入理解@app.route()","date":"2017-07-26T03:11:20.000Z","_content":"\n\n下面这段代码是Flask的主页上给出的，这是一段Hello World级别的代码段，但是里面包含的概念可一点都不简单。\n\n``` python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello World!\"\n```\n\n这里面的 `@app.route('/')` 到底是什么意思呢，具体又是如何实现的呢？很多初学者都是很迷茫。我在集中精力理解了装饰器之后，慢慢的就对app.route 这个装饰器的原理以及目的有了了解了。\n\n以前写过一篇文章，详细说明了装饰器的概念：[搞懂Python装饰器](https://lvraikkonen.github.io/2017/07/20/%E6%90%9E%E6%87%82Python%E8%A3%85%E9%A5%B0%E5%99%A8/) 要是忘了可以随时复习一下。\n\n<!-- more -->\n\n## 给装饰器传参数\n\n需要外嵌一个工厂函数，调用这个函数，然后返回函数的装饰器\n\n``` python\ndef decorator_factory(enter_message, exit_message):\n    # return this decorator\n    print \"In decorator_factory\"\n\n    def simple_deco(func):\n        def wrapper():\n            print enter_message\n            func()\n            print exit_message\n        return wrapper\n    return simple_deco\n\n@decorator_factory(\"Start\", \"End\")\ndef hello():\n    print \"Hello World\"\n\nhello()\n```\n\n注意，这里使用 `@decorator_factory(\"Start\", \"End\")` 的时候，实际调用的是 `decorator_factory` 函数。相当于如下调用：\n\n```\ndecorator_factory(\"Start\", \"End\")(hello)\n```\n\n输出结果为：\n\n![flask_hello_world](http://7xkfga.com1.z0.glb.clouddn.com/flaskHelloWorld.png)\n\n## 创建自己的Flask类\n\n现在我们已经有了足够的装饰器的背景知识，可以模拟一下Flask对象里面的内容。\n\n### 创建route装饰器\n\n我们知道，Flask是一个类，而类方法也可以被用作装饰器。\n\n``` python\nclass MyFlask():\n\n    # decorator_factory\n    def route(self, route_str):\n        def decorator(func):\n            return func\n\n        return decorator\n\napp = MyFlask()\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello World\"\n```\n\n这里不想修改被装饰函数的行为，只是想获取被装饰函数的引用，以便后面注册这个函数用。\n\n### 添加一个存储路由的字典\n\n现在，需要一个变量去存储路由和其关联的函数\n\n``` python\nclass MyFlask():\n    def __init__(self):\n        self.routes = {}\n\n    # decorator_factory\n    def route(self, route_str):\n        def decorator(func):\n            self.routes[route_str] = func\n            return func\n    return decorator\n\n    # access register variable\n    def serve(self, path):\n        view_function = self.routes.get(path)\n        if view_function:\n            return view_function()\n        else:\n            raise ValueError('Route \"{}\" has not been registered'.format(path))\n\napp = MyFlask()\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello World\"\n```\n\n当给定的路径被注册过则返回函数运行结果，当路径尚未注册时则抛出一个异常。\n\n### 解释动态URL\n\n形如 `@app.route(\"/hello/<username>\")` 这样的路径又是如何解析出参数的呢？Flask使用正则的形式表达路径。这样就可以将路径作为一种模式进行匹配。\n\n#### 使用正则表达式\n\n``` python\nimport re\n\nroute_regex = re.compile(r'^/hello/(?P<username>.+)$')\nmatch = route_regex.match(\"/hello/ains\")\n\nprint match.groupdict()\n```\n\n输出结果为：`{'username': 'ains'}`\n\n\n现在需要使用 `(pattern, view_function)` 这个元组来保存路径编译变成一个正则表达式和注册函数的关系。然后在装饰器中，把编译好的正则表达式和注册函数的元组保存在列表中。\n\n``` python\nroutes = []\n\ndef build_route_pattern(route):\n    route_regex = re.sub(r'(<\\w+>)', r'(?P\\1.+)', route)\n    return re.compile(\"^{}$\".format(route_regex))\n\ndef route(self, route_str):\n    def decorator(func):\n        route_pattern = build_route_pattern(route_str)\n        routes.append((route_pattern, func))\n\n        return func\n\n    return decorator\n```\n\n接下来，再创建一个访问routes变量的函数，如果匹配上，则返回正则表达式匹配组和注册函数组成的元组。\n\n``` python\ndef get_route_match(path):\n    for route_pattern, view_function in routes:\n        m = route_pattern.match(path)\n        if m:\n            return m.groupdict(), view_function\n\n    return None\n```\n\n再接下来要找出调用view_function的方法，使用来自正则表达式匹配组字典的正确参数\n\n``` python\ndef serve(path):\n    route_match = get_route_match(path)\n    if route_match:\n        kwargs, view_function = route_match\n        return view_function(**kwargs)\n    else:\n        raise ValueError('Route \"{}\"\" has not been registered'.format(path))\n```\n\n改好的MyFlask类如下：\n\n``` python\nclass MyFlask():\n    def __init__(self):\n        self.routes = []\n\n    @staticmethod\n    def build_route_pattern(route):\n        route_regex = re.sub(r'(<\\w+>)', r'(?P\\1.+)', route)\n        return re.compile(\"^{}$\".format(route_regex))\n\n    def route(self, route_str):\n        def decorator(func):\n            route_pattern = self.build_route_pattern(route_str)\n            self.routes.append((route_pattern, func))\n\n            return func\n\n        return decorator\n\n    def get_route_match(self, path):\n        for route_pattern, view_function in self.routes:\n            m = route_pattern.match(path)\n            if m:\n                return m.groupdict(), view_function\n\n        return None\n\n    def serve(self, path):\n        route_match = self.get_route_match(path)\n        if route_match:\n            kwargs, view_function = route_match\n            return view_function(**kwargs)\n        else:\n            raise ValueError('Route \"{}\"\" has not been registered'.format(path))\n```\n\n运行一段带参数的试试\n\n``` python\napp = MyFlask()\n\n@app.route(\"/hello/<username>\")\ndef hello_user(username):\n    return \"Hello {}!\".format(username)\n\nprint app.serve(\"/hello/ains\")\n```\n\n下面是程序运行的引用关系图\n\n![RefDiagram](http://7xkfga.com1.z0.glb.clouddn.com/refPic.png)\n","source":"_posts/Flask-¥”»Î√≈µΩ∑≈∆˙2-…Ó»Î¿ÌΩ‚-app-route.md","raw":"---\ntitle: 'Flask 从入门到放弃2: 深入理解@app.route()'\ntags:\n  - Python\n  - Flask\ncategories: Flask从入门到放弃\ndate: 2017-07-26 11:11:20\n---\n\n\n下面这段代码是Flask的主页上给出的，这是一段Hello World级别的代码段，但是里面包含的概念可一点都不简单。\n\n``` python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello World!\"\n```\n\n这里面的 `@app.route('/')` 到底是什么意思呢，具体又是如何实现的呢？很多初学者都是很迷茫。我在集中精力理解了装饰器之后，慢慢的就对app.route 这个装饰器的原理以及目的有了了解了。\n\n以前写过一篇文章，详细说明了装饰器的概念：[搞懂Python装饰器](https://lvraikkonen.github.io/2017/07/20/%E6%90%9E%E6%87%82Python%E8%A3%85%E9%A5%B0%E5%99%A8/) 要是忘了可以随时复习一下。\n\n<!-- more -->\n\n## 给装饰器传参数\n\n需要外嵌一个工厂函数，调用这个函数，然后返回函数的装饰器\n\n``` python\ndef decorator_factory(enter_message, exit_message):\n    # return this decorator\n    print \"In decorator_factory\"\n\n    def simple_deco(func):\n        def wrapper():\n            print enter_message\n            func()\n            print exit_message\n        return wrapper\n    return simple_deco\n\n@decorator_factory(\"Start\", \"End\")\ndef hello():\n    print \"Hello World\"\n\nhello()\n```\n\n注意，这里使用 `@decorator_factory(\"Start\", \"End\")` 的时候，实际调用的是 `decorator_factory` 函数。相当于如下调用：\n\n```\ndecorator_factory(\"Start\", \"End\")(hello)\n```\n\n输出结果为：\n\n![flask_hello_world](http://7xkfga.com1.z0.glb.clouddn.com/flaskHelloWorld.png)\n\n## 创建自己的Flask类\n\n现在我们已经有了足够的装饰器的背景知识，可以模拟一下Flask对象里面的内容。\n\n### 创建route装饰器\n\n我们知道，Flask是一个类，而类方法也可以被用作装饰器。\n\n``` python\nclass MyFlask():\n\n    # decorator_factory\n    def route(self, route_str):\n        def decorator(func):\n            return func\n\n        return decorator\n\napp = MyFlask()\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello World\"\n```\n\n这里不想修改被装饰函数的行为，只是想获取被装饰函数的引用，以便后面注册这个函数用。\n\n### 添加一个存储路由的字典\n\n现在，需要一个变量去存储路由和其关联的函数\n\n``` python\nclass MyFlask():\n    def __init__(self):\n        self.routes = {}\n\n    # decorator_factory\n    def route(self, route_str):\n        def decorator(func):\n            self.routes[route_str] = func\n            return func\n    return decorator\n\n    # access register variable\n    def serve(self, path):\n        view_function = self.routes.get(path)\n        if view_function:\n            return view_function()\n        else:\n            raise ValueError('Route \"{}\" has not been registered'.format(path))\n\napp = MyFlask()\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello World\"\n```\n\n当给定的路径被注册过则返回函数运行结果，当路径尚未注册时则抛出一个异常。\n\n### 解释动态URL\n\n形如 `@app.route(\"/hello/<username>\")` 这样的路径又是如何解析出参数的呢？Flask使用正则的形式表达路径。这样就可以将路径作为一种模式进行匹配。\n\n#### 使用正则表达式\n\n``` python\nimport re\n\nroute_regex = re.compile(r'^/hello/(?P<username>.+)$')\nmatch = route_regex.match(\"/hello/ains\")\n\nprint match.groupdict()\n```\n\n输出结果为：`{'username': 'ains'}`\n\n\n现在需要使用 `(pattern, view_function)` 这个元组来保存路径编译变成一个正则表达式和注册函数的关系。然后在装饰器中，把编译好的正则表达式和注册函数的元组保存在列表中。\n\n``` python\nroutes = []\n\ndef build_route_pattern(route):\n    route_regex = re.sub(r'(<\\w+>)', r'(?P\\1.+)', route)\n    return re.compile(\"^{}$\".format(route_regex))\n\ndef route(self, route_str):\n    def decorator(func):\n        route_pattern = build_route_pattern(route_str)\n        routes.append((route_pattern, func))\n\n        return func\n\n    return decorator\n```\n\n接下来，再创建一个访问routes变量的函数，如果匹配上，则返回正则表达式匹配组和注册函数组成的元组。\n\n``` python\ndef get_route_match(path):\n    for route_pattern, view_function in routes:\n        m = route_pattern.match(path)\n        if m:\n            return m.groupdict(), view_function\n\n    return None\n```\n\n再接下来要找出调用view_function的方法，使用来自正则表达式匹配组字典的正确参数\n\n``` python\ndef serve(path):\n    route_match = get_route_match(path)\n    if route_match:\n        kwargs, view_function = route_match\n        return view_function(**kwargs)\n    else:\n        raise ValueError('Route \"{}\"\" has not been registered'.format(path))\n```\n\n改好的MyFlask类如下：\n\n``` python\nclass MyFlask():\n    def __init__(self):\n        self.routes = []\n\n    @staticmethod\n    def build_route_pattern(route):\n        route_regex = re.sub(r'(<\\w+>)', r'(?P\\1.+)', route)\n        return re.compile(\"^{}$\".format(route_regex))\n\n    def route(self, route_str):\n        def decorator(func):\n            route_pattern = self.build_route_pattern(route_str)\n            self.routes.append((route_pattern, func))\n\n            return func\n\n        return decorator\n\n    def get_route_match(self, path):\n        for route_pattern, view_function in self.routes:\n            m = route_pattern.match(path)\n            if m:\n                return m.groupdict(), view_function\n\n        return None\n\n    def serve(self, path):\n        route_match = self.get_route_match(path)\n        if route_match:\n            kwargs, view_function = route_match\n            return view_function(**kwargs)\n        else:\n            raise ValueError('Route \"{}\"\" has not been registered'.format(path))\n```\n\n运行一段带参数的试试\n\n``` python\napp = MyFlask()\n\n@app.route(\"/hello/<username>\")\ndef hello_user(username):\n    return \"Hello {}!\".format(username)\n\nprint app.serve(\"/hello/ains\")\n```\n\n下面是程序运行的引用关系图\n\n![RefDiagram](http://7xkfga.com1.z0.glb.clouddn.com/refPic.png)\n","slug":"Flask-¥”»Î√≈µΩ∑≈∆˙2-…Ó»Î¿ÌΩ‚-app-route","published":1,"updated":"2017-07-26T03:17:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3nw001szd68qjglnp7r","content":"<p>下面这段代码是Flask的主页上给出的，这是一段Hello World级别的代码段，但是里面包含的概念可一点都不简单。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(\"/\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World!\"</span></span><br></pre></td></tr></table></figure>\n<p>这里面的 <a href=\"mailto:`@app.route\" target=\"_blank\" rel=\"noopener\">`@app.route</a>(‘/‘)` 到底是什么意思呢，具体又是如何实现的呢？很多初学者都是很迷茫。我在集中精力理解了装饰器之后，慢慢的就对app.route 这个装饰器的原理以及目的有了了解了。</p>\n<p>以前写过一篇文章，详细说明了装饰器的概念：<a href=\"https://lvraikkonen.github.io/2017/07/20/%E6%90%9E%E6%87%82Python%E8%A3%85%E9%A5%B0%E5%99%A8/\">搞懂Python装饰器</a> 要是忘了可以随时复习一下。</p>\n<a id=\"more\"></a>\n<h2 id=\"给装饰器传参数\"><a href=\"#给装饰器传参数\" class=\"headerlink\" title=\"给装饰器传参数\"></a>给装饰器传参数</h2><p>需要外嵌一个工厂函数，调用这个函数，然后返回函数的装饰器</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator_factory</span><span class=\"params\">(enter_message, exit_message)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># return this decorator</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"In decorator_factory\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">simple_deco</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">print</span> enter_message</span><br><span class=\"line\">            func()</span><br><span class=\"line\">            <span class=\"keyword\">print</span> exit_message</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> simple_deco</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@decorator_factory(\"Start\", \"End\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">hello()</span><br></pre></td></tr></table></figure>\n<p>注意，这里使用 <code>@decorator_factory(&quot;Start&quot;, &quot;End&quot;)</code> 的时候，实际调用的是 <code>decorator_factory</code> 函数。相当于如下调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">decorator_factory(&quot;Start&quot;, &quot;End&quot;)(hello)</span><br></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/flaskHelloWorld.png\" alt=\"flask_hello_world\"></p>\n<h2 id=\"创建自己的Flask类\"><a href=\"#创建自己的Flask类\" class=\"headerlink\" title=\"创建自己的Flask类\"></a>创建自己的Flask类</h2><p>现在我们已经有了足够的装饰器的背景知识，可以模拟一下Flask对象里面的内容。</p>\n<h3 id=\"创建route装饰器\"><a href=\"#创建route装饰器\" class=\"headerlink\" title=\"创建route装饰器\"></a>创建route装饰器</h3><p>我们知道，Flask是一个类，而类方法也可以被用作装饰器。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFlask</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># decorator_factory</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">route</span><span class=\"params\">(self, route_str)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> func</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\">app = MyFlask()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(\"/\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World\"</span></span><br></pre></td></tr></table></figure>\n<p>这里不想修改被装饰函数的行为，只是想获取被装饰函数的引用，以便后面注册这个函数用。</p>\n<h3 id=\"添加一个存储路由的字典\"><a href=\"#添加一个存储路由的字典\" class=\"headerlink\" title=\"添加一个存储路由的字典\"></a>添加一个存储路由的字典</h3><p>现在，需要一个变量去存储路由和其关联的函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFlask</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.routes = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># decorator_factory</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">route</span><span class=\"params\">(self, route_str)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">            self.routes[route_str] = func</span><br><span class=\"line\">            <span class=\"keyword\">return</span> func</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># access register variable</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">serve</span><span class=\"params\">(self, path)</span>:</span></span><br><span class=\"line\">        view_function = self.routes.get(path)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> view_function:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> view_function()</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'Route \"&#123;&#125;\" has not been registered'</span>.format(path))</span><br><span class=\"line\"></span><br><span class=\"line\">app = MyFlask()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(\"/\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World\"</span></span><br></pre></td></tr></table></figure>\n<p>当给定的路径被注册过则返回函数运行结果，当路径尚未注册时则抛出一个异常。</p>\n<h3 id=\"解释动态URL\"><a href=\"#解释动态URL\" class=\"headerlink\" title=\"解释动态URL\"></a>解释动态URL</h3><p>形如 <a href=\"mailto:`@app.route\" target=\"_blank\" rel=\"noopener\">`@app.route</a>(“/hello/<username>“)` 这样的路径又是如何解析出参数的呢？Flask使用正则的形式表达路径。这样就可以将路径作为一种模式进行匹配。</username></p>\n<h4 id=\"使用正则表达式\"><a href=\"#使用正则表达式\" class=\"headerlink\" title=\"使用正则表达式\"></a>使用正则表达式</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">route_regex = re.compile(<span class=\"string\">r'^/hello/(?P&lt;username&gt;.+)$'</span>)</span><br><span class=\"line\">match = route_regex.match(<span class=\"string\">\"/hello/ains\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> match.groupdict()</span><br></pre></td></tr></table></figure>\n<p>输出结果为：<code>{&#39;username&#39;: &#39;ains&#39;}</code></p>\n<p>现在需要使用 <code>(pattern, view_function)</code> 这个元组来保存路径编译变成一个正则表达式和注册函数的关系。然后在装饰器中，把编译好的正则表达式和注册函数的元组保存在列表中。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">routes = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build_route_pattern</span><span class=\"params\">(route)</span>:</span></span><br><span class=\"line\">    route_regex = re.sub(<span class=\"string\">r'(&lt;\\w+&gt;)'</span>, <span class=\"string\">r'(?P\\1.+)'</span>, route)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> re.compile(<span class=\"string\">\"^&#123;&#125;$\"</span>.format(route_regex))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">route</span><span class=\"params\">(self, route_str)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">        route_pattern = build_route_pattern(route_str)</span><br><span class=\"line\">        routes.append((route_pattern, func))</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> func</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator</span><br></pre></td></tr></table></figure>\n<p>接下来，再创建一个访问routes变量的函数，如果匹配上，则返回正则表达式匹配组和注册函数组成的元组。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_route_match</span><span class=\"params\">(path)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> route_pattern, view_function <span class=\"keyword\">in</span> routes:</span><br><span class=\"line\">        m = route_pattern.match(path)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> m.groupdict(), view_function</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br></pre></td></tr></table></figure>\n<p>再接下来要找出调用view_function的方法，使用来自正则表达式匹配组字典的正确参数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">serve</span><span class=\"params\">(path)</span>:</span></span><br><span class=\"line\">    route_match = get_route_match(path)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> route_match:</span><br><span class=\"line\">        kwargs, view_function = route_match</span><br><span class=\"line\">        <span class=\"keyword\">return</span> view_function(**kwargs)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'Route \"&#123;&#125;\"\" has not been registered'</span>.format(path))</span><br></pre></td></tr></table></figure>\n<p>改好的MyFlask类如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFlask</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.routes = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build_route_pattern</span><span class=\"params\">(route)</span>:</span></span><br><span class=\"line\">        route_regex = re.sub(<span class=\"string\">r'(&lt;\\w+&gt;)'</span>, <span class=\"string\">r'(?P\\1.+)'</span>, route)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> re.compile(<span class=\"string\">\"^&#123;&#125;$\"</span>.format(route_regex))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">route</span><span class=\"params\">(self, route_str)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">            route_pattern = self.build_route_pattern(route_str)</span><br><span class=\"line\">            self.routes.append((route_pattern, func))</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> func</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_route_match</span><span class=\"params\">(self, path)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> route_pattern, view_function <span class=\"keyword\">in</span> self.routes:</span><br><span class=\"line\">            m = route_pattern.match(path)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> m:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> m.groupdict(), view_function</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">serve</span><span class=\"params\">(self, path)</span>:</span></span><br><span class=\"line\">        route_match = self.get_route_match(path)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> route_match:</span><br><span class=\"line\">            kwargs, view_function = route_match</span><br><span class=\"line\">            <span class=\"keyword\">return</span> view_function(**kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'Route \"&#123;&#125;\"\" has not been registered'</span>.format(path))</span><br></pre></td></tr></table></figure>\n<p>运行一段带参数的试试</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app = MyFlask()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(\"/hello/&lt;username&gt;\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello_user</span><span class=\"params\">(username)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello &#123;&#125;!\"</span>.format(username)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> app.serve(<span class=\"string\">\"/hello/ains\"</span>)</span><br></pre></td></tr></table></figure>\n<p>下面是程序运行的引用关系图</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/refPic.png\" alt=\"RefDiagram\"></p>\n","site":{"data":{}},"excerpt":"<p>下面这段代码是Flask的主页上给出的，这是一段Hello World级别的代码段，但是里面包含的概念可一点都不简单。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(\"/\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World!\"</span></span><br></pre></td></tr></table></figure>\n<p>这里面的 <a href=\"mailto:`@app.route\" target=\"_blank\" rel=\"noopener\">`@app.route</a>(‘/‘)` 到底是什么意思呢，具体又是如何实现的呢？很多初学者都是很迷茫。我在集中精力理解了装饰器之后，慢慢的就对app.route 这个装饰器的原理以及目的有了了解了。</p>\n<p>以前写过一篇文章，详细说明了装饰器的概念：<a href=\"https://lvraikkonen.github.io/2017/07/20/%E6%90%9E%E6%87%82Python%E8%A3%85%E9%A5%B0%E5%99%A8/\">搞懂Python装饰器</a> 要是忘了可以随时复习一下。</p>","more":"<h2 id=\"给装饰器传参数\"><a href=\"#给装饰器传参数\" class=\"headerlink\" title=\"给装饰器传参数\"></a>给装饰器传参数</h2><p>需要外嵌一个工厂函数，调用这个函数，然后返回函数的装饰器</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator_factory</span><span class=\"params\">(enter_message, exit_message)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># return this decorator</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"In decorator_factory\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">simple_deco</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">print</span> enter_message</span><br><span class=\"line\">            func()</span><br><span class=\"line\">            <span class=\"keyword\">print</span> exit_message</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> simple_deco</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@decorator_factory(\"Start\", \"End\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">hello()</span><br></pre></td></tr></table></figure>\n<p>注意，这里使用 <code>@decorator_factory(&quot;Start&quot;, &quot;End&quot;)</code> 的时候，实际调用的是 <code>decorator_factory</code> 函数。相当于如下调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">decorator_factory(&quot;Start&quot;, &quot;End&quot;)(hello)</span><br></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/flaskHelloWorld.png\" alt=\"flask_hello_world\"></p>\n<h2 id=\"创建自己的Flask类\"><a href=\"#创建自己的Flask类\" class=\"headerlink\" title=\"创建自己的Flask类\"></a>创建自己的Flask类</h2><p>现在我们已经有了足够的装饰器的背景知识，可以模拟一下Flask对象里面的内容。</p>\n<h3 id=\"创建route装饰器\"><a href=\"#创建route装饰器\" class=\"headerlink\" title=\"创建route装饰器\"></a>创建route装饰器</h3><p>我们知道，Flask是一个类，而类方法也可以被用作装饰器。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFlask</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># decorator_factory</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">route</span><span class=\"params\">(self, route_str)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> func</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\">app = MyFlask()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(\"/\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World\"</span></span><br></pre></td></tr></table></figure>\n<p>这里不想修改被装饰函数的行为，只是想获取被装饰函数的引用，以便后面注册这个函数用。</p>\n<h3 id=\"添加一个存储路由的字典\"><a href=\"#添加一个存储路由的字典\" class=\"headerlink\" title=\"添加一个存储路由的字典\"></a>添加一个存储路由的字典</h3><p>现在，需要一个变量去存储路由和其关联的函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFlask</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.routes = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># decorator_factory</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">route</span><span class=\"params\">(self, route_str)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">            self.routes[route_str] = func</span><br><span class=\"line\">            <span class=\"keyword\">return</span> func</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># access register variable</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">serve</span><span class=\"params\">(self, path)</span>:</span></span><br><span class=\"line\">        view_function = self.routes.get(path)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> view_function:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> view_function()</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'Route \"&#123;&#125;\" has not been registered'</span>.format(path))</span><br><span class=\"line\"></span><br><span class=\"line\">app = MyFlask()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(\"/\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World\"</span></span><br></pre></td></tr></table></figure>\n<p>当给定的路径被注册过则返回函数运行结果，当路径尚未注册时则抛出一个异常。</p>\n<h3 id=\"解释动态URL\"><a href=\"#解释动态URL\" class=\"headerlink\" title=\"解释动态URL\"></a>解释动态URL</h3><p>形如 <a href=\"mailto:`@app.route\" target=\"_blank\" rel=\"noopener\">`@app.route</a>(“/hello/<username>“)` 这样的路径又是如何解析出参数的呢？Flask使用正则的形式表达路径。这样就可以将路径作为一种模式进行匹配。</username></p>\n<h4 id=\"使用正则表达式\"><a href=\"#使用正则表达式\" class=\"headerlink\" title=\"使用正则表达式\"></a>使用正则表达式</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">route_regex = re.compile(<span class=\"string\">r'^/hello/(?P&lt;username&gt;.+)$'</span>)</span><br><span class=\"line\">match = route_regex.match(<span class=\"string\">\"/hello/ains\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> match.groupdict()</span><br></pre></td></tr></table></figure>\n<p>输出结果为：<code>{&#39;username&#39;: &#39;ains&#39;}</code></p>\n<p>现在需要使用 <code>(pattern, view_function)</code> 这个元组来保存路径编译变成一个正则表达式和注册函数的关系。然后在装饰器中，把编译好的正则表达式和注册函数的元组保存在列表中。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">routes = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build_route_pattern</span><span class=\"params\">(route)</span>:</span></span><br><span class=\"line\">    route_regex = re.sub(<span class=\"string\">r'(&lt;\\w+&gt;)'</span>, <span class=\"string\">r'(?P\\1.+)'</span>, route)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> re.compile(<span class=\"string\">\"^&#123;&#125;$\"</span>.format(route_regex))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">route</span><span class=\"params\">(self, route_str)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">        route_pattern = build_route_pattern(route_str)</span><br><span class=\"line\">        routes.append((route_pattern, func))</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> func</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator</span><br></pre></td></tr></table></figure>\n<p>接下来，再创建一个访问routes变量的函数，如果匹配上，则返回正则表达式匹配组和注册函数组成的元组。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_route_match</span><span class=\"params\">(path)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> route_pattern, view_function <span class=\"keyword\">in</span> routes:</span><br><span class=\"line\">        m = route_pattern.match(path)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> m.groupdict(), view_function</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br></pre></td></tr></table></figure>\n<p>再接下来要找出调用view_function的方法，使用来自正则表达式匹配组字典的正确参数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">serve</span><span class=\"params\">(path)</span>:</span></span><br><span class=\"line\">    route_match = get_route_match(path)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> route_match:</span><br><span class=\"line\">        kwargs, view_function = route_match</span><br><span class=\"line\">        <span class=\"keyword\">return</span> view_function(**kwargs)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'Route \"&#123;&#125;\"\" has not been registered'</span>.format(path))</span><br></pre></td></tr></table></figure>\n<p>改好的MyFlask类如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFlask</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.routes = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build_route_pattern</span><span class=\"params\">(route)</span>:</span></span><br><span class=\"line\">        route_regex = re.sub(<span class=\"string\">r'(&lt;\\w+&gt;)'</span>, <span class=\"string\">r'(?P\\1.+)'</span>, route)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> re.compile(<span class=\"string\">\"^&#123;&#125;$\"</span>.format(route_regex))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">route</span><span class=\"params\">(self, route_str)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">            route_pattern = self.build_route_pattern(route_str)</span><br><span class=\"line\">            self.routes.append((route_pattern, func))</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> func</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_route_match</span><span class=\"params\">(self, path)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> route_pattern, view_function <span class=\"keyword\">in</span> self.routes:</span><br><span class=\"line\">            m = route_pattern.match(path)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> m:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> m.groupdict(), view_function</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">serve</span><span class=\"params\">(self, path)</span>:</span></span><br><span class=\"line\">        route_match = self.get_route_match(path)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> route_match:</span><br><span class=\"line\">            kwargs, view_function = route_match</span><br><span class=\"line\">            <span class=\"keyword\">return</span> view_function(**kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'Route \"&#123;&#125;\"\" has not been registered'</span>.format(path))</span><br></pre></td></tr></table></figure>\n<p>运行一段带参数的试试</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app = MyFlask()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(\"/hello/&lt;username&gt;\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello_user</span><span class=\"params\">(username)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello &#123;&#125;!\"</span>.format(username)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> app.serve(<span class=\"string\">\"/hello/ains\"</span>)</span><br></pre></td></tr></table></figure>\n<p>下面是程序运行的引用关系图</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/refPic.png\" alt=\"RefDiagram\"></p>"},{"title":"Flask 从入门到放弃3: 渲染模版","date":"2017-08-14T03:22:12.000Z","_content":"\n\n## MVC\n\nMVC：Model-View-Controller，中文名“模型-视图-控制器”\n\n- Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。\n- View（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。\n- Controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。\n\nFlask支持MVC模型，Flask默认使用Jinjia2模板引擎，对模版进行渲染，最终生成HTML文件。视图方法有两个作用：处理业务逻辑（比如操作数据库）和 返回响应内容。模板起到了将两者分开管理的作用。\n\n\n下面介绍自动生成HTML的方法：模版渲染\n\n<!-- more -->\n\n## 模版\n\n默认情况下,Flask 在程序文件夹中的 templates 子文件夹中寻找模板。\n\n一个模版文件 user.html：\n\n``` HTML\n<html>\n  <head>\n    <title>{{ title }} - microblog</title>\n  </head>\n  <body>\n      <h1>Hello, {{ user_name }}!</h1>\n  </body>\n</html>\n```\n\n调用模版\n\n``` python\nfrom flask import Flask, render_template\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/user/<name>')\ndef user(name):\n    return render_template('user.html', user_name=name)\n```\n\n`render_template()`第一个参数是模板的名称，然后是 键/值 对，user_name=name左边表示模板中的占位符，右边是当前视图中的变量。\n\n### 变量类型\n\n模板中不仅能使用字符串数字等简单的数据类型，还能接收复杂的数据结构，比如dict、list、obj等。\n\n``` HTML\n<p>A value from a dictionary: {{ mydict['key'] }}.</p>\n<p>A value from a list: {{ mylist[3] }}.</p>\n<p>A value from a list, with a variable index: {{ mylist[myintvar] }}.</p>\n<p>A value from an object's method: {{ myobj.somemethod() }}.</p>\n```\n\n### 控制结构\n\nJinjia2能够使用常见的控制流，如下是常用的几种控制流：\n\n- if else\n- for\n\n``` html\n{% if user %}\n    Hello, {{user}}\n{% else %}\n    Hello, stranger\n{% endif %}\n```\n\n``` html\n<ul>\n   {% for comment in comments%}\n        <li>{{ comment }}</li>\n    {% endfor %}\n</ul>\n```\n\n## 模版继承\n\n和类继承的方式类似，如果多个页面的大部分内容相同，可以定义一个父模板，包含相同的内容，然后子模板继承内容，并根据需要进行部分修改。`block`标签定义的元素可以在衍生模板中修改。\n\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    {% block head%}\n        <title>\n            {% block title%}{% endblock%}- My Application\n        </title>\n    {% endblock %}\n</head>\n<body>\n    {% block body%}\n    {% endblock%}\n</body>\n</html>\n```\n\n父模版定义了`head`, `title`和`body`三个块，可以在子模板中进行修改。\n\n\n``` html\n{% extends 'base.html'%}\n{% block title%}\n    Index\n{% endblock %}\n{% block head%}\n    {{ super() }}\n    <style>\n    </style>\n{% endblock%}\n{% block body%}\n    <h1>Helll, World!</h1>\n{% endblock%}\n```\n\n继承父模版，extends命令声明这个模版继承自base.html。其中，`super()`这个命令调用父模版的内容。\n\n## 例子：Jinjia2集成Bootstrap\n\n[Bootstrap](http://getbootstrap.com/) 是腿特开源的一个开源框架，可以使用这个框架创建一个比较漂亮的网页。这里使用叫做`Flask-Bootstrap`的Flask扩展。\n\n``` shell\n(venv) $ pip install flask-bootstrap\n```\n\n安装好之后，就可以在命名空间中导入了。\n\n``` python\nfrom flask_bootstrap import Bootstrap\n# ...\nbootstrap = Bootstrap(app)\n```\n\n### 创建UI的父模版\n\n页面整体可以分为两部分：导航条和页面主体。\n\n![Bootstrap_baseTemplate](http://7xkfga.com1.z0.glb.clouddn.com/bootstrap_fartherTemplate.png)\n\n`extends \"bootstrap/base.html\"` 表明这个模版继承自Bootstrap中的bootstrap/base.html。在这个模板中定义了`title`, `navbar`, `content`和`page_content`这几个块。\n\n### 自定义404页面\n\nUI的框架已经定义好了，下面就可以自定义一个模版，用来显示404页面。\n\n404.html\n\n``` html\n{% extends \"base.html\" %}\n\n{% block title %}Flasky - Page not found{% endblock %}\n\n{% block page_content %}\n<div class=\"page-header\">\n    <h1>Not Found</h1>\n</div>\n{% endblock %}\n```\n\n这个页面继承自上面定义好的父模版，在404.html模版页里面，对`title`和`page_content`这两个块的内容进行修改。\n\n现在页面的UI就从丑陋变得稍微美观一点了。\n\n![render_template_html](http://7xkfga.com1.z0.glb.clouddn.com/render_template_result.png)\n","source":"_posts/Flask-¥”»Î√≈µΩ∑≈∆˙3-‰÷»æƒ£∞Ê.md","raw":"---\ntitle: 'Flask 从入门到放弃3: 渲染模版'\ndate: 2017-08-14 11:22:12\ntags:\n  - Python\n  - Flask\ncategories: Flask从入门到放弃\n---\n\n\n## MVC\n\nMVC：Model-View-Controller，中文名“模型-视图-控制器”\n\n- Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。\n- View（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。\n- Controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。\n\nFlask支持MVC模型，Flask默认使用Jinjia2模板引擎，对模版进行渲染，最终生成HTML文件。视图方法有两个作用：处理业务逻辑（比如操作数据库）和 返回响应内容。模板起到了将两者分开管理的作用。\n\n\n下面介绍自动生成HTML的方法：模版渲染\n\n<!-- more -->\n\n## 模版\n\n默认情况下,Flask 在程序文件夹中的 templates 子文件夹中寻找模板。\n\n一个模版文件 user.html：\n\n``` HTML\n<html>\n  <head>\n    <title>{{ title }} - microblog</title>\n  </head>\n  <body>\n      <h1>Hello, {{ user_name }}!</h1>\n  </body>\n</html>\n```\n\n调用模版\n\n``` python\nfrom flask import Flask, render_template\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/user/<name>')\ndef user(name):\n    return render_template('user.html', user_name=name)\n```\n\n`render_template()`第一个参数是模板的名称，然后是 键/值 对，user_name=name左边表示模板中的占位符，右边是当前视图中的变量。\n\n### 变量类型\n\n模板中不仅能使用字符串数字等简单的数据类型，还能接收复杂的数据结构，比如dict、list、obj等。\n\n``` HTML\n<p>A value from a dictionary: {{ mydict['key'] }}.</p>\n<p>A value from a list: {{ mylist[3] }}.</p>\n<p>A value from a list, with a variable index: {{ mylist[myintvar] }}.</p>\n<p>A value from an object's method: {{ myobj.somemethod() }}.</p>\n```\n\n### 控制结构\n\nJinjia2能够使用常见的控制流，如下是常用的几种控制流：\n\n- if else\n- for\n\n``` html\n{% if user %}\n    Hello, {{user}}\n{% else %}\n    Hello, stranger\n{% endif %}\n```\n\n``` html\n<ul>\n   {% for comment in comments%}\n        <li>{{ comment }}</li>\n    {% endfor %}\n</ul>\n```\n\n## 模版继承\n\n和类继承的方式类似，如果多个页面的大部分内容相同，可以定义一个父模板，包含相同的内容，然后子模板继承内容，并根据需要进行部分修改。`block`标签定义的元素可以在衍生模板中修改。\n\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    {% block head%}\n        <title>\n            {% block title%}{% endblock%}- My Application\n        </title>\n    {% endblock %}\n</head>\n<body>\n    {% block body%}\n    {% endblock%}\n</body>\n</html>\n```\n\n父模版定义了`head`, `title`和`body`三个块，可以在子模板中进行修改。\n\n\n``` html\n{% extends 'base.html'%}\n{% block title%}\n    Index\n{% endblock %}\n{% block head%}\n    {{ super() }}\n    <style>\n    </style>\n{% endblock%}\n{% block body%}\n    <h1>Helll, World!</h1>\n{% endblock%}\n```\n\n继承父模版，extends命令声明这个模版继承自base.html。其中，`super()`这个命令调用父模版的内容。\n\n## 例子：Jinjia2集成Bootstrap\n\n[Bootstrap](http://getbootstrap.com/) 是腿特开源的一个开源框架，可以使用这个框架创建一个比较漂亮的网页。这里使用叫做`Flask-Bootstrap`的Flask扩展。\n\n``` shell\n(venv) $ pip install flask-bootstrap\n```\n\n安装好之后，就可以在命名空间中导入了。\n\n``` python\nfrom flask_bootstrap import Bootstrap\n# ...\nbootstrap = Bootstrap(app)\n```\n\n### 创建UI的父模版\n\n页面整体可以分为两部分：导航条和页面主体。\n\n![Bootstrap_baseTemplate](http://7xkfga.com1.z0.glb.clouddn.com/bootstrap_fartherTemplate.png)\n\n`extends \"bootstrap/base.html\"` 表明这个模版继承自Bootstrap中的bootstrap/base.html。在这个模板中定义了`title`, `navbar`, `content`和`page_content`这几个块。\n\n### 自定义404页面\n\nUI的框架已经定义好了，下面就可以自定义一个模版，用来显示404页面。\n\n404.html\n\n``` html\n{% extends \"base.html\" %}\n\n{% block title %}Flasky - Page not found{% endblock %}\n\n{% block page_content %}\n<div class=\"page-header\">\n    <h1>Not Found</h1>\n</div>\n{% endblock %}\n```\n\n这个页面继承自上面定义好的父模版，在404.html模版页里面，对`title`和`page_content`这两个块的内容进行修改。\n\n现在页面的UI就从丑陋变得稍微美观一点了。\n\n![render_template_html](http://7xkfga.com1.z0.glb.clouddn.com/render_template_result.png)\n","slug":"Flask-¥”»Î√≈µΩ∑≈∆˙3-‰÷»æƒ£∞Ê","published":1,"updated":"2017-08-14T09:07:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3nx001uzd685gcq3koz","content":"<h2 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h2><p>MVC：Model-View-Controller，中文名“模型-视图-控制器”</p>\n<ul>\n<li>Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。</li>\n<li>View（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。</li>\n<li>Controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</li>\n</ul>\n<p>Flask支持MVC模型，Flask默认使用Jinjia2模板引擎，对模版进行渲染，最终生成HTML文件。视图方法有两个作用：处理业务逻辑（比如操作数据库）和 返回响应内容。模板起到了将两者分开管理的作用。</p>\n<p>下面介绍自动生成HTML的方法：模版渲染</p>\n<a id=\"more\"></a>\n<h2 id=\"模版\"><a href=\"#模版\" class=\"headerlink\" title=\"模版\"></a>模版</h2><p>默认情况下,Flask 在程序文件夹中的 templates 子文件夹中寻找模板。</p>\n<p>一个模版文件 user.html：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>&#123;&#123; title &#125;&#125; - microblog<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;&#123; user_name &#125;&#125;!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>调用模版</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, render_template</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">index</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">'index.html'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/user/&lt;name&gt;')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">user</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">'user.html'</span>, user_name=name)</span><br></pre></td></tr></table></figure>\n<p><code>render_template()</code>第一个参数是模板的名称，然后是 键/值 对，user_name=name左边表示模板中的占位符，右边是当前视图中的变量。</p>\n<h3 id=\"变量类型\"><a href=\"#变量类型\" class=\"headerlink\" title=\"变量类型\"></a>变量类型</h3><p>模板中不仅能使用字符串数字等简单的数据类型，还能接收复杂的数据结构，比如dict、list、obj等。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>A value from a dictionary: &#123;&#123; mydict['key'] &#125;&#125;.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>A value from a list: &#123;&#123; mylist[3] &#125;&#125;.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>A value from a list, with a variable index: &#123;&#123; mylist[myintvar] &#125;&#125;.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>A value from an object's method: &#123;&#123; myobj.somemethod() &#125;&#125;.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"控制结构\"><a href=\"#控制结构\" class=\"headerlink\" title=\"控制结构\"></a>控制结构</h3><p>Jinjia2能够使用常见的控制流，如下是常用的几种控制流：</p>\n<ul>\n<li>if else</li>\n<li>for</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% if user %&#125;</span><br><span class=\"line\">    Hello, &#123;&#123;user&#125;&#125;</span><br><span class=\"line\">&#123;% else %&#125;</span><br><span class=\"line\">    Hello, stranger</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">   &#123;% for comment in comments%&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>&#123;&#123; comment &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    &#123;% endfor %&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"模版继承\"><a href=\"#模版继承\" class=\"headerlink\" title=\"模版继承\"></a>模版继承</h2><p>和类继承的方式类似，如果多个页面的大部分内容相同，可以定义一个父模板，包含相同的内容，然后子模板继承内容，并根据需要进行部分修改。<code>block</code>标签定义的元素可以在衍生模板中修改。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    &#123;% block head%&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">            &#123;% block title%&#125;&#123;% endblock%&#125;- My Application</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    &#123;% endblock %&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    &#123;% block body%&#125;</span><br><span class=\"line\">    &#123;% endblock%&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>父模版定义了<code>head</code>, <code>title</code>和<code>body</code>三个块，可以在子模板中进行修改。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% extends 'base.html'%&#125;</span><br><span class=\"line\">&#123;% block title%&#125;</span><br><span class=\"line\">    Index</span><br><span class=\"line\">&#123;% endblock %&#125;</span><br><span class=\"line\">&#123;% block head%&#125;</span><br><span class=\"line\">    &#123;&#123; super() &#125;&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">&#123;% endblock%&#125;</span><br><span class=\"line\">&#123;% block body%&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Helll, World!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">&#123;% endblock%&#125;</span><br></pre></td></tr></table></figure>\n<p>继承父模版，extends命令声明这个模版继承自base.html。其中，<code>super()</code>这个命令调用父模版的内容。</p>\n<h2 id=\"例子：Jinjia2集成Bootstrap\"><a href=\"#例子：Jinjia2集成Bootstrap\" class=\"headerlink\" title=\"例子：Jinjia2集成Bootstrap\"></a>例子：Jinjia2集成Bootstrap</h2><p><a href=\"http://getbootstrap.com/\" target=\"_blank\" rel=\"noopener\">Bootstrap</a> 是腿特开源的一个开源框架，可以使用这个框架创建一个比较漂亮的网页。这里使用叫做<code>Flask-Bootstrap</code>的Flask扩展。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(venv) $ pip install flask-bootstrap</span><br></pre></td></tr></table></figure>\n<p>安装好之后，就可以在命名空间中导入了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask_bootstrap <span class=\"keyword\">import</span> Bootstrap</span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br><span class=\"line\">bootstrap = Bootstrap(app)</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建UI的父模版\"><a href=\"#创建UI的父模版\" class=\"headerlink\" title=\"创建UI的父模版\"></a>创建UI的父模版</h3><p>页面整体可以分为两部分：导航条和页面主体。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/bootstrap_fartherTemplate.png\" alt=\"Bootstrap_baseTemplate\"></p>\n<p><code>extends &quot;bootstrap/base.html&quot;</code> 表明这个模版继承自Bootstrap中的bootstrap/base.html。在这个模板中定义了<code>title</code>, <code>navbar</code>, <code>content</code>和<code>page_content</code>这几个块。</p>\n<h3 id=\"自定义404页面\"><a href=\"#自定义404页面\" class=\"headerlink\" title=\"自定义404页面\"></a>自定义404页面</h3><p>UI的框架已经定义好了，下面就可以自定义一个模版，用来显示404页面。</p>\n<p>404.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% extends \"base.html\" %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block title %&#125;Flasky - Page not found&#123;% endblock %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block page_content %&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"page-header\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Not Found<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>\n<p>这个页面继承自上面定义好的父模版，在404.html模版页里面，对<code>title</code>和<code>page_content</code>这两个块的内容进行修改。</p>\n<p>现在页面的UI就从丑陋变得稍微美观一点了。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/render_template_result.png\" alt=\"render_template_html\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h2><p>MVC：Model-View-Controller，中文名“模型-视图-控制器”</p>\n<ul>\n<li>Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。</li>\n<li>View（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。</li>\n<li>Controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</li>\n</ul>\n<p>Flask支持MVC模型，Flask默认使用Jinjia2模板引擎，对模版进行渲染，最终生成HTML文件。视图方法有两个作用：处理业务逻辑（比如操作数据库）和 返回响应内容。模板起到了将两者分开管理的作用。</p>\n<p>下面介绍自动生成HTML的方法：模版渲染</p>","more":"<h2 id=\"模版\"><a href=\"#模版\" class=\"headerlink\" title=\"模版\"></a>模版</h2><p>默认情况下,Flask 在程序文件夹中的 templates 子文件夹中寻找模板。</p>\n<p>一个模版文件 user.html：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>&#123;&#123; title &#125;&#125; - microblog<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;&#123; user_name &#125;&#125;!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>调用模版</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, render_template</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">index</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">'index.html'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/user/&lt;name&gt;')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">user</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">'user.html'</span>, user_name=name)</span><br></pre></td></tr></table></figure>\n<p><code>render_template()</code>第一个参数是模板的名称，然后是 键/值 对，user_name=name左边表示模板中的占位符，右边是当前视图中的变量。</p>\n<h3 id=\"变量类型\"><a href=\"#变量类型\" class=\"headerlink\" title=\"变量类型\"></a>变量类型</h3><p>模板中不仅能使用字符串数字等简单的数据类型，还能接收复杂的数据结构，比如dict、list、obj等。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>A value from a dictionary: &#123;&#123; mydict['key'] &#125;&#125;.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>A value from a list: &#123;&#123; mylist[3] &#125;&#125;.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>A value from a list, with a variable index: &#123;&#123; mylist[myintvar] &#125;&#125;.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>A value from an object's method: &#123;&#123; myobj.somemethod() &#125;&#125;.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"控制结构\"><a href=\"#控制结构\" class=\"headerlink\" title=\"控制结构\"></a>控制结构</h3><p>Jinjia2能够使用常见的控制流，如下是常用的几种控制流：</p>\n<ul>\n<li>if else</li>\n<li>for</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% if user %&#125;</span><br><span class=\"line\">    Hello, &#123;&#123;user&#125;&#125;</span><br><span class=\"line\">&#123;% else %&#125;</span><br><span class=\"line\">    Hello, stranger</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">   &#123;% for comment in comments%&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>&#123;&#123; comment &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    &#123;% endfor %&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"模版继承\"><a href=\"#模版继承\" class=\"headerlink\" title=\"模版继承\"></a>模版继承</h2><p>和类继承的方式类似，如果多个页面的大部分内容相同，可以定义一个父模板，包含相同的内容，然后子模板继承内容，并根据需要进行部分修改。<code>block</code>标签定义的元素可以在衍生模板中修改。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    &#123;% block head%&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">            &#123;% block title%&#125;&#123;% endblock%&#125;- My Application</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    &#123;% endblock %&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    &#123;% block body%&#125;</span><br><span class=\"line\">    &#123;% endblock%&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>父模版定义了<code>head</code>, <code>title</code>和<code>body</code>三个块，可以在子模板中进行修改。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% extends 'base.html'%&#125;</span><br><span class=\"line\">&#123;% block title%&#125;</span><br><span class=\"line\">    Index</span><br><span class=\"line\">&#123;% endblock %&#125;</span><br><span class=\"line\">&#123;% block head%&#125;</span><br><span class=\"line\">    &#123;&#123; super() &#125;&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">&#123;% endblock%&#125;</span><br><span class=\"line\">&#123;% block body%&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Helll, World!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">&#123;% endblock%&#125;</span><br></pre></td></tr></table></figure>\n<p>继承父模版，extends命令声明这个模版继承自base.html。其中，<code>super()</code>这个命令调用父模版的内容。</p>\n<h2 id=\"例子：Jinjia2集成Bootstrap\"><a href=\"#例子：Jinjia2集成Bootstrap\" class=\"headerlink\" title=\"例子：Jinjia2集成Bootstrap\"></a>例子：Jinjia2集成Bootstrap</h2><p><a href=\"http://getbootstrap.com/\" target=\"_blank\" rel=\"noopener\">Bootstrap</a> 是腿特开源的一个开源框架，可以使用这个框架创建一个比较漂亮的网页。这里使用叫做<code>Flask-Bootstrap</code>的Flask扩展。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(venv) $ pip install flask-bootstrap</span><br></pre></td></tr></table></figure>\n<p>安装好之后，就可以在命名空间中导入了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask_bootstrap <span class=\"keyword\">import</span> Bootstrap</span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br><span class=\"line\">bootstrap = Bootstrap(app)</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建UI的父模版\"><a href=\"#创建UI的父模版\" class=\"headerlink\" title=\"创建UI的父模版\"></a>创建UI的父模版</h3><p>页面整体可以分为两部分：导航条和页面主体。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/bootstrap_fartherTemplate.png\" alt=\"Bootstrap_baseTemplate\"></p>\n<p><code>extends &quot;bootstrap/base.html&quot;</code> 表明这个模版继承自Bootstrap中的bootstrap/base.html。在这个模板中定义了<code>title</code>, <code>navbar</code>, <code>content</code>和<code>page_content</code>这几个块。</p>\n<h3 id=\"自定义404页面\"><a href=\"#自定义404页面\" class=\"headerlink\" title=\"自定义404页面\"></a>自定义404页面</h3><p>UI的框架已经定义好了，下面就可以自定义一个模版，用来显示404页面。</p>\n<p>404.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% extends \"base.html\" %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block title %&#125;Flasky - Page not found&#123;% endblock %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block page_content %&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"page-header\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Not Found<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>\n<p>这个页面继承自上面定义好的父模版，在404.html模版页里面，对<code>title</code>和<code>page_content</code>这两个块的内容进行修改。</p>\n<p>现在页面的UI就从丑陋变得稍微美观一点了。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/render_template_result.png\" alt=\"render_template_html\"></p>"},{"title":"Flask 从入门到放弃4: Web表单","date":"2017-08-15T08:08:46.000Z","_content":"\n\nHTML表单用于搜集不同类型的用户输入，是Web应用和用户交互的一种HTML元素。关于表单的基础知识可以去 [W3School HTML 表单](http://www.w3school.com.cn/html/html_forms.asp) 去复习一下。\n\n先歪个楼回顾一下HTTP请求的基础知识\n\n> [HTTP 方法：GET 对比 POST](http://www.w3school.com.cn/tags/html_ref_httpmethods.asp)\n\nFlask中的request对象可以存储来自客户端的所有信息，其中可以通过 `request.form` 来获得POST请求所提交的表单数据。在处理表单的时候，像构建表单、表单数据验证是重复并且很繁琐的。可以使用 [Flask-WTF](https://flask-wtf.readthedocs.io/en/stable/) 来简化相关操作。\n\n![Flask-WTF_logo](http://7xkfga.com1.z0.glb.clouddn.com/Flask-wtf_logo.png)\n\n``` shell\n(venv) $ pip install flask-wtf\n```\n\nFlask-WTF是一个集成了WTForms的Flask扩展，使用它你可以在python文件里创建表单类，然后在HTML使用它提供的函数渲染表单。\n\n<!-- more -->\n\n## 创建Flask-WTF表单\n\n### 跨站请求伪造保护CSRF\n\nFlask-WTF默认支持CSRF（跨站请求伪造）保护，只需要在程序中设置一个密钥。Flask-WTF使用这个密钥生成加密令牌，再用令牌验证表单中数据的真伪。\n\n``` python\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'DontTellAnyone'\n```\n\n### 表单类\n\n从Flask-WTF导入FlaskForm类，再从WTForms导入表单字段和验证函数\n\n``` python\nfrom flask_wtf import FlaskForm\nfrom wtforms import StringField, PasswordField, SubmitField\nfrom wtforms.validators import DataRequired, Length, Email, AnyOf\n```\n\n每个表单都用一个继承自FlaskForm的类表示，每个字段都用一个对象表示，每个对象可以附加多个验证函数。常见的验证函数有Required()，Length()，Email()等。 下面创建自己的表单类：\n\n``` python\nclass LoginForm(FlaskForm):\n    email = StringField(u'邮箱', validators=[DataRequired(message=u'邮箱不能为空'), Length(1, 64), Email(message=u'请输入有效的邮箱地址，比如：username@domain.com')])\n    password = PasswordField(u'密码', validators=[DataRequired(message=u'密码不能为空'), Length(min=5, max=13), AnyOf(['secret', 'password'])])\n    submit = SubmitField(u'登录')\n```\n\n自定义的表单类里面包含了三个元素：email文本框、password密码框和提交按钮。其中文本框和密码框引入了一些验证函数。\n\n### 表单渲染\n\n在视图函数中引入自定义的表单类的实例，然后在返回模版的时候传入这个实例：\n\n``` python\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    form = LoginForm()\n    if form.validate_on_submit():\n        email = form.email.data\n        password = form.password.data\n        print \"email: %s password: %s\" % (email, password)\n        print 'Form Successfully Submitted!'\n        flash(u'登录成功，欢迎回来！', 'info')\n    return render_template('wtf.html', form=form)\n```\n\n在模板中使用下面方式渲染模版：(wtf.html)\n\n``` html\n<form class=\"form\" method=\"POST\">\n    {{ form.hidden_tag() }}\n    {{ form.email.label }}{{ form.email() }}\n    {{ form.password.label }}{{ form.password() }}\n    {{ form.submit() }}\n</form>\n```\n\n### 使用Bootstrap渲染表单\n\n上篇渲染模版，提到了使用Flask-Bootstrap提供比较美观的模版，现在就用这种方式渲染表单。\n\nwtf.html模版首先继承bootstrap的基模版，然后再引入bootstrap对wtf支持的文件。\n\n``` html\n{% extends \"bootstrap/base.html\" %}\n{% import 'bootstrap/wtf.html' as wtf %}\n\n{% block title %}\nWTForm extends Bootstrap\n{% endblock %}\n\n{% block content %}\n<form class=\"form\" method=\"POST\">\n    <dl>\n        {{ form.csrf_token }}\n        {{ wtf.form_field(form.email) }}\n        {{ wtf.form_field(form.password) }}\n        <button type=\"submit\" class=\"btn btn-primary\">Sign in</button>\n    </dl>\n\n</form>\n{% endblock %}\n```\n\n到这里，一个简单的表单就已经创建好了，当用户第一次访问到这个页面的时候，服务器接收到一个GET方法请求，validate_on_submit() 返回False，if分支内的内容会跳过；当用户通过POST方法来提交请求时，validate_on_submit()调用Required()来验证name属性，如验证通过，if内的逻辑会被执行。而模板内容最后会被渲染到页面上。\n\n## 处理表单数据\n\n### 表单数据验证\n\n当点击了submit提交按钮的时候，`form.validate_on_submit()` 方法会判断：\n\n1. 通过is_submitted()来判断是否提交了表单\n2. 通过WTForms提供的validate()验证方法验证表单数据是否符合规则。\n\n当然，在自定义的表单类中也可以写自己的验证方法，比如从数据库中查找用户名是否被占用：(`class LoginForm`)\n\n``` python\ndef validate_username(self, field):\n    if User.query.filter_by(username=field.data).first():\n        raise ValidationError(u'用户名已被注册，换一个吧。')\n```\n\n在表单数据验证通过后，使用 form.<NAME>.data来访问表单的单个值\n\n### 存储表单数据\n\n当接收POST请求的时候，可以从form.<NAME>.data中获取数据，请求结束后数据就丢失了，这时候可以使用session来存储起来，提供给以后的请求使用，在下面的代码中，就把POST提交之后的\n\n``` python\nform = NameForm()\nif form.validate_on_submit():\n    old_name = session.get('name')\n    if old_name is not None and old_name != form.name.data:\n        flash(\"Looks like you have changed your name!\")\n    session['name'] = form.name.data\n    return redirect(url_for('hello_somebody'))\nreturn render_template('userform_index.html', form=form, name=session.get('name'))\n```\n","source":"_posts/Flask-¥”»Î√≈µΩ∑≈∆˙4-Web±Ìµ•.md","raw":"---\ntitle: 'Flask 从入门到放弃4: Web表单'\ndate: 2017-08-15 16:08:46\ntags:\n  - Python\n  - Flask\ncategories: Flask从入门到放弃\n---\n\n\nHTML表单用于搜集不同类型的用户输入，是Web应用和用户交互的一种HTML元素。关于表单的基础知识可以去 [W3School HTML 表单](http://www.w3school.com.cn/html/html_forms.asp) 去复习一下。\n\n先歪个楼回顾一下HTTP请求的基础知识\n\n> [HTTP 方法：GET 对比 POST](http://www.w3school.com.cn/tags/html_ref_httpmethods.asp)\n\nFlask中的request对象可以存储来自客户端的所有信息，其中可以通过 `request.form` 来获得POST请求所提交的表单数据。在处理表单的时候，像构建表单、表单数据验证是重复并且很繁琐的。可以使用 [Flask-WTF](https://flask-wtf.readthedocs.io/en/stable/) 来简化相关操作。\n\n![Flask-WTF_logo](http://7xkfga.com1.z0.glb.clouddn.com/Flask-wtf_logo.png)\n\n``` shell\n(venv) $ pip install flask-wtf\n```\n\nFlask-WTF是一个集成了WTForms的Flask扩展，使用它你可以在python文件里创建表单类，然后在HTML使用它提供的函数渲染表单。\n\n<!-- more -->\n\n## 创建Flask-WTF表单\n\n### 跨站请求伪造保护CSRF\n\nFlask-WTF默认支持CSRF（跨站请求伪造）保护，只需要在程序中设置一个密钥。Flask-WTF使用这个密钥生成加密令牌，再用令牌验证表单中数据的真伪。\n\n``` python\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'DontTellAnyone'\n```\n\n### 表单类\n\n从Flask-WTF导入FlaskForm类，再从WTForms导入表单字段和验证函数\n\n``` python\nfrom flask_wtf import FlaskForm\nfrom wtforms import StringField, PasswordField, SubmitField\nfrom wtforms.validators import DataRequired, Length, Email, AnyOf\n```\n\n每个表单都用一个继承自FlaskForm的类表示，每个字段都用一个对象表示，每个对象可以附加多个验证函数。常见的验证函数有Required()，Length()，Email()等。 下面创建自己的表单类：\n\n``` python\nclass LoginForm(FlaskForm):\n    email = StringField(u'邮箱', validators=[DataRequired(message=u'邮箱不能为空'), Length(1, 64), Email(message=u'请输入有效的邮箱地址，比如：username@domain.com')])\n    password = PasswordField(u'密码', validators=[DataRequired(message=u'密码不能为空'), Length(min=5, max=13), AnyOf(['secret', 'password'])])\n    submit = SubmitField(u'登录')\n```\n\n自定义的表单类里面包含了三个元素：email文本框、password密码框和提交按钮。其中文本框和密码框引入了一些验证函数。\n\n### 表单渲染\n\n在视图函数中引入自定义的表单类的实例，然后在返回模版的时候传入这个实例：\n\n``` python\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    form = LoginForm()\n    if form.validate_on_submit():\n        email = form.email.data\n        password = form.password.data\n        print \"email: %s password: %s\" % (email, password)\n        print 'Form Successfully Submitted!'\n        flash(u'登录成功，欢迎回来！', 'info')\n    return render_template('wtf.html', form=form)\n```\n\n在模板中使用下面方式渲染模版：(wtf.html)\n\n``` html\n<form class=\"form\" method=\"POST\">\n    {{ form.hidden_tag() }}\n    {{ form.email.label }}{{ form.email() }}\n    {{ form.password.label }}{{ form.password() }}\n    {{ form.submit() }}\n</form>\n```\n\n### 使用Bootstrap渲染表单\n\n上篇渲染模版，提到了使用Flask-Bootstrap提供比较美观的模版，现在就用这种方式渲染表单。\n\nwtf.html模版首先继承bootstrap的基模版，然后再引入bootstrap对wtf支持的文件。\n\n``` html\n{% extends \"bootstrap/base.html\" %}\n{% import 'bootstrap/wtf.html' as wtf %}\n\n{% block title %}\nWTForm extends Bootstrap\n{% endblock %}\n\n{% block content %}\n<form class=\"form\" method=\"POST\">\n    <dl>\n        {{ form.csrf_token }}\n        {{ wtf.form_field(form.email) }}\n        {{ wtf.form_field(form.password) }}\n        <button type=\"submit\" class=\"btn btn-primary\">Sign in</button>\n    </dl>\n\n</form>\n{% endblock %}\n```\n\n到这里，一个简单的表单就已经创建好了，当用户第一次访问到这个页面的时候，服务器接收到一个GET方法请求，validate_on_submit() 返回False，if分支内的内容会跳过；当用户通过POST方法来提交请求时，validate_on_submit()调用Required()来验证name属性，如验证通过，if内的逻辑会被执行。而模板内容最后会被渲染到页面上。\n\n## 处理表单数据\n\n### 表单数据验证\n\n当点击了submit提交按钮的时候，`form.validate_on_submit()` 方法会判断：\n\n1. 通过is_submitted()来判断是否提交了表单\n2. 通过WTForms提供的validate()验证方法验证表单数据是否符合规则。\n\n当然，在自定义的表单类中也可以写自己的验证方法，比如从数据库中查找用户名是否被占用：(`class LoginForm`)\n\n``` python\ndef validate_username(self, field):\n    if User.query.filter_by(username=field.data).first():\n        raise ValidationError(u'用户名已被注册，换一个吧。')\n```\n\n在表单数据验证通过后，使用 form.<NAME>.data来访问表单的单个值\n\n### 存储表单数据\n\n当接收POST请求的时候，可以从form.<NAME>.data中获取数据，请求结束后数据就丢失了，这时候可以使用session来存储起来，提供给以后的请求使用，在下面的代码中，就把POST提交之后的\n\n``` python\nform = NameForm()\nif form.validate_on_submit():\n    old_name = session.get('name')\n    if old_name is not None and old_name != form.name.data:\n        flash(\"Looks like you have changed your name!\")\n    session['name'] = form.name.data\n    return redirect(url_for('hello_somebody'))\nreturn render_template('userform_index.html', form=form, name=session.get('name'))\n```\n","slug":"Flask-¥”»Î√≈µΩ∑≈∆˙4-Web±Ìµ•","published":1,"updated":"2017-08-16T03:59:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3nz001yzd68sqgo9aq6","content":"<p>HTML表单用于搜集不同类型的用户输入，是Web应用和用户交互的一种HTML元素。关于表单的基础知识可以去 <a href=\"http://www.w3school.com.cn/html/html_forms.asp\" target=\"_blank\" rel=\"noopener\">W3School HTML 表单</a> 去复习一下。</p>\n<p>先歪个楼回顾一下HTTP请求的基础知识</p>\n<blockquote>\n<p><a href=\"http://www.w3school.com.cn/tags/html_ref_httpmethods.asp\" target=\"_blank\" rel=\"noopener\">HTTP 方法：GET 对比 POST</a></p>\n</blockquote>\n<p>Flask中的request对象可以存储来自客户端的所有信息，其中可以通过 <code>request.form</code> 来获得POST请求所提交的表单数据。在处理表单的时候，像构建表单、表单数据验证是重复并且很繁琐的。可以使用 <a href=\"https://flask-wtf.readthedocs.io/en/stable/\" target=\"_blank\" rel=\"noopener\">Flask-WTF</a> 来简化相关操作。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/Flask-wtf_logo.png\" alt=\"Flask-WTF_logo\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(venv) $ pip install flask-wtf</span><br></pre></td></tr></table></figure>\n<p>Flask-WTF是一个集成了WTForms的Flask扩展，使用它你可以在python文件里创建表单类，然后在HTML使用它提供的函数渲染表单。</p>\n<a id=\"more\"></a>\n<h2 id=\"创建Flask-WTF表单\"><a href=\"#创建Flask-WTF表单\" class=\"headerlink\" title=\"创建Flask-WTF表单\"></a>创建Flask-WTF表单</h2><h3 id=\"跨站请求伪造保护CSRF\"><a href=\"#跨站请求伪造保护CSRF\" class=\"headerlink\" title=\"跨站请求伪造保护CSRF\"></a>跨站请求伪造保护CSRF</h3><p>Flask-WTF默认支持CSRF（跨站请求伪造）保护，只需要在程序中设置一个密钥。Flask-WTF使用这个密钥生成加密令牌，再用令牌验证表单中数据的真伪。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\">app.config[<span class=\"string\">'SECRET_KEY'</span>] = <span class=\"string\">'DontTellAnyone'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"表单类\"><a href=\"#表单类\" class=\"headerlink\" title=\"表单类\"></a>表单类</h3><p>从Flask-WTF导入FlaskForm类，再从WTForms导入表单字段和验证函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask_wtf <span class=\"keyword\">import</span> FlaskForm</span><br><span class=\"line\"><span class=\"keyword\">from</span> wtforms <span class=\"keyword\">import</span> StringField, PasswordField, SubmitField</span><br><span class=\"line\"><span class=\"keyword\">from</span> wtforms.validators <span class=\"keyword\">import</span> DataRequired, Length, Email, AnyOf</span><br></pre></td></tr></table></figure>\n<p>每个表单都用一个继承自FlaskForm的类表示，每个字段都用一个对象表示，每个对象可以附加多个验证函数。常见的验证函数有Required()，Length()，Email()等。 下面创建自己的表单类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginForm</span><span class=\"params\">(FlaskForm)</span>:</span></span><br><span class=\"line\">    email = StringField(<span class=\"string\">u'邮箱'</span>, validators=[DataRequired(message=<span class=\"string\">u'邮箱不能为空'</span>), Length(<span class=\"number\">1</span>, <span class=\"number\">64</span>), Email(message=<span class=\"string\">u'请输入有效的邮箱地址，比如：username@domain.com'</span>)])</span><br><span class=\"line\">    password = PasswordField(<span class=\"string\">u'密码'</span>, validators=[DataRequired(message=<span class=\"string\">u'密码不能为空'</span>), Length(min=<span class=\"number\">5</span>, max=<span class=\"number\">13</span>), AnyOf([<span class=\"string\">'secret'</span>, <span class=\"string\">'password'</span>])])</span><br><span class=\"line\">    submit = SubmitField(<span class=\"string\">u'登录'</span>)</span><br></pre></td></tr></table></figure>\n<p>自定义的表单类里面包含了三个元素：email文本框、password密码框和提交按钮。其中文本框和密码框引入了一些验证函数。</p>\n<h3 id=\"表单渲染\"><a href=\"#表单渲染\" class=\"headerlink\" title=\"表单渲染\"></a>表单渲染</h3><p>在视图函数中引入自定义的表单类的实例，然后在返回模版的时候传入这个实例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@app.route('/login', methods=['GET', 'POST'])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">login</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    form = LoginForm()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> form.validate_on_submit():</span><br><span class=\"line\">        email = form.email.data</span><br><span class=\"line\">        password = form.password.data</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"email: %s password: %s\"</span> % (email, password)</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'Form Successfully Submitted!'</span></span><br><span class=\"line\">        flash(<span class=\"string\">u'登录成功，欢迎回来！'</span>, <span class=\"string\">'info'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">'wtf.html'</span>, form=form)</span><br></pre></td></tr></table></figure>\n<p>在模板中使用下面方式渲染模版：(wtf.html)</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">class</span>=<span class=\"string\">\"form\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"POST\"</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123; form.hidden_tag() &#125;&#125;</span><br><span class=\"line\">    &#123;&#123; form.email.label &#125;&#125;&#123;&#123; form.email() &#125;&#125;</span><br><span class=\"line\">    &#123;&#123; form.password.label &#125;&#125;&#123;&#123; form.password() &#125;&#125;</span><br><span class=\"line\">    &#123;&#123; form.submit() &#125;&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用Bootstrap渲染表单\"><a href=\"#使用Bootstrap渲染表单\" class=\"headerlink\" title=\"使用Bootstrap渲染表单\"></a>使用Bootstrap渲染表单</h3><p>上篇渲染模版，提到了使用Flask-Bootstrap提供比较美观的模版，现在就用这种方式渲染表单。</p>\n<p>wtf.html模版首先继承bootstrap的基模版，然后再引入bootstrap对wtf支持的文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% extends \"bootstrap/base.html\" %&#125;</span><br><span class=\"line\">&#123;% import 'bootstrap/wtf.html' as wtf %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block title %&#125;</span><br><span class=\"line\">WTForm extends Bootstrap</span><br><span class=\"line\">&#123;% endblock %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block content %&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">class</span>=<span class=\"string\">\"form\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"POST\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dl</span>&gt;</span></span><br><span class=\"line\">        &#123;&#123; form.csrf_token &#125;&#125;</span><br><span class=\"line\">        &#123;&#123; wtf.form_field(form.email) &#125;&#125;</span><br><span class=\"line\">        &#123;&#123; wtf.form_field(form.password) &#125;&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn btn-primary\"</span>&gt;</span>Sign in<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dl</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里，一个简单的表单就已经创建好了，当用户第一次访问到这个页面的时候，服务器接收到一个GET方法请求，validate_on_submit() 返回False，if分支内的内容会跳过；当用户通过POST方法来提交请求时，validate_on_submit()调用Required()来验证name属性，如验证通过，if内的逻辑会被执行。而模板内容最后会被渲染到页面上。</p>\n<h2 id=\"处理表单数据\"><a href=\"#处理表单数据\" class=\"headerlink\" title=\"处理表单数据\"></a>处理表单数据</h2><h3 id=\"表单数据验证\"><a href=\"#表单数据验证\" class=\"headerlink\" title=\"表单数据验证\"></a>表单数据验证</h3><p>当点击了submit提交按钮的时候，<code>form.validate_on_submit()</code> 方法会判断：</p>\n<ol>\n<li>通过is_submitted()来判断是否提交了表单</li>\n<li>通过WTForms提供的validate()验证方法验证表单数据是否符合规则。</li>\n</ol>\n<p>当然，在自定义的表单类中也可以写自己的验证方法，比如从数据库中查找用户名是否被占用：(<code>class LoginForm</code>)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validate_username</span><span class=\"params\">(self, field)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> User.query.filter_by(username=field.data).first():</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> ValidationError(<span class=\"string\">u'用户名已被注册，换一个吧。'</span>)</span><br></pre></td></tr></table></figure>\n<p>在表单数据验证通过后，使用 form.<name>.data来访问表单的单个值</name></p>\n<h3 id=\"存储表单数据\"><a href=\"#存储表单数据\" class=\"headerlink\" title=\"存储表单数据\"></a>存储表单数据</h3><p>当接收POST请求的时候，可以从form.<name>.data中获取数据，请求结束后数据就丢失了，这时候可以使用session来存储起来，提供给以后的请求使用，在下面的代码中，就把POST提交之后的</name></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">form = NameForm()</span><br><span class=\"line\"><span class=\"keyword\">if</span> form.validate_on_submit():</span><br><span class=\"line\">    old_name = session.get(<span class=\"string\">'name'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> old_name <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span> <span class=\"keyword\">and</span> old_name != form.name.data:</span><br><span class=\"line\">        flash(<span class=\"string\">\"Looks like you have changed your name!\"</span>)</span><br><span class=\"line\">    session[<span class=\"string\">'name'</span>] = form.name.data</span><br><span class=\"line\">    <span class=\"keyword\">return</span> redirect(url_for(<span class=\"string\">'hello_somebody'</span>))</span><br><span class=\"line\"><span class=\"keyword\">return</span> render_template(<span class=\"string\">'userform_index.html'</span>, form=form, name=session.get(<span class=\"string\">'name'</span>))</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>HTML表单用于搜集不同类型的用户输入，是Web应用和用户交互的一种HTML元素。关于表单的基础知识可以去 <a href=\"http://www.w3school.com.cn/html/html_forms.asp\" target=\"_blank\" rel=\"noopener\">W3School HTML 表单</a> 去复习一下。</p>\n<p>先歪个楼回顾一下HTTP请求的基础知识</p>\n<blockquote>\n<p><a href=\"http://www.w3school.com.cn/tags/html_ref_httpmethods.asp\" target=\"_blank\" rel=\"noopener\">HTTP 方法：GET 对比 POST</a></p>\n</blockquote>\n<p>Flask中的request对象可以存储来自客户端的所有信息，其中可以通过 <code>request.form</code> 来获得POST请求所提交的表单数据。在处理表单的时候，像构建表单、表单数据验证是重复并且很繁琐的。可以使用 <a href=\"https://flask-wtf.readthedocs.io/en/stable/\" target=\"_blank\" rel=\"noopener\">Flask-WTF</a> 来简化相关操作。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/Flask-wtf_logo.png\" alt=\"Flask-WTF_logo\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(venv) $ pip install flask-wtf</span><br></pre></td></tr></table></figure>\n<p>Flask-WTF是一个集成了WTForms的Flask扩展，使用它你可以在python文件里创建表单类，然后在HTML使用它提供的函数渲染表单。</p>","more":"<h2 id=\"创建Flask-WTF表单\"><a href=\"#创建Flask-WTF表单\" class=\"headerlink\" title=\"创建Flask-WTF表单\"></a>创建Flask-WTF表单</h2><h3 id=\"跨站请求伪造保护CSRF\"><a href=\"#跨站请求伪造保护CSRF\" class=\"headerlink\" title=\"跨站请求伪造保护CSRF\"></a>跨站请求伪造保护CSRF</h3><p>Flask-WTF默认支持CSRF（跨站请求伪造）保护，只需要在程序中设置一个密钥。Flask-WTF使用这个密钥生成加密令牌，再用令牌验证表单中数据的真伪。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\">app.config[<span class=\"string\">'SECRET_KEY'</span>] = <span class=\"string\">'DontTellAnyone'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"表单类\"><a href=\"#表单类\" class=\"headerlink\" title=\"表单类\"></a>表单类</h3><p>从Flask-WTF导入FlaskForm类，再从WTForms导入表单字段和验证函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask_wtf <span class=\"keyword\">import</span> FlaskForm</span><br><span class=\"line\"><span class=\"keyword\">from</span> wtforms <span class=\"keyword\">import</span> StringField, PasswordField, SubmitField</span><br><span class=\"line\"><span class=\"keyword\">from</span> wtforms.validators <span class=\"keyword\">import</span> DataRequired, Length, Email, AnyOf</span><br></pre></td></tr></table></figure>\n<p>每个表单都用一个继承自FlaskForm的类表示，每个字段都用一个对象表示，每个对象可以附加多个验证函数。常见的验证函数有Required()，Length()，Email()等。 下面创建自己的表单类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginForm</span><span class=\"params\">(FlaskForm)</span>:</span></span><br><span class=\"line\">    email = StringField(<span class=\"string\">u'邮箱'</span>, validators=[DataRequired(message=<span class=\"string\">u'邮箱不能为空'</span>), Length(<span class=\"number\">1</span>, <span class=\"number\">64</span>), Email(message=<span class=\"string\">u'请输入有效的邮箱地址，比如：username@domain.com'</span>)])</span><br><span class=\"line\">    password = PasswordField(<span class=\"string\">u'密码'</span>, validators=[DataRequired(message=<span class=\"string\">u'密码不能为空'</span>), Length(min=<span class=\"number\">5</span>, max=<span class=\"number\">13</span>), AnyOf([<span class=\"string\">'secret'</span>, <span class=\"string\">'password'</span>])])</span><br><span class=\"line\">    submit = SubmitField(<span class=\"string\">u'登录'</span>)</span><br></pre></td></tr></table></figure>\n<p>自定义的表单类里面包含了三个元素：email文本框、password密码框和提交按钮。其中文本框和密码框引入了一些验证函数。</p>\n<h3 id=\"表单渲染\"><a href=\"#表单渲染\" class=\"headerlink\" title=\"表单渲染\"></a>表单渲染</h3><p>在视图函数中引入自定义的表单类的实例，然后在返回模版的时候传入这个实例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@app.route('/login', methods=['GET', 'POST'])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">login</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    form = LoginForm()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> form.validate_on_submit():</span><br><span class=\"line\">        email = form.email.data</span><br><span class=\"line\">        password = form.password.data</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"email: %s password: %s\"</span> % (email, password)</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'Form Successfully Submitted!'</span></span><br><span class=\"line\">        flash(<span class=\"string\">u'登录成功，欢迎回来！'</span>, <span class=\"string\">'info'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">'wtf.html'</span>, form=form)</span><br></pre></td></tr></table></figure>\n<p>在模板中使用下面方式渲染模版：(wtf.html)</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">class</span>=<span class=\"string\">\"form\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"POST\"</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123; form.hidden_tag() &#125;&#125;</span><br><span class=\"line\">    &#123;&#123; form.email.label &#125;&#125;&#123;&#123; form.email() &#125;&#125;</span><br><span class=\"line\">    &#123;&#123; form.password.label &#125;&#125;&#123;&#123; form.password() &#125;&#125;</span><br><span class=\"line\">    &#123;&#123; form.submit() &#125;&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用Bootstrap渲染表单\"><a href=\"#使用Bootstrap渲染表单\" class=\"headerlink\" title=\"使用Bootstrap渲染表单\"></a>使用Bootstrap渲染表单</h3><p>上篇渲染模版，提到了使用Flask-Bootstrap提供比较美观的模版，现在就用这种方式渲染表单。</p>\n<p>wtf.html模版首先继承bootstrap的基模版，然后再引入bootstrap对wtf支持的文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% extends \"bootstrap/base.html\" %&#125;</span><br><span class=\"line\">&#123;% import 'bootstrap/wtf.html' as wtf %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block title %&#125;</span><br><span class=\"line\">WTForm extends Bootstrap</span><br><span class=\"line\">&#123;% endblock %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block content %&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">class</span>=<span class=\"string\">\"form\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"POST\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dl</span>&gt;</span></span><br><span class=\"line\">        &#123;&#123; form.csrf_token &#125;&#125;</span><br><span class=\"line\">        &#123;&#123; wtf.form_field(form.email) &#125;&#125;</span><br><span class=\"line\">        &#123;&#123; wtf.form_field(form.password) &#125;&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn btn-primary\"</span>&gt;</span>Sign in<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dl</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里，一个简单的表单就已经创建好了，当用户第一次访问到这个页面的时候，服务器接收到一个GET方法请求，validate_on_submit() 返回False，if分支内的内容会跳过；当用户通过POST方法来提交请求时，validate_on_submit()调用Required()来验证name属性，如验证通过，if内的逻辑会被执行。而模板内容最后会被渲染到页面上。</p>\n<h2 id=\"处理表单数据\"><a href=\"#处理表单数据\" class=\"headerlink\" title=\"处理表单数据\"></a>处理表单数据</h2><h3 id=\"表单数据验证\"><a href=\"#表单数据验证\" class=\"headerlink\" title=\"表单数据验证\"></a>表单数据验证</h3><p>当点击了submit提交按钮的时候，<code>form.validate_on_submit()</code> 方法会判断：</p>\n<ol>\n<li>通过is_submitted()来判断是否提交了表单</li>\n<li>通过WTForms提供的validate()验证方法验证表单数据是否符合规则。</li>\n</ol>\n<p>当然，在自定义的表单类中也可以写自己的验证方法，比如从数据库中查找用户名是否被占用：(<code>class LoginForm</code>)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validate_username</span><span class=\"params\">(self, field)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> User.query.filter_by(username=field.data).first():</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> ValidationError(<span class=\"string\">u'用户名已被注册，换一个吧。'</span>)</span><br></pre></td></tr></table></figure>\n<p>在表单数据验证通过后，使用 form.<name>.data来访问表单的单个值</name></p>\n<h3 id=\"存储表单数据\"><a href=\"#存储表单数据\" class=\"headerlink\" title=\"存储表单数据\"></a>存储表单数据</h3><p>当接收POST请求的时候，可以从form.<name>.data中获取数据，请求结束后数据就丢失了，这时候可以使用session来存储起来，提供给以后的请求使用，在下面的代码中，就把POST提交之后的</name></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">form = NameForm()</span><br><span class=\"line\"><span class=\"keyword\">if</span> form.validate_on_submit():</span><br><span class=\"line\">    old_name = session.get(<span class=\"string\">'name'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> old_name <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span> <span class=\"keyword\">and</span> old_name != form.name.data:</span><br><span class=\"line\">        flash(<span class=\"string\">\"Looks like you have changed your name!\"</span>)</span><br><span class=\"line\">    session[<span class=\"string\">'name'</span>] = form.name.data</span><br><span class=\"line\">    <span class=\"keyword\">return</span> redirect(url_for(<span class=\"string\">'hello_somebody'</span>))</span><br><span class=\"line\"><span class=\"keyword\">return</span> render_template(<span class=\"string\">'userform_index.html'</span>, form=form, name=session.get(<span class=\"string\">'name'</span>))</span><br></pre></td></tr></table></figure>"},{"title":"Flask 从入门到放弃5: 数据库操作","date":"2017-08-28T03:16:14.000Z","_content":"\nFlask-SQLAlchemy是一个Flask扩展，它简化了在Flask应用程序中对SQLAlchemy的使用。SQLAlchemy是一个强大的关系数据库框架，支持一些数据库后端。提供高级的ORM和底层访问数据库的本地SQL功能。\n\n通过pip安装Flask-SQLAlchemy：\n\n``` shell\n(venv) $ pip install flask-sqlalchemy\n```\n\n![Flask-SQLAlchemy Logo](http://7xkfga.com1.z0.glb.clouddn.com/Flask-SQLAlchemy_logo.png)\n\n对于一个Flask应用，我们需要先创建Flask应用，选择加载配置，然后创建SQLAlchemy对象时候把Flask应用传递给它作为参数。\n\n``` python\nfrom flask_sqlalchemy import SQLAlchemy\nfrom config import config\n\ndb = SQLAlchemy()\n\n\ndef create_app(config_name):\n    app = Flask(__name__)\n    app.config.from_object(config[config_name])\n    config[config_name].init_app(app)\n\n    db.init_app(app)\n    return app\n```\n\n<!-- more -->\n\n## 配置\n\n下面是Flask-SQLAlchemy中常用的配置值。Flask-SQLAlchemy从Flask主配置(config.py)中加载这些值。\n\n- SQLALCHEMY_DATABASE_URI：用于数据库的连接，例如sqlite:////tmp/test.db\n- SQLALCHEMY_TRACK_MODIFICATIONS：如果设置成True(默认情况)，Flask-SQLAlchemy将会追踪对象的修改并且发送信号。这需要额外的内存，如果不必要的可以禁用它。\n- SQLALCHEMY_COMMIT_ON_TEARDOWN：每次request自动提交db.session.commit()\n\n更多的配置键请参考[Flask-SQLAlchemy官方文档](http://www.pythondoc.com/flask-sqlalchemy/config.html)。\n\n常见数据库的连接URI格式如下所示：\n\n| Database | URI          |\n|:---------|:-------------|\n|Postgres  | postgresql://scott:tiger@localhost/mydatabase |\n|MySQL     | mysql://scott:tiger@localhost/mydatabase |\n|Oracle    | oracle://scott:tiger@127.0.0.1:1521/sidname |\n|SQLite    | sqlite:////absolute/path/to/foo.db |\n\n## 模型定义\n\n在ORM中，模型一般是一个Python类，类中的属性对应为数据表中的列 (app/models.py)\n\n``` python\nfrom . import db\n\n\nclass User(db.Model):\n    __tablename__ = 'users'\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(64), unique=True, index=True)\n\n    def __repr__(self):\n        return '<User %r>' % self.username\n```\n\n这个模型创建了两个字段，他们是类db.Column的实例，id和username。db.Column 类构造函数的第一个参数是数据库列和模型属性的类型，下面列出了一些常见的列类型以及在模型中使用的Python类型：\n\n- Integer：普通整数，一般是32bit\n- String：变长字符串\n- Text：变长字符串，对较长或不限长度的字符做了优化\n- Boolean：布尔值\n- Date：日期\n- DateTime：日期和时间\n\ndb.Column 中其余的参数指定属性的配置选项。下面列出了一些常用选项：\n\n- primary_key：如果设置为True，这列就是表的主键\n- unique：如果设置为True，这列不允许出现重复的值\n- index：如果设置为True，为这列创建索引，提升查询效率\n- default：为这列定义默认值\n\n### 一对多关系\n\n关系型数据库使用主外键关系把不同表中的行联系起来。关系可能分为：一对一、一对多、多对多等。关系使用`db.relationship()`函数表示，外键使用`db.ForeignKey`来单独声明。\n\n``` python\nclass Role(db.Model):\n    __tablename__ = 'roles'\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(64), unique=True)\n    users = db.relationship('User', backref='role', lazy='dynamic')\n\n    def __repr__(self):\n        return '<Role %r>' % self.name\n\n\nclass User(db.Model):\n    __tablename__ = 'users'\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(64), unique=True, index=True)\n    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))\n\n    def __repr__(self):\n        return '<User %r>' % self.username\n```\n\nuser表中的`db.ForeignKey('roles.id')`属性说明，user表的role_id列被定义为外键去关联roles表的id列。在role表中添加的users属性将返回与角色相关联的用户组成的列表(代表这个关系的面向对象视角)\n\n常用的配置选项如下所示：\n- backref：在关系的另一个模型中添加反向引用\n- primaryjoin：明确指定两个模型之间使用的联结条件。只在模棱两可的关系中需要指定\n- lazy：决定了SQLAlchemy什么时候从数据库中加载数据。可选值有 select(首次访问时按需加载)、immediate(源对象加\n载后就加载)、 joined(加载记录，但使用联结)、 subquery (立即加载，但使用子查询)，\nnoload(永不加载)和 dynamic(不加载记录，但提供加载记录的查询)\n\n### 多对多关系\n\n在学习数据库时，处理多对多关系的方法是用到第三张表，也就是关系表。\n\n## 数据库基本操作\n\n在创建好Flask应用、配置好，创建了SQLAlchemy对象之后，就可以对定义好的数据库进行操作了，主要操作就是增删改查四项。\n\n### 创建表\n\n``` python\ndb.create_all()\n```\n\n这时候在程序目录中创建了一个.sqlite的文件，这个就是数据库文件了。\n\n### 插入数据\n\n``` python\nuser_john=User(username='john')\n#添加到数据库会话\ndb.session.add(user_john)\n#提交\ndb.session.commit()\n```\n\n数据库会话(db.session)和Flask的session没有什么关系，数据库会话就是关系型数据库的事务，事务能够保证数据库的一致性，提交操作使用原子方式把会话中的对象全部写入数据库，如果发生错误，可以回滚(`db.session.rollback()`)。\n\n### 修改数据\n\n``` python\nadmin_role = 'new role name'\ndb.session.add(admin_role)\ndb.session.commit()\n```\n\n### 删除数据\n\n数据库会话也有删除操作\n\n``` python\n#删除行\ndb.session.delete(user_john)\ndb.session.commit()\n```\n\n### 查询数据\n\nFlask-SQLAlchemy 在Model类上提供了 query 属性。访问它，会得到一个新的所有记录的查询对象。\n\n``` python\n#查询行\nUser.query.all()\n```\n\n使用过滤器可以配置query对象进行更精确的数据库查询:\n\n- filter()：把过滤器添加到原查询上，返回一个新查询\n- filter_by()：把等值过滤器添加到原查询上，返回一个新查询\n- limit()：使用指定的值限制原查询返回的结果数量，返回一个新查询\n- offset()：偏移原查询返回的结果，返回一个新查询\n- order_by()：根据指定条件对原查询结果进行排序，返回一个新查询\n- group_by()：根据指定条件对原查询结果进行分组，返回一个新查询\n\n在查询上应用指定的过滤器后，通过调用all()执行查询，以列表的形式返回结果。除了all()之外，还有其他方法能触发查询执行。下面列出常用的执行查询方法：\n\n- all()：以列表形式返回查询的所有结果\n- first()：返回查询的第一个结果，如果没有结果，则返回 None\n- first_or_404()：返回查询的第一个结果，如果没有结果，则终止请求，返回 404 错误响应\n- get()：返回指定主键对应的行，如果没有对应的行，则返回 None\n- get_or_404()：返回指定主键对应的行，如果没找到指定的主键，则终止请求，返回 404 错误响应\n- count()：返回查询结果的数量\n- paginate()：返回一个 Paginate 对象，它包含指定范围内的结果\n","source":"_posts/Flask-¥”»Î√≈µΩ∑≈∆˙5- ˝æ›ø‚≤Ÿ◊˜.md","raw":"---\ntitle: 'Flask 从入门到放弃5: 数据库操作'\ndate: 2017-08-28 11:16:14\ntags:\n  - Python\n  - Flask\ncategories: Flask从入门到放弃\n---\n\nFlask-SQLAlchemy是一个Flask扩展，它简化了在Flask应用程序中对SQLAlchemy的使用。SQLAlchemy是一个强大的关系数据库框架，支持一些数据库后端。提供高级的ORM和底层访问数据库的本地SQL功能。\n\n通过pip安装Flask-SQLAlchemy：\n\n``` shell\n(venv) $ pip install flask-sqlalchemy\n```\n\n![Flask-SQLAlchemy Logo](http://7xkfga.com1.z0.glb.clouddn.com/Flask-SQLAlchemy_logo.png)\n\n对于一个Flask应用，我们需要先创建Flask应用，选择加载配置，然后创建SQLAlchemy对象时候把Flask应用传递给它作为参数。\n\n``` python\nfrom flask_sqlalchemy import SQLAlchemy\nfrom config import config\n\ndb = SQLAlchemy()\n\n\ndef create_app(config_name):\n    app = Flask(__name__)\n    app.config.from_object(config[config_name])\n    config[config_name].init_app(app)\n\n    db.init_app(app)\n    return app\n```\n\n<!-- more -->\n\n## 配置\n\n下面是Flask-SQLAlchemy中常用的配置值。Flask-SQLAlchemy从Flask主配置(config.py)中加载这些值。\n\n- SQLALCHEMY_DATABASE_URI：用于数据库的连接，例如sqlite:////tmp/test.db\n- SQLALCHEMY_TRACK_MODIFICATIONS：如果设置成True(默认情况)，Flask-SQLAlchemy将会追踪对象的修改并且发送信号。这需要额外的内存，如果不必要的可以禁用它。\n- SQLALCHEMY_COMMIT_ON_TEARDOWN：每次request自动提交db.session.commit()\n\n更多的配置键请参考[Flask-SQLAlchemy官方文档](http://www.pythondoc.com/flask-sqlalchemy/config.html)。\n\n常见数据库的连接URI格式如下所示：\n\n| Database | URI          |\n|:---------|:-------------|\n|Postgres  | postgresql://scott:tiger@localhost/mydatabase |\n|MySQL     | mysql://scott:tiger@localhost/mydatabase |\n|Oracle    | oracle://scott:tiger@127.0.0.1:1521/sidname |\n|SQLite    | sqlite:////absolute/path/to/foo.db |\n\n## 模型定义\n\n在ORM中，模型一般是一个Python类，类中的属性对应为数据表中的列 (app/models.py)\n\n``` python\nfrom . import db\n\n\nclass User(db.Model):\n    __tablename__ = 'users'\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(64), unique=True, index=True)\n\n    def __repr__(self):\n        return '<User %r>' % self.username\n```\n\n这个模型创建了两个字段，他们是类db.Column的实例，id和username。db.Column 类构造函数的第一个参数是数据库列和模型属性的类型，下面列出了一些常见的列类型以及在模型中使用的Python类型：\n\n- Integer：普通整数，一般是32bit\n- String：变长字符串\n- Text：变长字符串，对较长或不限长度的字符做了优化\n- Boolean：布尔值\n- Date：日期\n- DateTime：日期和时间\n\ndb.Column 中其余的参数指定属性的配置选项。下面列出了一些常用选项：\n\n- primary_key：如果设置为True，这列就是表的主键\n- unique：如果设置为True，这列不允许出现重复的值\n- index：如果设置为True，为这列创建索引，提升查询效率\n- default：为这列定义默认值\n\n### 一对多关系\n\n关系型数据库使用主外键关系把不同表中的行联系起来。关系可能分为：一对一、一对多、多对多等。关系使用`db.relationship()`函数表示，外键使用`db.ForeignKey`来单独声明。\n\n``` python\nclass Role(db.Model):\n    __tablename__ = 'roles'\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(64), unique=True)\n    users = db.relationship('User', backref='role', lazy='dynamic')\n\n    def __repr__(self):\n        return '<Role %r>' % self.name\n\n\nclass User(db.Model):\n    __tablename__ = 'users'\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(64), unique=True, index=True)\n    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))\n\n    def __repr__(self):\n        return '<User %r>' % self.username\n```\n\nuser表中的`db.ForeignKey('roles.id')`属性说明，user表的role_id列被定义为外键去关联roles表的id列。在role表中添加的users属性将返回与角色相关联的用户组成的列表(代表这个关系的面向对象视角)\n\n常用的配置选项如下所示：\n- backref：在关系的另一个模型中添加反向引用\n- primaryjoin：明确指定两个模型之间使用的联结条件。只在模棱两可的关系中需要指定\n- lazy：决定了SQLAlchemy什么时候从数据库中加载数据。可选值有 select(首次访问时按需加载)、immediate(源对象加\n载后就加载)、 joined(加载记录，但使用联结)、 subquery (立即加载，但使用子查询)，\nnoload(永不加载)和 dynamic(不加载记录，但提供加载记录的查询)\n\n### 多对多关系\n\n在学习数据库时，处理多对多关系的方法是用到第三张表，也就是关系表。\n\n## 数据库基本操作\n\n在创建好Flask应用、配置好，创建了SQLAlchemy对象之后，就可以对定义好的数据库进行操作了，主要操作就是增删改查四项。\n\n### 创建表\n\n``` python\ndb.create_all()\n```\n\n这时候在程序目录中创建了一个.sqlite的文件，这个就是数据库文件了。\n\n### 插入数据\n\n``` python\nuser_john=User(username='john')\n#添加到数据库会话\ndb.session.add(user_john)\n#提交\ndb.session.commit()\n```\n\n数据库会话(db.session)和Flask的session没有什么关系，数据库会话就是关系型数据库的事务，事务能够保证数据库的一致性，提交操作使用原子方式把会话中的对象全部写入数据库，如果发生错误，可以回滚(`db.session.rollback()`)。\n\n### 修改数据\n\n``` python\nadmin_role = 'new role name'\ndb.session.add(admin_role)\ndb.session.commit()\n```\n\n### 删除数据\n\n数据库会话也有删除操作\n\n``` python\n#删除行\ndb.session.delete(user_john)\ndb.session.commit()\n```\n\n### 查询数据\n\nFlask-SQLAlchemy 在Model类上提供了 query 属性。访问它，会得到一个新的所有记录的查询对象。\n\n``` python\n#查询行\nUser.query.all()\n```\n\n使用过滤器可以配置query对象进行更精确的数据库查询:\n\n- filter()：把过滤器添加到原查询上，返回一个新查询\n- filter_by()：把等值过滤器添加到原查询上，返回一个新查询\n- limit()：使用指定的值限制原查询返回的结果数量，返回一个新查询\n- offset()：偏移原查询返回的结果，返回一个新查询\n- order_by()：根据指定条件对原查询结果进行排序，返回一个新查询\n- group_by()：根据指定条件对原查询结果进行分组，返回一个新查询\n\n在查询上应用指定的过滤器后，通过调用all()执行查询，以列表的形式返回结果。除了all()之外，还有其他方法能触发查询执行。下面列出常用的执行查询方法：\n\n- all()：以列表形式返回查询的所有结果\n- first()：返回查询的第一个结果，如果没有结果，则返回 None\n- first_or_404()：返回查询的第一个结果，如果没有结果，则终止请求，返回 404 错误响应\n- get()：返回指定主键对应的行，如果没有对应的行，则返回 None\n- get_or_404()：返回指定主键对应的行，如果没找到指定的主键，则终止请求，返回 404 错误响应\n- count()：返回查询结果的数量\n- paginate()：返回一个 Paginate 对象，它包含指定范围内的结果\n","slug":"Flask-¥”»Î√≈µΩ∑≈∆˙5- ˝æ›ø‚≤Ÿ◊˜","published":1,"updated":"2017-08-28T08:54:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3o10021zd68x3bn2shw","content":"<p>Flask-SQLAlchemy是一个Flask扩展，它简化了在Flask应用程序中对SQLAlchemy的使用。SQLAlchemy是一个强大的关系数据库框架，支持一些数据库后端。提供高级的ORM和底层访问数据库的本地SQL功能。</p>\n<p>通过pip安装Flask-SQLAlchemy：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(venv) $ pip install flask-sqlalchemy</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/Flask-SQLAlchemy_logo.png\" alt=\"Flask-SQLAlchemy Logo\"></p>\n<p>对于一个Flask应用，我们需要先创建Flask应用，选择加载配置，然后创建SQLAlchemy对象时候把Flask应用传递给它作为参数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask_sqlalchemy <span class=\"keyword\">import</span> SQLAlchemy</span><br><span class=\"line\"><span class=\"keyword\">from</span> config <span class=\"keyword\">import</span> config</span><br><span class=\"line\"></span><br><span class=\"line\">db = SQLAlchemy()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_app</span><span class=\"params\">(config_name)</span>:</span></span><br><span class=\"line\">    app = Flask(__name__)</span><br><span class=\"line\">    app.config.from_object(config[config_name])</span><br><span class=\"line\">    config[config_name].init_app(app)</span><br><span class=\"line\"></span><br><span class=\"line\">    db.init_app(app)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> app</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>下面是Flask-SQLAlchemy中常用的配置值。Flask-SQLAlchemy从Flask主配置(config.py)中加载这些值。</p>\n<ul>\n<li>SQLALCHEMY_DATABASE_URI：用于数据库的连接，例如sqlite:////tmp/test.db</li>\n<li>SQLALCHEMY_TRACK_MODIFICATIONS：如果设置成True(默认情况)，Flask-SQLAlchemy将会追踪对象的修改并且发送信号。这需要额外的内存，如果不必要的可以禁用它。</li>\n<li>SQLALCHEMY_COMMIT_ON_TEARDOWN：每次request自动提交db.session.commit()</li>\n</ul>\n<p>更多的配置键请参考<a href=\"http://www.pythondoc.com/flask-sqlalchemy/config.html\" target=\"_blank\" rel=\"noopener\">Flask-SQLAlchemy官方文档</a>。</p>\n<p>常见数据库的连接URI格式如下所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Database</th>\n<th style=\"text-align:left\">URI</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Postgres</td>\n<td style=\"text-align:left\">postgresql://scott:tiger@localhost/mydatabase</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">MySQL</td>\n<td style=\"text-align:left\">mysql://scott:tiger@localhost/mydatabase</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Oracle</td>\n<td style=\"text-align:left\">oracle://scott:<a href=\"mailto:tiger@127.0.0.1\" target=\"_blank\" rel=\"noopener\">tiger@127.0.0.1</a>:1521/sidname</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SQLite</td>\n<td style=\"text-align:left\">sqlite:////absolute/path/to/foo.db</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"模型定义\"><a href=\"#模型定义\" class=\"headerlink\" title=\"模型定义\"></a>模型定义</h2><p>在ORM中，模型一般是一个Python类，类中的属性对应为数据表中的列 (app/models.py)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> . <span class=\"keyword\">import</span> db</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span><span class=\"params\">(db.Model)</span>:</span></span><br><span class=\"line\">    __tablename__ = <span class=\"string\">'users'</span></span><br><span class=\"line\">    id = db.Column(db.Integer, primary_key=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    username = db.Column(db.String(<span class=\"number\">64</span>), unique=<span class=\"keyword\">True</span>, index=<span class=\"keyword\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'&lt;User %r&gt;'</span> % self.username</span><br></pre></td></tr></table></figure>\n<p>这个模型创建了两个字段，他们是类db.Column的实例，id和username。db.Column 类构造函数的第一个参数是数据库列和模型属性的类型，下面列出了一些常见的列类型以及在模型中使用的Python类型：</p>\n<ul>\n<li>Integer：普通整数，一般是32bit</li>\n<li>String：变长字符串</li>\n<li>Text：变长字符串，对较长或不限长度的字符做了优化</li>\n<li>Boolean：布尔值</li>\n<li>Date：日期</li>\n<li>DateTime：日期和时间</li>\n</ul>\n<p>db.Column 中其余的参数指定属性的配置选项。下面列出了一些常用选项：</p>\n<ul>\n<li>primary_key：如果设置为True，这列就是表的主键</li>\n<li>unique：如果设置为True，这列不允许出现重复的值</li>\n<li>index：如果设置为True，为这列创建索引，提升查询效率</li>\n<li>default：为这列定义默认值</li>\n</ul>\n<h3 id=\"一对多关系\"><a href=\"#一对多关系\" class=\"headerlink\" title=\"一对多关系\"></a>一对多关系</h3><p>关系型数据库使用主外键关系把不同表中的行联系起来。关系可能分为：一对一、一对多、多对多等。关系使用<code>db.relationship()</code>函数表示，外键使用<code>db.ForeignKey</code>来单独声明。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Role</span><span class=\"params\">(db.Model)</span>:</span></span><br><span class=\"line\">    __tablename__ = <span class=\"string\">'roles'</span></span><br><span class=\"line\">    id = db.Column(db.Integer, primary_key=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    name = db.Column(db.String(<span class=\"number\">64</span>), unique=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    users = db.relationship(<span class=\"string\">'User'</span>, backref=<span class=\"string\">'role'</span>, lazy=<span class=\"string\">'dynamic'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'&lt;Role %r&gt;'</span> % self.name</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span><span class=\"params\">(db.Model)</span>:</span></span><br><span class=\"line\">    __tablename__ = <span class=\"string\">'users'</span></span><br><span class=\"line\">    id = db.Column(db.Integer, primary_key=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    username = db.Column(db.String(<span class=\"number\">64</span>), unique=<span class=\"keyword\">True</span>, index=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    role_id = db.Column(db.Integer, db.ForeignKey(<span class=\"string\">'roles.id'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'&lt;User %r&gt;'</span> % self.username</span><br></pre></td></tr></table></figure>\n<p>user表中的<code>db.ForeignKey(&#39;roles.id&#39;)</code>属性说明，user表的role_id列被定义为外键去关联roles表的id列。在role表中添加的users属性将返回与角色相关联的用户组成的列表(代表这个关系的面向对象视角)</p>\n<p>常用的配置选项如下所示：</p>\n<ul>\n<li>backref：在关系的另一个模型中添加反向引用</li>\n<li>primaryjoin：明确指定两个模型之间使用的联结条件。只在模棱两可的关系中需要指定</li>\n<li>lazy：决定了SQLAlchemy什么时候从数据库中加载数据。可选值有 select(首次访问时按需加载)、immediate(源对象加<br>载后就加载)、 joined(加载记录，但使用联结)、 subquery (立即加载，但使用子查询)，<br>noload(永不加载)和 dynamic(不加载记录，但提供加载记录的查询)</li>\n</ul>\n<h3 id=\"多对多关系\"><a href=\"#多对多关系\" class=\"headerlink\" title=\"多对多关系\"></a>多对多关系</h3><p>在学习数据库时，处理多对多关系的方法是用到第三张表，也就是关系表。</p>\n<h2 id=\"数据库基本操作\"><a href=\"#数据库基本操作\" class=\"headerlink\" title=\"数据库基本操作\"></a>数据库基本操作</h2><p>在创建好Flask应用、配置好，创建了SQLAlchemy对象之后，就可以对定义好的数据库进行操作了，主要操作就是增删改查四项。</p>\n<h3 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.create_all()</span><br></pre></td></tr></table></figure>\n<p>这时候在程序目录中创建了一个.sqlite的文件，这个就是数据库文件了。</p>\n<h3 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user_john=User(username=<span class=\"string\">'john'</span>)</span><br><span class=\"line\"><span class=\"comment\">#添加到数据库会话</span></span><br><span class=\"line\">db.session.add(user_john)</span><br><span class=\"line\"><span class=\"comment\">#提交</span></span><br><span class=\"line\">db.session.commit()</span><br></pre></td></tr></table></figure>\n<p>数据库会话(db.session)和Flask的session没有什么关系，数据库会话就是关系型数据库的事务，事务能够保证数据库的一致性，提交操作使用原子方式把会话中的对象全部写入数据库，如果发生错误，可以回滚(<code>db.session.rollback()</code>)。</p>\n<h3 id=\"修改数据\"><a href=\"#修改数据\" class=\"headerlink\" title=\"修改数据\"></a>修改数据</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">admin_role = <span class=\"string\">'new role name'</span></span><br><span class=\"line\">db.session.add(admin_role)</span><br><span class=\"line\">db.session.commit()</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h3><p>数据库会话也有删除操作</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#删除行</span></span><br><span class=\"line\">db.session.delete(user_john)</span><br><span class=\"line\">db.session.commit()</span><br></pre></td></tr></table></figure>\n<h3 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h3><p>Flask-SQLAlchemy 在Model类上提供了 query 属性。访问它，会得到一个新的所有记录的查询对象。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#查询行</span></span><br><span class=\"line\">User.query.all()</span><br></pre></td></tr></table></figure>\n<p>使用过滤器可以配置query对象进行更精确的数据库查询:</p>\n<ul>\n<li>filter()：把过滤器添加到原查询上，返回一个新查询</li>\n<li>filter_by()：把等值过滤器添加到原查询上，返回一个新查询</li>\n<li>limit()：使用指定的值限制原查询返回的结果数量，返回一个新查询</li>\n<li>offset()：偏移原查询返回的结果，返回一个新查询</li>\n<li>order_by()：根据指定条件对原查询结果进行排序，返回一个新查询</li>\n<li>group_by()：根据指定条件对原查询结果进行分组，返回一个新查询</li>\n</ul>\n<p>在查询上应用指定的过滤器后，通过调用all()执行查询，以列表的形式返回结果。除了all()之外，还有其他方法能触发查询执行。下面列出常用的执行查询方法：</p>\n<ul>\n<li>all()：以列表形式返回查询的所有结果</li>\n<li>first()：返回查询的第一个结果，如果没有结果，则返回 None</li>\n<li>first_or_404()：返回查询的第一个结果，如果没有结果，则终止请求，返回 404 错误响应</li>\n<li>get()：返回指定主键对应的行，如果没有对应的行，则返回 None</li>\n<li>get_or_404()：返回指定主键对应的行，如果没找到指定的主键，则终止请求，返回 404 错误响应</li>\n<li>count()：返回查询结果的数量</li>\n<li>paginate()：返回一个 Paginate 对象，它包含指定范围内的结果</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Flask-SQLAlchemy是一个Flask扩展，它简化了在Flask应用程序中对SQLAlchemy的使用。SQLAlchemy是一个强大的关系数据库框架，支持一些数据库后端。提供高级的ORM和底层访问数据库的本地SQL功能。</p>\n<p>通过pip安装Flask-SQLAlchemy：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(venv) $ pip install flask-sqlalchemy</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/Flask-SQLAlchemy_logo.png\" alt=\"Flask-SQLAlchemy Logo\"></p>\n<p>对于一个Flask应用，我们需要先创建Flask应用，选择加载配置，然后创建SQLAlchemy对象时候把Flask应用传递给它作为参数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask_sqlalchemy <span class=\"keyword\">import</span> SQLAlchemy</span><br><span class=\"line\"><span class=\"keyword\">from</span> config <span class=\"keyword\">import</span> config</span><br><span class=\"line\"></span><br><span class=\"line\">db = SQLAlchemy()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_app</span><span class=\"params\">(config_name)</span>:</span></span><br><span class=\"line\">    app = Flask(__name__)</span><br><span class=\"line\">    app.config.from_object(config[config_name])</span><br><span class=\"line\">    config[config_name].init_app(app)</span><br><span class=\"line\"></span><br><span class=\"line\">    db.init_app(app)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> app</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>下面是Flask-SQLAlchemy中常用的配置值。Flask-SQLAlchemy从Flask主配置(config.py)中加载这些值。</p>\n<ul>\n<li>SQLALCHEMY_DATABASE_URI：用于数据库的连接，例如sqlite:////tmp/test.db</li>\n<li>SQLALCHEMY_TRACK_MODIFICATIONS：如果设置成True(默认情况)，Flask-SQLAlchemy将会追踪对象的修改并且发送信号。这需要额外的内存，如果不必要的可以禁用它。</li>\n<li>SQLALCHEMY_COMMIT_ON_TEARDOWN：每次request自动提交db.session.commit()</li>\n</ul>\n<p>更多的配置键请参考<a href=\"http://www.pythondoc.com/flask-sqlalchemy/config.html\" target=\"_blank\" rel=\"noopener\">Flask-SQLAlchemy官方文档</a>。</p>\n<p>常见数据库的连接URI格式如下所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Database</th>\n<th style=\"text-align:left\">URI</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Postgres</td>\n<td style=\"text-align:left\">postgresql://scott:tiger@localhost/mydatabase</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">MySQL</td>\n<td style=\"text-align:left\">mysql://scott:tiger@localhost/mydatabase</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Oracle</td>\n<td style=\"text-align:left\">oracle://scott:<a href=\"mailto:tiger@127.0.0.1\" target=\"_blank\" rel=\"noopener\">tiger@127.0.0.1</a>:1521/sidname</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SQLite</td>\n<td style=\"text-align:left\">sqlite:////absolute/path/to/foo.db</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"模型定义\"><a href=\"#模型定义\" class=\"headerlink\" title=\"模型定义\"></a>模型定义</h2><p>在ORM中，模型一般是一个Python类，类中的属性对应为数据表中的列 (app/models.py)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> . <span class=\"keyword\">import</span> db</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span><span class=\"params\">(db.Model)</span>:</span></span><br><span class=\"line\">    __tablename__ = <span class=\"string\">'users'</span></span><br><span class=\"line\">    id = db.Column(db.Integer, primary_key=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    username = db.Column(db.String(<span class=\"number\">64</span>), unique=<span class=\"keyword\">True</span>, index=<span class=\"keyword\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'&lt;User %r&gt;'</span> % self.username</span><br></pre></td></tr></table></figure>\n<p>这个模型创建了两个字段，他们是类db.Column的实例，id和username。db.Column 类构造函数的第一个参数是数据库列和模型属性的类型，下面列出了一些常见的列类型以及在模型中使用的Python类型：</p>\n<ul>\n<li>Integer：普通整数，一般是32bit</li>\n<li>String：变长字符串</li>\n<li>Text：变长字符串，对较长或不限长度的字符做了优化</li>\n<li>Boolean：布尔值</li>\n<li>Date：日期</li>\n<li>DateTime：日期和时间</li>\n</ul>\n<p>db.Column 中其余的参数指定属性的配置选项。下面列出了一些常用选项：</p>\n<ul>\n<li>primary_key：如果设置为True，这列就是表的主键</li>\n<li>unique：如果设置为True，这列不允许出现重复的值</li>\n<li>index：如果设置为True，为这列创建索引，提升查询效率</li>\n<li>default：为这列定义默认值</li>\n</ul>\n<h3 id=\"一对多关系\"><a href=\"#一对多关系\" class=\"headerlink\" title=\"一对多关系\"></a>一对多关系</h3><p>关系型数据库使用主外键关系把不同表中的行联系起来。关系可能分为：一对一、一对多、多对多等。关系使用<code>db.relationship()</code>函数表示，外键使用<code>db.ForeignKey</code>来单独声明。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Role</span><span class=\"params\">(db.Model)</span>:</span></span><br><span class=\"line\">    __tablename__ = <span class=\"string\">'roles'</span></span><br><span class=\"line\">    id = db.Column(db.Integer, primary_key=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    name = db.Column(db.String(<span class=\"number\">64</span>), unique=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    users = db.relationship(<span class=\"string\">'User'</span>, backref=<span class=\"string\">'role'</span>, lazy=<span class=\"string\">'dynamic'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'&lt;Role %r&gt;'</span> % self.name</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span><span class=\"params\">(db.Model)</span>:</span></span><br><span class=\"line\">    __tablename__ = <span class=\"string\">'users'</span></span><br><span class=\"line\">    id = db.Column(db.Integer, primary_key=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    username = db.Column(db.String(<span class=\"number\">64</span>), unique=<span class=\"keyword\">True</span>, index=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    role_id = db.Column(db.Integer, db.ForeignKey(<span class=\"string\">'roles.id'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'&lt;User %r&gt;'</span> % self.username</span><br></pre></td></tr></table></figure>\n<p>user表中的<code>db.ForeignKey(&#39;roles.id&#39;)</code>属性说明，user表的role_id列被定义为外键去关联roles表的id列。在role表中添加的users属性将返回与角色相关联的用户组成的列表(代表这个关系的面向对象视角)</p>\n<p>常用的配置选项如下所示：</p>\n<ul>\n<li>backref：在关系的另一个模型中添加反向引用</li>\n<li>primaryjoin：明确指定两个模型之间使用的联结条件。只在模棱两可的关系中需要指定</li>\n<li>lazy：决定了SQLAlchemy什么时候从数据库中加载数据。可选值有 select(首次访问时按需加载)、immediate(源对象加<br>载后就加载)、 joined(加载记录，但使用联结)、 subquery (立即加载，但使用子查询)，<br>noload(永不加载)和 dynamic(不加载记录，但提供加载记录的查询)</li>\n</ul>\n<h3 id=\"多对多关系\"><a href=\"#多对多关系\" class=\"headerlink\" title=\"多对多关系\"></a>多对多关系</h3><p>在学习数据库时，处理多对多关系的方法是用到第三张表，也就是关系表。</p>\n<h2 id=\"数据库基本操作\"><a href=\"#数据库基本操作\" class=\"headerlink\" title=\"数据库基本操作\"></a>数据库基本操作</h2><p>在创建好Flask应用、配置好，创建了SQLAlchemy对象之后，就可以对定义好的数据库进行操作了，主要操作就是增删改查四项。</p>\n<h3 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.create_all()</span><br></pre></td></tr></table></figure>\n<p>这时候在程序目录中创建了一个.sqlite的文件，这个就是数据库文件了。</p>\n<h3 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user_john=User(username=<span class=\"string\">'john'</span>)</span><br><span class=\"line\"><span class=\"comment\">#添加到数据库会话</span></span><br><span class=\"line\">db.session.add(user_john)</span><br><span class=\"line\"><span class=\"comment\">#提交</span></span><br><span class=\"line\">db.session.commit()</span><br></pre></td></tr></table></figure>\n<p>数据库会话(db.session)和Flask的session没有什么关系，数据库会话就是关系型数据库的事务，事务能够保证数据库的一致性，提交操作使用原子方式把会话中的对象全部写入数据库，如果发生错误，可以回滚(<code>db.session.rollback()</code>)。</p>\n<h3 id=\"修改数据\"><a href=\"#修改数据\" class=\"headerlink\" title=\"修改数据\"></a>修改数据</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">admin_role = <span class=\"string\">'new role name'</span></span><br><span class=\"line\">db.session.add(admin_role)</span><br><span class=\"line\">db.session.commit()</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h3><p>数据库会话也有删除操作</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#删除行</span></span><br><span class=\"line\">db.session.delete(user_john)</span><br><span class=\"line\">db.session.commit()</span><br></pre></td></tr></table></figure>\n<h3 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h3><p>Flask-SQLAlchemy 在Model类上提供了 query 属性。访问它，会得到一个新的所有记录的查询对象。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#查询行</span></span><br><span class=\"line\">User.query.all()</span><br></pre></td></tr></table></figure>\n<p>使用过滤器可以配置query对象进行更精确的数据库查询:</p>\n<ul>\n<li>filter()：把过滤器添加到原查询上，返回一个新查询</li>\n<li>filter_by()：把等值过滤器添加到原查询上，返回一个新查询</li>\n<li>limit()：使用指定的值限制原查询返回的结果数量，返回一个新查询</li>\n<li>offset()：偏移原查询返回的结果，返回一个新查询</li>\n<li>order_by()：根据指定条件对原查询结果进行排序，返回一个新查询</li>\n<li>group_by()：根据指定条件对原查询结果进行分组，返回一个新查询</li>\n</ul>\n<p>在查询上应用指定的过滤器后，通过调用all()执行查询，以列表的形式返回结果。除了all()之外，还有其他方法能触发查询执行。下面列出常用的执行查询方法：</p>\n<ul>\n<li>all()：以列表形式返回查询的所有结果</li>\n<li>first()：返回查询的第一个结果，如果没有结果，则返回 None</li>\n<li>first_or_404()：返回查询的第一个结果，如果没有结果，则终止请求，返回 404 错误响应</li>\n<li>get()：返回指定主键对应的行，如果没有对应的行，则返回 None</li>\n<li>get_or_404()：返回指定主键对应的行，如果没找到指定的主键，则终止请求，返回 404 错误响应</li>\n<li>count()：返回查询结果的数量</li>\n<li>paginate()：返回一个 Paginate 对象，它包含指定范围内的结果</li>\n</ul>"},{"title":"Flask 从入门到放弃6: 网站结构最佳实践","date":"2017-08-28T09:50:39.000Z","_content":"\n\n来自[狗书](https://item.jd.com/11594082.html)第七章：大型程序的结构\n\n ![Flask Web Development](https://covers.oreillystatic.com/images/0636920031116/lrg.jpg)\n\n## 项目结构\n\n下图显示多文件的Flask程序的基本结构\n\n![FlaskProjectTree](http://7xkfga.com1.z0.glb.clouddn.com/structure.png)\n\n<!-- more -->\n\n这个结构有四个顶层目录：\n\n- Flask应用一般放置在名为`app`的目录下\n- `migrations`目录包含数据库迁移脚本\n- 单元测试放置在`test`目录下\n- `venv`目录包含Python虚拟环境\n\n还有一些新的文件：\n\n- `requirements.txt`列出一些依赖包，这样就可以很容易的在不同的计算机上部署一个相同的虚拟环境。\n- `config.py`存储了一些配置设置。\n- `manage.py`用于启动应用程序和其他应用程序任务。\n\n## 配置选项\n\n在这里配置应用相关的配置，例如Form用到的`SECRET_KEY`, 数据库配置的`SQLALCHEMY_DATABASE_URI`等配置信息。也可以在这里配置开发、测试和生产环境所需要的不同配置等。\n\n `config.py`文件：\n\n``` python\nimport os\nbasedir = os.path.abspath(os.path.dirname(__file__))\n\nclass Config:\n    SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard to guess string'\n    SQLALCHEMY_COMMIT_ON_TEARDOWN = True\n    FLASKY_MAIL_SUBJECT_PREFIX = '[Flasky]'\n    FLASKY_MAIL_SENDER = 'Flasky Admin <flasky@example.com>'\n    FLASKY_ADMIN = os.environ.get('FLASKY_ADMIN')\n\n    @staticmethod\n    def init_app(app):\n        pass\n\nclass DevelopmentConfig(Config):\n    DEBUG = True\n\n    MAIL_SERVER = 'smtp.googlemail.com'\n    MAIL_PORT = 587\n    MAIL_USE_TLS = True\n    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')\n    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URL') or \\\n        'sqlite:///' + os.path.join(basedir, 'data-dev.sqlite')\n\nclass TestingConfig(Config):\n    TESTING = True\n    SQLALCHEMY_DATABASE_URI = os.environ.get('TEST_DATABASE_URL') or \\\n        'sqlite:///' + os.path.join(basedir, 'data-test.sqlite')\n\nclass ProductionConfig(Config):\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \\\n        'sqlite:///' + os.path.join(basedir, 'data.sqlite')\n\nconfig = {\n    'development': DevelopmentConfig,\n    'testing': TestingConfig,\n    'production': ProductionConfig,\n    'default': DevelopmentConfig\n}\n```\n\n## 程序包\n\n应用程序包放置了所有应用程序代码、模板(templates)和静态文件(static)。数据库模型和电子邮件支持功能也要置入到这个包中，以`app/models.py`和`app/email.py`形式存入自己的模块当中\n\n### 使用工厂函数创建程序实例\n\n单个文件中开发程序，创建程序实例在全局作用域中，无法动态修改配置，对于单元测试来说很重要，必须在不同的配置环境中运行程序。\n\n这里把创建程序实例的过程放到可显示调用的**工厂函数**中。(`app.__init__.py`)\n\n``` python\nfrom flask import Flask\nfrom flask_bootstrap import Bootstrap\nfrom flask_sqlalchemy import SQLAlchemy\nfrom config import config\n\nbootstrap = Bootstrap()\ndb = SQLAlchemy()\n\n\ndef create_app(config_name):\n    app = Flask(__name__)\n    app.config.from_object(config[config_name])\n    config[config_name].init_app(app)\n\n    bootstrap.init_app(app)\n    mail.init_app(app)\n    moment.init_app(app)\n    db.init_app(app)\n\n    ## route and errorhandler\n\n    return app\n```\n\n工厂函数返回创建的Flask程序实例。`create_app()`函数就是程序的工厂函数，接收一个参数就是程序所使用的配置名。这时候，是动态获得了程序实例了，但是定义路由需要在调用工厂函数之后才能使用`app.route`装饰器定义路由。这时候就引入蓝图(Blueprint)来进行路由的定义。\n\n### 蓝图中实现程序功能\n\n蓝图定义的路由处于休眠状态，直到蓝图注册到应用实例上后，路由才真正成为程序的一部分，蓝图的使用对于大型程序的模块化开发提供了方便。\n\n`app/main/__init__.py`\n\n``` python\nfrom flask import Blueprint\n\nmain = Blueprint('main', __name__)\n\nfrom . import views, errors\n```\n\n这里定义蓝图main，程序的路由在views.py中，错误处理程序在errors.py中\n\n在工厂函数`create_app()`中将蓝图注册到程序实例上\n\n``` python\ndef create_app(config_name):\n    app = Flask(__name__)\n    # ...\n\n    from .main import main as main_blueprint\n    app.register_blueprint(main_blueprint)\n\n    return app\n```\n\n## 启动脚本\n\n在顶级文件夹中的manage.py文件用于启动应用程序 manage.py\n\n``` python\n#!/usr/bin/env python\nimport os\nfrom app import create_app, db\nfrom app.models import User, Role\nfrom flask_script import Manager, Shell\nfrom flask_migrate import Migrate, MigrateCommand\n\napp = create_app(os.getenv('FLASK_CONFIG') or 'default')\nmanager = Manager(app)\nmigrate = Migrate(app, db)\n\n\ndef make_shell_context():\n    return dict(app=app, db=db, User=User, Role=Role)\n\nmanager.add_command(\"shell\", Shell(make_context=make_shell_context))\nmanager.add_command('db', MigrateCommand)\n\n\nif __name__ == '__main__':\n    manager.run()\n```\n\n## 需求文件\n\n包含一个requirement.txt文件，用于记录所有依赖包以及精准的版本号，pip使用下面命令生成需求文件\n\n``` shell\n(venv) $ pip freeze > requirements.txt\n```\n\n在一个新环境中，使用下面的命令创建一个相同的环境\n\n``` shell\n(venv) $ pip install -r requirements.txt\n```\n","source":"_posts/Flask-¥”»Î√≈µΩ∑≈∆˙6-Õ¯’æΩ·ππ◊Óº— µº˘.md","raw":"---\ntitle: 'Flask 从入门到放弃6: 网站结构最佳实践'\ntags:\n  - Python\n  - Flask\ncategories: Flask从入门到放弃\ndate: 2017-08-28 17:50:39\n---\n\n\n来自[狗书](https://item.jd.com/11594082.html)第七章：大型程序的结构\n\n ![Flask Web Development](https://covers.oreillystatic.com/images/0636920031116/lrg.jpg)\n\n## 项目结构\n\n下图显示多文件的Flask程序的基本结构\n\n![FlaskProjectTree](http://7xkfga.com1.z0.glb.clouddn.com/structure.png)\n\n<!-- more -->\n\n这个结构有四个顶层目录：\n\n- Flask应用一般放置在名为`app`的目录下\n- `migrations`目录包含数据库迁移脚本\n- 单元测试放置在`test`目录下\n- `venv`目录包含Python虚拟环境\n\n还有一些新的文件：\n\n- `requirements.txt`列出一些依赖包，这样就可以很容易的在不同的计算机上部署一个相同的虚拟环境。\n- `config.py`存储了一些配置设置。\n- `manage.py`用于启动应用程序和其他应用程序任务。\n\n## 配置选项\n\n在这里配置应用相关的配置，例如Form用到的`SECRET_KEY`, 数据库配置的`SQLALCHEMY_DATABASE_URI`等配置信息。也可以在这里配置开发、测试和生产环境所需要的不同配置等。\n\n `config.py`文件：\n\n``` python\nimport os\nbasedir = os.path.abspath(os.path.dirname(__file__))\n\nclass Config:\n    SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard to guess string'\n    SQLALCHEMY_COMMIT_ON_TEARDOWN = True\n    FLASKY_MAIL_SUBJECT_PREFIX = '[Flasky]'\n    FLASKY_MAIL_SENDER = 'Flasky Admin <flasky@example.com>'\n    FLASKY_ADMIN = os.environ.get('FLASKY_ADMIN')\n\n    @staticmethod\n    def init_app(app):\n        pass\n\nclass DevelopmentConfig(Config):\n    DEBUG = True\n\n    MAIL_SERVER = 'smtp.googlemail.com'\n    MAIL_PORT = 587\n    MAIL_USE_TLS = True\n    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')\n    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URL') or \\\n        'sqlite:///' + os.path.join(basedir, 'data-dev.sqlite')\n\nclass TestingConfig(Config):\n    TESTING = True\n    SQLALCHEMY_DATABASE_URI = os.environ.get('TEST_DATABASE_URL') or \\\n        'sqlite:///' + os.path.join(basedir, 'data-test.sqlite')\n\nclass ProductionConfig(Config):\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \\\n        'sqlite:///' + os.path.join(basedir, 'data.sqlite')\n\nconfig = {\n    'development': DevelopmentConfig,\n    'testing': TestingConfig,\n    'production': ProductionConfig,\n    'default': DevelopmentConfig\n}\n```\n\n## 程序包\n\n应用程序包放置了所有应用程序代码、模板(templates)和静态文件(static)。数据库模型和电子邮件支持功能也要置入到这个包中，以`app/models.py`和`app/email.py`形式存入自己的模块当中\n\n### 使用工厂函数创建程序实例\n\n单个文件中开发程序，创建程序实例在全局作用域中，无法动态修改配置，对于单元测试来说很重要，必须在不同的配置环境中运行程序。\n\n这里把创建程序实例的过程放到可显示调用的**工厂函数**中。(`app.__init__.py`)\n\n``` python\nfrom flask import Flask\nfrom flask_bootstrap import Bootstrap\nfrom flask_sqlalchemy import SQLAlchemy\nfrom config import config\n\nbootstrap = Bootstrap()\ndb = SQLAlchemy()\n\n\ndef create_app(config_name):\n    app = Flask(__name__)\n    app.config.from_object(config[config_name])\n    config[config_name].init_app(app)\n\n    bootstrap.init_app(app)\n    mail.init_app(app)\n    moment.init_app(app)\n    db.init_app(app)\n\n    ## route and errorhandler\n\n    return app\n```\n\n工厂函数返回创建的Flask程序实例。`create_app()`函数就是程序的工厂函数，接收一个参数就是程序所使用的配置名。这时候，是动态获得了程序实例了，但是定义路由需要在调用工厂函数之后才能使用`app.route`装饰器定义路由。这时候就引入蓝图(Blueprint)来进行路由的定义。\n\n### 蓝图中实现程序功能\n\n蓝图定义的路由处于休眠状态，直到蓝图注册到应用实例上后，路由才真正成为程序的一部分，蓝图的使用对于大型程序的模块化开发提供了方便。\n\n`app/main/__init__.py`\n\n``` python\nfrom flask import Blueprint\n\nmain = Blueprint('main', __name__)\n\nfrom . import views, errors\n```\n\n这里定义蓝图main，程序的路由在views.py中，错误处理程序在errors.py中\n\n在工厂函数`create_app()`中将蓝图注册到程序实例上\n\n``` python\ndef create_app(config_name):\n    app = Flask(__name__)\n    # ...\n\n    from .main import main as main_blueprint\n    app.register_blueprint(main_blueprint)\n\n    return app\n```\n\n## 启动脚本\n\n在顶级文件夹中的manage.py文件用于启动应用程序 manage.py\n\n``` python\n#!/usr/bin/env python\nimport os\nfrom app import create_app, db\nfrom app.models import User, Role\nfrom flask_script import Manager, Shell\nfrom flask_migrate import Migrate, MigrateCommand\n\napp = create_app(os.getenv('FLASK_CONFIG') or 'default')\nmanager = Manager(app)\nmigrate = Migrate(app, db)\n\n\ndef make_shell_context():\n    return dict(app=app, db=db, User=User, Role=Role)\n\nmanager.add_command(\"shell\", Shell(make_context=make_shell_context))\nmanager.add_command('db', MigrateCommand)\n\n\nif __name__ == '__main__':\n    manager.run()\n```\n\n## 需求文件\n\n包含一个requirement.txt文件，用于记录所有依赖包以及精准的版本号，pip使用下面命令生成需求文件\n\n``` shell\n(venv) $ pip freeze > requirements.txt\n```\n\n在一个新环境中，使用下面的命令创建一个相同的环境\n\n``` shell\n(venv) $ pip install -r requirements.txt\n```\n","slug":"Flask-¥”»Î√≈µΩ∑≈∆˙6-Õ¯’æΩ·ππ◊Óº— µº˘","published":1,"updated":"2017-08-28T09:51:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3o20026zd68x5lhji3x","content":"<p>来自<a href=\"https://item.jd.com/11594082.html\" target=\"_blank\" rel=\"noopener\">狗书</a>第七章：大型程序的结构</p>\n<p> <img src=\"https://covers.oreillystatic.com/images/0636920031116/lrg.jpg\" alt=\"Flask Web Development\"></p>\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>下图显示多文件的Flask程序的基本结构</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/structure.png\" alt=\"FlaskProjectTree\"></p>\n<a id=\"more\"></a>\n<p>这个结构有四个顶层目录：</p>\n<ul>\n<li>Flask应用一般放置在名为<code>app</code>的目录下</li>\n<li><code>migrations</code>目录包含数据库迁移脚本</li>\n<li>单元测试放置在<code>test</code>目录下</li>\n<li><code>venv</code>目录包含Python虚拟环境</li>\n</ul>\n<p>还有一些新的文件：</p>\n<ul>\n<li><code>requirements.txt</code>列出一些依赖包，这样就可以很容易的在不同的计算机上部署一个相同的虚拟环境。</li>\n<li><code>config.py</code>存储了一些配置设置。</li>\n<li><code>manage.py</code>用于启动应用程序和其他应用程序任务。</li>\n</ul>\n<h2 id=\"配置选项\"><a href=\"#配置选项\" class=\"headerlink\" title=\"配置选项\"></a>配置选项</h2><p>在这里配置应用相关的配置，例如Form用到的<code>SECRET_KEY</code>, 数据库配置的<code>SQLALCHEMY_DATABASE_URI</code>等配置信息。也可以在这里配置开发、测试和生产环境所需要的不同配置等。</p>\n<p> <code>config.py</code>文件：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\">basedir = os.path.abspath(os.path.dirname(__file__))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Config</span>:</span></span><br><span class=\"line\">    SECRET_KEY = os.environ.get(<span class=\"string\">'SECRET_KEY'</span>) <span class=\"keyword\">or</span> <span class=\"string\">'hard to guess string'</span></span><br><span class=\"line\">    SQLALCHEMY_COMMIT_ON_TEARDOWN = <span class=\"keyword\">True</span></span><br><span class=\"line\">    FLASKY_MAIL_SUBJECT_PREFIX = <span class=\"string\">'[Flasky]'</span></span><br><span class=\"line\">    FLASKY_MAIL_SENDER = <span class=\"string\">'Flasky Admin &lt;flasky@example.com&gt;'</span></span><br><span class=\"line\">    FLASKY_ADMIN = os.environ.get(<span class=\"string\">'FLASKY_ADMIN'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init_app</span><span class=\"params\">(app)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DevelopmentConfig</span><span class=\"params\">(Config)</span>:</span></span><br><span class=\"line\">    DEBUG = <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    MAIL_SERVER = <span class=\"string\">'smtp.googlemail.com'</span></span><br><span class=\"line\">    MAIL_PORT = <span class=\"number\">587</span></span><br><span class=\"line\">    MAIL_USE_TLS = <span class=\"keyword\">True</span></span><br><span class=\"line\">    MAIL_USERNAME = os.environ.get(<span class=\"string\">'MAIL_USERNAME'</span>)</span><br><span class=\"line\">    MAIL_PASSWORD = os.environ.get(<span class=\"string\">'MAIL_PASSWORD'</span>)</span><br><span class=\"line\">    SQLALCHEMY_DATABASE_URI = os.environ.get(<span class=\"string\">'DEV_DATABASE_URL'</span>) <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">        <span class=\"string\">'sqlite:///'</span> + os.path.join(basedir, <span class=\"string\">'data-dev.sqlite'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestingConfig</span><span class=\"params\">(Config)</span>:</span></span><br><span class=\"line\">    TESTING = <span class=\"keyword\">True</span></span><br><span class=\"line\">    SQLALCHEMY_DATABASE_URI = os.environ.get(<span class=\"string\">'TEST_DATABASE_URL'</span>) <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">        <span class=\"string\">'sqlite:///'</span> + os.path.join(basedir, <span class=\"string\">'data-test.sqlite'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductionConfig</span><span class=\"params\">(Config)</span>:</span></span><br><span class=\"line\">    SQLALCHEMY_DATABASE_URI = os.environ.get(<span class=\"string\">'DATABASE_URL'</span>) <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">        <span class=\"string\">'sqlite:///'</span> + os.path.join(basedir, <span class=\"string\">'data.sqlite'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">config = &#123;</span><br><span class=\"line\">    <span class=\"string\">'development'</span>: DevelopmentConfig,</span><br><span class=\"line\">    <span class=\"string\">'testing'</span>: TestingConfig,</span><br><span class=\"line\">    <span class=\"string\">'production'</span>: ProductionConfig,</span><br><span class=\"line\">    <span class=\"string\">'default'</span>: DevelopmentConfig</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"程序包\"><a href=\"#程序包\" class=\"headerlink\" title=\"程序包\"></a>程序包</h2><p>应用程序包放置了所有应用程序代码、模板(templates)和静态文件(static)。数据库模型和电子邮件支持功能也要置入到这个包中，以<code>app/models.py</code>和<code>app/email.py</code>形式存入自己的模块当中</p>\n<h3 id=\"使用工厂函数创建程序实例\"><a href=\"#使用工厂函数创建程序实例\" class=\"headerlink\" title=\"使用工厂函数创建程序实例\"></a>使用工厂函数创建程序实例</h3><p>单个文件中开发程序，创建程序实例在全局作用域中，无法动态修改配置，对于单元测试来说很重要，必须在不同的配置环境中运行程序。</p>\n<p>这里把创建程序实例的过程放到可显示调用的<strong>工厂函数</strong>中。(<code>app.__init__.py</code>)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_bootstrap <span class=\"keyword\">import</span> Bootstrap</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_sqlalchemy <span class=\"keyword\">import</span> SQLAlchemy</span><br><span class=\"line\"><span class=\"keyword\">from</span> config <span class=\"keyword\">import</span> config</span><br><span class=\"line\"></span><br><span class=\"line\">bootstrap = Bootstrap()</span><br><span class=\"line\">db = SQLAlchemy()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_app</span><span class=\"params\">(config_name)</span>:</span></span><br><span class=\"line\">    app = Flask(__name__)</span><br><span class=\"line\">    app.config.from_object(config[config_name])</span><br><span class=\"line\">    config[config_name].init_app(app)</span><br><span class=\"line\"></span><br><span class=\"line\">    bootstrap.init_app(app)</span><br><span class=\"line\">    mail.init_app(app)</span><br><span class=\"line\">    moment.init_app(app)</span><br><span class=\"line\">    db.init_app(app)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">## route and errorhandler</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> app</span><br></pre></td></tr></table></figure>\n<p>工厂函数返回创建的Flask程序实例。<code>create_app()</code>函数就是程序的工厂函数，接收一个参数就是程序所使用的配置名。这时候，是动态获得了程序实例了，但是定义路由需要在调用工厂函数之后才能使用<code>app.route</code>装饰器定义路由。这时候就引入蓝图(Blueprint)来进行路由的定义。</p>\n<h3 id=\"蓝图中实现程序功能\"><a href=\"#蓝图中实现程序功能\" class=\"headerlink\" title=\"蓝图中实现程序功能\"></a>蓝图中实现程序功能</h3><p>蓝图定义的路由处于休眠状态，直到蓝图注册到应用实例上后，路由才真正成为程序的一部分，蓝图的使用对于大型程序的模块化开发提供了方便。</p>\n<p><code>app/main/__init__.py</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Blueprint</span><br><span class=\"line\"></span><br><span class=\"line\">main = Blueprint(<span class=\"string\">'main'</span>, __name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> . <span class=\"keyword\">import</span> views, errors</span><br></pre></td></tr></table></figure>\n<p>这里定义蓝图main，程序的路由在views.py中，错误处理程序在errors.py中</p>\n<p>在工厂函数<code>create_app()</code>中将蓝图注册到程序实例上</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_app</span><span class=\"params\">(config_name)</span>:</span></span><br><span class=\"line\">    app = Flask(__name__)</span><br><span class=\"line\">    <span class=\"comment\"># ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">from</span> .main <span class=\"keyword\">import</span> main <span class=\"keyword\">as</span> main_blueprint</span><br><span class=\"line\">    app.register_blueprint(main_blueprint)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> app</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动脚本\"><a href=\"#启动脚本\" class=\"headerlink\" title=\"启动脚本\"></a>启动脚本</h2><p>在顶级文件夹中的manage.py文件用于启动应用程序 manage.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">from</span> app <span class=\"keyword\">import</span> create_app, db</span><br><span class=\"line\"><span class=\"keyword\">from</span> app.models <span class=\"keyword\">import</span> User, Role</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_script <span class=\"keyword\">import</span> Manager, Shell</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_migrate <span class=\"keyword\">import</span> Migrate, MigrateCommand</span><br><span class=\"line\"></span><br><span class=\"line\">app = create_app(os.getenv(<span class=\"string\">'FLASK_CONFIG'</span>) <span class=\"keyword\">or</span> <span class=\"string\">'default'</span>)</span><br><span class=\"line\">manager = Manager(app)</span><br><span class=\"line\">migrate = Migrate(app, db)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_shell_context</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dict(app=app, db=db, User=User, Role=Role)</span><br><span class=\"line\"></span><br><span class=\"line\">manager.add_command(<span class=\"string\">\"shell\"</span>, Shell(make_context=make_shell_context))</span><br><span class=\"line\">manager.add_command(<span class=\"string\">'db'</span>, MigrateCommand)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    manager.run()</span><br></pre></td></tr></table></figure>\n<h2 id=\"需求文件\"><a href=\"#需求文件\" class=\"headerlink\" title=\"需求文件\"></a>需求文件</h2><p>包含一个requirement.txt文件，用于记录所有依赖包以及精准的版本号，pip使用下面命令生成需求文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(venv) $ pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>\n<p>在一个新环境中，使用下面的命令创建一个相同的环境</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(venv) $ pip install -r requirements.txt</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>来自<a href=\"https://item.jd.com/11594082.html\" target=\"_blank\" rel=\"noopener\">狗书</a>第七章：大型程序的结构</p>\n<p> <img src=\"https://covers.oreillystatic.com/images/0636920031116/lrg.jpg\" alt=\"Flask Web Development\"></p>\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>下图显示多文件的Flask程序的基本结构</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/structure.png\" alt=\"FlaskProjectTree\"></p>","more":"<p>这个结构有四个顶层目录：</p>\n<ul>\n<li>Flask应用一般放置在名为<code>app</code>的目录下</li>\n<li><code>migrations</code>目录包含数据库迁移脚本</li>\n<li>单元测试放置在<code>test</code>目录下</li>\n<li><code>venv</code>目录包含Python虚拟环境</li>\n</ul>\n<p>还有一些新的文件：</p>\n<ul>\n<li><code>requirements.txt</code>列出一些依赖包，这样就可以很容易的在不同的计算机上部署一个相同的虚拟环境。</li>\n<li><code>config.py</code>存储了一些配置设置。</li>\n<li><code>manage.py</code>用于启动应用程序和其他应用程序任务。</li>\n</ul>\n<h2 id=\"配置选项\"><a href=\"#配置选项\" class=\"headerlink\" title=\"配置选项\"></a>配置选项</h2><p>在这里配置应用相关的配置，例如Form用到的<code>SECRET_KEY</code>, 数据库配置的<code>SQLALCHEMY_DATABASE_URI</code>等配置信息。也可以在这里配置开发、测试和生产环境所需要的不同配置等。</p>\n<p> <code>config.py</code>文件：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\">basedir = os.path.abspath(os.path.dirname(__file__))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Config</span>:</span></span><br><span class=\"line\">    SECRET_KEY = os.environ.get(<span class=\"string\">'SECRET_KEY'</span>) <span class=\"keyword\">or</span> <span class=\"string\">'hard to guess string'</span></span><br><span class=\"line\">    SQLALCHEMY_COMMIT_ON_TEARDOWN = <span class=\"keyword\">True</span></span><br><span class=\"line\">    FLASKY_MAIL_SUBJECT_PREFIX = <span class=\"string\">'[Flasky]'</span></span><br><span class=\"line\">    FLASKY_MAIL_SENDER = <span class=\"string\">'Flasky Admin &lt;flasky@example.com&gt;'</span></span><br><span class=\"line\">    FLASKY_ADMIN = os.environ.get(<span class=\"string\">'FLASKY_ADMIN'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init_app</span><span class=\"params\">(app)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DevelopmentConfig</span><span class=\"params\">(Config)</span>:</span></span><br><span class=\"line\">    DEBUG = <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    MAIL_SERVER = <span class=\"string\">'smtp.googlemail.com'</span></span><br><span class=\"line\">    MAIL_PORT = <span class=\"number\">587</span></span><br><span class=\"line\">    MAIL_USE_TLS = <span class=\"keyword\">True</span></span><br><span class=\"line\">    MAIL_USERNAME = os.environ.get(<span class=\"string\">'MAIL_USERNAME'</span>)</span><br><span class=\"line\">    MAIL_PASSWORD = os.environ.get(<span class=\"string\">'MAIL_PASSWORD'</span>)</span><br><span class=\"line\">    SQLALCHEMY_DATABASE_URI = os.environ.get(<span class=\"string\">'DEV_DATABASE_URL'</span>) <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">        <span class=\"string\">'sqlite:///'</span> + os.path.join(basedir, <span class=\"string\">'data-dev.sqlite'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestingConfig</span><span class=\"params\">(Config)</span>:</span></span><br><span class=\"line\">    TESTING = <span class=\"keyword\">True</span></span><br><span class=\"line\">    SQLALCHEMY_DATABASE_URI = os.environ.get(<span class=\"string\">'TEST_DATABASE_URL'</span>) <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">        <span class=\"string\">'sqlite:///'</span> + os.path.join(basedir, <span class=\"string\">'data-test.sqlite'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductionConfig</span><span class=\"params\">(Config)</span>:</span></span><br><span class=\"line\">    SQLALCHEMY_DATABASE_URI = os.environ.get(<span class=\"string\">'DATABASE_URL'</span>) <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">        <span class=\"string\">'sqlite:///'</span> + os.path.join(basedir, <span class=\"string\">'data.sqlite'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">config = &#123;</span><br><span class=\"line\">    <span class=\"string\">'development'</span>: DevelopmentConfig,</span><br><span class=\"line\">    <span class=\"string\">'testing'</span>: TestingConfig,</span><br><span class=\"line\">    <span class=\"string\">'production'</span>: ProductionConfig,</span><br><span class=\"line\">    <span class=\"string\">'default'</span>: DevelopmentConfig</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"程序包\"><a href=\"#程序包\" class=\"headerlink\" title=\"程序包\"></a>程序包</h2><p>应用程序包放置了所有应用程序代码、模板(templates)和静态文件(static)。数据库模型和电子邮件支持功能也要置入到这个包中，以<code>app/models.py</code>和<code>app/email.py</code>形式存入自己的模块当中</p>\n<h3 id=\"使用工厂函数创建程序实例\"><a href=\"#使用工厂函数创建程序实例\" class=\"headerlink\" title=\"使用工厂函数创建程序实例\"></a>使用工厂函数创建程序实例</h3><p>单个文件中开发程序，创建程序实例在全局作用域中，无法动态修改配置，对于单元测试来说很重要，必须在不同的配置环境中运行程序。</p>\n<p>这里把创建程序实例的过程放到可显示调用的<strong>工厂函数</strong>中。(<code>app.__init__.py</code>)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_bootstrap <span class=\"keyword\">import</span> Bootstrap</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_sqlalchemy <span class=\"keyword\">import</span> SQLAlchemy</span><br><span class=\"line\"><span class=\"keyword\">from</span> config <span class=\"keyword\">import</span> config</span><br><span class=\"line\"></span><br><span class=\"line\">bootstrap = Bootstrap()</span><br><span class=\"line\">db = SQLAlchemy()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_app</span><span class=\"params\">(config_name)</span>:</span></span><br><span class=\"line\">    app = Flask(__name__)</span><br><span class=\"line\">    app.config.from_object(config[config_name])</span><br><span class=\"line\">    config[config_name].init_app(app)</span><br><span class=\"line\"></span><br><span class=\"line\">    bootstrap.init_app(app)</span><br><span class=\"line\">    mail.init_app(app)</span><br><span class=\"line\">    moment.init_app(app)</span><br><span class=\"line\">    db.init_app(app)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">## route and errorhandler</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> app</span><br></pre></td></tr></table></figure>\n<p>工厂函数返回创建的Flask程序实例。<code>create_app()</code>函数就是程序的工厂函数，接收一个参数就是程序所使用的配置名。这时候，是动态获得了程序实例了，但是定义路由需要在调用工厂函数之后才能使用<code>app.route</code>装饰器定义路由。这时候就引入蓝图(Blueprint)来进行路由的定义。</p>\n<h3 id=\"蓝图中实现程序功能\"><a href=\"#蓝图中实现程序功能\" class=\"headerlink\" title=\"蓝图中实现程序功能\"></a>蓝图中实现程序功能</h3><p>蓝图定义的路由处于休眠状态，直到蓝图注册到应用实例上后，路由才真正成为程序的一部分，蓝图的使用对于大型程序的模块化开发提供了方便。</p>\n<p><code>app/main/__init__.py</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Blueprint</span><br><span class=\"line\"></span><br><span class=\"line\">main = Blueprint(<span class=\"string\">'main'</span>, __name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> . <span class=\"keyword\">import</span> views, errors</span><br></pre></td></tr></table></figure>\n<p>这里定义蓝图main，程序的路由在views.py中，错误处理程序在errors.py中</p>\n<p>在工厂函数<code>create_app()</code>中将蓝图注册到程序实例上</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_app</span><span class=\"params\">(config_name)</span>:</span></span><br><span class=\"line\">    app = Flask(__name__)</span><br><span class=\"line\">    <span class=\"comment\"># ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">from</span> .main <span class=\"keyword\">import</span> main <span class=\"keyword\">as</span> main_blueprint</span><br><span class=\"line\">    app.register_blueprint(main_blueprint)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> app</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动脚本\"><a href=\"#启动脚本\" class=\"headerlink\" title=\"启动脚本\"></a>启动脚本</h2><p>在顶级文件夹中的manage.py文件用于启动应用程序 manage.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">from</span> app <span class=\"keyword\">import</span> create_app, db</span><br><span class=\"line\"><span class=\"keyword\">from</span> app.models <span class=\"keyword\">import</span> User, Role</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_script <span class=\"keyword\">import</span> Manager, Shell</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_migrate <span class=\"keyword\">import</span> Migrate, MigrateCommand</span><br><span class=\"line\"></span><br><span class=\"line\">app = create_app(os.getenv(<span class=\"string\">'FLASK_CONFIG'</span>) <span class=\"keyword\">or</span> <span class=\"string\">'default'</span>)</span><br><span class=\"line\">manager = Manager(app)</span><br><span class=\"line\">migrate = Migrate(app, db)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_shell_context</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dict(app=app, db=db, User=User, Role=Role)</span><br><span class=\"line\"></span><br><span class=\"line\">manager.add_command(<span class=\"string\">\"shell\"</span>, Shell(make_context=make_shell_context))</span><br><span class=\"line\">manager.add_command(<span class=\"string\">'db'</span>, MigrateCommand)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    manager.run()</span><br></pre></td></tr></table></figure>\n<h2 id=\"需求文件\"><a href=\"#需求文件\" class=\"headerlink\" title=\"需求文件\"></a>需求文件</h2><p>包含一个requirement.txt文件，用于记录所有依赖包以及精准的版本号，pip使用下面命令生成需求文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(venv) $ pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>\n<p>在一个新环境中，使用下面的命令创建一个相同的环境</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(venv) $ pip install -r requirements.txt</span><br></pre></td></tr></table></figure>"},{"title":"Hexo command Cheatsheet","date":"2017-06-05T07:30:37.000Z","_content":"\n\n## hexo\n\n``` bash\nnpm install hexo -g #安装  \nnpm update hexo -g #升级  \nhexo init #初始化\n```\n\n## 简写\n\n``` bash\nhexo n \"我的博客\"  # == hexo new \"我的博客\" #新建文章\nhexo p           # == hexo publish #发布草稿\nhexo g           # == hexo generate#生成\nhexo s           # == hexo server #启动服务预览\nhexo d           # == hexo deploy#部署\n```\n\n## 服务器\n\n``` bash\nhexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。\nhexo server -s #静态模式\nhexo server -p 5000 #更改端口\nhexo server -i 192.168.1.1 #自定义 IP\n\nhexo clean #清除缓存 网页正常情况下可以忽略此条命令\nhexo g #生成静态网页\nhexo d #开始部署\n```\n\n## 监视文件变动\n\n``` bash\nhexo generate #使用 Hexo 生成静态文件快速而且简单\nhexo generate --watch #监视文件变动\n```\n\n## 完成后部署\n\n两个命令的作用是相同的\n\n``` bash\nhexo generate --deploy\nhexo deploy --generate\n\nhexo deploy -g\nhexo server -g\n```\n\n## 草稿\n\n``` bash\nhexo publish [layout] <title>\n```\n\n## 模版\n\n``` bash\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #将.deploy目录部署到GitHub\n\nhexo new [layout] <title>\nhexo new photo \"My Gallery\"\nhexo new \"Hello World\" --lang tw\n```\n\n|变量  |\t描述 |\n|----  |---- |\n|layout |\t布局|\n|title\t|标题|\n|date\t|文件建立日期|\n","source":"_posts/Hexo-command-Cheatsheet.md","raw":"---\ntitle: Hexo command Cheatsheet\ndate: 2017-06-05 15:30:37\ntags:\n    - hexo\n    - Cheat Sheet\n---\n\n\n## hexo\n\n``` bash\nnpm install hexo -g #安装  \nnpm update hexo -g #升级  \nhexo init #初始化\n```\n\n## 简写\n\n``` bash\nhexo n \"我的博客\"  # == hexo new \"我的博客\" #新建文章\nhexo p           # == hexo publish #发布草稿\nhexo g           # == hexo generate#生成\nhexo s           # == hexo server #启动服务预览\nhexo d           # == hexo deploy#部署\n```\n\n## 服务器\n\n``` bash\nhexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。\nhexo server -s #静态模式\nhexo server -p 5000 #更改端口\nhexo server -i 192.168.1.1 #自定义 IP\n\nhexo clean #清除缓存 网页正常情况下可以忽略此条命令\nhexo g #生成静态网页\nhexo d #开始部署\n```\n\n## 监视文件变动\n\n``` bash\nhexo generate #使用 Hexo 生成静态文件快速而且简单\nhexo generate --watch #监视文件变动\n```\n\n## 完成后部署\n\n两个命令的作用是相同的\n\n``` bash\nhexo generate --deploy\nhexo deploy --generate\n\nhexo deploy -g\nhexo server -g\n```\n\n## 草稿\n\n``` bash\nhexo publish [layout] <title>\n```\n\n## 模版\n\n``` bash\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #将.deploy目录部署到GitHub\n\nhexo new [layout] <title>\nhexo new photo \"My Gallery\"\nhexo new \"Hello World\" --lang tw\n```\n\n|变量  |\t描述 |\n|----  |---- |\n|layout |\t布局|\n|title\t|标题|\n|date\t|文件建立日期|\n","slug":"Hexo-command-Cheatsheet","published":1,"updated":"2017-06-08T07:45:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3o30029zd68v6bt8tct","content":"<h2 id=\"hexo\"><a href=\"#hexo\" class=\"headerlink\" title=\"hexo\"></a>hexo</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo -g <span class=\"comment\">#安装  </span></span><br><span class=\"line\">npm update hexo -g <span class=\"comment\">#升级  </span></span><br><span class=\"line\">hexo init <span class=\"comment\">#初始化</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"简写\"><a href=\"#简写\" class=\"headerlink\" title=\"简写\"></a>简写</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n <span class=\"string\">\"我的博客\"</span>  <span class=\"comment\"># == hexo new \"我的博客\" #新建文章</span></span><br><span class=\"line\">hexo p           <span class=\"comment\"># == hexo publish #发布草稿</span></span><br><span class=\"line\">hexo g           <span class=\"comment\"># == hexo generate#生成</span></span><br><span class=\"line\">hexo s           <span class=\"comment\"># == hexo server #启动服务预览</span></span><br><span class=\"line\">hexo d           <span class=\"comment\"># == hexo deploy#部署</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server <span class=\"comment\">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span></span><br><span class=\"line\">hexo server -s <span class=\"comment\">#静态模式</span></span><br><span class=\"line\">hexo server -p 5000 <span class=\"comment\">#更改端口</span></span><br><span class=\"line\">hexo server -i 192.168.1.1 <span class=\"comment\">#自定义 IP</span></span><br><span class=\"line\"></span><br><span class=\"line\">hexo clean <span class=\"comment\">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class=\"line\">hexo g <span class=\"comment\">#生成静态网页</span></span><br><span class=\"line\">hexo d <span class=\"comment\">#开始部署</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"监视文件变动\"><a href=\"#监视文件变动\" class=\"headerlink\" title=\"监视文件变动\"></a>监视文件变动</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate <span class=\"comment\">#使用 Hexo 生成静态文件快速而且简单</span></span><br><span class=\"line\">hexo generate --watch <span class=\"comment\">#监视文件变动</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"完成后部署\"><a href=\"#完成后部署\" class=\"headerlink\" title=\"完成后部署\"></a>完成后部署</h2><p>两个命令的作用是相同的</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate --deploy</span><br><span class=\"line\">hexo deploy --generate</span><br><span class=\"line\"></span><br><span class=\"line\">hexo deploy -g</span><br><span class=\"line\">hexo server -g</span><br></pre></td></tr></table></figure>\n<h2 id=\"草稿\"><a href=\"#草稿\" class=\"headerlink\" title=\"草稿\"></a>草稿</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"模版\"><a href=\"#模版\" class=\"headerlink\" title=\"模版\"></a>模版</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"postName\"</span> <span class=\"comment\">#新建文章</span></span><br><span class=\"line\">hexo new page <span class=\"string\">\"pageName\"</span> <span class=\"comment\">#新建页面</span></span><br><span class=\"line\">hexo generate <span class=\"comment\">#生成静态页面至public目录</span></span><br><span class=\"line\">hexo server <span class=\"comment\">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\">#将.deploy目录部署到GitHub</span></span><br><span class=\"line\"></span><br><span class=\"line\">hexo new [layout] &lt;title&gt;</span><br><span class=\"line\">hexo new photo <span class=\"string\">\"My Gallery\"</span></span><br><span class=\"line\">hexo new <span class=\"string\">\"Hello World\"</span> --lang tw</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>layout</td>\n<td>布局</td>\n</tr>\n<tr>\n<td>title</td>\n<td>标题</td>\n</tr>\n<tr>\n<td>date</td>\n<td>文件建立日期</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"hexo\"><a href=\"#hexo\" class=\"headerlink\" title=\"hexo\"></a>hexo</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo -g <span class=\"comment\">#安装  </span></span><br><span class=\"line\">npm update hexo -g <span class=\"comment\">#升级  </span></span><br><span class=\"line\">hexo init <span class=\"comment\">#初始化</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"简写\"><a href=\"#简写\" class=\"headerlink\" title=\"简写\"></a>简写</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n <span class=\"string\">\"我的博客\"</span>  <span class=\"comment\"># == hexo new \"我的博客\" #新建文章</span></span><br><span class=\"line\">hexo p           <span class=\"comment\"># == hexo publish #发布草稿</span></span><br><span class=\"line\">hexo g           <span class=\"comment\"># == hexo generate#生成</span></span><br><span class=\"line\">hexo s           <span class=\"comment\"># == hexo server #启动服务预览</span></span><br><span class=\"line\">hexo d           <span class=\"comment\"># == hexo deploy#部署</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server <span class=\"comment\">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span></span><br><span class=\"line\">hexo server -s <span class=\"comment\">#静态模式</span></span><br><span class=\"line\">hexo server -p 5000 <span class=\"comment\">#更改端口</span></span><br><span class=\"line\">hexo server -i 192.168.1.1 <span class=\"comment\">#自定义 IP</span></span><br><span class=\"line\"></span><br><span class=\"line\">hexo clean <span class=\"comment\">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class=\"line\">hexo g <span class=\"comment\">#生成静态网页</span></span><br><span class=\"line\">hexo d <span class=\"comment\">#开始部署</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"监视文件变动\"><a href=\"#监视文件变动\" class=\"headerlink\" title=\"监视文件变动\"></a>监视文件变动</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate <span class=\"comment\">#使用 Hexo 生成静态文件快速而且简单</span></span><br><span class=\"line\">hexo generate --watch <span class=\"comment\">#监视文件变动</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"完成后部署\"><a href=\"#完成后部署\" class=\"headerlink\" title=\"完成后部署\"></a>完成后部署</h2><p>两个命令的作用是相同的</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate --deploy</span><br><span class=\"line\">hexo deploy --generate</span><br><span class=\"line\"></span><br><span class=\"line\">hexo deploy -g</span><br><span class=\"line\">hexo server -g</span><br></pre></td></tr></table></figure>\n<h2 id=\"草稿\"><a href=\"#草稿\" class=\"headerlink\" title=\"草稿\"></a>草稿</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"模版\"><a href=\"#模版\" class=\"headerlink\" title=\"模版\"></a>模版</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"postName\"</span> <span class=\"comment\">#新建文章</span></span><br><span class=\"line\">hexo new page <span class=\"string\">\"pageName\"</span> <span class=\"comment\">#新建页面</span></span><br><span class=\"line\">hexo generate <span class=\"comment\">#生成静态页面至public目录</span></span><br><span class=\"line\">hexo server <span class=\"comment\">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\">#将.deploy目录部署到GitHub</span></span><br><span class=\"line\"></span><br><span class=\"line\">hexo new [layout] &lt;title&gt;</span><br><span class=\"line\">hexo new photo <span class=\"string\">\"My Gallery\"</span></span><br><span class=\"line\">hexo new <span class=\"string\">\"Hello World\"</span> --lang tw</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>layout</td>\n<td>布局</td>\n</tr>\n<tr>\n<td>title</td>\n<td>标题</td>\n</tr>\n<tr>\n<td>date</td>\n<td>文件建立日期</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"Hexo设置主题和其他配置","date":"2017-06-05T06:59:24.000Z","_content":"\n博客的主题很多，我选择一个非常流行的主题 [NexT](http://theme-next.iissnan.com/)，作为我博客的主题，这个主题简约，并且文档和维护都很好。\n\n下面记录一下我的Hexo站点的配置，以及NexT主题的配置，以备日后查找\n\n## 站点配置\n\n博客根目录下的`_config.yml` 文件是站点的配置文件。\n\n\n为了能够使Hexo部署到GitHub上，需要安装一个插件：\n\n``` shell\nnpm install hexo-deployer-git --save\n```\n\n设置站点配置文件指定部署的位置\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/lvraikkonen/lvraikkonen.github.io.git\n  branch: master\n```\n\n在 `站点配置文件` 中找到theme字段，把值改为 `next`\n\n<!-- more -->\n\n## 主题NexT配置\n\n### 选择主题样式\n\nScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：\n\n- Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白\n- Mist - Muse 的紧凑版本，整洁有序的单栏外观\n- Pisces - 双栏 Scheme，小家碧玉似的清新 (我的)\n\n``` yml\n#scheme: Muse\n#scheme: Mist\nscheme: Pisces\n```\n\n### 头像设置\n\n编辑 `主题配置文件`， 修改字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是：\n\n|地址\t |值 |\n|----| --- |\n|完整的互联网URI\t |http://example.com/avatar.png |\n|站内地址 | - 将头像放置主题目录下的 source/uploads/ 或者 放置在 source/images/ 目录下 |\n\n配置为：avatar: /images/avatar.png\n\n### 添加标签页和分类页\n\n``` shell\nhexo new page \"tags\"\nhexo new page \"categories\"\n```\n\n同时，在/source目录下会生成一个tags文件夹和categories文件夹，里面各包含一个index.md文件。\n\n修改/source/tags目录下的 `index.md`文件\n\n``` markdown\ntitle: tags\ndate: 2017-05-29 18:16:02\ntype: \"tags\"\n\n---\n```\n\n修改/source/categories目录下的 `index.md`文件\n\n``` markdown\ntitle: categories\ndate: 2015-09-29 18:17:14\ntype: \"categories\"\n\n---\n```\n\n修改 `主题配置文件`， 去掉相应的注释\n\n``` yml\nmenu:\n  home: /                       #主页\n  categories: /categories\t#分类页（需手动创建）\n  #about: /about\t\t  #关于页面（需手动创建）\n  archives: /archives\t\t#归档页\n  tags: /tags\t\t\t#标签页（需手动创建）\n  #commonweal: /404.html        #公益 404 （需手动创建）\n\n```\n\n### 设置网站的图标Favicon\n\n从网上找一张 icon 图标文件，放在 source 目录下就可以了\n\n### 添加友情链接\n\n在 `站点配置文件` 中添加参数：\n\n``` yml\nlinks_title: 友情链接\nlinks:\n    #百度: http://www.baidu.com/\n    #新浪: http://example.com/\n```\n\n### 设置代码高亮\n\nNexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 `normal`，`night`， `night blue`， `night bright`， `night eighties`\n\n更改 highlight_theme 字段，将其值设定成你所喜爱的高亮主题\n\n### 配置Algolia 搜索\n\n[官网](https://www.algolia.com/) 注册一个账号，可以用Github账户注册\n\n![AlgoliaSinup](http://7xkfga.com1.z0.glb.clouddn.com/Algolia_Signup.png)\n\n登录进入Dashboard控制台页面，创建一个新Index\n\n![AlgoliaCreateIndex](http://7xkfga.com1.z0.glb.clouddn.com/AlgoliaCreateIndex.png)\n\n进入 API Keys 界面，拷贝 `Application ID` 、`Search-Only API Key` 和 `Admin API Key`\n\n编辑 `站点配置文件` ，新增以下配置：\n\n``` yml\nalgolia:\n  applicationID: 'your applicationID'\n  apiKey: 'your Search-Only API Key'\n  adminApiKey: 'your Admin API Key'\n  indexName: 'your newcreated indexName'\n  chunkSize: 5000\n```\n\n安装Hexo Algolia\n在Hexo根目录执行如下指令，进行Hexo Algolia的安装：\n\n``` shell\nnpm install --save hexo-algolia\n```\n\n到Hexo的根目录，在其中找到package.json文件，修改其中的hexo-algolia属性值为^0.2.0，如下图所示：\n\n![package.json](http://7xkfga.com1.z0.glb.clouddn.com/hexo_algolia_version.png)\n\n当配置完成，在站点根目录下执行hexo algolia 来更新Index\n\n``` shell\nhexo algolia\n```\n\n*注意：*\n\n> 如果发现没有上传数据，这时候可以先 `hexo clean` 然后再 `hexo algolia` _\n\n在 `主题配置文件`中，找到Algolia Search 配置部分：\n\n``` yml\n# Algolia Search\nalgolia_search:\n  enable: true\n  hits:\n    per_page: 10\n  labels:\n    input_placeholder: Search for Posts\n    hits_empty: \"We didn't find any results for the search: ${query}\"\n    hits_stats: \"${hits} results found in ${time} ms\"\n```\n\n将 `enable` 改为true 即可，根据需要你可以调整labels 中的文本。\n\n### 配置来必力评论\n\n评论插件，最出名的是 Disqus，但是对于国内用户来说，自带梯子好些。改用多说，路边社消息，多说好像要完蛋了。发现了个叫 LiveRe（来必力）的评论插件，韩国出的，用着感觉还不错。\n\n[来必力官网](https://livere.com/)注册账号\n\nLiveRe 有两个版本：\n\n- City 版：是一款适合所有人使用的免费版本；\n- Premium 版：是一款能够帮助企业实现自动化管理的多功能收费版本。\n\n选择City版就可以了\n\n![installLiveRe](http://7xkfga.com1.z0.glb.clouddn.com/installLiveRe.png)\n\n获取 LiveRe UID。 编辑 `主题配置文件`， 编辑 livere_uid 字段，设置如下：\n\n``` yml\nlivere_uid: #your livere_uid\n```\n\nNexT 已经支持来必力，这样就能在页面显示评论了\n\n### 添加阅读次数统计\n\n这里使用 [LeanCloud](https://leancloud.cn/) 为文章添加统计功能\n\n注册账号登陆以后获得 `AppID`以及 `AppKey`这两个参数即可正常使用文章阅读量统计的功能了。\n\n创建应用\n\n![CreateApp](http://7xkfga.com1.z0.glb.clouddn.com/leancloudCreateApp.png)\n\n配置应用\n\n![configApp](http://7xkfga.com1.z0.glb.clouddn.com/configApp.png)\n\n在应用的数据配置界面，左侧下划线开头的都是系统预定义好的表。在弹出的选项中选择创建Class来新建Class用来专门保存我们博客的文章访问量等数据:\n为了保证我们前面对NexT主题的修改兼容，此处的新建Class名字为 `Counter`\n\n![GetAppKey](http://7xkfga.com1.z0.glb.clouddn.com/leancloudGetAPIKey.png)\n\n复制 `AppID`以及 `AppKey` 修改 `主题配置文件`\n\n``` yml\n# You can visit https://leancloud.cn get AppID and AppKey.\nleancloud_visitors:\n  enable: true\n  app_id: #<app_id>\n  app_key: #<app_key>\n```\n\n重新生成并部署博客就可以显示阅读量了\n\n_note: 记录文章访问量的唯一标识符是 `文章的发布日期`以及`文章的标题`，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计_\n\n后台可以看到，刚才创建的Counter类\n\n![backendReadCount](http://7xkfga.com1.z0.glb.clouddn.com/leanCloudbackend_data.png)\n\n\n### 添加字数统计功能\n\n首先在博客目录下使用 npm 安装插件\n\n``` shell\nnpm install hexo-wordcount --save\n```\n\n在 `主题配置文件`中打开wordcount 统计功能\n\n``` yml\n# Post wordcount display settings\n# Dependencies: https://github.com/willin/hexo-wordcount\npost_wordcount:\n  item_text: true\n  wordcount: true\n  min2read: false\n```\n\n找到..\\themes\\next\\layout\\_macro\\post.swig 文件，将\"字\"、\"分钟\" 字样添加到如下位置\n\n```\n<span title=\"{{ __('post.wordcount') }}\">\n  {{ wordcount(post.content) }} 字\n</span>\n ...\n<span title=\"{{ __('post.min2read') }}\">\n  {{ min2read(post.content) }} 分钟\n</span>\n```","source":"_posts/Hexo…Ë÷√÷˜Ã‚∫Õ∆‰À˚≈‰÷√.md","raw":"---\ntitle: Hexo设置主题和其他配置\ndate: 2017-06-05 14:59:24\ntags:\n  - hexo\n---\n\n博客的主题很多，我选择一个非常流行的主题 [NexT](http://theme-next.iissnan.com/)，作为我博客的主题，这个主题简约，并且文档和维护都很好。\n\n下面记录一下我的Hexo站点的配置，以及NexT主题的配置，以备日后查找\n\n## 站点配置\n\n博客根目录下的`_config.yml` 文件是站点的配置文件。\n\n\n为了能够使Hexo部署到GitHub上，需要安装一个插件：\n\n``` shell\nnpm install hexo-deployer-git --save\n```\n\n设置站点配置文件指定部署的位置\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/lvraikkonen/lvraikkonen.github.io.git\n  branch: master\n```\n\n在 `站点配置文件` 中找到theme字段，把值改为 `next`\n\n<!-- more -->\n\n## 主题NexT配置\n\n### 选择主题样式\n\nScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：\n\n- Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白\n- Mist - Muse 的紧凑版本，整洁有序的单栏外观\n- Pisces - 双栏 Scheme，小家碧玉似的清新 (我的)\n\n``` yml\n#scheme: Muse\n#scheme: Mist\nscheme: Pisces\n```\n\n### 头像设置\n\n编辑 `主题配置文件`， 修改字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是：\n\n|地址\t |值 |\n|----| --- |\n|完整的互联网URI\t |http://example.com/avatar.png |\n|站内地址 | - 将头像放置主题目录下的 source/uploads/ 或者 放置在 source/images/ 目录下 |\n\n配置为：avatar: /images/avatar.png\n\n### 添加标签页和分类页\n\n``` shell\nhexo new page \"tags\"\nhexo new page \"categories\"\n```\n\n同时，在/source目录下会生成一个tags文件夹和categories文件夹，里面各包含一个index.md文件。\n\n修改/source/tags目录下的 `index.md`文件\n\n``` markdown\ntitle: tags\ndate: 2017-05-29 18:16:02\ntype: \"tags\"\n\n---\n```\n\n修改/source/categories目录下的 `index.md`文件\n\n``` markdown\ntitle: categories\ndate: 2015-09-29 18:17:14\ntype: \"categories\"\n\n---\n```\n\n修改 `主题配置文件`， 去掉相应的注释\n\n``` yml\nmenu:\n  home: /                       #主页\n  categories: /categories\t#分类页（需手动创建）\n  #about: /about\t\t  #关于页面（需手动创建）\n  archives: /archives\t\t#归档页\n  tags: /tags\t\t\t#标签页（需手动创建）\n  #commonweal: /404.html        #公益 404 （需手动创建）\n\n```\n\n### 设置网站的图标Favicon\n\n从网上找一张 icon 图标文件，放在 source 目录下就可以了\n\n### 添加友情链接\n\n在 `站点配置文件` 中添加参数：\n\n``` yml\nlinks_title: 友情链接\nlinks:\n    #百度: http://www.baidu.com/\n    #新浪: http://example.com/\n```\n\n### 设置代码高亮\n\nNexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 `normal`，`night`， `night blue`， `night bright`， `night eighties`\n\n更改 highlight_theme 字段，将其值设定成你所喜爱的高亮主题\n\n### 配置Algolia 搜索\n\n[官网](https://www.algolia.com/) 注册一个账号，可以用Github账户注册\n\n![AlgoliaSinup](http://7xkfga.com1.z0.glb.clouddn.com/Algolia_Signup.png)\n\n登录进入Dashboard控制台页面，创建一个新Index\n\n![AlgoliaCreateIndex](http://7xkfga.com1.z0.glb.clouddn.com/AlgoliaCreateIndex.png)\n\n进入 API Keys 界面，拷贝 `Application ID` 、`Search-Only API Key` 和 `Admin API Key`\n\n编辑 `站点配置文件` ，新增以下配置：\n\n``` yml\nalgolia:\n  applicationID: 'your applicationID'\n  apiKey: 'your Search-Only API Key'\n  adminApiKey: 'your Admin API Key'\n  indexName: 'your newcreated indexName'\n  chunkSize: 5000\n```\n\n安装Hexo Algolia\n在Hexo根目录执行如下指令，进行Hexo Algolia的安装：\n\n``` shell\nnpm install --save hexo-algolia\n```\n\n到Hexo的根目录，在其中找到package.json文件，修改其中的hexo-algolia属性值为^0.2.0，如下图所示：\n\n![package.json](http://7xkfga.com1.z0.glb.clouddn.com/hexo_algolia_version.png)\n\n当配置完成，在站点根目录下执行hexo algolia 来更新Index\n\n``` shell\nhexo algolia\n```\n\n*注意：*\n\n> 如果发现没有上传数据，这时候可以先 `hexo clean` 然后再 `hexo algolia` _\n\n在 `主题配置文件`中，找到Algolia Search 配置部分：\n\n``` yml\n# Algolia Search\nalgolia_search:\n  enable: true\n  hits:\n    per_page: 10\n  labels:\n    input_placeholder: Search for Posts\n    hits_empty: \"We didn't find any results for the search: ${query}\"\n    hits_stats: \"${hits} results found in ${time} ms\"\n```\n\n将 `enable` 改为true 即可，根据需要你可以调整labels 中的文本。\n\n### 配置来必力评论\n\n评论插件，最出名的是 Disqus，但是对于国内用户来说，自带梯子好些。改用多说，路边社消息，多说好像要完蛋了。发现了个叫 LiveRe（来必力）的评论插件，韩国出的，用着感觉还不错。\n\n[来必力官网](https://livere.com/)注册账号\n\nLiveRe 有两个版本：\n\n- City 版：是一款适合所有人使用的免费版本；\n- Premium 版：是一款能够帮助企业实现自动化管理的多功能收费版本。\n\n选择City版就可以了\n\n![installLiveRe](http://7xkfga.com1.z0.glb.clouddn.com/installLiveRe.png)\n\n获取 LiveRe UID。 编辑 `主题配置文件`， 编辑 livere_uid 字段，设置如下：\n\n``` yml\nlivere_uid: #your livere_uid\n```\n\nNexT 已经支持来必力，这样就能在页面显示评论了\n\n### 添加阅读次数统计\n\n这里使用 [LeanCloud](https://leancloud.cn/) 为文章添加统计功能\n\n注册账号登陆以后获得 `AppID`以及 `AppKey`这两个参数即可正常使用文章阅读量统计的功能了。\n\n创建应用\n\n![CreateApp](http://7xkfga.com1.z0.glb.clouddn.com/leancloudCreateApp.png)\n\n配置应用\n\n![configApp](http://7xkfga.com1.z0.glb.clouddn.com/configApp.png)\n\n在应用的数据配置界面，左侧下划线开头的都是系统预定义好的表。在弹出的选项中选择创建Class来新建Class用来专门保存我们博客的文章访问量等数据:\n为了保证我们前面对NexT主题的修改兼容，此处的新建Class名字为 `Counter`\n\n![GetAppKey](http://7xkfga.com1.z0.glb.clouddn.com/leancloudGetAPIKey.png)\n\n复制 `AppID`以及 `AppKey` 修改 `主题配置文件`\n\n``` yml\n# You can visit https://leancloud.cn get AppID and AppKey.\nleancloud_visitors:\n  enable: true\n  app_id: #<app_id>\n  app_key: #<app_key>\n```\n\n重新生成并部署博客就可以显示阅读量了\n\n_note: 记录文章访问量的唯一标识符是 `文章的发布日期`以及`文章的标题`，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计_\n\n后台可以看到，刚才创建的Counter类\n\n![backendReadCount](http://7xkfga.com1.z0.glb.clouddn.com/leanCloudbackend_data.png)\n\n\n### 添加字数统计功能\n\n首先在博客目录下使用 npm 安装插件\n\n``` shell\nnpm install hexo-wordcount --save\n```\n\n在 `主题配置文件`中打开wordcount 统计功能\n\n``` yml\n# Post wordcount display settings\n# Dependencies: https://github.com/willin/hexo-wordcount\npost_wordcount:\n  item_text: true\n  wordcount: true\n  min2read: false\n```\n\n找到..\\themes\\next\\layout\\_macro\\post.swig 文件，将\"字\"、\"分钟\" 字样添加到如下位置\n\n```\n<span title=\"{{ __('post.wordcount') }}\">\n  {{ wordcount(post.content) }} 字\n</span>\n ...\n<span title=\"{{ __('post.min2read') }}\">\n  {{ min2read(post.content) }} 分钟\n</span>\n```","slug":"Hexo…Ë÷√÷˜Ã‚∫Õ∆‰À˚≈‰÷√","published":1,"updated":"2017-06-08T07:41:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3o4002czd68befva0em","content":"<p>博客的主题很多，我选择一个非常流行的主题 <a href=\"http://theme-next.iissnan.com/\" target=\"_blank\" rel=\"noopener\">NexT</a>，作为我博客的主题，这个主题简约，并且文档和维护都很好。</p>\n<p>下面记录一下我的Hexo站点的配置，以及NexT主题的配置，以备日后查找</p>\n<h2 id=\"站点配置\"><a href=\"#站点配置\" class=\"headerlink\" title=\"站点配置\"></a>站点配置</h2><p>博客根目录下的<code>_config.yml</code> 文件是站点的配置文件。</p>\n<p>为了能够使Hexo部署到GitHub上，需要安装一个插件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<p>设置站点配置文件指定部署的位置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/lvraikkonen/lvraikkonen.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<p>在 <code>站点配置文件</code> 中找到theme字段，把值改为 <code>next</code></p>\n<a id=\"more\"></a>\n<h2 id=\"主题NexT配置\"><a href=\"#主题NexT配置\" class=\"headerlink\" title=\"主题NexT配置\"></a>主题NexT配置</h2><h3 id=\"选择主题样式\"><a href=\"#选择主题样式\" class=\"headerlink\" title=\"选择主题样式\"></a>选择主题样式</h3><p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：</p>\n<ul>\n<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>\n<li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li>\n<li>Pisces - 双栏 Scheme，小家碧玉似的清新 (我的)</li>\n</ul>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#scheme: Muse</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Mist</span></span><br><span class=\"line\"><span class=\"attr\">scheme:</span> <span class=\"string\">Pisces</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"头像设置\"><a href=\"#头像设置\" class=\"headerlink\" title=\"头像设置\"></a>头像设置</h3><p>编辑 <code>主题配置文件</code>， 修改字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是：</p>\n<table>\n<thead>\n<tr>\n<th>地址</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>完整的互联网URI</td>\n<td><a href=\"http://example.com/avatar.png\" target=\"_blank\" rel=\"noopener\">http://example.com/avatar.png</a></td>\n</tr>\n<tr>\n<td>站内地址</td>\n<td>- 将头像放置主题目录下的 source/uploads/ 或者 放置在 source/images/ 目录下</td>\n</tr>\n</tbody>\n</table>\n<p>配置为：avatar: /images/avatar.png</p>\n<h3 id=\"添加标签页和分类页\"><a href=\"#添加标签页和分类页\" class=\"headerlink\" title=\"添加标签页和分类页\"></a>添加标签页和分类页</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page \"tags\"</span><br><span class=\"line\">hexo new page \"categories\"</span><br></pre></td></tr></table></figure>\n<p>同时，在/source目录下会生成一个tags文件夹和categories文件夹，里面各包含一个index.md文件。</p>\n<p>修改/source/tags目录下的 <code>index.md</code>文件</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: tags</span><br><span class=\"line\">date: 2017-05-29 18:16:02</span><br><span class=\"line\">type: \"tags\"</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>修改/source/categories目录下的 <code>index.md</code>文件</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: categories</span><br><span class=\"line\">date: 2015-09-29 18:17:14</span><br><span class=\"line\">type: \"categories\"</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>修改 <code>主题配置文件</code>， 去掉相应的注释</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\"><span class=\"attr\">  home:</span> <span class=\"string\">/</span>                       <span class=\"comment\">#主页</span></span><br><span class=\"line\"><span class=\"attr\">  categories:</span> <span class=\"string\">/categories</span>\t<span class=\"comment\">#分类页（需手动创建）</span></span><br><span class=\"line\">  <span class=\"comment\">#about: /about\t\t  #关于页面（需手动创建）</span></span><br><span class=\"line\"><span class=\"attr\">  archives:</span> <span class=\"string\">/archives</span>\t\t<span class=\"comment\">#归档页</span></span><br><span class=\"line\"><span class=\"attr\">  tags:</span> <span class=\"string\">/tags</span>\t\t\t<span class=\"comment\">#标签页（需手动创建）</span></span><br><span class=\"line\">  <span class=\"comment\">#commonweal: /404.html        #公益 404 （需手动创建）</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"设置网站的图标Favicon\"><a href=\"#设置网站的图标Favicon\" class=\"headerlink\" title=\"设置网站的图标Favicon\"></a>设置网站的图标Favicon</h3><p>从网上找一张 icon 图标文件，放在 source 目录下就可以了</p>\n<h3 id=\"添加友情链接\"><a href=\"#添加友情链接\" class=\"headerlink\" title=\"添加友情链接\"></a>添加友情链接</h3><p>在 <code>站点配置文件</code> 中添加参数：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">links_title:</span> <span class=\"string\">友情链接</span></span><br><span class=\"line\"><span class=\"attr\">links:</span></span><br><span class=\"line\">    <span class=\"comment\">#百度: http://www.baidu.com/</span></span><br><span class=\"line\">    <span class=\"comment\">#新浪: http://example.com/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"设置代码高亮\"><a href=\"#设置代码高亮\" class=\"headerlink\" title=\"设置代码高亮\"></a>设置代码高亮</h3><p>NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 <code>normal</code>，<code>night</code>， <code>night blue</code>， <code>night bright</code>， <code>night eighties</code></p>\n<p>更改 highlight_theme 字段，将其值设定成你所喜爱的高亮主题</p>\n<h3 id=\"配置Algolia-搜索\"><a href=\"#配置Algolia-搜索\" class=\"headerlink\" title=\"配置Algolia 搜索\"></a>配置Algolia 搜索</h3><p><a href=\"https://www.algolia.com/\" target=\"_blank\" rel=\"noopener\">官网</a> 注册一个账号，可以用Github账户注册</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/Algolia_Signup.png\" alt=\"AlgoliaSinup\"></p>\n<p>登录进入Dashboard控制台页面，创建一个新Index</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/AlgoliaCreateIndex.png\" alt=\"AlgoliaCreateIndex\"></p>\n<p>进入 API Keys 界面，拷贝 <code>Application ID</code> 、<code>Search-Only API Key</code> 和 <code>Admin API Key</code></p>\n<p>编辑 <code>站点配置文件</code> ，新增以下配置：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">algolia:</span></span><br><span class=\"line\"><span class=\"attr\">  applicationID:</span> <span class=\"string\">'your applicationID'</span></span><br><span class=\"line\"><span class=\"attr\">  apiKey:</span> <span class=\"string\">'your Search-Only API Key'</span></span><br><span class=\"line\"><span class=\"attr\">  adminApiKey:</span> <span class=\"string\">'your Admin API Key'</span></span><br><span class=\"line\"><span class=\"attr\">  indexName:</span> <span class=\"string\">'your newcreated indexName'</span></span><br><span class=\"line\"><span class=\"attr\">  chunkSize:</span> <span class=\"number\">5000</span></span><br></pre></td></tr></table></figure>\n<p>安装Hexo Algolia<br>在Hexo根目录执行如下指令，进行Hexo Algolia的安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-algolia</span><br></pre></td></tr></table></figure>\n<p>到Hexo的根目录，在其中找到package.json文件，修改其中的hexo-algolia属性值为^0.2.0，如下图所示：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/hexo_algolia_version.png\" alt=\"package.json\"></p>\n<p>当配置完成，在站点根目录下执行hexo algolia 来更新Index</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo algolia</span><br></pre></td></tr></table></figure>\n<p><em>注意：</em></p>\n<blockquote>\n<p>如果发现没有上传数据，这时候可以先 <code>hexo clean</code> 然后再 <code>hexo algolia</code> _</p>\n</blockquote>\n<p>在 <code>主题配置文件</code>中，找到Algolia Search 配置部分：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Algolia Search</span></span><br><span class=\"line\"><span class=\"attr\">algolia_search:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  hits:</span></span><br><span class=\"line\"><span class=\"attr\">    per_page:</span> <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"attr\">  labels:</span></span><br><span class=\"line\"><span class=\"attr\">    input_placeholder:</span> <span class=\"string\">Search</span> <span class=\"string\">for</span> <span class=\"string\">Posts</span></span><br><span class=\"line\"><span class=\"attr\">    hits_empty:</span> <span class=\"string\">\"We didn't find any results for the search: $&#123;query&#125;\"</span></span><br><span class=\"line\"><span class=\"attr\">    hits_stats:</span> <span class=\"string\">\"$&#123;hits&#125; results found in $&#123;time&#125; ms\"</span></span><br></pre></td></tr></table></figure>\n<p>将 <code>enable</code> 改为true 即可，根据需要你可以调整labels 中的文本。</p>\n<h3 id=\"配置来必力评论\"><a href=\"#配置来必力评论\" class=\"headerlink\" title=\"配置来必力评论\"></a>配置来必力评论</h3><p>评论插件，最出名的是 Disqus，但是对于国内用户来说，自带梯子好些。改用多说，路边社消息，多说好像要完蛋了。发现了个叫 LiveRe（来必力）的评论插件，韩国出的，用着感觉还不错。</p>\n<p><a href=\"https://livere.com/\" target=\"_blank\" rel=\"noopener\">来必力官网</a>注册账号</p>\n<p>LiveRe 有两个版本：</p>\n<ul>\n<li>City 版：是一款适合所有人使用的免费版本；</li>\n<li>Premium 版：是一款能够帮助企业实现自动化管理的多功能收费版本。</li>\n</ul>\n<p>选择City版就可以了</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/installLiveRe.png\" alt=\"installLiveRe\"></p>\n<p>获取 LiveRe UID。 编辑 <code>主题配置文件</code>， 编辑 livere_uid 字段，设置如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">livere_uid:</span> <span class=\"comment\">#your livere_uid</span></span><br></pre></td></tr></table></figure>\n<p>NexT 已经支持来必力，这样就能在页面显示评论了</p>\n<h3 id=\"添加阅读次数统计\"><a href=\"#添加阅读次数统计\" class=\"headerlink\" title=\"添加阅读次数统计\"></a>添加阅读次数统计</h3><p>这里使用 <a href=\"https://leancloud.cn/\" target=\"_blank\" rel=\"noopener\">LeanCloud</a> 为文章添加统计功能</p>\n<p>注册账号登陆以后获得 <code>AppID</code>以及 <code>AppKey</code>这两个参数即可正常使用文章阅读量统计的功能了。</p>\n<p>创建应用</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/leancloudCreateApp.png\" alt=\"CreateApp\"></p>\n<p>配置应用</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/configApp.png\" alt=\"configApp\"></p>\n<p>在应用的数据配置界面，左侧下划线开头的都是系统预定义好的表。在弹出的选项中选择创建Class来新建Class用来专门保存我们博客的文章访问量等数据:<br>为了保证我们前面对NexT主题的修改兼容，此处的新建Class名字为 <code>Counter</code></p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/leancloudGetAPIKey.png\" alt=\"GetAppKey\"></p>\n<p>复制 <code>AppID</code>以及 <code>AppKey</code> 修改 <code>主题配置文件</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># You can visit https://leancloud.cn get AppID and AppKey.</span></span><br><span class=\"line\"><span class=\"attr\">leancloud_visitors:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  app_id:</span> <span class=\"comment\">#&lt;app_id&gt;</span></span><br><span class=\"line\"><span class=\"attr\">  app_key:</span> <span class=\"comment\">#&lt;app_key&gt;</span></span><br></pre></td></tr></table></figure>\n<p>重新生成并部署博客就可以显示阅读量了</p>\n<p><em>note: 记录文章访问量的唯一标识符是 <code>文章的发布日期</code>以及<code>文章的标题</code>，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计</em></p>\n<p>后台可以看到，刚才创建的Counter类</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/leanCloudbackend_data.png\" alt=\"backendReadCount\"></p>\n<h3 id=\"添加字数统计功能\"><a href=\"#添加字数统计功能\" class=\"headerlink\" title=\"添加字数统计功能\"></a>添加字数统计功能</h3><p>首先在博客目录下使用 npm 安装插件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>\n<p>在 <code>主题配置文件</code>中打开wordcount 统计功能</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Post wordcount display settings</span></span><br><span class=\"line\"><span class=\"comment\"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class=\"line\"><span class=\"attr\">post_wordcount:</span></span><br><span class=\"line\"><span class=\"attr\">  item_text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  wordcount:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  min2read:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>找到..\\themes\\next\\layout_macro\\post.swig 文件，将”字”、”分钟” 字样添加到如下位置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt;</span><br><span class=\"line\">  &#123;&#123; wordcount(post.content) &#125;&#125; 字</span><br><span class=\"line\">&lt;/span&gt;</span><br><span class=\"line\"> ...</span><br><span class=\"line\">&lt;span title=&quot;&#123;&#123; __(&apos;post.min2read&apos;) &#125;&#125;&quot;&gt;</span><br><span class=\"line\">  &#123;&#123; min2read(post.content) &#125;&#125; 分钟</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>博客的主题很多，我选择一个非常流行的主题 <a href=\"http://theme-next.iissnan.com/\" target=\"_blank\" rel=\"noopener\">NexT</a>，作为我博客的主题，这个主题简约，并且文档和维护都很好。</p>\n<p>下面记录一下我的Hexo站点的配置，以及NexT主题的配置，以备日后查找</p>\n<h2 id=\"站点配置\"><a href=\"#站点配置\" class=\"headerlink\" title=\"站点配置\"></a>站点配置</h2><p>博客根目录下的<code>_config.yml</code> 文件是站点的配置文件。</p>\n<p>为了能够使Hexo部署到GitHub上，需要安装一个插件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<p>设置站点配置文件指定部署的位置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/lvraikkonen/lvraikkonen.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<p>在 <code>站点配置文件</code> 中找到theme字段，把值改为 <code>next</code></p>","more":"<h2 id=\"主题NexT配置\"><a href=\"#主题NexT配置\" class=\"headerlink\" title=\"主题NexT配置\"></a>主题NexT配置</h2><h3 id=\"选择主题样式\"><a href=\"#选择主题样式\" class=\"headerlink\" title=\"选择主题样式\"></a>选择主题样式</h3><p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：</p>\n<ul>\n<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>\n<li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li>\n<li>Pisces - 双栏 Scheme，小家碧玉似的清新 (我的)</li>\n</ul>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#scheme: Muse</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Mist</span></span><br><span class=\"line\"><span class=\"attr\">scheme:</span> <span class=\"string\">Pisces</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"头像设置\"><a href=\"#头像设置\" class=\"headerlink\" title=\"头像设置\"></a>头像设置</h3><p>编辑 <code>主题配置文件</code>， 修改字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是：</p>\n<table>\n<thead>\n<tr>\n<th>地址</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>完整的互联网URI</td>\n<td><a href=\"http://example.com/avatar.png\" target=\"_blank\" rel=\"noopener\">http://example.com/avatar.png</a></td>\n</tr>\n<tr>\n<td>站内地址</td>\n<td>- 将头像放置主题目录下的 source/uploads/ 或者 放置在 source/images/ 目录下</td>\n</tr>\n</tbody>\n</table>\n<p>配置为：avatar: /images/avatar.png</p>\n<h3 id=\"添加标签页和分类页\"><a href=\"#添加标签页和分类页\" class=\"headerlink\" title=\"添加标签页和分类页\"></a>添加标签页和分类页</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page \"tags\"</span><br><span class=\"line\">hexo new page \"categories\"</span><br></pre></td></tr></table></figure>\n<p>同时，在/source目录下会生成一个tags文件夹和categories文件夹，里面各包含一个index.md文件。</p>\n<p>修改/source/tags目录下的 <code>index.md</code>文件</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: tags</span><br><span class=\"line\">date: 2017-05-29 18:16:02</span><br><span class=\"line\">type: \"tags\"</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>修改/source/categories目录下的 <code>index.md</code>文件</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: categories</span><br><span class=\"line\">date: 2015-09-29 18:17:14</span><br><span class=\"line\">type: \"categories\"</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>修改 <code>主题配置文件</code>， 去掉相应的注释</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\"><span class=\"attr\">  home:</span> <span class=\"string\">/</span>                       <span class=\"comment\">#主页</span></span><br><span class=\"line\"><span class=\"attr\">  categories:</span> <span class=\"string\">/categories</span>\t<span class=\"comment\">#分类页（需手动创建）</span></span><br><span class=\"line\">  <span class=\"comment\">#about: /about\t\t  #关于页面（需手动创建）</span></span><br><span class=\"line\"><span class=\"attr\">  archives:</span> <span class=\"string\">/archives</span>\t\t<span class=\"comment\">#归档页</span></span><br><span class=\"line\"><span class=\"attr\">  tags:</span> <span class=\"string\">/tags</span>\t\t\t<span class=\"comment\">#标签页（需手动创建）</span></span><br><span class=\"line\">  <span class=\"comment\">#commonweal: /404.html        #公益 404 （需手动创建）</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"设置网站的图标Favicon\"><a href=\"#设置网站的图标Favicon\" class=\"headerlink\" title=\"设置网站的图标Favicon\"></a>设置网站的图标Favicon</h3><p>从网上找一张 icon 图标文件，放在 source 目录下就可以了</p>\n<h3 id=\"添加友情链接\"><a href=\"#添加友情链接\" class=\"headerlink\" title=\"添加友情链接\"></a>添加友情链接</h3><p>在 <code>站点配置文件</code> 中添加参数：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">links_title:</span> <span class=\"string\">友情链接</span></span><br><span class=\"line\"><span class=\"attr\">links:</span></span><br><span class=\"line\">    <span class=\"comment\">#百度: http://www.baidu.com/</span></span><br><span class=\"line\">    <span class=\"comment\">#新浪: http://example.com/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"设置代码高亮\"><a href=\"#设置代码高亮\" class=\"headerlink\" title=\"设置代码高亮\"></a>设置代码高亮</h3><p>NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 <code>normal</code>，<code>night</code>， <code>night blue</code>， <code>night bright</code>， <code>night eighties</code></p>\n<p>更改 highlight_theme 字段，将其值设定成你所喜爱的高亮主题</p>\n<h3 id=\"配置Algolia-搜索\"><a href=\"#配置Algolia-搜索\" class=\"headerlink\" title=\"配置Algolia 搜索\"></a>配置Algolia 搜索</h3><p><a href=\"https://www.algolia.com/\" target=\"_blank\" rel=\"noopener\">官网</a> 注册一个账号，可以用Github账户注册</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/Algolia_Signup.png\" alt=\"AlgoliaSinup\"></p>\n<p>登录进入Dashboard控制台页面，创建一个新Index</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/AlgoliaCreateIndex.png\" alt=\"AlgoliaCreateIndex\"></p>\n<p>进入 API Keys 界面，拷贝 <code>Application ID</code> 、<code>Search-Only API Key</code> 和 <code>Admin API Key</code></p>\n<p>编辑 <code>站点配置文件</code> ，新增以下配置：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">algolia:</span></span><br><span class=\"line\"><span class=\"attr\">  applicationID:</span> <span class=\"string\">'your applicationID'</span></span><br><span class=\"line\"><span class=\"attr\">  apiKey:</span> <span class=\"string\">'your Search-Only API Key'</span></span><br><span class=\"line\"><span class=\"attr\">  adminApiKey:</span> <span class=\"string\">'your Admin API Key'</span></span><br><span class=\"line\"><span class=\"attr\">  indexName:</span> <span class=\"string\">'your newcreated indexName'</span></span><br><span class=\"line\"><span class=\"attr\">  chunkSize:</span> <span class=\"number\">5000</span></span><br></pre></td></tr></table></figure>\n<p>安装Hexo Algolia<br>在Hexo根目录执行如下指令，进行Hexo Algolia的安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-algolia</span><br></pre></td></tr></table></figure>\n<p>到Hexo的根目录，在其中找到package.json文件，修改其中的hexo-algolia属性值为^0.2.0，如下图所示：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/hexo_algolia_version.png\" alt=\"package.json\"></p>\n<p>当配置完成，在站点根目录下执行hexo algolia 来更新Index</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo algolia</span><br></pre></td></tr></table></figure>\n<p><em>注意：</em></p>\n<blockquote>\n<p>如果发现没有上传数据，这时候可以先 <code>hexo clean</code> 然后再 <code>hexo algolia</code> _</p>\n</blockquote>\n<p>在 <code>主题配置文件</code>中，找到Algolia Search 配置部分：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Algolia Search</span></span><br><span class=\"line\"><span class=\"attr\">algolia_search:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  hits:</span></span><br><span class=\"line\"><span class=\"attr\">    per_page:</span> <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"attr\">  labels:</span></span><br><span class=\"line\"><span class=\"attr\">    input_placeholder:</span> <span class=\"string\">Search</span> <span class=\"string\">for</span> <span class=\"string\">Posts</span></span><br><span class=\"line\"><span class=\"attr\">    hits_empty:</span> <span class=\"string\">\"We didn't find any results for the search: $&#123;query&#125;\"</span></span><br><span class=\"line\"><span class=\"attr\">    hits_stats:</span> <span class=\"string\">\"$&#123;hits&#125; results found in $&#123;time&#125; ms\"</span></span><br></pre></td></tr></table></figure>\n<p>将 <code>enable</code> 改为true 即可，根据需要你可以调整labels 中的文本。</p>\n<h3 id=\"配置来必力评论\"><a href=\"#配置来必力评论\" class=\"headerlink\" title=\"配置来必力评论\"></a>配置来必力评论</h3><p>评论插件，最出名的是 Disqus，但是对于国内用户来说，自带梯子好些。改用多说，路边社消息，多说好像要完蛋了。发现了个叫 LiveRe（来必力）的评论插件，韩国出的，用着感觉还不错。</p>\n<p><a href=\"https://livere.com/\" target=\"_blank\" rel=\"noopener\">来必力官网</a>注册账号</p>\n<p>LiveRe 有两个版本：</p>\n<ul>\n<li>City 版：是一款适合所有人使用的免费版本；</li>\n<li>Premium 版：是一款能够帮助企业实现自动化管理的多功能收费版本。</li>\n</ul>\n<p>选择City版就可以了</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/installLiveRe.png\" alt=\"installLiveRe\"></p>\n<p>获取 LiveRe UID。 编辑 <code>主题配置文件</code>， 编辑 livere_uid 字段，设置如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">livere_uid:</span> <span class=\"comment\">#your livere_uid</span></span><br></pre></td></tr></table></figure>\n<p>NexT 已经支持来必力，这样就能在页面显示评论了</p>\n<h3 id=\"添加阅读次数统计\"><a href=\"#添加阅读次数统计\" class=\"headerlink\" title=\"添加阅读次数统计\"></a>添加阅读次数统计</h3><p>这里使用 <a href=\"https://leancloud.cn/\" target=\"_blank\" rel=\"noopener\">LeanCloud</a> 为文章添加统计功能</p>\n<p>注册账号登陆以后获得 <code>AppID</code>以及 <code>AppKey</code>这两个参数即可正常使用文章阅读量统计的功能了。</p>\n<p>创建应用</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/leancloudCreateApp.png\" alt=\"CreateApp\"></p>\n<p>配置应用</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/configApp.png\" alt=\"configApp\"></p>\n<p>在应用的数据配置界面，左侧下划线开头的都是系统预定义好的表。在弹出的选项中选择创建Class来新建Class用来专门保存我们博客的文章访问量等数据:<br>为了保证我们前面对NexT主题的修改兼容，此处的新建Class名字为 <code>Counter</code></p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/leancloudGetAPIKey.png\" alt=\"GetAppKey\"></p>\n<p>复制 <code>AppID</code>以及 <code>AppKey</code> 修改 <code>主题配置文件</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># You can visit https://leancloud.cn get AppID and AppKey.</span></span><br><span class=\"line\"><span class=\"attr\">leancloud_visitors:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  app_id:</span> <span class=\"comment\">#&lt;app_id&gt;</span></span><br><span class=\"line\"><span class=\"attr\">  app_key:</span> <span class=\"comment\">#&lt;app_key&gt;</span></span><br></pre></td></tr></table></figure>\n<p>重新生成并部署博客就可以显示阅读量了</p>\n<p><em>note: 记录文章访问量的唯一标识符是 <code>文章的发布日期</code>以及<code>文章的标题</code>，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计</em></p>\n<p>后台可以看到，刚才创建的Counter类</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/leanCloudbackend_data.png\" alt=\"backendReadCount\"></p>\n<h3 id=\"添加字数统计功能\"><a href=\"#添加字数统计功能\" class=\"headerlink\" title=\"添加字数统计功能\"></a>添加字数统计功能</h3><p>首先在博客目录下使用 npm 安装插件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>\n<p>在 <code>主题配置文件</code>中打开wordcount 统计功能</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Post wordcount display settings</span></span><br><span class=\"line\"><span class=\"comment\"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class=\"line\"><span class=\"attr\">post_wordcount:</span></span><br><span class=\"line\"><span class=\"attr\">  item_text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  wordcount:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  min2read:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>找到..\\themes\\next\\layout_macro\\post.swig 文件，将”字”、”分钟” 字样添加到如下位置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt;</span><br><span class=\"line\">  &#123;&#123; wordcount(post.content) &#125;&#125; 字</span><br><span class=\"line\">&lt;/span&gt;</span><br><span class=\"line\"> ...</span><br><span class=\"line\">&lt;span title=&quot;&#123;&#123; __(&apos;post.min2read&apos;) &#125;&#125;&quot;&gt;</span><br><span class=\"line\">  &#123;&#123; min2read(post.content) &#125;&#125; 分钟</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure>"},{"title":"Markdown Cheatsheet","date":"2017-05-31T03:38:38.000Z","_content":"\n\n开始写博客后，Markdown成为一种常用的文档格式，Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然，里面的语法记下来，为了以后查询方便。\n\n## 文本样式\n\n```\n*斜体*或_斜体_\n**粗体**\n***加粗斜体***\n~~删除线~~\n```\n\n- *斜体* 或 _斜体_\n- **粗体**\n- ***加粗斜体***\n- ~~删除线~~\n\n- *This text will be italic*\n- _This will also be italic_\n- **This text will be bold**\n- __This will also be bold__\n- *You **can** combine them*\n\n<!-- more -->\n\n## 引用\n\n使用大于号 `>` 表示引用内容：\n\nAs Grace Hopper said:\n> I’ve always been more interested\n> in the future than in the past.\n\n## 分级标题\n\n第一种写法\n\n```\n这是一个一级标题\n============================\n这是一个二级标题\n--------------------------------------------------\n```\n第二种写法\n\n```\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n## 超链接\n\nMarkdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。\n\n### 行内式\n\n语法说明：\n\n[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 “链接标题”)’这样的形式。链接地址与链接标题前有一个空格。\n\n```\n欢迎来到[我的博客](https://lvraikkonen.github.io/)\n欢迎来到[我的博客](https://lvraikkonen.github.io/ \"博客名\")\n```\n\n- 欢迎来到[我的博客](https://lvraikkonen.github.io/)\n- 欢迎来到[我的博客](https://lvraikkonen.github.io/ \"博客名\")\n\n### 参考式\n\n参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。\n\n语法说明：\n参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。\n\n如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]\n[链接文字]：链接地址的形式，见代码的最后一行。\n\n```\n我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]\n[Leanote 笔记][2]是一个不错的[网站][]。\n[1]:http://www.google.com \"Google\"\n[2]:http://www.leanote.com \"Leanote\"\n[3]:https://lvraikkonen.github.io \"lvraikkonen\"\n[网站]:https://lvraikkonen.github.io\n```\n\n我经常去的几个网站[Google][1]、[Leanote][2]\n\n以及[自己的博客][3]，[Leanote 笔记][2]是一个不错的[网站][]。\n\n[1]:http://www.google.com \"Google\"\n[2]:http://www.leanote.com \"Leanote\"\n[3]:https://lvraikkonen.github.io \"lvraikkonen\"\n[网站]:https://lvraikkonen.github.io\n\n### 自动链接\n\n语法说明：\nMarkdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用<>包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：\n\n```\n<http://example.com/>\n<address@example.com>\n```\n\n显示效果：\n\n- <http://example.com/>\n- <address@example.com>\n\n## 列表\n\n无序列表使用星号 `*`、加号 `+`或是减号 `-` 作为列表标记\n\n*   Red\n*   Green\n*   Blue\n\n有序列表则使用数字接着一个英文句点：\n\n1.  Bird\n2.  McHale\n3.  Parish\n\n\n列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：\n\n1.  This is a list item with two paragraphs. Lorem ipsum dolor\n    sit amet, consectetuer adipiscing elit. Aliquam hendrerit\n    mi posuere lectus.\n\n    Vestibulum enim wisi, viverra nec, fringilla in, laoreet\n    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum\n    sit amet velit.\n\n2.  Suspendisse id sem consectetuer libero luctus adipiscing.\n\n如果要在列表项目内放进引用，那 `>` 就需要缩进：\n\n*   A list item with a blockquote:\n\n    > This is a blockquote\n    > inside a list item.\n\n## 图像\n\n和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式\n\n### 行内式\n\n- 一个惊叹号 !\n- 接着一个方括号，里面放上图片的替代文字\n- 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 'title' 文字\n\n```\n![Alt text](/path/to/img.jpg)\n\n![Alt text](/path/to/img.jpg \"Optional title\")\n```\n\nInline-style:\n![alt text](https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"Logo Title Text 1\")\n\n\n### 参考式\n\nid是图片参考的名称，图片参考的定义方式则和链接参考一样：\n```\n![Alt text][id]\n[id]: url/to/image  \"Optional title attribute\"\n```\n\nReference-style:\n![alt text][logo]\n\n[logo]: https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"Logo Title Text 2\"\n\n## 代码\n\n如果要标记一小段行内代码，你可以用反引号把它包起来 `code`\n\n也可以使用三个反引号包裹一段代码，并指定一种语言\n\n```javascript\nvar s = \"JavaScript syntax highlighting\";\nalert(s);\n```\n\n```python\ns = \"Python syntax highlighting\"\nprint s\n```\n\n```\nNo language indicated, so no syntax highlighting.\nBut let's throw in a <b>tag</b>.\n```\n\n\n## 表格\n\n| Tables        | Are           | Cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n\n\n以下是Github支持的markdown语法：\n\n## To-Do list\n\nTASK LISTS\n- [x] this is a complete item\n- [ ] this is an incomplete item\n- [x] @mentions, #refs, [links](), **formatting**, and <del>tags</del> supported\n- [x] list syntax required (any unordered or ordered list supported)\n\n\n## EMOJI\n\nGitHub supports emoji!\n:+1: :sparkles: :camel: :tada:\n:rocket: :metal: :octocat:\n","source":"_posts/Markdown-Cheatsheet.md","raw":"---\ntitle: Markdown Cheatsheet\ndate: 2017-05-31 11:38:38\ntags:\n    - Markdown\n    - 备忘\n    - Cheat Sheet\n---\n\n\n开始写博客后，Markdown成为一种常用的文档格式，Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然，里面的语法记下来，为了以后查询方便。\n\n## 文本样式\n\n```\n*斜体*或_斜体_\n**粗体**\n***加粗斜体***\n~~删除线~~\n```\n\n- *斜体* 或 _斜体_\n- **粗体**\n- ***加粗斜体***\n- ~~删除线~~\n\n- *This text will be italic*\n- _This will also be italic_\n- **This text will be bold**\n- __This will also be bold__\n- *You **can** combine them*\n\n<!-- more -->\n\n## 引用\n\n使用大于号 `>` 表示引用内容：\n\nAs Grace Hopper said:\n> I’ve always been more interested\n> in the future than in the past.\n\n## 分级标题\n\n第一种写法\n\n```\n这是一个一级标题\n============================\n这是一个二级标题\n--------------------------------------------------\n```\n第二种写法\n\n```\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n## 超链接\n\nMarkdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。\n\n### 行内式\n\n语法说明：\n\n[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 “链接标题”)’这样的形式。链接地址与链接标题前有一个空格。\n\n```\n欢迎来到[我的博客](https://lvraikkonen.github.io/)\n欢迎来到[我的博客](https://lvraikkonen.github.io/ \"博客名\")\n```\n\n- 欢迎来到[我的博客](https://lvraikkonen.github.io/)\n- 欢迎来到[我的博客](https://lvraikkonen.github.io/ \"博客名\")\n\n### 参考式\n\n参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。\n\n语法说明：\n参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。\n\n如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]\n[链接文字]：链接地址的形式，见代码的最后一行。\n\n```\n我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]\n[Leanote 笔记][2]是一个不错的[网站][]。\n[1]:http://www.google.com \"Google\"\n[2]:http://www.leanote.com \"Leanote\"\n[3]:https://lvraikkonen.github.io \"lvraikkonen\"\n[网站]:https://lvraikkonen.github.io\n```\n\n我经常去的几个网站[Google][1]、[Leanote][2]\n\n以及[自己的博客][3]，[Leanote 笔记][2]是一个不错的[网站][]。\n\n[1]:http://www.google.com \"Google\"\n[2]:http://www.leanote.com \"Leanote\"\n[3]:https://lvraikkonen.github.io \"lvraikkonen\"\n[网站]:https://lvraikkonen.github.io\n\n### 自动链接\n\n语法说明：\nMarkdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用<>包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：\n\n```\n<http://example.com/>\n<address@example.com>\n```\n\n显示效果：\n\n- <http://example.com/>\n- <address@example.com>\n\n## 列表\n\n无序列表使用星号 `*`、加号 `+`或是减号 `-` 作为列表标记\n\n*   Red\n*   Green\n*   Blue\n\n有序列表则使用数字接着一个英文句点：\n\n1.  Bird\n2.  McHale\n3.  Parish\n\n\n列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：\n\n1.  This is a list item with two paragraphs. Lorem ipsum dolor\n    sit amet, consectetuer adipiscing elit. Aliquam hendrerit\n    mi posuere lectus.\n\n    Vestibulum enim wisi, viverra nec, fringilla in, laoreet\n    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum\n    sit amet velit.\n\n2.  Suspendisse id sem consectetuer libero luctus adipiscing.\n\n如果要在列表项目内放进引用，那 `>` 就需要缩进：\n\n*   A list item with a blockquote:\n\n    > This is a blockquote\n    > inside a list item.\n\n## 图像\n\n和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式\n\n### 行内式\n\n- 一个惊叹号 !\n- 接着一个方括号，里面放上图片的替代文字\n- 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 'title' 文字\n\n```\n![Alt text](/path/to/img.jpg)\n\n![Alt text](/path/to/img.jpg \"Optional title\")\n```\n\nInline-style:\n![alt text](https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"Logo Title Text 1\")\n\n\n### 参考式\n\nid是图片参考的名称，图片参考的定义方式则和链接参考一样：\n```\n![Alt text][id]\n[id]: url/to/image  \"Optional title attribute\"\n```\n\nReference-style:\n![alt text][logo]\n\n[logo]: https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"Logo Title Text 2\"\n\n## 代码\n\n如果要标记一小段行内代码，你可以用反引号把它包起来 `code`\n\n也可以使用三个反引号包裹一段代码，并指定一种语言\n\n```javascript\nvar s = \"JavaScript syntax highlighting\";\nalert(s);\n```\n\n```python\ns = \"Python syntax highlighting\"\nprint s\n```\n\n```\nNo language indicated, so no syntax highlighting.\nBut let's throw in a <b>tag</b>.\n```\n\n\n## 表格\n\n| Tables        | Are           | Cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n\n\n以下是Github支持的markdown语法：\n\n## To-Do list\n\nTASK LISTS\n- [x] this is a complete item\n- [ ] this is an incomplete item\n- [x] @mentions, #refs, [links](), **formatting**, and <del>tags</del> supported\n- [x] list syntax required (any unordered or ordered list supported)\n\n\n## EMOJI\n\nGitHub supports emoji!\n:+1: :sparkles: :camel: :tada:\n:rocket: :metal: :octocat:\n","slug":"Markdown-Cheatsheet","published":1,"updated":"2017-06-08T07:45:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3o6002dzd68ugaife6f","content":"<p>开始写博客后，Markdown成为一种常用的文档格式，Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然，里面的语法记下来，为了以后查询方便。</p>\n<h2 id=\"文本样式\"><a href=\"#文本样式\" class=\"headerlink\" title=\"文本样式\"></a>文本样式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*斜体*或_斜体_</span><br><span class=\"line\">**粗体**</span><br><span class=\"line\">***加粗斜体***</span><br><span class=\"line\">~~删除线~~</span><br></pre></td></tr></table></figure>\n<ul>\n<li><em>斜体</em> 或 _斜体_</li>\n<li><strong>粗体</strong></li>\n<li><strong><em>加粗斜体</em></strong></li>\n<li><p><del>删除线</del></p>\n</li>\n<li><p><em>This text will be italic</em></p>\n</li>\n<li><em>This will also be italic</em></li>\n<li><strong>This text will be bold</strong></li>\n<li><strong>This will also be bold</strong></li>\n<li><em>You <strong>can</strong> combine them</em></li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>使用大于号 <code>&gt;</code> 表示引用内容：</p>\n<p>As Grace Hopper said:</p>\n<blockquote>\n<p>I’ve always been more interested<br>in the future than in the past.</p>\n</blockquote>\n<h2 id=\"分级标题\"><a href=\"#分级标题\" class=\"headerlink\" title=\"分级标题\"></a>分级标题</h2><p>第一种写法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是一个一级标题</span><br><span class=\"line\">============================</span><br><span class=\"line\">这是一个二级标题</span><br><span class=\"line\">--------------------------------------------------</span><br></pre></td></tr></table></figure>\n<p>第二种写法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 一级标题</span><br><span class=\"line\">## 二级标题</span><br><span class=\"line\">### 三级标题</span><br><span class=\"line\">#### 四级标题</span><br><span class=\"line\">##### 五级标题</span><br><span class=\"line\">###### 六级标题</span><br></pre></td></tr></table></figure>\n<h2 id=\"超链接\"><a href=\"#超链接\" class=\"headerlink\" title=\"超链接\"></a>超链接</h2><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。</p>\n<h3 id=\"行内式\"><a href=\"#行内式\" class=\"headerlink\" title=\"行内式\"></a>行内式</h3><p>语法说明：</p>\n<p>[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。<a href=\"链接地址 “链接标题”\">链接文字</a>’这样的形式。链接地址与链接标题前有一个空格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">欢迎来到[我的博客](https://lvraikkonen.github.io/)</span><br><span class=\"line\">欢迎来到[我的博客](https://lvraikkonen.github.io/ &quot;博客名&quot;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>欢迎来到<a href=\"https://lvraikkonen.github.io/\">我的博客</a></li>\n<li>欢迎来到<a href=\"https://lvraikkonen.github.io/\" title=\"博客名\">我的博客</a></li>\n</ul>\n<h3 id=\"参考式\"><a href=\"#参考式\" class=\"headerlink\" title=\"参考式\"></a>参考式</h3><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p>\n<p>语法说明：<br>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。</p>\n<p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>[链接文字]：链接地址的形式，见代码的最后一行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]</span><br><span class=\"line\">[Leanote 笔记][2]是一个不错的[网站][]。</span><br><span class=\"line\">[1]:http://www.google.com &quot;Google&quot;</span><br><span class=\"line\">[2]:http://www.leanote.com &quot;Leanote&quot;</span><br><span class=\"line\">[3]:https://lvraikkonen.github.io &quot;lvraikkonen&quot;</span><br><span class=\"line\">[网站]:https://lvraikkonen.github.io</span><br></pre></td></tr></table></figure>\n<p>我经常去的几个网站<a href=\"http://www.google.com\" title=\"Google\" target=\"_blank\" rel=\"noopener\">Google</a>、<a href=\"http://www.leanote.com\" title=\"Leanote\" target=\"_blank\" rel=\"noopener\">Leanote</a></p>\n<p>以及<a href=\"https://lvraikkonen.github.io\" title=\"lvraikkonen\">自己的博客</a>，<a href=\"http://www.leanote.com\" title=\"Leanote\" target=\"_blank\" rel=\"noopener\">Leanote 笔记</a>是一个不错的<a href=\"https://lvraikkonen.github.io\">网站</a>。</p>\n<h3 id=\"自动链接\"><a href=\"#自动链接\" class=\"headerlink\" title=\"自动链接\"></a>自动链接</h3><p>语法说明：<br>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;http://example.com/&gt;</span><br><span class=\"line\">&lt;address@example.com&gt;</span><br></pre></td></tr></table></figure>\n<p>显示效果：</p>\n<ul>\n<li><a href=\"http://example.com/\" target=\"_blank\" rel=\"noopener\">http://example.com/</a></li>\n<li><a href=\"mailto:&#x61;&#100;&#100;&#x72;&#101;&#x73;&#x73;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x61;&#100;&#100;&#x72;&#101;&#x73;&#x73;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#x6d;</a></li>\n</ul>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><p>无序列表使用星号 <code>*</code>、加号 <code>+</code>或是减号 <code>-</code> 作为列表标记</p>\n<ul>\n<li>Red</li>\n<li>Green</li>\n<li>Blue</li>\n</ul>\n<p>有序列表则使用数字接着一个英文句点：</p>\n<ol>\n<li>Bird</li>\n<li>McHale</li>\n<li>Parish</li>\n</ol>\n<p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p>\n<ol>\n<li><p>This is a list item with two paragraphs. Lorem ipsum dolor<br>sit amet, consectetuer adipiscing elit. Aliquam hendrerit<br>mi posuere lectus.</p>\n<p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet<br>vitae, risus. Donec sit amet nisl. Aliquam semper ipsum<br>sit amet velit.</p>\n</li>\n<li><p>Suspendisse id sem consectetuer libero luctus adipiscing.</p>\n</li>\n</ol>\n<p>如果要在列表项目内放进引用，那 <code>&gt;</code> 就需要缩进：</p>\n<ul>\n<li><p>A list item with a blockquote:</p>\n<blockquote>\n<p>This is a blockquote<br>inside a list item.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"图像\"><a href=\"#图像\" class=\"headerlink\" title=\"图像\"></a>图像</h2><p>和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式</p>\n<h3 id=\"行内式-1\"><a href=\"#行内式-1\" class=\"headerlink\" title=\"行内式\"></a>行内式</h3><ul>\n<li>一个惊叹号 !</li>\n<li>接着一个方括号，里面放上图片的替代文字</li>\n<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![Alt text](/path/to/img.jpg)</span><br><span class=\"line\"></span><br><span class=\"line\">![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</span><br></pre></td></tr></table></figure>\n<p>Inline-style:<br><img src=\"https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png\" alt=\"alt text\" title=\"Logo Title Text 1\"></p>\n<h3 id=\"参考式-1\"><a href=\"#参考式-1\" class=\"headerlink\" title=\"参考式\"></a>参考式</h3><p>id是图片参考的名称，图片参考的定义方式则和链接参考一样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![Alt text][id]</span><br><span class=\"line\">[id]: url/to/image  &quot;Optional title attribute&quot;</span><br></pre></td></tr></table></figure></p>\n<p>Reference-style:<br><img src=\"https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png\" alt=\"alt text\" title=\"Logo Title Text 2\"></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>如果要标记一小段行内代码，你可以用反引号把它包起来 <code>code</code></p>\n<p>也可以使用三个反引号包裹一段代码，并指定一种语言</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">\"JavaScript syntax highlighting\"</span>;</span><br><span class=\"line\">alert(s);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">\"Python syntax highlighting\"</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> s</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No language indicated, so no syntax highlighting.</span><br><span class=\"line\">But let&apos;s throw in a &lt;b&gt;tag&lt;/b&gt;.</span><br></pre></td></tr></table></figure>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><table>\n<thead>\n<tr>\n<th>Tables</th>\n<th style=\"text-align:center\">Are</th>\n<th style=\"text-align:right\">Cool</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>col 3 is</td>\n<td style=\"text-align:center\">right-aligned</td>\n<td style=\"text-align:right\">$1600</td>\n</tr>\n<tr>\n<td>col 2 is</td>\n<td style=\"text-align:center\">centered</td>\n<td style=\"text-align:right\">$12</td>\n</tr>\n<tr>\n<td>zebra stripes</td>\n<td style=\"text-align:center\">are neat</td>\n<td style=\"text-align:right\">$1</td>\n</tr>\n</tbody>\n</table>\n<p>以下是Github支持的markdown语法：</p>\n<h2 id=\"To-Do-list\"><a href=\"#To-Do-list\" class=\"headerlink\" title=\"To-Do list\"></a>To-Do list</h2><p>TASK LISTS</p>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\" checked> this is a complete item</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> this is an incomplete item</li>\n<li style=\"list-style: none\"><input type=\"checkbox\" checked> @mentions, #refs, <a href=\"\">links</a>, <strong>formatting</strong>, and <del>tags</del> supported</li>\n<li style=\"list-style: none\"><input type=\"checkbox\" checked> list syntax required (any unordered or ordered list supported)</li>\n</ul>\n<h2 id=\"EMOJI\"><a href=\"#EMOJI\" class=\"headerlink\" title=\"EMOJI\"></a>EMOJI</h2><p>GitHub supports emoji!<br>:+1: :sparkles: :camel: :tada:<br>:rocket: :metal: :octocat:</p>\n","site":{"data":{}},"excerpt":"<p>开始写博客后，Markdown成为一种常用的文档格式，Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然，里面的语法记下来，为了以后查询方便。</p>\n<h2 id=\"文本样式\"><a href=\"#文本样式\" class=\"headerlink\" title=\"文本样式\"></a>文本样式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*斜体*或_斜体_</span><br><span class=\"line\">**粗体**</span><br><span class=\"line\">***加粗斜体***</span><br><span class=\"line\">~~删除线~~</span><br></pre></td></tr></table></figure>\n<ul>\n<li><em>斜体</em> 或 _斜体_</li>\n<li><strong>粗体</strong></li>\n<li><strong><em>加粗斜体</em></strong></li>\n<li><p><del>删除线</del></p>\n</li>\n<li><p><em>This text will be italic</em></p>\n</li>\n<li><em>This will also be italic</em></li>\n<li><strong>This text will be bold</strong></li>\n<li><strong>This will also be bold</strong></li>\n<li><em>You <strong>can</strong> combine them</em></li>\n</ul>","more":"<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>使用大于号 <code>&gt;</code> 表示引用内容：</p>\n<p>As Grace Hopper said:</p>\n<blockquote>\n<p>I’ve always been more interested<br>in the future than in the past.</p>\n</blockquote>\n<h2 id=\"分级标题\"><a href=\"#分级标题\" class=\"headerlink\" title=\"分级标题\"></a>分级标题</h2><p>第一种写法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是一个一级标题</span><br><span class=\"line\">============================</span><br><span class=\"line\">这是一个二级标题</span><br><span class=\"line\">--------------------------------------------------</span><br></pre></td></tr></table></figure>\n<p>第二种写法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 一级标题</span><br><span class=\"line\">## 二级标题</span><br><span class=\"line\">### 三级标题</span><br><span class=\"line\">#### 四级标题</span><br><span class=\"line\">##### 五级标题</span><br><span class=\"line\">###### 六级标题</span><br></pre></td></tr></table></figure>\n<h2 id=\"超链接\"><a href=\"#超链接\" class=\"headerlink\" title=\"超链接\"></a>超链接</h2><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。</p>\n<h3 id=\"行内式\"><a href=\"#行内式\" class=\"headerlink\" title=\"行内式\"></a>行内式</h3><p>语法说明：</p>\n<p>[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。<a href=\"链接地址 “链接标题”\">链接文字</a>’这样的形式。链接地址与链接标题前有一个空格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">欢迎来到[我的博客](https://lvraikkonen.github.io/)</span><br><span class=\"line\">欢迎来到[我的博客](https://lvraikkonen.github.io/ &quot;博客名&quot;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>欢迎来到<a href=\"https://lvraikkonen.github.io/\">我的博客</a></li>\n<li>欢迎来到<a href=\"https://lvraikkonen.github.io/\" title=\"博客名\">我的博客</a></li>\n</ul>\n<h3 id=\"参考式\"><a href=\"#参考式\" class=\"headerlink\" title=\"参考式\"></a>参考式</h3><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p>\n<p>语法说明：<br>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。</p>\n<p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>[链接文字]：链接地址的形式，见代码的最后一行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]</span><br><span class=\"line\">[Leanote 笔记][2]是一个不错的[网站][]。</span><br><span class=\"line\">[1]:http://www.google.com &quot;Google&quot;</span><br><span class=\"line\">[2]:http://www.leanote.com &quot;Leanote&quot;</span><br><span class=\"line\">[3]:https://lvraikkonen.github.io &quot;lvraikkonen&quot;</span><br><span class=\"line\">[网站]:https://lvraikkonen.github.io</span><br></pre></td></tr></table></figure>\n<p>我经常去的几个网站<a href=\"http://www.google.com\" title=\"Google\" target=\"_blank\" rel=\"noopener\">Google</a>、<a href=\"http://www.leanote.com\" title=\"Leanote\" target=\"_blank\" rel=\"noopener\">Leanote</a></p>\n<p>以及<a href=\"https://lvraikkonen.github.io\" title=\"lvraikkonen\">自己的博客</a>，<a href=\"http://www.leanote.com\" title=\"Leanote\" target=\"_blank\" rel=\"noopener\">Leanote 笔记</a>是一个不错的<a href=\"https://lvraikkonen.github.io\">网站</a>。</p>\n<h3 id=\"自动链接\"><a href=\"#自动链接\" class=\"headerlink\" title=\"自动链接\"></a>自动链接</h3><p>语法说明：<br>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;http://example.com/&gt;</span><br><span class=\"line\">&lt;address@example.com&gt;</span><br></pre></td></tr></table></figure>\n<p>显示效果：</p>\n<ul>\n<li><a href=\"http://example.com/\" target=\"_blank\" rel=\"noopener\">http://example.com/</a></li>\n<li><a href=\"mailto:&#x61;&#100;&#100;&#x72;&#101;&#x73;&#x73;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x61;&#100;&#100;&#x72;&#101;&#x73;&#x73;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#x6d;</a></li>\n</ul>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><p>无序列表使用星号 <code>*</code>、加号 <code>+</code>或是减号 <code>-</code> 作为列表标记</p>\n<ul>\n<li>Red</li>\n<li>Green</li>\n<li>Blue</li>\n</ul>\n<p>有序列表则使用数字接着一个英文句点：</p>\n<ol>\n<li>Bird</li>\n<li>McHale</li>\n<li>Parish</li>\n</ol>\n<p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p>\n<ol>\n<li><p>This is a list item with two paragraphs. Lorem ipsum dolor<br>sit amet, consectetuer adipiscing elit. Aliquam hendrerit<br>mi posuere lectus.</p>\n<p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet<br>vitae, risus. Donec sit amet nisl. Aliquam semper ipsum<br>sit amet velit.</p>\n</li>\n<li><p>Suspendisse id sem consectetuer libero luctus adipiscing.</p>\n</li>\n</ol>\n<p>如果要在列表项目内放进引用，那 <code>&gt;</code> 就需要缩进：</p>\n<ul>\n<li><p>A list item with a blockquote:</p>\n<blockquote>\n<p>This is a blockquote<br>inside a list item.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"图像\"><a href=\"#图像\" class=\"headerlink\" title=\"图像\"></a>图像</h2><p>和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式</p>\n<h3 id=\"行内式-1\"><a href=\"#行内式-1\" class=\"headerlink\" title=\"行内式\"></a>行内式</h3><ul>\n<li>一个惊叹号 !</li>\n<li>接着一个方括号，里面放上图片的替代文字</li>\n<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![Alt text](/path/to/img.jpg)</span><br><span class=\"line\"></span><br><span class=\"line\">![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</span><br></pre></td></tr></table></figure>\n<p>Inline-style:<br><img src=\"https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png\" alt=\"alt text\" title=\"Logo Title Text 1\"></p>\n<h3 id=\"参考式-1\"><a href=\"#参考式-1\" class=\"headerlink\" title=\"参考式\"></a>参考式</h3><p>id是图片参考的名称，图片参考的定义方式则和链接参考一样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![Alt text][id]</span><br><span class=\"line\">[id]: url/to/image  &quot;Optional title attribute&quot;</span><br></pre></td></tr></table></figure></p>\n<p>Reference-style:<br><img src=\"https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png\" alt=\"alt text\" title=\"Logo Title Text 2\"></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>如果要标记一小段行内代码，你可以用反引号把它包起来 <code>code</code></p>\n<p>也可以使用三个反引号包裹一段代码，并指定一种语言</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">\"JavaScript syntax highlighting\"</span>;</span><br><span class=\"line\">alert(s);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">\"Python syntax highlighting\"</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> s</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No language indicated, so no syntax highlighting.</span><br><span class=\"line\">But let&apos;s throw in a &lt;b&gt;tag&lt;/b&gt;.</span><br></pre></td></tr></table></figure>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><table>\n<thead>\n<tr>\n<th>Tables</th>\n<th style=\"text-align:center\">Are</th>\n<th style=\"text-align:right\">Cool</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>col 3 is</td>\n<td style=\"text-align:center\">right-aligned</td>\n<td style=\"text-align:right\">$1600</td>\n</tr>\n<tr>\n<td>col 2 is</td>\n<td style=\"text-align:center\">centered</td>\n<td style=\"text-align:right\">$12</td>\n</tr>\n<tr>\n<td>zebra stripes</td>\n<td style=\"text-align:center\">are neat</td>\n<td style=\"text-align:right\">$1</td>\n</tr>\n</tbody>\n</table>\n<p>以下是Github支持的markdown语法：</p>\n<h2 id=\"To-Do-list\"><a href=\"#To-Do-list\" class=\"headerlink\" title=\"To-Do list\"></a>To-Do list</h2><p>TASK LISTS</p>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\" checked> this is a complete item</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> this is an incomplete item</li>\n<li style=\"list-style: none\"><input type=\"checkbox\" checked> @mentions, #refs, <a href=\"\">links</a>, <strong>formatting</strong>, and <del>tags</del> supported</li>\n<li style=\"list-style: none\"><input type=\"checkbox\" checked> list syntax required (any unordered or ordered list supported)</li>\n</ul>\n<h2 id=\"EMOJI\"><a href=\"#EMOJI\" class=\"headerlink\" title=\"EMOJI\"></a>EMOJI</h2><p>GitHub supports emoji!<br>:+1: :sparkles: :camel: :tada:<br>:rocket: :metal: :octocat:</p>"},{"title":"MongoDB CRUD 快速复习","date":"2017-06-28T03:08:32.000Z","_content":"\n提到数据库的基本操作，无论关系型还是非关系型，首先想到的肯定是数据的增删改查 (Create, Read, Update, Delete)，下面记录一下MongoDB里面的CRUD操作。\n\n<!-- more -->\n\n## INSERT 操作\n\n![insertStatement](https://docs.mongodb.com/manual/_images/crud-annotated-mongodb-insertOne.bakedsvg.svg)\n\nMongoDB里面数据叫做文档Document，其实就是JSON对象，常见的插入操作分为单条插入 `insertOne()` 和多条插入 `insertMany()` ，单条插入传入一个JSON对象，多条插入传入一个多个JSON对象的数组\n\n## FIND 操作\n\n![findStatement](https://docs.mongodb.com/manual/_images/crud-annotated-mongodb-find.bakedsvg.svg)\n\nQuery操作是这4中操作最重要的部分， 查询的语法如下：\n\n- query criteria，可选。表示集合的查询条件。可指定条件查询参数，或一个空对象({})\n- projection，可选。表示查询时所要返回的字段，省略此参数将返回全部字段。其格式如下：\n{ field1: <boolean>, field2: <boolean> ... }\n\n返回查询文档的游标，即：执行find()方法时其返回的文档，实际是对文档引用的一个游标。当指定projection参数时，返回值仅包含指定的字段和_id字段，也可以指定不返回_id字段\n\n### 查询参数\n\n下面这些在SQL的WHERE子句中的操作符，在MongoDB中都有实现。\n\nSQL :\n\n```\n>, >=, <, <=, !=\nAnd，OR，In，NotIn\n```\nMongoDB:\n\n```\n\"$gt\", \"$gte\", \"$lt\", \"$lte\", \"$ne\"\n\"$and\", \"$or\", \"$in\"，\"$nin\"\n```\n\n举几个查询的例子：\n\n``` shell\ndb.inventory.find( { status: { $in: [ \"A\", \"D\" ] } } )\n# SELECT * FROM inventory WHERE status in (\"A\", \"D\")\n\ndb.inventory.find( $and: [ { status: \"A\", qty: { $lt: 30 } } ] )\n# SELECT * FROM inventory WHERE status = \"A\" AND qty < 30\n\ndb.inventory.find( { $or: [ { status: \"A\" }, { qty: { $lt: 30 } } ] } )\n# SELECT * FROM inventory WHERE status = \"A\" OR qty < 30\n\ndb.inventory.find( {\n     status: \"A\",\n     $or: [ { qty: { $lt: 30 } }, { item: /^p/ } ]\n} )\n# SELECT * FROM inventory WHERE status = \"A\" AND ( qty < 30 OR item LIKE \"p%\")\n```\n\n如果查询使用的是嵌套的文档的属性，那就使用 `\"field.nestedField\"`\n\n## UPDATE 操作\n\nUPDATE 的语法如下：\n\n```\ndb.collection.update(\n   <query>,\n   <update>,\n   {\n     upsert: <boolean>,\n     multi: <boolean>,\n     writeConcern: <document>,\n     collation: <document>\n   }\n)\n```\n\n更新操作分为整体更新和局部更新，整体更新是用一个新的文档完全替代匹配的文档。\n\n**危险**： 使用替换更新时应当注意，如果查询条件匹配到多个文档，所有的文档都会被替换\n\n下面主要说的是局部更新。\n\n![updateStatement](https://docs.mongodb.com/manual/_images/crud-annotated-mongodb-updateMany.bakedsvg.svg)\n\n### 修改器\n\n现在有个文档products\n``` json\n{\n  _id: 100,\n  sku: \"abc123\",\n  quantity: 250,\n  instock: true,\n  reorder: false,\n  details: { model: \"14Q2\", make: \"xyz\" },\n  tags: [ \"apparel\", \"clothing\" ],\n  ratings: [ { by: \"ijk\", rating: 4 } ]\n}\n```\n\n`$set`修改器\n\n`$set`修改器用于指定一个字段的值，字段不存在时，则会创建字段。 修改错误或不在需要的字段，可以使用`$unset`方法将这个键删除\n\n现在要把文档中 `details.make`字段的值更新为\"zzz\"\n\n``` shell\ndb.products.update(\n    { _id: 100},\n    { $set: {\"details.make\": \"zzz\"},\n      $currentDate: {lastModified: true}\n    }\n)\n```\n\n其中，$set操作符将details.make字段的值更新为zzz， $currentDate 操作符用来更新lastModified字段的值为当前时间，如果该字段不存在，$currentDate 操作符将会创建这个字段\n\n`$inc`修改器\n\n`$inc`修改器用于字段值的增加和减少\n\nproducts文档如下：\n``` JSON\n{\n  _id: 1,\n  sku: \"abc123\",\n  quantity: 10,\n  metrics: {\n    orders: 2,\n    ratings: 3.5\n  }\n}\n```\n\n将quantity字段的值减2，并且将orders的值加1\n\n``` shell\ndb.products.update(\n    { sku: \"abc123\"},\n    { $inc: {quiantity: -2, \"metrics.orders\": 1 }}\n)\n```\n\n## DELETE 操作\n\n**危险**：remove中如果不带参数将删除所有数据\n\n![deleteStetement](https://docs.mongodb.com/manual/_images/crud-annotated-mongodb-deleteMany.bakedsvg.svg)\n\n下面附的是 [MongoDB 的速查手册](http://7xkfga.com1.z0.glb.clouddn.com/MongoDBReferenceCards.pdf)\n","source":"_posts/MongoDB-CRUD-øÏÀŸ∏¥œ∞.md","raw":"---\ntitle: MongoDB CRUD 快速复习\ndate: 2017-06-28 11:08:32\ntags:\n    - MongoDB\n---\n\n提到数据库的基本操作，无论关系型还是非关系型，首先想到的肯定是数据的增删改查 (Create, Read, Update, Delete)，下面记录一下MongoDB里面的CRUD操作。\n\n<!-- more -->\n\n## INSERT 操作\n\n![insertStatement](https://docs.mongodb.com/manual/_images/crud-annotated-mongodb-insertOne.bakedsvg.svg)\n\nMongoDB里面数据叫做文档Document，其实就是JSON对象，常见的插入操作分为单条插入 `insertOne()` 和多条插入 `insertMany()` ，单条插入传入一个JSON对象，多条插入传入一个多个JSON对象的数组\n\n## FIND 操作\n\n![findStatement](https://docs.mongodb.com/manual/_images/crud-annotated-mongodb-find.bakedsvg.svg)\n\nQuery操作是这4中操作最重要的部分， 查询的语法如下：\n\n- query criteria，可选。表示集合的查询条件。可指定条件查询参数，或一个空对象({})\n- projection，可选。表示查询时所要返回的字段，省略此参数将返回全部字段。其格式如下：\n{ field1: <boolean>, field2: <boolean> ... }\n\n返回查询文档的游标，即：执行find()方法时其返回的文档，实际是对文档引用的一个游标。当指定projection参数时，返回值仅包含指定的字段和_id字段，也可以指定不返回_id字段\n\n### 查询参数\n\n下面这些在SQL的WHERE子句中的操作符，在MongoDB中都有实现。\n\nSQL :\n\n```\n>, >=, <, <=, !=\nAnd，OR，In，NotIn\n```\nMongoDB:\n\n```\n\"$gt\", \"$gte\", \"$lt\", \"$lte\", \"$ne\"\n\"$and\", \"$or\", \"$in\"，\"$nin\"\n```\n\n举几个查询的例子：\n\n``` shell\ndb.inventory.find( { status: { $in: [ \"A\", \"D\" ] } } )\n# SELECT * FROM inventory WHERE status in (\"A\", \"D\")\n\ndb.inventory.find( $and: [ { status: \"A\", qty: { $lt: 30 } } ] )\n# SELECT * FROM inventory WHERE status = \"A\" AND qty < 30\n\ndb.inventory.find( { $or: [ { status: \"A\" }, { qty: { $lt: 30 } } ] } )\n# SELECT * FROM inventory WHERE status = \"A\" OR qty < 30\n\ndb.inventory.find( {\n     status: \"A\",\n     $or: [ { qty: { $lt: 30 } }, { item: /^p/ } ]\n} )\n# SELECT * FROM inventory WHERE status = \"A\" AND ( qty < 30 OR item LIKE \"p%\")\n```\n\n如果查询使用的是嵌套的文档的属性，那就使用 `\"field.nestedField\"`\n\n## UPDATE 操作\n\nUPDATE 的语法如下：\n\n```\ndb.collection.update(\n   <query>,\n   <update>,\n   {\n     upsert: <boolean>,\n     multi: <boolean>,\n     writeConcern: <document>,\n     collation: <document>\n   }\n)\n```\n\n更新操作分为整体更新和局部更新，整体更新是用一个新的文档完全替代匹配的文档。\n\n**危险**： 使用替换更新时应当注意，如果查询条件匹配到多个文档，所有的文档都会被替换\n\n下面主要说的是局部更新。\n\n![updateStatement](https://docs.mongodb.com/manual/_images/crud-annotated-mongodb-updateMany.bakedsvg.svg)\n\n### 修改器\n\n现在有个文档products\n``` json\n{\n  _id: 100,\n  sku: \"abc123\",\n  quantity: 250,\n  instock: true,\n  reorder: false,\n  details: { model: \"14Q2\", make: \"xyz\" },\n  tags: [ \"apparel\", \"clothing\" ],\n  ratings: [ { by: \"ijk\", rating: 4 } ]\n}\n```\n\n`$set`修改器\n\n`$set`修改器用于指定一个字段的值，字段不存在时，则会创建字段。 修改错误或不在需要的字段，可以使用`$unset`方法将这个键删除\n\n现在要把文档中 `details.make`字段的值更新为\"zzz\"\n\n``` shell\ndb.products.update(\n    { _id: 100},\n    { $set: {\"details.make\": \"zzz\"},\n      $currentDate: {lastModified: true}\n    }\n)\n```\n\n其中，$set操作符将details.make字段的值更新为zzz， $currentDate 操作符用来更新lastModified字段的值为当前时间，如果该字段不存在，$currentDate 操作符将会创建这个字段\n\n`$inc`修改器\n\n`$inc`修改器用于字段值的增加和减少\n\nproducts文档如下：\n``` JSON\n{\n  _id: 1,\n  sku: \"abc123\",\n  quantity: 10,\n  metrics: {\n    orders: 2,\n    ratings: 3.5\n  }\n}\n```\n\n将quantity字段的值减2，并且将orders的值加1\n\n``` shell\ndb.products.update(\n    { sku: \"abc123\"},\n    { $inc: {quiantity: -2, \"metrics.orders\": 1 }}\n)\n```\n\n## DELETE 操作\n\n**危险**：remove中如果不带参数将删除所有数据\n\n![deleteStetement](https://docs.mongodb.com/manual/_images/crud-annotated-mongodb-deleteMany.bakedsvg.svg)\n\n下面附的是 [MongoDB 的速查手册](http://7xkfga.com1.z0.glb.clouddn.com/MongoDBReferenceCards.pdf)\n","slug":"MongoDB-CRUD-øÏÀŸ∏¥œ∞","published":1,"updated":"2017-06-28T06:15:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3o7002hzd68z5r10x0j","content":"<p>提到数据库的基本操作，无论关系型还是非关系型，首先想到的肯定是数据的增删改查 (Create, Read, Update, Delete)，下面记录一下MongoDB里面的CRUD操作。</p>\n<a id=\"more\"></a>\n<h2 id=\"INSERT-操作\"><a href=\"#INSERT-操作\" class=\"headerlink\" title=\"INSERT 操作\"></a>INSERT 操作</h2><p><img src=\"https://docs.mongodb.com/manual/_images/crud-annotated-mongodb-insertOne.bakedsvg.svg\" alt=\"insertStatement\"></p>\n<p>MongoDB里面数据叫做文档Document，其实就是JSON对象，常见的插入操作分为单条插入 <code>insertOne()</code> 和多条插入 <code>insertMany()</code> ，单条插入传入一个JSON对象，多条插入传入一个多个JSON对象的数组</p>\n<h2 id=\"FIND-操作\"><a href=\"#FIND-操作\" class=\"headerlink\" title=\"FIND 操作\"></a>FIND 操作</h2><p><img src=\"https://docs.mongodb.com/manual/_images/crud-annotated-mongodb-find.bakedsvg.svg\" alt=\"findStatement\"></p>\n<p>Query操作是这4中操作最重要的部分， 查询的语法如下：</p>\n<ul>\n<li>query criteria，可选。表示集合的查询条件。可指定条件查询参数，或一个空对象({})</li>\n<li>projection，可选。表示查询时所要返回的字段，省略此参数将返回全部字段。其格式如下：<br>{ field1: <boolean>, field2: <boolean> … }</boolean></boolean></li>\n</ul>\n<p>返回查询文档的游标，即：执行find()方法时其返回的文档，实际是对文档引用的一个游标。当指定projection参数时，返回值仅包含指定的字段和_id字段，也可以指定不返回_id字段</p>\n<h3 id=\"查询参数\"><a href=\"#查询参数\" class=\"headerlink\" title=\"查询参数\"></a>查询参数</h3><p>下面这些在SQL的WHERE子句中的操作符，在MongoDB中都有实现。</p>\n<p>SQL :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;, &gt;=, &lt;, &lt;=, !=</span><br><span class=\"line\">And，OR，In，NotIn</span><br></pre></td></tr></table></figure>\n<p>MongoDB:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;$gt&quot;, &quot;$gte&quot;, &quot;$lt&quot;, &quot;$lte&quot;, &quot;$ne&quot;</span><br><span class=\"line\">&quot;$and&quot;, &quot;$or&quot;, &quot;$in&quot;，&quot;$nin&quot;</span><br></pre></td></tr></table></figure>\n<p>举几个查询的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.inventory.find( &#123; status: &#123; $in: [ \"A\", \"D\" ] &#125; &#125; )</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> SELECT * FROM inventory WHERE status <span class=\"keyword\">in</span> (<span class=\"string\">\"A\"</span>, <span class=\"string\">\"D\"</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.inventory.find( $and: [ &#123; status: \"A\", qty: &#123; $lt: 30 &#125; &#125; ] )</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> SELECT * FROM inventory WHERE status = <span class=\"string\">\"A\"</span> AND qty &lt; 30</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.inventory.find( &#123; $or: [ &#123; status: \"A\" &#125;, &#123; qty: &#123; $lt: 30 &#125; &#125; ] &#125; )</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> SELECT * FROM inventory WHERE status = <span class=\"string\">\"A\"</span> OR qty &lt; 30</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.inventory.find( &#123;</span><br><span class=\"line\">     status: \"A\",</span><br><span class=\"line\">     $or: [ &#123; qty: &#123; $lt: 30 &#125; &#125;, &#123; item: /^p/ &#125; ]</span><br><span class=\"line\">&#125; )</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> SELECT * FROM inventory WHERE status = <span class=\"string\">\"A\"</span> AND ( qty &lt; 30 OR item LIKE <span class=\"string\">\"p%\"</span>)</span></span><br></pre></td></tr></table></figure>\n<p>如果查询使用的是嵌套的文档的属性，那就使用 <code>&quot;field.nestedField&quot;</code></p>\n<h2 id=\"UPDATE-操作\"><a href=\"#UPDATE-操作\" class=\"headerlink\" title=\"UPDATE 操作\"></a>UPDATE 操作</h2><p>UPDATE 的语法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.update(</span><br><span class=\"line\">   &lt;query&gt;,</span><br><span class=\"line\">   &lt;update&gt;,</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     upsert: &lt;boolean&gt;,</span><br><span class=\"line\">     multi: &lt;boolean&gt;,</span><br><span class=\"line\">     writeConcern: &lt;document&gt;,</span><br><span class=\"line\">     collation: &lt;document&gt;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>更新操作分为整体更新和局部更新，整体更新是用一个新的文档完全替代匹配的文档。</p>\n<p><strong>危险</strong>： 使用替换更新时应当注意，如果查询条件匹配到多个文档，所有的文档都会被替换</p>\n<p>下面主要说的是局部更新。</p>\n<p><img src=\"https://docs.mongodb.com/manual/_images/crud-annotated-mongodb-updateMany.bakedsvg.svg\" alt=\"updateStatement\"></p>\n<h3 id=\"修改器\"><a href=\"#修改器\" class=\"headerlink\" title=\"修改器\"></a>修改器</h3><p>现在有个文档products<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  _id: 100,</span><br><span class=\"line\">  sku: \"abc123\",</span><br><span class=\"line\">  quantity: 250,</span><br><span class=\"line\">  instock: true,</span><br><span class=\"line\">  reorder: false,</span><br><span class=\"line\">  details: &#123; model: \"14Q2\", make: \"xyz\" &#125;,</span><br><span class=\"line\">  tags: [ \"apparel\", \"clothing\" ],</span><br><span class=\"line\">  ratings: [ &#123; by: \"ijk\", rating: 4 &#125; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>$set</code>修改器</p>\n<p><code>$set</code>修改器用于指定一个字段的值，字段不存在时，则会创建字段。 修改错误或不在需要的字段，可以使用<code>$unset</code>方法将这个键删除</p>\n<p>现在要把文档中 <code>details.make</code>字段的值更新为”zzz”</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.products.update(</span><br><span class=\"line\">    &#123; _id: 100&#125;,</span><br><span class=\"line\">    &#123; $set: &#123;\"details.make\": \"zzz\"&#125;,</span><br><span class=\"line\">      $currentDate: &#123;lastModified: true&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>其中，$set操作符将details.make字段的值更新为zzz， $currentDate 操作符用来更新lastModified字段的值为当前时间，如果该字段不存在，$currentDate 操作符将会创建这个字段</p>\n<p><code>$inc</code>修改器</p>\n<p><code>$inc</code>修改器用于字段值的增加和减少</p>\n<p>products文档如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  _id: 1,</span><br><span class=\"line\">  sku: \"abc123\",</span><br><span class=\"line\">  quantity: 10,</span><br><span class=\"line\">  metrics: &#123;</span><br><span class=\"line\">    orders: 2,</span><br><span class=\"line\">    ratings: 3.5</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>将quantity字段的值减2，并且将orders的值加1</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.products.update(</span><br><span class=\"line\">    &#123; sku: \"abc123\"&#125;,</span><br><span class=\"line\">    &#123; $inc: &#123;quiantity: -2, \"metrics.orders\": 1 &#125;&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"DELETE-操作\"><a href=\"#DELETE-操作\" class=\"headerlink\" title=\"DELETE 操作\"></a>DELETE 操作</h2><p><strong>危险</strong>：remove中如果不带参数将删除所有数据</p>\n<p><img src=\"https://docs.mongodb.com/manual/_images/crud-annotated-mongodb-deleteMany.bakedsvg.svg\" alt=\"deleteStetement\"></p>\n<p>下面附的是 <a href=\"http://7xkfga.com1.z0.glb.clouddn.com/MongoDBReferenceCards.pdf\" target=\"_blank\" rel=\"noopener\">MongoDB 的速查手册</a></p>\n","site":{"data":{}},"excerpt":"<p>提到数据库的基本操作，无论关系型还是非关系型，首先想到的肯定是数据的增删改查 (Create, Read, Update, Delete)，下面记录一下MongoDB里面的CRUD操作。</p>","more":"<h2 id=\"INSERT-操作\"><a href=\"#INSERT-操作\" class=\"headerlink\" title=\"INSERT 操作\"></a>INSERT 操作</h2><p><img src=\"https://docs.mongodb.com/manual/_images/crud-annotated-mongodb-insertOne.bakedsvg.svg\" alt=\"insertStatement\"></p>\n<p>MongoDB里面数据叫做文档Document，其实就是JSON对象，常见的插入操作分为单条插入 <code>insertOne()</code> 和多条插入 <code>insertMany()</code> ，单条插入传入一个JSON对象，多条插入传入一个多个JSON对象的数组</p>\n<h2 id=\"FIND-操作\"><a href=\"#FIND-操作\" class=\"headerlink\" title=\"FIND 操作\"></a>FIND 操作</h2><p><img src=\"https://docs.mongodb.com/manual/_images/crud-annotated-mongodb-find.bakedsvg.svg\" alt=\"findStatement\"></p>\n<p>Query操作是这4中操作最重要的部分， 查询的语法如下：</p>\n<ul>\n<li>query criteria，可选。表示集合的查询条件。可指定条件查询参数，或一个空对象({})</li>\n<li>projection，可选。表示查询时所要返回的字段，省略此参数将返回全部字段。其格式如下：<br>{ field1: <boolean>, field2: <boolean> … }</boolean></boolean></li>\n</ul>\n<p>返回查询文档的游标，即：执行find()方法时其返回的文档，实际是对文档引用的一个游标。当指定projection参数时，返回值仅包含指定的字段和_id字段，也可以指定不返回_id字段</p>\n<h3 id=\"查询参数\"><a href=\"#查询参数\" class=\"headerlink\" title=\"查询参数\"></a>查询参数</h3><p>下面这些在SQL的WHERE子句中的操作符，在MongoDB中都有实现。</p>\n<p>SQL :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;, &gt;=, &lt;, &lt;=, !=</span><br><span class=\"line\">And，OR，In，NotIn</span><br></pre></td></tr></table></figure>\n<p>MongoDB:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;$gt&quot;, &quot;$gte&quot;, &quot;$lt&quot;, &quot;$lte&quot;, &quot;$ne&quot;</span><br><span class=\"line\">&quot;$and&quot;, &quot;$or&quot;, &quot;$in&quot;，&quot;$nin&quot;</span><br></pre></td></tr></table></figure>\n<p>举几个查询的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.inventory.find( &#123; status: &#123; $in: [ \"A\", \"D\" ] &#125; &#125; )</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> SELECT * FROM inventory WHERE status <span class=\"keyword\">in</span> (<span class=\"string\">\"A\"</span>, <span class=\"string\">\"D\"</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.inventory.find( $and: [ &#123; status: \"A\", qty: &#123; $lt: 30 &#125; &#125; ] )</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> SELECT * FROM inventory WHERE status = <span class=\"string\">\"A\"</span> AND qty &lt; 30</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.inventory.find( &#123; $or: [ &#123; status: \"A\" &#125;, &#123; qty: &#123; $lt: 30 &#125; &#125; ] &#125; )</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> SELECT * FROM inventory WHERE status = <span class=\"string\">\"A\"</span> OR qty &lt; 30</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.inventory.find( &#123;</span><br><span class=\"line\">     status: \"A\",</span><br><span class=\"line\">     $or: [ &#123; qty: &#123; $lt: 30 &#125; &#125;, &#123; item: /^p/ &#125; ]</span><br><span class=\"line\">&#125; )</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> SELECT * FROM inventory WHERE status = <span class=\"string\">\"A\"</span> AND ( qty &lt; 30 OR item LIKE <span class=\"string\">\"p%\"</span>)</span></span><br></pre></td></tr></table></figure>\n<p>如果查询使用的是嵌套的文档的属性，那就使用 <code>&quot;field.nestedField&quot;</code></p>\n<h2 id=\"UPDATE-操作\"><a href=\"#UPDATE-操作\" class=\"headerlink\" title=\"UPDATE 操作\"></a>UPDATE 操作</h2><p>UPDATE 的语法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.update(</span><br><span class=\"line\">   &lt;query&gt;,</span><br><span class=\"line\">   &lt;update&gt;,</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     upsert: &lt;boolean&gt;,</span><br><span class=\"line\">     multi: &lt;boolean&gt;,</span><br><span class=\"line\">     writeConcern: &lt;document&gt;,</span><br><span class=\"line\">     collation: &lt;document&gt;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>更新操作分为整体更新和局部更新，整体更新是用一个新的文档完全替代匹配的文档。</p>\n<p><strong>危险</strong>： 使用替换更新时应当注意，如果查询条件匹配到多个文档，所有的文档都会被替换</p>\n<p>下面主要说的是局部更新。</p>\n<p><img src=\"https://docs.mongodb.com/manual/_images/crud-annotated-mongodb-updateMany.bakedsvg.svg\" alt=\"updateStatement\"></p>\n<h3 id=\"修改器\"><a href=\"#修改器\" class=\"headerlink\" title=\"修改器\"></a>修改器</h3><p>现在有个文档products<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  _id: 100,</span><br><span class=\"line\">  sku: \"abc123\",</span><br><span class=\"line\">  quantity: 250,</span><br><span class=\"line\">  instock: true,</span><br><span class=\"line\">  reorder: false,</span><br><span class=\"line\">  details: &#123; model: \"14Q2\", make: \"xyz\" &#125;,</span><br><span class=\"line\">  tags: [ \"apparel\", \"clothing\" ],</span><br><span class=\"line\">  ratings: [ &#123; by: \"ijk\", rating: 4 &#125; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>$set</code>修改器</p>\n<p><code>$set</code>修改器用于指定一个字段的值，字段不存在时，则会创建字段。 修改错误或不在需要的字段，可以使用<code>$unset</code>方法将这个键删除</p>\n<p>现在要把文档中 <code>details.make</code>字段的值更新为”zzz”</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.products.update(</span><br><span class=\"line\">    &#123; _id: 100&#125;,</span><br><span class=\"line\">    &#123; $set: &#123;\"details.make\": \"zzz\"&#125;,</span><br><span class=\"line\">      $currentDate: &#123;lastModified: true&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>其中，$set操作符将details.make字段的值更新为zzz， $currentDate 操作符用来更新lastModified字段的值为当前时间，如果该字段不存在，$currentDate 操作符将会创建这个字段</p>\n<p><code>$inc</code>修改器</p>\n<p><code>$inc</code>修改器用于字段值的增加和减少</p>\n<p>products文档如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  _id: 1,</span><br><span class=\"line\">  sku: \"abc123\",</span><br><span class=\"line\">  quantity: 10,</span><br><span class=\"line\">  metrics: &#123;</span><br><span class=\"line\">    orders: 2,</span><br><span class=\"line\">    ratings: 3.5</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>将quantity字段的值减2，并且将orders的值加1</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.products.update(</span><br><span class=\"line\">    &#123; sku: \"abc123\"&#125;,</span><br><span class=\"line\">    &#123; $inc: &#123;quiantity: -2, \"metrics.orders\": 1 &#125;&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"DELETE-操作\"><a href=\"#DELETE-操作\" class=\"headerlink\" title=\"DELETE 操作\"></a>DELETE 操作</h2><p><strong>危险</strong>：remove中如果不带参数将删除所有数据</p>\n<p><img src=\"https://docs.mongodb.com/manual/_images/crud-annotated-mongodb-deleteMany.bakedsvg.svg\" alt=\"deleteStetement\"></p>\n<p>下面附的是 <a href=\"http://7xkfga.com1.z0.glb.clouddn.com/MongoDBReferenceCards.pdf\" target=\"_blank\" rel=\"noopener\">MongoDB 的速查手册</a></p>"},{"title":"MongoDB 基础知识","date":"2017-06-27T05:20:00.000Z","_content":"\n\nMongoDB 是一个基于 分布式文件存储 的数据库。由 C++ 语言编写。\n\n## MongoDB 相关概念\n\nmongodb中基本的概念是文档、集合、数据库，和传统关系型数据库相关概念的对应关系如下表：\n\n|  RDBMS       |  MongoDB    |  描述      |\n|------------- | ----------- |------------|\n| database     |\tdatabase   |\t数据库         |\n| table        |\tcollection |\t数据库表/集合  |\n| row          |\tdocument   |\t数据记录行/文档|\n| column       |\tfield\t     | 数据字段/域    |\n| index        |\tindex\t     | 索引          |\n| table\tjoins\t|              |MongoDB可以使用DbRef或者$lookup实现|\n| primary key |\tprimary key |\t主键,MongoDB自动将_id字段设置为主键|\n\n<!-- more -->\n\n### 数据存储————文档\n\n文档是一个键值(key-value)对(即BSON)类似JSON对象。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。\n\n### MongoDB的主键 `_id`\n\nMongoDB默认会为每个document生成一个 `_id` 属性，作为默认主键，且默认值为ObjectId,可以更改 `_id` 的值(可为空字符串)，但每个document必须拥有 `_id` 属性。这个字段是为了保证文档的唯一性。\n\n### MongoDB系统保留数据库\n\n- admin\n- local\n- config\n\n\n### 时间数据类型\n\nMongoDB中的时间类型默认是MongoDate，MongoDate默认是按照UTC（世界标准时间）来存储。例如下面的两种使用方式:\n\n``` shell\ndb.col.insert({\"date\": new Date(), num: 1})\ndb.col.insert({\"date\": new Date().toLocaleString(), num: 2})\n\ndb.col.find()\n{\n    \"_id\" : ObjectId(\"539944b14a696442d95eaf08\"),\n    \"date\" : ISODate(\"2014-06-12T06:12:01.500Z\"),\n    \"num\" : 1\n}\n{\n    \"_id\" : ObjectId(\"539944b14a696442d95eaf09\"),\n    \"date\" : \"Thu Jun 12 14:12:01 2014\",\n    \"num\" : 2\n}\n```\n\nnote: 第一条数据存储的是一个Date类型，第二条存储存储的是String类型。两条数据的时间相差大约8个小时（忽略操作时间），第一条数据MongoDB是按照UTC时间来进行存储。\n\n### MongoDB中的一对多、多对多关系\n\nMongoDB的基本单元是Document（文档），通过文档的嵌套（关联）来组织、描述数据之间的关系。\n例如我们要表示一对多关系，在关系型数据库中我们通常会设计两张表A（一）、B（多），然后在B表中存入A的主键，以此做关联关系。然后查询的时候需要从两张表分别取数据。MongoDB中的Document是通过嵌套来描述数据之间的关系，例如：\n\n``` JSON\n{\n    _id:ObjectId(\"akdjfiou23o4iu23oi5jktlksdjfa\")\n    teacherName: \"foo\",\n    students: [\n        {\n            stuName: \"foo\",\n            totalScore：100，\n            otherInfo :[]\n            ...\n        },{\n            stuName: \"bar\",\n            totalScore：90，\n            otherInfo :[]\n            ...\n        }\n    ]\n}\n```\n一次查询便可得到所有老师和同学的对应关系。\n\n\n### 内嵌文档查询\n\n在MongoDB中文档的查询是与顺序有关的。例如：\n\n``` json\n{\n    \"address\" : {\n        \"province\" : \"河北省\",\n        \"city\" : \"石家庄\"\n    },\n    \"number\" : 2640613\n}\n```\n\n要搜索province为“河北省”、city为“石家庄”可以这样:\n\n``` shell\ndb.col.find(\n    {\n        \"address\":{\n            \"city\" : \"石家庄\",\n            \"province\" : \"河北省\"\n        }\n    }\n)\n```\n\n然而这样什么都不会查询到。事实上，这样的查询MongoDB会当做全量匹配查询，即document中所有属性与查询条件全部一致时才会被返回。当然这里的“全部一致”也包括属性的顺序。那么，上面的查询如果想搜索到之前的应该先补充number属性，然后更改address属性下的顺序。\n\n在实际应用中我们当然不会这么来查询文档，尤其是需要查询内嵌文档的时候。MongoDB中提供\".\"（点）表示法来查询内嵌文档。因此，上面的查询可以这样写：\n\n``` shell\ndb.col.find(\n    {\n        \"address.privince\":\"河北省\"\n    }\n)\n```\n","source":"_posts/MongoDB-ª˘¥°÷™ ∂.md","raw":"---\ntitle: MongoDB 基础知识\ntags:\n  - MongoDB\ndate: 2017-06-27 13:20:00\n---\n\n\nMongoDB 是一个基于 分布式文件存储 的数据库。由 C++ 语言编写。\n\n## MongoDB 相关概念\n\nmongodb中基本的概念是文档、集合、数据库，和传统关系型数据库相关概念的对应关系如下表：\n\n|  RDBMS       |  MongoDB    |  描述      |\n|------------- | ----------- |------------|\n| database     |\tdatabase   |\t数据库         |\n| table        |\tcollection |\t数据库表/集合  |\n| row          |\tdocument   |\t数据记录行/文档|\n| column       |\tfield\t     | 数据字段/域    |\n| index        |\tindex\t     | 索引          |\n| table\tjoins\t|              |MongoDB可以使用DbRef或者$lookup实现|\n| primary key |\tprimary key |\t主键,MongoDB自动将_id字段设置为主键|\n\n<!-- more -->\n\n### 数据存储————文档\n\n文档是一个键值(key-value)对(即BSON)类似JSON对象。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。\n\n### MongoDB的主键 `_id`\n\nMongoDB默认会为每个document生成一个 `_id` 属性，作为默认主键，且默认值为ObjectId,可以更改 `_id` 的值(可为空字符串)，但每个document必须拥有 `_id` 属性。这个字段是为了保证文档的唯一性。\n\n### MongoDB系统保留数据库\n\n- admin\n- local\n- config\n\n\n### 时间数据类型\n\nMongoDB中的时间类型默认是MongoDate，MongoDate默认是按照UTC（世界标准时间）来存储。例如下面的两种使用方式:\n\n``` shell\ndb.col.insert({\"date\": new Date(), num: 1})\ndb.col.insert({\"date\": new Date().toLocaleString(), num: 2})\n\ndb.col.find()\n{\n    \"_id\" : ObjectId(\"539944b14a696442d95eaf08\"),\n    \"date\" : ISODate(\"2014-06-12T06:12:01.500Z\"),\n    \"num\" : 1\n}\n{\n    \"_id\" : ObjectId(\"539944b14a696442d95eaf09\"),\n    \"date\" : \"Thu Jun 12 14:12:01 2014\",\n    \"num\" : 2\n}\n```\n\nnote: 第一条数据存储的是一个Date类型，第二条存储存储的是String类型。两条数据的时间相差大约8个小时（忽略操作时间），第一条数据MongoDB是按照UTC时间来进行存储。\n\n### MongoDB中的一对多、多对多关系\n\nMongoDB的基本单元是Document（文档），通过文档的嵌套（关联）来组织、描述数据之间的关系。\n例如我们要表示一对多关系，在关系型数据库中我们通常会设计两张表A（一）、B（多），然后在B表中存入A的主键，以此做关联关系。然后查询的时候需要从两张表分别取数据。MongoDB中的Document是通过嵌套来描述数据之间的关系，例如：\n\n``` JSON\n{\n    _id:ObjectId(\"akdjfiou23o4iu23oi5jktlksdjfa\")\n    teacherName: \"foo\",\n    students: [\n        {\n            stuName: \"foo\",\n            totalScore：100，\n            otherInfo :[]\n            ...\n        },{\n            stuName: \"bar\",\n            totalScore：90，\n            otherInfo :[]\n            ...\n        }\n    ]\n}\n```\n一次查询便可得到所有老师和同学的对应关系。\n\n\n### 内嵌文档查询\n\n在MongoDB中文档的查询是与顺序有关的。例如：\n\n``` json\n{\n    \"address\" : {\n        \"province\" : \"河北省\",\n        \"city\" : \"石家庄\"\n    },\n    \"number\" : 2640613\n}\n```\n\n要搜索province为“河北省”、city为“石家庄”可以这样:\n\n``` shell\ndb.col.find(\n    {\n        \"address\":{\n            \"city\" : \"石家庄\",\n            \"province\" : \"河北省\"\n        }\n    }\n)\n```\n\n然而这样什么都不会查询到。事实上，这样的查询MongoDB会当做全量匹配查询，即document中所有属性与查询条件全部一致时才会被返回。当然这里的“全部一致”也包括属性的顺序。那么，上面的查询如果想搜索到之前的应该先补充number属性，然后更改address属性下的顺序。\n\n在实际应用中我们当然不会这么来查询文档，尤其是需要查询内嵌文档的时候。MongoDB中提供\".\"（点）表示法来查询内嵌文档。因此，上面的查询可以这样写：\n\n``` shell\ndb.col.find(\n    {\n        \"address.privince\":\"河北省\"\n    }\n)\n```\n","slug":"MongoDB-ª˘¥°÷™ ∂","published":1,"updated":"2017-06-29T07:25:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3o9002kzd68866nsmse","content":"<p>MongoDB 是一个基于 分布式文件存储 的数据库。由 C++ 语言编写。</p>\n<h2 id=\"MongoDB-相关概念\"><a href=\"#MongoDB-相关概念\" class=\"headerlink\" title=\"MongoDB 相关概念\"></a>MongoDB 相关概念</h2><p>mongodb中基本的概念是文档、集合、数据库，和传统关系型数据库相关概念的对应关系如下表：</p>\n<table>\n<thead>\n<tr>\n<th>RDBMS</th>\n<th>MongoDB</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>database</td>\n<td>database</td>\n<td>数据库</td>\n</tr>\n<tr>\n<td>table</td>\n<td>collection</td>\n<td>数据库表/集合</td>\n</tr>\n<tr>\n<td>row</td>\n<td>document</td>\n<td>数据记录行/文档</td>\n</tr>\n<tr>\n<td>column</td>\n<td>field</td>\n<td>数据字段/域</td>\n</tr>\n<tr>\n<td>index</td>\n<td>index</td>\n<td>索引</td>\n</tr>\n<tr>\n<td>table    joins</td>\n<td></td>\n<td>MongoDB可以使用DbRef或者$lookup实现</td>\n</tr>\n<tr>\n<td>primary key</td>\n<td>primary key</td>\n<td>主键,MongoDB自动将_id字段设置为主键</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<h3 id=\"数据存储————文档\"><a href=\"#数据存储————文档\" class=\"headerlink\" title=\"数据存储————文档\"></a>数据存储————文档</h3><p>文档是一个键值(key-value)对(即BSON)类似JSON对象。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。</p>\n<h3 id=\"MongoDB的主键-id\"><a href=\"#MongoDB的主键-id\" class=\"headerlink\" title=\"MongoDB的主键 _id\"></a>MongoDB的主键 <code>_id</code></h3><p>MongoDB默认会为每个document生成一个 <code>_id</code> 属性，作为默认主键，且默认值为ObjectId,可以更改 <code>_id</code> 的值(可为空字符串)，但每个document必须拥有 <code>_id</code> 属性。这个字段是为了保证文档的唯一性。</p>\n<h3 id=\"MongoDB系统保留数据库\"><a href=\"#MongoDB系统保留数据库\" class=\"headerlink\" title=\"MongoDB系统保留数据库\"></a>MongoDB系统保留数据库</h3><ul>\n<li>admin</li>\n<li>local</li>\n<li>config</li>\n</ul>\n<h3 id=\"时间数据类型\"><a href=\"#时间数据类型\" class=\"headerlink\" title=\"时间数据类型\"></a>时间数据类型</h3><p>MongoDB中的时间类型默认是MongoDate，MongoDate默认是按照UTC（世界标准时间）来存储。例如下面的两种使用方式:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.insert(&#123;\"date\": new Date(), num: 1&#125;)</span><br><span class=\"line\">db.col.insert(&#123;\"date\": new Date().toLocaleString(), num: 2&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">db.col.find()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"_id\" : ObjectId(\"539944b14a696442d95eaf08\"),</span><br><span class=\"line\">    \"date\" : ISODate(\"2014-06-12T06:12:01.500Z\"),</span><br><span class=\"line\">    \"num\" : 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"_id\" : ObjectId(\"539944b14a696442d95eaf09\"),</span><br><span class=\"line\">    \"date\" : \"Thu Jun 12 14:12:01 2014\",</span><br><span class=\"line\">    \"num\" : 2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>note: 第一条数据存储的是一个Date类型，第二条存储存储的是String类型。两条数据的时间相差大约8个小时（忽略操作时间），第一条数据MongoDB是按照UTC时间来进行存储。</p>\n<h3 id=\"MongoDB中的一对多、多对多关系\"><a href=\"#MongoDB中的一对多、多对多关系\" class=\"headerlink\" title=\"MongoDB中的一对多、多对多关系\"></a>MongoDB中的一对多、多对多关系</h3><p>MongoDB的基本单元是Document（文档），通过文档的嵌套（关联）来组织、描述数据之间的关系。<br>例如我们要表示一对多关系，在关系型数据库中我们通常会设计两张表A（一）、B（多），然后在B表中存入A的主键，以此做关联关系。然后查询的时候需要从两张表分别取数据。MongoDB中的Document是通过嵌套来描述数据之间的关系，例如：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    _id:ObjectId(\"akdjfiou23o4iu23oi5jktlksdjfa\")</span><br><span class=\"line\">    teacherName: \"foo\",</span><br><span class=\"line\">    students: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            stuName: \"foo\",</span><br><span class=\"line\">            totalScore：100，</span><br><span class=\"line\">            otherInfo :[]</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;,&#123;</span><br><span class=\"line\">            stuName: \"bar\",</span><br><span class=\"line\">            totalScore：90，</span><br><span class=\"line\">            otherInfo :[]</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一次查询便可得到所有老师和同学的对应关系。</p>\n<h3 id=\"内嵌文档查询\"><a href=\"#内嵌文档查询\" class=\"headerlink\" title=\"内嵌文档查询\"></a>内嵌文档查询</h3><p>在MongoDB中文档的查询是与顺序有关的。例如：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"address\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"province\"</span> : <span class=\"string\">\"河北省\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"city\"</span> : <span class=\"string\">\"石家庄\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"number\"</span> : <span class=\"number\">2640613</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要搜索province为“河北省”、city为“石家庄”可以这样:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find(</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        \"address\":&#123;</span><br><span class=\"line\">            \"city\" : \"石家庄\",</span><br><span class=\"line\">            \"province\" : \"河北省\"</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>然而这样什么都不会查询到。事实上，这样的查询MongoDB会当做全量匹配查询，即document中所有属性与查询条件全部一致时才会被返回。当然这里的“全部一致”也包括属性的顺序。那么，上面的查询如果想搜索到之前的应该先补充number属性，然后更改address属性下的顺序。</p>\n<p>在实际应用中我们当然不会这么来查询文档，尤其是需要查询内嵌文档的时候。MongoDB中提供”.”（点）表示法来查询内嵌文档。因此，上面的查询可以这样写：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find(</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        \"address.privince\":\"河北省\"</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>MongoDB 是一个基于 分布式文件存储 的数据库。由 C++ 语言编写。</p>\n<h2 id=\"MongoDB-相关概念\"><a href=\"#MongoDB-相关概念\" class=\"headerlink\" title=\"MongoDB 相关概念\"></a>MongoDB 相关概念</h2><p>mongodb中基本的概念是文档、集合、数据库，和传统关系型数据库相关概念的对应关系如下表：</p>\n<table>\n<thead>\n<tr>\n<th>RDBMS</th>\n<th>MongoDB</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>database</td>\n<td>database</td>\n<td>数据库</td>\n</tr>\n<tr>\n<td>table</td>\n<td>collection</td>\n<td>数据库表/集合</td>\n</tr>\n<tr>\n<td>row</td>\n<td>document</td>\n<td>数据记录行/文档</td>\n</tr>\n<tr>\n<td>column</td>\n<td>field</td>\n<td>数据字段/域</td>\n</tr>\n<tr>\n<td>index</td>\n<td>index</td>\n<td>索引</td>\n</tr>\n<tr>\n<td>table    joins</td>\n<td></td>\n<td>MongoDB可以使用DbRef或者$lookup实现</td>\n</tr>\n<tr>\n<td>primary key</td>\n<td>primary key</td>\n<td>主键,MongoDB自动将_id字段设置为主键</td>\n</tr>\n</tbody>\n</table>","more":"<h3 id=\"数据存储————文档\"><a href=\"#数据存储————文档\" class=\"headerlink\" title=\"数据存储————文档\"></a>数据存储————文档</h3><p>文档是一个键值(key-value)对(即BSON)类似JSON对象。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。</p>\n<h3 id=\"MongoDB的主键-id\"><a href=\"#MongoDB的主键-id\" class=\"headerlink\" title=\"MongoDB的主键 _id\"></a>MongoDB的主键 <code>_id</code></h3><p>MongoDB默认会为每个document生成一个 <code>_id</code> 属性，作为默认主键，且默认值为ObjectId,可以更改 <code>_id</code> 的值(可为空字符串)，但每个document必须拥有 <code>_id</code> 属性。这个字段是为了保证文档的唯一性。</p>\n<h3 id=\"MongoDB系统保留数据库\"><a href=\"#MongoDB系统保留数据库\" class=\"headerlink\" title=\"MongoDB系统保留数据库\"></a>MongoDB系统保留数据库</h3><ul>\n<li>admin</li>\n<li>local</li>\n<li>config</li>\n</ul>\n<h3 id=\"时间数据类型\"><a href=\"#时间数据类型\" class=\"headerlink\" title=\"时间数据类型\"></a>时间数据类型</h3><p>MongoDB中的时间类型默认是MongoDate，MongoDate默认是按照UTC（世界标准时间）来存储。例如下面的两种使用方式:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.insert(&#123;\"date\": new Date(), num: 1&#125;)</span><br><span class=\"line\">db.col.insert(&#123;\"date\": new Date().toLocaleString(), num: 2&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">db.col.find()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"_id\" : ObjectId(\"539944b14a696442d95eaf08\"),</span><br><span class=\"line\">    \"date\" : ISODate(\"2014-06-12T06:12:01.500Z\"),</span><br><span class=\"line\">    \"num\" : 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"_id\" : ObjectId(\"539944b14a696442d95eaf09\"),</span><br><span class=\"line\">    \"date\" : \"Thu Jun 12 14:12:01 2014\",</span><br><span class=\"line\">    \"num\" : 2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>note: 第一条数据存储的是一个Date类型，第二条存储存储的是String类型。两条数据的时间相差大约8个小时（忽略操作时间），第一条数据MongoDB是按照UTC时间来进行存储。</p>\n<h3 id=\"MongoDB中的一对多、多对多关系\"><a href=\"#MongoDB中的一对多、多对多关系\" class=\"headerlink\" title=\"MongoDB中的一对多、多对多关系\"></a>MongoDB中的一对多、多对多关系</h3><p>MongoDB的基本单元是Document（文档），通过文档的嵌套（关联）来组织、描述数据之间的关系。<br>例如我们要表示一对多关系，在关系型数据库中我们通常会设计两张表A（一）、B（多），然后在B表中存入A的主键，以此做关联关系。然后查询的时候需要从两张表分别取数据。MongoDB中的Document是通过嵌套来描述数据之间的关系，例如：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    _id:ObjectId(\"akdjfiou23o4iu23oi5jktlksdjfa\")</span><br><span class=\"line\">    teacherName: \"foo\",</span><br><span class=\"line\">    students: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            stuName: \"foo\",</span><br><span class=\"line\">            totalScore：100，</span><br><span class=\"line\">            otherInfo :[]</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;,&#123;</span><br><span class=\"line\">            stuName: \"bar\",</span><br><span class=\"line\">            totalScore：90，</span><br><span class=\"line\">            otherInfo :[]</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一次查询便可得到所有老师和同学的对应关系。</p>\n<h3 id=\"内嵌文档查询\"><a href=\"#内嵌文档查询\" class=\"headerlink\" title=\"内嵌文档查询\"></a>内嵌文档查询</h3><p>在MongoDB中文档的查询是与顺序有关的。例如：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"address\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"province\"</span> : <span class=\"string\">\"河北省\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"city\"</span> : <span class=\"string\">\"石家庄\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"number\"</span> : <span class=\"number\">2640613</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要搜索province为“河北省”、city为“石家庄”可以这样:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find(</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        \"address\":&#123;</span><br><span class=\"line\">            \"city\" : \"石家庄\",</span><br><span class=\"line\">            \"province\" : \"河北省\"</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>然而这样什么都不会查询到。事实上，这样的查询MongoDB会当做全量匹配查询，即document中所有属性与查询条件全部一致时才会被返回。当然这里的“全部一致”也包括属性的顺序。那么，上面的查询如果想搜索到之前的应该先补充number属性，然后更改address属性下的顺序。</p>\n<p>在实际应用中我们当然不会这么来查询文档，尤其是需要查询内嵌文档的时候。MongoDB中提供”.”（点）表示法来查询内嵌文档。因此，上面的查询可以这样写：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find(</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        \"address.privince\":\"河北省\"</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>"},{"title":"MongoDB 分析查询计划","date":"2017-06-29T02:18:51.000Z","_content":"\n\n## 查询计划\n\n和传统的关系型数据库的执行计划类似，MongoDB也提供了查询计划。MongoDB的查询优化器处理查询语句，并且从生成的执行计划中选择最优的来执行查询过程。下图显示了MongoDB查询计划的逻辑步骤：\n\n![QueryPlannerLogic](https://docs.mongodb.com/manual/_images/query-planner-diagram.bakedsvg.svg)\n\n## 分析查询的性能\n\nMongoDB 提供了一个 explain 命令让我们获知系统如何处理查询请求。利用 explain 命令，我们可以很好地观察系统如何使用索引来加快检索，同时可以针对性优化索引。\n\n<!-- more -->\n\n## 分析实例\n\n### 准备数据\n\n``` shell\ndb.inventory.insertMany([\n{ \"_id\" : 1, \"item\" : \"f1\", type: \"food\", quantity: 500 },\n{ \"_id\" : 2, \"item\" : \"f2\", type: \"food\", quantity: 100 },\n{ \"_id\" : 3, \"item\" : \"p1\", type: \"paper\", quantity: 200 },\n{ \"_id\" : 4, \"item\" : \"p2\", type: \"paper\", quantity: 150 },\n{ \"_id\" : 5, \"item\" : \"f3\", type: \"food\", quantity: 300 },\n{ \"_id\" : 6, \"item\" : \"t1\", type: \"toys\", quantity: 500 },\n{ \"_id\" : 7, \"item\" : \"a1\", type: \"apparel\", quantity: 250 },\n{ \"_id\" : 8, \"item\" : \"a2\", type: \"apparel\", quantity: 400 },\n{ \"_id\" : 9, \"item\" : \"t2\", type: \"toys\", quantity: 50 },\n{ \"_id\" : 10, \"item\" : \"f4\", type: \"food\", quantity: 75 }\n])\n```\n\n### 无索引的查询\n\n在这个collection没有索引的情况下，写一个查询，查询quantity字段的值在100和200之间的文档\n\n``` shell\ndb.inventory.find({ quantity: { $gte: 100, $lte: 200}})\n```\n\n这时候，我们想知道这个查询语句所选择的查询计划是怎么样的：\n\n``` shell\ndb.inventory.find(\n    { quantity: {$gte: 100, $lte: 200}}\n).explain(\"executionStats\")\n```\n\n下图为返回的结果：\n\n![executionStats](http://7xkfga.com1.z0.glb.clouddn.com/MongoDBexecutionStats.png)\n\n- `queryPlanner.winningPlan.stage` 显示的是 COLLSCAN集合扫描，也就是关系型数据库的全表扫描，看到这个说明性能肯定不好\n- `nReturned`为3，符合的条件的返回为3条\n- `totalKeysExamined`为0，没有使用index。\n- `totalDocsExamined`为10，扫描了所有记录。\n\n优化的方向也很明显， 就是如何减少检查的文档数量。\n\n### 创建索引\n\n在quantity字段上创建索引：\n\n``` shell\ndb.inventory.createIndex( {quantity: 1})\n```\n\n再次执行上面的命令查看查询计划\n\n![executionStatsAfterIndex](http://7xkfga.com1.z0.glb.clouddn.com/MongoDBexecutionStatsAfterIndex.png)\n\n- `queryPlanner.winningPlan.inputStage.stage` 显示IXSCAN说明使用了索引\n- `executionStats.nReturned` 有3条文档符合条件返回\n- `executionStats.totalKeysExamined` 扫描了3个索引\n- `executionStats.totalDocsExamined` 一共扫描了3个文档\n\n\n\n\n参考资料：\n\n> [MongoDB Documentation: Analyze Query Performance ](https://docs.mongodb.com/manual/tutorial/analyze-query-plan/)\n","source":"_posts/MongoDB-∑÷Œˆ≤È—Øº∆ªÆ.md","raw":"---\ntitle: MongoDB 分析查询计划\ntags:\n  - MongoDB\ndate: 2017-06-29 10:18:51\n---\n\n\n## 查询计划\n\n和传统的关系型数据库的执行计划类似，MongoDB也提供了查询计划。MongoDB的查询优化器处理查询语句，并且从生成的执行计划中选择最优的来执行查询过程。下图显示了MongoDB查询计划的逻辑步骤：\n\n![QueryPlannerLogic](https://docs.mongodb.com/manual/_images/query-planner-diagram.bakedsvg.svg)\n\n## 分析查询的性能\n\nMongoDB 提供了一个 explain 命令让我们获知系统如何处理查询请求。利用 explain 命令，我们可以很好地观察系统如何使用索引来加快检索，同时可以针对性优化索引。\n\n<!-- more -->\n\n## 分析实例\n\n### 准备数据\n\n``` shell\ndb.inventory.insertMany([\n{ \"_id\" : 1, \"item\" : \"f1\", type: \"food\", quantity: 500 },\n{ \"_id\" : 2, \"item\" : \"f2\", type: \"food\", quantity: 100 },\n{ \"_id\" : 3, \"item\" : \"p1\", type: \"paper\", quantity: 200 },\n{ \"_id\" : 4, \"item\" : \"p2\", type: \"paper\", quantity: 150 },\n{ \"_id\" : 5, \"item\" : \"f3\", type: \"food\", quantity: 300 },\n{ \"_id\" : 6, \"item\" : \"t1\", type: \"toys\", quantity: 500 },\n{ \"_id\" : 7, \"item\" : \"a1\", type: \"apparel\", quantity: 250 },\n{ \"_id\" : 8, \"item\" : \"a2\", type: \"apparel\", quantity: 400 },\n{ \"_id\" : 9, \"item\" : \"t2\", type: \"toys\", quantity: 50 },\n{ \"_id\" : 10, \"item\" : \"f4\", type: \"food\", quantity: 75 }\n])\n```\n\n### 无索引的查询\n\n在这个collection没有索引的情况下，写一个查询，查询quantity字段的值在100和200之间的文档\n\n``` shell\ndb.inventory.find({ quantity: { $gte: 100, $lte: 200}})\n```\n\n这时候，我们想知道这个查询语句所选择的查询计划是怎么样的：\n\n``` shell\ndb.inventory.find(\n    { quantity: {$gte: 100, $lte: 200}}\n).explain(\"executionStats\")\n```\n\n下图为返回的结果：\n\n![executionStats](http://7xkfga.com1.z0.glb.clouddn.com/MongoDBexecutionStats.png)\n\n- `queryPlanner.winningPlan.stage` 显示的是 COLLSCAN集合扫描，也就是关系型数据库的全表扫描，看到这个说明性能肯定不好\n- `nReturned`为3，符合的条件的返回为3条\n- `totalKeysExamined`为0，没有使用index。\n- `totalDocsExamined`为10，扫描了所有记录。\n\n优化的方向也很明显， 就是如何减少检查的文档数量。\n\n### 创建索引\n\n在quantity字段上创建索引：\n\n``` shell\ndb.inventory.createIndex( {quantity: 1})\n```\n\n再次执行上面的命令查看查询计划\n\n![executionStatsAfterIndex](http://7xkfga.com1.z0.glb.clouddn.com/MongoDBexecutionStatsAfterIndex.png)\n\n- `queryPlanner.winningPlan.inputStage.stage` 显示IXSCAN说明使用了索引\n- `executionStats.nReturned` 有3条文档符合条件返回\n- `executionStats.totalKeysExamined` 扫描了3个索引\n- `executionStats.totalDocsExamined` 一共扫描了3个文档\n\n\n\n\n参考资料：\n\n> [MongoDB Documentation: Analyze Query Performance ](https://docs.mongodb.com/manual/tutorial/analyze-query-plan/)\n","slug":"MongoDB-∑÷Œˆ≤È—Øº∆ªÆ","published":1,"updated":"2017-06-29T07:24:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3oa002pzd68balpsfte","content":"<h2 id=\"查询计划\"><a href=\"#查询计划\" class=\"headerlink\" title=\"查询计划\"></a>查询计划</h2><p>和传统的关系型数据库的执行计划类似，MongoDB也提供了查询计划。MongoDB的查询优化器处理查询语句，并且从生成的执行计划中选择最优的来执行查询过程。下图显示了MongoDB查询计划的逻辑步骤：</p>\n<p><img src=\"https://docs.mongodb.com/manual/_images/query-planner-diagram.bakedsvg.svg\" alt=\"QueryPlannerLogic\"></p>\n<h2 id=\"分析查询的性能\"><a href=\"#分析查询的性能\" class=\"headerlink\" title=\"分析查询的性能\"></a>分析查询的性能</h2><p>MongoDB 提供了一个 explain 命令让我们获知系统如何处理查询请求。利用 explain 命令，我们可以很好地观察系统如何使用索引来加快检索，同时可以针对性优化索引。</p>\n<a id=\"more\"></a>\n<h2 id=\"分析实例\"><a href=\"#分析实例\" class=\"headerlink\" title=\"分析实例\"></a>分析实例</h2><h3 id=\"准备数据\"><a href=\"#准备数据\" class=\"headerlink\" title=\"准备数据\"></a>准备数据</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.inventory.insertMany([</span><br><span class=\"line\">&#123; \"_id\" : 1, \"item\" : \"f1\", type: \"food\", quantity: 500 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 2, \"item\" : \"f2\", type: \"food\", quantity: 100 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 3, \"item\" : \"p1\", type: \"paper\", quantity: 200 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 4, \"item\" : \"p2\", type: \"paper\", quantity: 150 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 5, \"item\" : \"f3\", type: \"food\", quantity: 300 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 6, \"item\" : \"t1\", type: \"toys\", quantity: 500 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 7, \"item\" : \"a1\", type: \"apparel\", quantity: 250 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 8, \"item\" : \"a2\", type: \"apparel\", quantity: 400 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 9, \"item\" : \"t2\", type: \"toys\", quantity: 50 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 10, \"item\" : \"f4\", type: \"food\", quantity: 75 &#125;</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n<h3 id=\"无索引的查询\"><a href=\"#无索引的查询\" class=\"headerlink\" title=\"无索引的查询\"></a>无索引的查询</h3><p>在这个collection没有索引的情况下，写一个查询，查询quantity字段的值在100和200之间的文档</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.inventory.find(&#123; quantity: &#123; $gte: 100, $lte: 200&#125;&#125;)</span><br></pre></td></tr></table></figure>\n<p>这时候，我们想知道这个查询语句所选择的查询计划是怎么样的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.inventory.find(</span><br><span class=\"line\">    &#123; quantity: &#123;$gte: 100, $lte: 200&#125;&#125;</span><br><span class=\"line\">).explain(\"executionStats\")</span><br></pre></td></tr></table></figure>\n<p>下图为返回的结果：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/MongoDBexecutionStats.png\" alt=\"executionStats\"></p>\n<ul>\n<li><code>queryPlanner.winningPlan.stage</code> 显示的是 COLLSCAN集合扫描，也就是关系型数据库的全表扫描，看到这个说明性能肯定不好</li>\n<li><code>nReturned</code>为3，符合的条件的返回为3条</li>\n<li><code>totalKeysExamined</code>为0，没有使用index。</li>\n<li><code>totalDocsExamined</code>为10，扫描了所有记录。</li>\n</ul>\n<p>优化的方向也很明显， 就是如何减少检查的文档数量。</p>\n<h3 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h3><p>在quantity字段上创建索引：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.inventory.createIndex( &#123;quantity: 1&#125;)</span><br></pre></td></tr></table></figure>\n<p>再次执行上面的命令查看查询计划</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/MongoDBexecutionStatsAfterIndex.png\" alt=\"executionStatsAfterIndex\"></p>\n<ul>\n<li><code>queryPlanner.winningPlan.inputStage.stage</code> 显示IXSCAN说明使用了索引</li>\n<li><code>executionStats.nReturned</code> 有3条文档符合条件返回</li>\n<li><code>executionStats.totalKeysExamined</code> 扫描了3个索引</li>\n<li><code>executionStats.totalDocsExamined</code> 一共扫描了3个文档</li>\n</ul>\n<p>参考资料：</p>\n<blockquote>\n<p><a href=\"https://docs.mongodb.com/manual/tutorial/analyze-query-plan/\" target=\"_blank\" rel=\"noopener\">MongoDB Documentation: Analyze Query Performance </a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"查询计划\"><a href=\"#查询计划\" class=\"headerlink\" title=\"查询计划\"></a>查询计划</h2><p>和传统的关系型数据库的执行计划类似，MongoDB也提供了查询计划。MongoDB的查询优化器处理查询语句，并且从生成的执行计划中选择最优的来执行查询过程。下图显示了MongoDB查询计划的逻辑步骤：</p>\n<p><img src=\"https://docs.mongodb.com/manual/_images/query-planner-diagram.bakedsvg.svg\" alt=\"QueryPlannerLogic\"></p>\n<h2 id=\"分析查询的性能\"><a href=\"#分析查询的性能\" class=\"headerlink\" title=\"分析查询的性能\"></a>分析查询的性能</h2><p>MongoDB 提供了一个 explain 命令让我们获知系统如何处理查询请求。利用 explain 命令，我们可以很好地观察系统如何使用索引来加快检索，同时可以针对性优化索引。</p>","more":"<h2 id=\"分析实例\"><a href=\"#分析实例\" class=\"headerlink\" title=\"分析实例\"></a>分析实例</h2><h3 id=\"准备数据\"><a href=\"#准备数据\" class=\"headerlink\" title=\"准备数据\"></a>准备数据</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.inventory.insertMany([</span><br><span class=\"line\">&#123; \"_id\" : 1, \"item\" : \"f1\", type: \"food\", quantity: 500 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 2, \"item\" : \"f2\", type: \"food\", quantity: 100 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 3, \"item\" : \"p1\", type: \"paper\", quantity: 200 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 4, \"item\" : \"p2\", type: \"paper\", quantity: 150 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 5, \"item\" : \"f3\", type: \"food\", quantity: 300 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 6, \"item\" : \"t1\", type: \"toys\", quantity: 500 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 7, \"item\" : \"a1\", type: \"apparel\", quantity: 250 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 8, \"item\" : \"a2\", type: \"apparel\", quantity: 400 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 9, \"item\" : \"t2\", type: \"toys\", quantity: 50 &#125;,</span><br><span class=\"line\">&#123; \"_id\" : 10, \"item\" : \"f4\", type: \"food\", quantity: 75 &#125;</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n<h3 id=\"无索引的查询\"><a href=\"#无索引的查询\" class=\"headerlink\" title=\"无索引的查询\"></a>无索引的查询</h3><p>在这个collection没有索引的情况下，写一个查询，查询quantity字段的值在100和200之间的文档</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.inventory.find(&#123; quantity: &#123; $gte: 100, $lte: 200&#125;&#125;)</span><br></pre></td></tr></table></figure>\n<p>这时候，我们想知道这个查询语句所选择的查询计划是怎么样的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.inventory.find(</span><br><span class=\"line\">    &#123; quantity: &#123;$gte: 100, $lte: 200&#125;&#125;</span><br><span class=\"line\">).explain(\"executionStats\")</span><br></pre></td></tr></table></figure>\n<p>下图为返回的结果：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/MongoDBexecutionStats.png\" alt=\"executionStats\"></p>\n<ul>\n<li><code>queryPlanner.winningPlan.stage</code> 显示的是 COLLSCAN集合扫描，也就是关系型数据库的全表扫描，看到这个说明性能肯定不好</li>\n<li><code>nReturned</code>为3，符合的条件的返回为3条</li>\n<li><code>totalKeysExamined</code>为0，没有使用index。</li>\n<li><code>totalDocsExamined</code>为10，扫描了所有记录。</li>\n</ul>\n<p>优化的方向也很明显， 就是如何减少检查的文档数量。</p>\n<h3 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h3><p>在quantity字段上创建索引：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.inventory.createIndex( &#123;quantity: 1&#125;)</span><br></pre></td></tr></table></figure>\n<p>再次执行上面的命令查看查询计划</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/MongoDBexecutionStatsAfterIndex.png\" alt=\"executionStatsAfterIndex\"></p>\n<ul>\n<li><code>queryPlanner.winningPlan.inputStage.stage</code> 显示IXSCAN说明使用了索引</li>\n<li><code>executionStats.nReturned</code> 有3条文档符合条件返回</li>\n<li><code>executionStats.totalKeysExamined</code> 扫描了3个索引</li>\n<li><code>executionStats.totalDocsExamined</code> 一共扫描了3个文档</li>\n</ul>\n<p>参考资料：</p>\n<blockquote>\n<p><a href=\"https://docs.mongodb.com/manual/tutorial/analyze-query-plan/\" target=\"_blank\" rel=\"noopener\">MongoDB Documentation: Analyze Query Performance </a></p>\n</blockquote>"},{"title":"MongoDB索引操作","date":"2017-06-29T07:19:20.000Z","_content":"\n\n上面那篇MongoDB Documentation关于查询优化的案例，数据只有10条，看不出来性能有多少提升，这篇再尝试一个例子。\n\n<!-- more -->\n\n## 准备数据\n\n首先先插入1千万条测试数据\n\n``` shell\nuse test\n\nfor(var i = 0; i < 10000000; i++){\n    var rand = parseInt(i * Math.random());\n    db.person.insert({name: \"hxc\"+i, age: i})\n}\n```\n\n![prepareData](http://7xkfga.com1.z0.glb.clouddn.com/prepareData.png)\n\n数据插入需要好久，这个在以后也是个需要优化的地方。\n\n## 使用 explain函数分析查询性能\n\n现在在person这个collection上面没有创建任何索引，这里使用MongoDB提供的 explain工具分析一下一个查询的性能\n\n``` shell\ndb.person.find({ name: \"hxc\"+10000}).explain()\n```\n\n![initialPerformance](http://7xkfga.com1.z0.glb.clouddn.com/initialExecutionStatus.png)\n\n上面查询使用的是COLLSCAN，就是表扫描，totalDocsExamined为全部1千万，nReturn为1，最终返回一个文档， executionTimeMillisEstimate为4637，预计耗时4637毫秒。\n\n## 创建索引\n\n试一试在name字段上创建一个索引呢？\n\n``` shell\ndb.person.ensureIndex({ name: 1})\ndb.person.find({ name: \"hxc\"+10000}).explain()\n```\n\n![executionStatusAfterIndex](http://7xkfga.com1.z0.glb.clouddn.com/indexScan.png)\n\n再来看看查询的性能，这回使用的是IDXSCAN，mongodb在后台使用B树结构来存放索引，这里使用的索引名字是name_1，只浏览了一个文档就返回这一个文档，executionTimeMillisEstimate预计耗时0毫秒。\n\nnote: 在创建索引的时候，会占用一个写锁，如果数据量很大的话，会产生很多问题，所以建议用background方式为大表创建索引。\n\n``` shell\ndb.person.ensureIndex({ name: 1}, {background: 1})\n```\n\n\n## 创建组和索引\n\n有时候查询不是单条件的，可能是多条件，这时候可以创建组合索引来加速查询\n\n``` shell\ndb.person.ensureIndex({ name: 1, birthday: 1})\ndb.person.ensureIndex({ birthday: 1, name: 1})\n\ndb.person.getIndexes()\n```\n\n下面就是创建好的所有索引\n\n![showIndexes](http://7xkfga.com1.z0.glb.clouddn.com/allIndexes.png)\n\n其中第一个索引是在创建collection的时候系统自动创建的一个唯一性索引，key值为 `_id`。 最后两个是刚才所创建的组合索引，这两个组和索引使用的字段虽然是一样的，但是这是两个完全不同的索引\n\n下面分析一下下面的查询使用的到底是哪个索引\n\n``` shell\ndb.person.find({ birthday: \"1989-05-01\", name: \"mary\"}).explain()\n```\n\n![chooseIndex](http://7xkfga.com1.z0.glb.clouddn.com/winingPlan.png)\n\n可以看出，最终优化器选择了使用name_1_birthday_1这个索引。查询优化器会使用我们建立的这些索引来创建查询方案，优化器会从中选择最优的执行查询，同时也可以看到被优化器拒绝的查询计划。当然如果非要用自己指定的查询方案，这也是可以的，在mongodb中给我们提供了`hint`方法让我们可以暴力执行。\n","source":"_posts/MongoDBÀ˜“˝≤Ÿ◊˜.md","raw":"---\ntitle: MongoDB索引操作\ntags:\n  - MongoDB\ndate: 2017-06-29 15:19:20\n---\n\n\n上面那篇MongoDB Documentation关于查询优化的案例，数据只有10条，看不出来性能有多少提升，这篇再尝试一个例子。\n\n<!-- more -->\n\n## 准备数据\n\n首先先插入1千万条测试数据\n\n``` shell\nuse test\n\nfor(var i = 0; i < 10000000; i++){\n    var rand = parseInt(i * Math.random());\n    db.person.insert({name: \"hxc\"+i, age: i})\n}\n```\n\n![prepareData](http://7xkfga.com1.z0.glb.clouddn.com/prepareData.png)\n\n数据插入需要好久，这个在以后也是个需要优化的地方。\n\n## 使用 explain函数分析查询性能\n\n现在在person这个collection上面没有创建任何索引，这里使用MongoDB提供的 explain工具分析一下一个查询的性能\n\n``` shell\ndb.person.find({ name: \"hxc\"+10000}).explain()\n```\n\n![initialPerformance](http://7xkfga.com1.z0.glb.clouddn.com/initialExecutionStatus.png)\n\n上面查询使用的是COLLSCAN，就是表扫描，totalDocsExamined为全部1千万，nReturn为1，最终返回一个文档， executionTimeMillisEstimate为4637，预计耗时4637毫秒。\n\n## 创建索引\n\n试一试在name字段上创建一个索引呢？\n\n``` shell\ndb.person.ensureIndex({ name: 1})\ndb.person.find({ name: \"hxc\"+10000}).explain()\n```\n\n![executionStatusAfterIndex](http://7xkfga.com1.z0.glb.clouddn.com/indexScan.png)\n\n再来看看查询的性能，这回使用的是IDXSCAN，mongodb在后台使用B树结构来存放索引，这里使用的索引名字是name_1，只浏览了一个文档就返回这一个文档，executionTimeMillisEstimate预计耗时0毫秒。\n\nnote: 在创建索引的时候，会占用一个写锁，如果数据量很大的话，会产生很多问题，所以建议用background方式为大表创建索引。\n\n``` shell\ndb.person.ensureIndex({ name: 1}, {background: 1})\n```\n\n\n## 创建组和索引\n\n有时候查询不是单条件的，可能是多条件，这时候可以创建组合索引来加速查询\n\n``` shell\ndb.person.ensureIndex({ name: 1, birthday: 1})\ndb.person.ensureIndex({ birthday: 1, name: 1})\n\ndb.person.getIndexes()\n```\n\n下面就是创建好的所有索引\n\n![showIndexes](http://7xkfga.com1.z0.glb.clouddn.com/allIndexes.png)\n\n其中第一个索引是在创建collection的时候系统自动创建的一个唯一性索引，key值为 `_id`。 最后两个是刚才所创建的组合索引，这两个组和索引使用的字段虽然是一样的，但是这是两个完全不同的索引\n\n下面分析一下下面的查询使用的到底是哪个索引\n\n``` shell\ndb.person.find({ birthday: \"1989-05-01\", name: \"mary\"}).explain()\n```\n\n![chooseIndex](http://7xkfga.com1.z0.glb.clouddn.com/winingPlan.png)\n\n可以看出，最终优化器选择了使用name_1_birthday_1这个索引。查询优化器会使用我们建立的这些索引来创建查询方案，优化器会从中选择最优的执行查询，同时也可以看到被优化器拒绝的查询计划。当然如果非要用自己指定的查询方案，这也是可以的，在mongodb中给我们提供了`hint`方法让我们可以暴力执行。\n","slug":"MongoDBÀ˜“˝≤Ÿ◊˜","published":1,"updated":"2017-06-29T07:24:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3ob002szd686ki107k4","content":"<p>上面那篇MongoDB Documentation关于查询优化的案例，数据只有10条，看不出来性能有多少提升，这篇再尝试一个例子。</p>\n<a id=\"more\"></a>\n<h2 id=\"准备数据\"><a href=\"#准备数据\" class=\"headerlink\" title=\"准备数据\"></a>准备数据</h2><p>首先先插入1千万条测试数据</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use test</span><br><span class=\"line\"></span><br><span class=\"line\">for(var i = 0; i &lt; 10000000; i++)&#123;</span><br><span class=\"line\">    var rand = parseInt(i * Math.random());</span><br><span class=\"line\">    db.person.insert(&#123;name: \"hxc\"+i, age: i&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/prepareData.png\" alt=\"prepareData\"></p>\n<p>数据插入需要好久，这个在以后也是个需要优化的地方。</p>\n<h2 id=\"使用-explain函数分析查询性能\"><a href=\"#使用-explain函数分析查询性能\" class=\"headerlink\" title=\"使用 explain函数分析查询性能\"></a>使用 explain函数分析查询性能</h2><p>现在在person这个collection上面没有创建任何索引，这里使用MongoDB提供的 explain工具分析一下一个查询的性能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.person.find(&#123; name: \"hxc\"+10000&#125;).explain()</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/initialExecutionStatus.png\" alt=\"initialPerformance\"></p>\n<p>上面查询使用的是COLLSCAN，就是表扫描，totalDocsExamined为全部1千万，nReturn为1，最终返回一个文档， executionTimeMillisEstimate为4637，预计耗时4637毫秒。</p>\n<h2 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h2><p>试一试在name字段上创建一个索引呢？</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.person.ensureIndex(&#123; name: 1&#125;)</span><br><span class=\"line\">db.person.find(&#123; name: \"hxc\"+10000&#125;).explain()</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/indexScan.png\" alt=\"executionStatusAfterIndex\"></p>\n<p>再来看看查询的性能，这回使用的是IDXSCAN，mongodb在后台使用B树结构来存放索引，这里使用的索引名字是name_1，只浏览了一个文档就返回这一个文档，executionTimeMillisEstimate预计耗时0毫秒。</p>\n<p>note: 在创建索引的时候，会占用一个写锁，如果数据量很大的话，会产生很多问题，所以建议用background方式为大表创建索引。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.person.ensureIndex(&#123; name: 1&#125;, &#123;background: 1&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建组和索引\"><a href=\"#创建组和索引\" class=\"headerlink\" title=\"创建组和索引\"></a>创建组和索引</h2><p>有时候查询不是单条件的，可能是多条件，这时候可以创建组合索引来加速查询</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.person.ensureIndex(&#123; name: 1, birthday: 1&#125;)</span><br><span class=\"line\">db.person.ensureIndex(&#123; birthday: 1, name: 1&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">db.person.getIndexes()</span><br></pre></td></tr></table></figure>\n<p>下面就是创建好的所有索引</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/allIndexes.png\" alt=\"showIndexes\"></p>\n<p>其中第一个索引是在创建collection的时候系统自动创建的一个唯一性索引，key值为 <code>_id</code>。 最后两个是刚才所创建的组合索引，这两个组和索引使用的字段虽然是一样的，但是这是两个完全不同的索引</p>\n<p>下面分析一下下面的查询使用的到底是哪个索引</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.person.find(&#123; birthday: \"1989-05-01\", name: \"mary\"&#125;).explain()</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/winingPlan.png\" alt=\"chooseIndex\"></p>\n<p>可以看出，最终优化器选择了使用name_1_birthday_1这个索引。查询优化器会使用我们建立的这些索引来创建查询方案，优化器会从中选择最优的执行查询，同时也可以看到被优化器拒绝的查询计划。当然如果非要用自己指定的查询方案，这也是可以的，在mongodb中给我们提供了<code>hint</code>方法让我们可以暴力执行。</p>\n","site":{"data":{}},"excerpt":"<p>上面那篇MongoDB Documentation关于查询优化的案例，数据只有10条，看不出来性能有多少提升，这篇再尝试一个例子。</p>","more":"<h2 id=\"准备数据\"><a href=\"#准备数据\" class=\"headerlink\" title=\"准备数据\"></a>准备数据</h2><p>首先先插入1千万条测试数据</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use test</span><br><span class=\"line\"></span><br><span class=\"line\">for(var i = 0; i &lt; 10000000; i++)&#123;</span><br><span class=\"line\">    var rand = parseInt(i * Math.random());</span><br><span class=\"line\">    db.person.insert(&#123;name: \"hxc\"+i, age: i&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/prepareData.png\" alt=\"prepareData\"></p>\n<p>数据插入需要好久，这个在以后也是个需要优化的地方。</p>\n<h2 id=\"使用-explain函数分析查询性能\"><a href=\"#使用-explain函数分析查询性能\" class=\"headerlink\" title=\"使用 explain函数分析查询性能\"></a>使用 explain函数分析查询性能</h2><p>现在在person这个collection上面没有创建任何索引，这里使用MongoDB提供的 explain工具分析一下一个查询的性能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.person.find(&#123; name: \"hxc\"+10000&#125;).explain()</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/initialExecutionStatus.png\" alt=\"initialPerformance\"></p>\n<p>上面查询使用的是COLLSCAN，就是表扫描，totalDocsExamined为全部1千万，nReturn为1，最终返回一个文档， executionTimeMillisEstimate为4637，预计耗时4637毫秒。</p>\n<h2 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h2><p>试一试在name字段上创建一个索引呢？</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.person.ensureIndex(&#123; name: 1&#125;)</span><br><span class=\"line\">db.person.find(&#123; name: \"hxc\"+10000&#125;).explain()</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/indexScan.png\" alt=\"executionStatusAfterIndex\"></p>\n<p>再来看看查询的性能，这回使用的是IDXSCAN，mongodb在后台使用B树结构来存放索引，这里使用的索引名字是name_1，只浏览了一个文档就返回这一个文档，executionTimeMillisEstimate预计耗时0毫秒。</p>\n<p>note: 在创建索引的时候，会占用一个写锁，如果数据量很大的话，会产生很多问题，所以建议用background方式为大表创建索引。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.person.ensureIndex(&#123; name: 1&#125;, &#123;background: 1&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建组和索引\"><a href=\"#创建组和索引\" class=\"headerlink\" title=\"创建组和索引\"></a>创建组和索引</h2><p>有时候查询不是单条件的，可能是多条件，这时候可以创建组合索引来加速查询</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.person.ensureIndex(&#123; name: 1, birthday: 1&#125;)</span><br><span class=\"line\">db.person.ensureIndex(&#123; birthday: 1, name: 1&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">db.person.getIndexes()</span><br></pre></td></tr></table></figure>\n<p>下面就是创建好的所有索引</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/allIndexes.png\" alt=\"showIndexes\"></p>\n<p>其中第一个索引是在创建collection的时候系统自动创建的一个唯一性索引，key值为 <code>_id</code>。 最后两个是刚才所创建的组合索引，这两个组和索引使用的字段虽然是一样的，但是这是两个完全不同的索引</p>\n<p>下面分析一下下面的查询使用的到底是哪个索引</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.person.find(&#123; birthday: \"1989-05-01\", name: \"mary\"&#125;).explain()</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/winingPlan.png\" alt=\"chooseIndex\"></p>\n<p>可以看出，最终优化器选择了使用name_1_birthday_1这个索引。查询优化器会使用我们建立的这些索引来创建查询方案，优化器会从中选择最优的执行查询，同时也可以看到被优化器拒绝的查询计划。当然如果非要用自己指定的查询方案，这也是可以的，在mongodb中给我们提供了<code>hint</code>方法让我们可以暴力执行。</p>"},{"title":"Python Collection集合模块","date":"2017-05-27T10:40:54.000Z","_content":"\n\n``` python\nimport collections\n```\n\ncollections是Python内建的一个集合模块，提供了许多有用的集合类。Python拥有一些内置的数据类型，比如`str`, `int`, `list`, `tuple`, `dict`等， collections模块在这些内置数据类型的基础上，提供了几个额外的数据类型：\n\n- namedtuple(): 生成可以使用名字来访问元素内容的tuple子类\n- deque: 双端队列，可以快速的从另外一侧追加和推出对象\n- Counter: 计数器，主要用来计数\n- OrderedDict: 有序字典\n- defaultdict: 带有默认值的字典\n\n\n<!-- more -->\n\n\n## namedtuple\n\n`namedtuple`主要用来产生可以使用名称来访问元素的数据对象，通常用来增强代码的可读性。\n\n`namedtuple`是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。\n\n``` python\nfrom collections import namedtuple\n\n# namedtuple('名称', [属性list])\nPoint = namedtuple('Point', ['x', 'y'])\np = Point(1, 2)\nprint p.x, p.y\n# 1, 2\nisinstance(p, Point)\n# True\nisinstance(p, tuple)\n# True\n```\n\n用`namedtuple`可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用\n\n\n## deque\n\n`deque`其实是double-ended queue的缩写，翻译过来就是双端队列，它最大的好处就是实现了从队列头部快速增加和取出对象: `.popleft()`, `.appendleft()`\n\nlist对象的这两种用法的时间复杂度是 O(n) ，也就是说随着元素数量的增加耗时呈 线性上升。而使用deque对象则是 O(1) 的复杂度\n\n``` python\n>>> from collections import deque\n>>> q = deque(['a', 'b', 'c'])\n>>> q.append('x')\n>>> q.appendleft('y')\n>>> q\ndeque(['y', 'a', 'b', 'c', 'x'])\n```\n\n`deque`提供了很多方法，例如 `rotate`\n\n``` python\n# -*- coding: utf-8 -*-\n\"\"\"\n下面这个是一个有趣的例子，主要使用了deque的rotate方法来实现了一个无限循环\n的加载动画\n\"\"\"\nimport sys\nimport time\nfrom collections import deque\n\nfancy_loading = deque('>--------------------')\n\nwhile True:\n    print '\\r%s' % ''.join(fancy_loading),\n    fancy_loading.rotate(1)\n    sys.stdout.flush()\n    time.sleep(0.08)\n\n# Result:\n\n# 一个无尽循环的跑马灯\n# ------------->-------\n```\n\n## Counter\n\n`Counter`是一个简单的计数器，例如，统计字符出现的个数\n\n``` python\n>>> from collections import Counter\n>>> c = Counter()\n>>> for ch in 'programming':\n...     c[ch] = c[ch] + 1\n...\n>>> c\nCounter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})\n\n>>> # 获取出现频率最高的5个字符\n>>> print c.most_common(5)\n```\n\n`Counter`实际上也是dict的一个子类，上面的结果可以看出，字符'g'、'm'、'r'各出现了两次，其他字符各出现了一次。\n\n\n## defaultdict\n\n使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用`defaultdict` : 如果使用defaultdict，只要你传入一个默认的工厂方法，那么请求一个不存在的key时， 便会调用这个工厂方法使用其结果来作为这个key的默认值\n\n``` python\n>>> from collections import defaultdict\n>>> dd = defaultdict(lambda: 'N/A')\n>>> dd['key1'] = 'abc'\n>>> dd['key1'] # key1存在\n'abc'\n>>> dd['key2'] # key2不存在，返回默认值\n'N/A'\n```\n\n\n## OrderedDict\n\n使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。\n\n如果要保持Key的顺序，可以用`OrderedDict`\n\n``` python\n>>> from collections import OrderedDict\n>>> d = dict([('a', 1), ('b', 2), ('c', 3)])\n>>> d # dict的Key是无序的\n{'a': 1, 'c': 3, 'b': 2}\n>>> od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])\n>>> od # OrderedDict的Key是有序的\nOrderedDict([('a', 1), ('b', 2), ('c', 3)])\n```\n\n**Note: OrderedDict的Key会按照插入的顺序排列，不是Key本身排序**\n\n","source":"_posts/Python-CollectionºØ∫œƒ£øÈ.md","raw":"---\ntitle: Python Collection集合模块\ndate: 2017-05-27 18:40:54\ntags: \n- Python\n- Data Structure\n---\n\n\n``` python\nimport collections\n```\n\ncollections是Python内建的一个集合模块，提供了许多有用的集合类。Python拥有一些内置的数据类型，比如`str`, `int`, `list`, `tuple`, `dict`等， collections模块在这些内置数据类型的基础上，提供了几个额外的数据类型：\n\n- namedtuple(): 生成可以使用名字来访问元素内容的tuple子类\n- deque: 双端队列，可以快速的从另外一侧追加和推出对象\n- Counter: 计数器，主要用来计数\n- OrderedDict: 有序字典\n- defaultdict: 带有默认值的字典\n\n\n<!-- more -->\n\n\n## namedtuple\n\n`namedtuple`主要用来产生可以使用名称来访问元素的数据对象，通常用来增强代码的可读性。\n\n`namedtuple`是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。\n\n``` python\nfrom collections import namedtuple\n\n# namedtuple('名称', [属性list])\nPoint = namedtuple('Point', ['x', 'y'])\np = Point(1, 2)\nprint p.x, p.y\n# 1, 2\nisinstance(p, Point)\n# True\nisinstance(p, tuple)\n# True\n```\n\n用`namedtuple`可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用\n\n\n## deque\n\n`deque`其实是double-ended queue的缩写，翻译过来就是双端队列，它最大的好处就是实现了从队列头部快速增加和取出对象: `.popleft()`, `.appendleft()`\n\nlist对象的这两种用法的时间复杂度是 O(n) ，也就是说随着元素数量的增加耗时呈 线性上升。而使用deque对象则是 O(1) 的复杂度\n\n``` python\n>>> from collections import deque\n>>> q = deque(['a', 'b', 'c'])\n>>> q.append('x')\n>>> q.appendleft('y')\n>>> q\ndeque(['y', 'a', 'b', 'c', 'x'])\n```\n\n`deque`提供了很多方法，例如 `rotate`\n\n``` python\n# -*- coding: utf-8 -*-\n\"\"\"\n下面这个是一个有趣的例子，主要使用了deque的rotate方法来实现了一个无限循环\n的加载动画\n\"\"\"\nimport sys\nimport time\nfrom collections import deque\n\nfancy_loading = deque('>--------------------')\n\nwhile True:\n    print '\\r%s' % ''.join(fancy_loading),\n    fancy_loading.rotate(1)\n    sys.stdout.flush()\n    time.sleep(0.08)\n\n# Result:\n\n# 一个无尽循环的跑马灯\n# ------------->-------\n```\n\n## Counter\n\n`Counter`是一个简单的计数器，例如，统计字符出现的个数\n\n``` python\n>>> from collections import Counter\n>>> c = Counter()\n>>> for ch in 'programming':\n...     c[ch] = c[ch] + 1\n...\n>>> c\nCounter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})\n\n>>> # 获取出现频率最高的5个字符\n>>> print c.most_common(5)\n```\n\n`Counter`实际上也是dict的一个子类，上面的结果可以看出，字符'g'、'm'、'r'各出现了两次，其他字符各出现了一次。\n\n\n## defaultdict\n\n使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用`defaultdict` : 如果使用defaultdict，只要你传入一个默认的工厂方法，那么请求一个不存在的key时， 便会调用这个工厂方法使用其结果来作为这个key的默认值\n\n``` python\n>>> from collections import defaultdict\n>>> dd = defaultdict(lambda: 'N/A')\n>>> dd['key1'] = 'abc'\n>>> dd['key1'] # key1存在\n'abc'\n>>> dd['key2'] # key2不存在，返回默认值\n'N/A'\n```\n\n\n## OrderedDict\n\n使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。\n\n如果要保持Key的顺序，可以用`OrderedDict`\n\n``` python\n>>> from collections import OrderedDict\n>>> d = dict([('a', 1), ('b', 2), ('c', 3)])\n>>> d # dict的Key是无序的\n{'a': 1, 'c': 3, 'b': 2}\n>>> od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])\n>>> od # OrderedDict的Key是有序的\nOrderedDict([('a', 1), ('b', 2), ('c', 3)])\n```\n\n**Note: OrderedDict的Key会按照插入的顺序排列，不是Key本身排序**\n\n","slug":"Python-CollectionºØ∫œƒ£øÈ","published":1,"updated":"2017-05-31T02:59:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3od002wzd680ljnmtvh","content":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> collections</span><br></pre></td></tr></table></figure>\n<p>collections是Python内建的一个集合模块，提供了许多有用的集合类。Python拥有一些内置的数据类型，比如<code>str</code>, <code>int</code>, <code>list</code>, <code>tuple</code>, <code>dict</code>等， collections模块在这些内置数据类型的基础上，提供了几个额外的数据类型：</p>\n<ul>\n<li>namedtuple(): 生成可以使用名字来访问元素内容的tuple子类</li>\n<li>deque: 双端队列，可以快速的从另外一侧追加和推出对象</li>\n<li>Counter: 计数器，主要用来计数</li>\n<li>OrderedDict: 有序字典</li>\n<li>defaultdict: 带有默认值的字典</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"namedtuple\"><a href=\"#namedtuple\" class=\"headerlink\" title=\"namedtuple\"></a>namedtuple</h2><p><code>namedtuple</code>主要用来产生可以使用名称来访问元素的数据对象，通常用来增强代码的可读性。</p>\n<p><code>namedtuple</code>是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> namedtuple</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># namedtuple('名称', [属性list])</span></span><br><span class=\"line\">Point = namedtuple(<span class=\"string\">'Point'</span>, [<span class=\"string\">'x'</span>, <span class=\"string\">'y'</span>])</span><br><span class=\"line\">p = Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> p.x, p.y</span><br><span class=\"line\"><span class=\"comment\"># 1, 2</span></span><br><span class=\"line\">isinstance(p, Point)</span><br><span class=\"line\"><span class=\"comment\"># True</span></span><br><span class=\"line\">isinstance(p, tuple)</span><br><span class=\"line\"><span class=\"comment\"># True</span></span><br></pre></td></tr></table></figure>\n<p>用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用</p>\n<h2 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h2><p><code>deque</code>其实是double-ended queue的缩写，翻译过来就是双端队列，它最大的好处就是实现了从队列头部快速增加和取出对象: <code>.popleft()</code>, <code>.appendleft()</code></p>\n<p>list对象的这两种用法的时间复杂度是 O(n) ，也就是说随着元素数量的增加耗时呈 线性上升。而使用deque对象则是 O(1) 的复杂度</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q = deque([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q.append(<span class=\"string\">'x'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q.appendleft(<span class=\"string\">'y'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q</span><br><span class=\"line\">deque([<span class=\"string\">'y'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'x'</span>])</span><br></pre></td></tr></table></figure>\n<p><code>deque</code>提供了很多方法，例如 <code>rotate</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">下面这个是一个有趣的例子，主要使用了deque的rotate方法来实现了一个无限循环</span></span><br><span class=\"line\"><span class=\"string\">的加载动画</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\"></span><br><span class=\"line\">fancy_loading = deque(<span class=\"string\">'&gt;--------------------'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'\\r%s'</span> % <span class=\"string\">''</span>.join(fancy_loading),</span><br><span class=\"line\">    fancy_loading.rotate(<span class=\"number\">1</span>)</span><br><span class=\"line\">    sys.stdout.flush()</span><br><span class=\"line\">    time.sleep(<span class=\"number\">0.08</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Result:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一个无尽循环的跑马灯</span></span><br><span class=\"line\"><span class=\"comment\"># -------------&gt;-------</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h2><p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c = Counter()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> <span class=\"string\">'programming'</span>:</span><br><span class=\"line\"><span class=\"meta\">... </span>    c[ch] = c[ch] + <span class=\"number\">1</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c</span><br><span class=\"line\">Counter(&#123;<span class=\"string\">'g'</span>: <span class=\"number\">2</span>, <span class=\"string\">'m'</span>: <span class=\"number\">2</span>, <span class=\"string\">'r'</span>: <span class=\"number\">2</span>, <span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'i'</span>: <span class=\"number\">1</span>, <span class=\"string\">'o'</span>: <span class=\"number\">1</span>, <span class=\"string\">'n'</span>: <span class=\"number\">1</span>, <span class=\"string\">'p'</span>: <span class=\"number\">1</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"comment\"># 获取出现频率最高的5个字符</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> c.most_common(<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<p><code>Counter</code>实际上也是dict的一个子类，上面的结果可以看出，字符’g’、’m’、’r’各出现了两次，其他字符各出现了一次。</p>\n<h2 id=\"defaultdict\"><a href=\"#defaultdict\" class=\"headerlink\" title=\"defaultdict\"></a>defaultdict</h2><p>使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用<code>defaultdict</code> : 如果使用defaultdict，只要你传入一个默认的工厂方法，那么请求一个不存在的key时， 便会调用这个工厂方法使用其结果来作为这个key的默认值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> defaultdict</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd = defaultdict(<span class=\"keyword\">lambda</span>: <span class=\"string\">'N/A'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key1'</span>] = <span class=\"string\">'abc'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key1'</span>] <span class=\"comment\"># key1存在</span></span><br><span class=\"line\"><span class=\"string\">'abc'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key2'</span>] <span class=\"comment\"># key2不存在，返回默认值</span></span><br><span class=\"line\"><span class=\"string\">'N/A'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"OrderedDict\"><a href=\"#OrderedDict\" class=\"headerlink\" title=\"OrderedDict\"></a>OrderedDict</h2><p>使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。</p>\n<p>如果要保持Key的顺序，可以用<code>OrderedDict</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> OrderedDict</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = dict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d <span class=\"comment\"># dict的Key是无序的</span></span><br><span class=\"line\">&#123;<span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'c'</span>: <span class=\"number\">3</span>, <span class=\"string\">'b'</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>od = OrderedDict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>od <span class=\"comment\"># OrderedDict的Key是有序的</span></span><br><span class=\"line\">OrderedDict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</span><br></pre></td></tr></table></figure>\n<p><strong>Note: OrderedDict的Key会按照插入的顺序排列，不是Key本身排序</strong></p>\n","site":{"data":{}},"excerpt":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> collections</span><br></pre></td></tr></table></figure>\n<p>collections是Python内建的一个集合模块，提供了许多有用的集合类。Python拥有一些内置的数据类型，比如<code>str</code>, <code>int</code>, <code>list</code>, <code>tuple</code>, <code>dict</code>等， collections模块在这些内置数据类型的基础上，提供了几个额外的数据类型：</p>\n<ul>\n<li>namedtuple(): 生成可以使用名字来访问元素内容的tuple子类</li>\n<li>deque: 双端队列，可以快速的从另外一侧追加和推出对象</li>\n<li>Counter: 计数器，主要用来计数</li>\n<li>OrderedDict: 有序字典</li>\n<li>defaultdict: 带有默认值的字典</li>\n</ul>","more":"<h2 id=\"namedtuple\"><a href=\"#namedtuple\" class=\"headerlink\" title=\"namedtuple\"></a>namedtuple</h2><p><code>namedtuple</code>主要用来产生可以使用名称来访问元素的数据对象，通常用来增强代码的可读性。</p>\n<p><code>namedtuple</code>是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> namedtuple</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># namedtuple('名称', [属性list])</span></span><br><span class=\"line\">Point = namedtuple(<span class=\"string\">'Point'</span>, [<span class=\"string\">'x'</span>, <span class=\"string\">'y'</span>])</span><br><span class=\"line\">p = Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> p.x, p.y</span><br><span class=\"line\"><span class=\"comment\"># 1, 2</span></span><br><span class=\"line\">isinstance(p, Point)</span><br><span class=\"line\"><span class=\"comment\"># True</span></span><br><span class=\"line\">isinstance(p, tuple)</span><br><span class=\"line\"><span class=\"comment\"># True</span></span><br></pre></td></tr></table></figure>\n<p>用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用</p>\n<h2 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h2><p><code>deque</code>其实是double-ended queue的缩写，翻译过来就是双端队列，它最大的好处就是实现了从队列头部快速增加和取出对象: <code>.popleft()</code>, <code>.appendleft()</code></p>\n<p>list对象的这两种用法的时间复杂度是 O(n) ，也就是说随着元素数量的增加耗时呈 线性上升。而使用deque对象则是 O(1) 的复杂度</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q = deque([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q.append(<span class=\"string\">'x'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q.appendleft(<span class=\"string\">'y'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q</span><br><span class=\"line\">deque([<span class=\"string\">'y'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'x'</span>])</span><br></pre></td></tr></table></figure>\n<p><code>deque</code>提供了很多方法，例如 <code>rotate</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">下面这个是一个有趣的例子，主要使用了deque的rotate方法来实现了一个无限循环</span></span><br><span class=\"line\"><span class=\"string\">的加载动画</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\"></span><br><span class=\"line\">fancy_loading = deque(<span class=\"string\">'&gt;--------------------'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'\\r%s'</span> % <span class=\"string\">''</span>.join(fancy_loading),</span><br><span class=\"line\">    fancy_loading.rotate(<span class=\"number\">1</span>)</span><br><span class=\"line\">    sys.stdout.flush()</span><br><span class=\"line\">    time.sleep(<span class=\"number\">0.08</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Result:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一个无尽循环的跑马灯</span></span><br><span class=\"line\"><span class=\"comment\"># -------------&gt;-------</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h2><p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c = Counter()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> <span class=\"string\">'programming'</span>:</span><br><span class=\"line\"><span class=\"meta\">... </span>    c[ch] = c[ch] + <span class=\"number\">1</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c</span><br><span class=\"line\">Counter(&#123;<span class=\"string\">'g'</span>: <span class=\"number\">2</span>, <span class=\"string\">'m'</span>: <span class=\"number\">2</span>, <span class=\"string\">'r'</span>: <span class=\"number\">2</span>, <span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'i'</span>: <span class=\"number\">1</span>, <span class=\"string\">'o'</span>: <span class=\"number\">1</span>, <span class=\"string\">'n'</span>: <span class=\"number\">1</span>, <span class=\"string\">'p'</span>: <span class=\"number\">1</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"comment\"># 获取出现频率最高的5个字符</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> c.most_common(<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<p><code>Counter</code>实际上也是dict的一个子类，上面的结果可以看出，字符’g’、’m’、’r’各出现了两次，其他字符各出现了一次。</p>\n<h2 id=\"defaultdict\"><a href=\"#defaultdict\" class=\"headerlink\" title=\"defaultdict\"></a>defaultdict</h2><p>使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用<code>defaultdict</code> : 如果使用defaultdict，只要你传入一个默认的工厂方法，那么请求一个不存在的key时， 便会调用这个工厂方法使用其结果来作为这个key的默认值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> defaultdict</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd = defaultdict(<span class=\"keyword\">lambda</span>: <span class=\"string\">'N/A'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key1'</span>] = <span class=\"string\">'abc'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key1'</span>] <span class=\"comment\"># key1存在</span></span><br><span class=\"line\"><span class=\"string\">'abc'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key2'</span>] <span class=\"comment\"># key2不存在，返回默认值</span></span><br><span class=\"line\"><span class=\"string\">'N/A'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"OrderedDict\"><a href=\"#OrderedDict\" class=\"headerlink\" title=\"OrderedDict\"></a>OrderedDict</h2><p>使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。</p>\n<p>如果要保持Key的顺序，可以用<code>OrderedDict</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> OrderedDict</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = dict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d <span class=\"comment\"># dict的Key是无序的</span></span><br><span class=\"line\">&#123;<span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'c'</span>: <span class=\"number\">3</span>, <span class=\"string\">'b'</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>od = OrderedDict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>od <span class=\"comment\"># OrderedDict的Key是有序的</span></span><br><span class=\"line\">OrderedDict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</span><br></pre></td></tr></table></figure>\n<p><strong>Note: OrderedDict的Key会按照插入的顺序排列，不是Key本身排序</strong></p>"},{"title":"Python dict类型的实现","date":"2017-07-18T08:38:09.000Z","_content":"\n程序员们的经验里面，通常都会认为字典和集合的速度是非常快的，字典的搜索的时间复杂读为O(1)，\n\n为什么能有这么快呢？在于字典和集合的后台实现。\n\n## 散列表 Hash table\n\n散列表是一个稀疏数组，散列表里面的单元叫做表元 `bucket`， 在dict的散列表中，每个键值对都占用一个表元，每个表元有两个部分：一个对键值的引用，一个对值的引用。因为所有表元大小一致，可以通过偏移量来读取某个表元。由于是稀疏数组，python会设法保证还有大约三分之一的表元是空的，快要到达这个阈值的时候，会把原有的散列表复制到一个更大的空间里面。\n\n<!-- more -->\n\n如果要把一个对象放入散列表，那么需要先计算这个元素的散列值\n\n``` python\nmap(hash, (0, 1, 2, 3))\n# [0, 1, 2, 3]\n\nmap(hash, (\"namea\", \"nameb\", \"namec\", \"named\"))\n# [6674681622036885098, -1135453951840843879, 3071659021342785694, 5386947181042036450]\n```\n\n## 常用构造hash函数的方法\n\n构造散列函数有多种方式，比如直接寻址法、数字分析法、平方取中法、折叠法、随机数法、除留余数法等。著名的hash算法: MD5 和 SHA-1 是应用最广泛的Hash算法。\n\n### 直接寻址法\n\n取keyword或keyword的某个线性函数值为散列地址。即H(key)=key或H(key) = a*key + b，当中a和b为常数（这样的散列函数叫做自身函数）\n\n### 数字分析法\n\n分析一组数据，比方一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体同样，这种话，出现冲突的几率就会非常大，可是我们发现年月日的后几位表示月份和详细日期的数字区别非常大，假设用后面的数字来构成散列地址，则冲突的几率会明显减少。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。\n\n### 平方取中法\n\n取keyword平方后的中间几位作为散列地址。\n\n### 折叠法\n\n将keyword切割成位数同样的几部分，最后一部分位数能够不同，然后取这几部分的叠加和（去除进位）作为散列地址。\n\n### 随机数法\n\n选择一随机函数，取keyword的随机值作为散列地址，通经常使用于keyword长度不同的场合。\n\n### 除留余数法\n\n取keyword被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p<=m。不仅能够对keyword直接取模，也可在折叠、平方取中等运算之后取模。对p的选择非常重要，一般取素数或m，若p选的不好，easy产生同义词。\n\n\n## 散列表算法\n\n为了获取my_dict[search_key] 的值， Python会调用hash(search_key) 来计算散列值，把这个值的最低几位数字当做偏移量，在散列表里面查找表元，如果摘到的表元是空的，则抛出KeyError异常，若不是空的， 表元里会有一对found_key: found_value，然后Python会检查search_key是否等于found_key，如果相等，就返回found_value。\n\n![从字典取值流程图](http://7xkfga.com1.z0.glb.clouddn.com/hash_search.png)\n\n如果search_key和found_key不匹配的话，就叫做散列冲突。\n\n## 散列冲突解决方法\n\n### 开放寻址法 Open addressing\n\nPython是使用开放寻址法中的二次探查来解决冲突的。如果使用的容量超过数组大小的2/3，就申请更大的容量。数组大小较小的时候resize为*4，较大的时候resize*2。实际上是用左移的形式。\n\n## 字典的C数据结构\n\n下面的C结构体来存储一个字典项，包括散列值、键和值。\n\n``` C\ntypedef struct {\n    Py_ssize_t me_hash;\n    PyObject *me_key;\n    PyObject *me_value;\n} PyDictEntry;\n```\n\n下面的结构代表了一个字典\n\n``` C\ntypedef struct _dictobject PyDictObject;\nstruct _dictobject {\n    PyObject_HEAD\n    Py_ssize_t ma_fill;\n    Py_ssize_t ma_used;\n    Py_ssize_t ma_mask;\n    PyDictEntry *ma_table;\n    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);\n    PyDictEntry ma_smalltable[PyDict_MINSIZE];\n};\n```\n\n- `ma_fill` 是使用了的slots加 dummy slots的数量和。当一个键值对被移除了时，它占据的那个slot会被标记为dummy。如果添加一个新的 key 并且新 key 不属于dummy，则 `ma_fill` 增加 1\n- `ma_used` 是被占用了（即活跃的）的slots数量\n- `ma_mask` 等于数组长度减一，它被用来计算slot的索引。在查找元素的一个 key 时，使用 `slot = key_hash & mask` 就能直接获得哈希槽序号\n- `ma_table` 一个 PyDictEntry 结构体的数组， PyDictEntry 包含 key 对象、value 对象，以及 key 的散列值\n- `ma_lookup` 一个用于查找 key 的函数指针\n- `ma_smalltable` 是一个初始大小为8的数组。\n\nCpython中，使用如下算法来进行二次探查序列查找空闲slot\n\n```\ni = (5 * i + perturb + 1)\nslot_index = i & ma_mask\nperturb >>= 5\n```\n\n## 字典的使用\n\n### 字典初始化\n\n第一次创建一个字典，PyDict_New()函数会被调用\n\n```\nreturns new dictionary object\nfunction PyDict_New:\n    allocate new dictionary object\n    clear dictionary's table\n    set dictionary's number of used slots + dummy slots (ma_fill) to 0\n    set dictionary's number of active slots (ma_used) to 0\n    set dictionary's mask (ma_value) to dictionary size - 1 = 7\n    set dictionary's lookup function to lookdict_string\n    return allocated dictionary object\n```\n\n### 添加项\n\n当添加一个新键值对时PyDict_SetItem()被调用，该函数带一个指向字典对象的指针和一个键值对作为参数。它检查该键是否为字符串并计算它的hash值（如果这个键的哈希值已经被缓存了则用缓存值）。然后insertdict()函数被调用来添加新的键/值对，如果使用了的slots和dummy slots的总量超过了数组大小的2/3则重新调整字典的大小。\n\n```\narguments: dictionary, key, value\nreturn: 0 if OK or -1\nfunction PyDict_SetItem:\n    if key's hash cached:\n        use hash\n    else:\n        calculate hash\n    call insertdict with dictionary object, key, hash and value\n    if key/value pair added successfully and capacity orver 2/3:\n        call dictresize to resize dictionary's table\n```\n\n`insertdict()` `使用查找函数 `lookdict_string`来寻找空闲的slot，这和寻找key的函数是一样的。`lookdict_string()``函数利用hash和mask值计算slot的索引，如果它不能在slot索引（=hash & mask）中找到这个key，它便开始如上述伪码描述循环来探测直到找到一个可用的空闲slot。第一次探测时，如果key为空(null)，那么如果找到了dummy slot则返回之\n\n下面一个列子，如何将{'a': 1, 'b': 2, 'z': 26, 'y': 25, 'c': 5, 'x': 24} 键值对添加到字典里面。(字典结构的表大小为8)\n\n```\nPyDict_SetItem: key='a', value = 1\n    hash = hash('a') = 12416037344\n    insertdict\n        lookdict_string\n            slot index = hash & mask = 12416037344 & 7 = 0\n            slot 0 is not used so return it\n        init entry at index 0 with key, value and hash\n        ma_used = 1, ma_fill = 1\nPyDict_SetItem: key='b', value = 2\n    hash = hash('b') = 12544037731\n    insertdict\n        lookdict_string\n            slot index = hash & mask = 12544037731 & 7 = 3\n            slot 3 is not used so return it\n        init entry at index 3 with key, value and hash\n        ma_used = 2, ma_fill = 2\nPyDict_SetItem: key='z', value = 26\n    hash = hash('z') = 15616046971\n    insertdict\n        lookdict_string\n            slot index = hash & mask = 15616046971 & 7 = 3\n            slot 3 is used so probe for a different slot: 5 is free\n        init entry at index 5 with key, value and hash\n        ma_used = 3, ma_fill = 3\nPyDict_SetItem: key='y', value = 25\n    hash = hash('y') = 15488046584\n    insertdict\n        lookdict_string\n            slot index = hash & mask = 15488046584 & 7 = 0\n            slot 0 is used so probe for a different slot: 1 is free\n        init entry at index 1 with key, value and hash\n        ma_used = 4, ma_fill = 4\nPyDict_SetItem: key='c', value = 3\n    hash = hash('c') = 12672038114\n    insertdict\n        lookdict_string\n            slot index = hash & mask = 12672038114 & 7 = 2\n            slot 2 is not used so return it\n        init entry at index 2 with key, value and hash\n        ma_used = 5, ma_fill = 5\nPyDict_SetItem: key='x', value = 24\n    hash = hash('x') = 15360046201\n    insertdict\n        lookdict_string\n            slot index = hash & mask = 15360046201 & 7 = 1\n            slot 1 is used so probe for a different slot: 7 is free\n        init entry at index 7 with key, value and hash\n        ma_used = 6, ma_fill = 6\n```\n\n![hashtable_items](http://www.laurentluce.com/images/blog/dict/insert.png)\n\n### 移除项\n\n`PyDict_DelItem()`被用来删除一个字典项。key的散列值被计算出来作为查找函数的参数，删除后这个slot就成为了dummy slot。\n\n## 参考\n\n[Python dictionary implementation](http://www.laurentluce.com/posts/python-dictionary-implementation/)\n\n[Fluent Python](https://www.amazon.com/Fluent-Python-Concise-Effective-Programming/dp/1491946008/ref=sr_1_1?ie=UTF8&qid=1500368395&sr=8-1&keywords=fluent+python)\n","source":"_posts/Python-dict¿‡–Õµƒ µœ÷.md","raw":"---\ntitle: Python dict类型的实现\ndate: 2017-07-18 16:38:09\ntags:\n        - Python\n        - dict\n        - hash\n---\n\n程序员们的经验里面，通常都会认为字典和集合的速度是非常快的，字典的搜索的时间复杂读为O(1)，\n\n为什么能有这么快呢？在于字典和集合的后台实现。\n\n## 散列表 Hash table\n\n散列表是一个稀疏数组，散列表里面的单元叫做表元 `bucket`， 在dict的散列表中，每个键值对都占用一个表元，每个表元有两个部分：一个对键值的引用，一个对值的引用。因为所有表元大小一致，可以通过偏移量来读取某个表元。由于是稀疏数组，python会设法保证还有大约三分之一的表元是空的，快要到达这个阈值的时候，会把原有的散列表复制到一个更大的空间里面。\n\n<!-- more -->\n\n如果要把一个对象放入散列表，那么需要先计算这个元素的散列值\n\n``` python\nmap(hash, (0, 1, 2, 3))\n# [0, 1, 2, 3]\n\nmap(hash, (\"namea\", \"nameb\", \"namec\", \"named\"))\n# [6674681622036885098, -1135453951840843879, 3071659021342785694, 5386947181042036450]\n```\n\n## 常用构造hash函数的方法\n\n构造散列函数有多种方式，比如直接寻址法、数字分析法、平方取中法、折叠法、随机数法、除留余数法等。著名的hash算法: MD5 和 SHA-1 是应用最广泛的Hash算法。\n\n### 直接寻址法\n\n取keyword或keyword的某个线性函数值为散列地址。即H(key)=key或H(key) = a*key + b，当中a和b为常数（这样的散列函数叫做自身函数）\n\n### 数字分析法\n\n分析一组数据，比方一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体同样，这种话，出现冲突的几率就会非常大，可是我们发现年月日的后几位表示月份和详细日期的数字区别非常大，假设用后面的数字来构成散列地址，则冲突的几率会明显减少。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。\n\n### 平方取中法\n\n取keyword平方后的中间几位作为散列地址。\n\n### 折叠法\n\n将keyword切割成位数同样的几部分，最后一部分位数能够不同，然后取这几部分的叠加和（去除进位）作为散列地址。\n\n### 随机数法\n\n选择一随机函数，取keyword的随机值作为散列地址，通经常使用于keyword长度不同的场合。\n\n### 除留余数法\n\n取keyword被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p<=m。不仅能够对keyword直接取模，也可在折叠、平方取中等运算之后取模。对p的选择非常重要，一般取素数或m，若p选的不好，easy产生同义词。\n\n\n## 散列表算法\n\n为了获取my_dict[search_key] 的值， Python会调用hash(search_key) 来计算散列值，把这个值的最低几位数字当做偏移量，在散列表里面查找表元，如果摘到的表元是空的，则抛出KeyError异常，若不是空的， 表元里会有一对found_key: found_value，然后Python会检查search_key是否等于found_key，如果相等，就返回found_value。\n\n![从字典取值流程图](http://7xkfga.com1.z0.glb.clouddn.com/hash_search.png)\n\n如果search_key和found_key不匹配的话，就叫做散列冲突。\n\n## 散列冲突解决方法\n\n### 开放寻址法 Open addressing\n\nPython是使用开放寻址法中的二次探查来解决冲突的。如果使用的容量超过数组大小的2/3，就申请更大的容量。数组大小较小的时候resize为*4，较大的时候resize*2。实际上是用左移的形式。\n\n## 字典的C数据结构\n\n下面的C结构体来存储一个字典项，包括散列值、键和值。\n\n``` C\ntypedef struct {\n    Py_ssize_t me_hash;\n    PyObject *me_key;\n    PyObject *me_value;\n} PyDictEntry;\n```\n\n下面的结构代表了一个字典\n\n``` C\ntypedef struct _dictobject PyDictObject;\nstruct _dictobject {\n    PyObject_HEAD\n    Py_ssize_t ma_fill;\n    Py_ssize_t ma_used;\n    Py_ssize_t ma_mask;\n    PyDictEntry *ma_table;\n    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);\n    PyDictEntry ma_smalltable[PyDict_MINSIZE];\n};\n```\n\n- `ma_fill` 是使用了的slots加 dummy slots的数量和。当一个键值对被移除了时，它占据的那个slot会被标记为dummy。如果添加一个新的 key 并且新 key 不属于dummy，则 `ma_fill` 增加 1\n- `ma_used` 是被占用了（即活跃的）的slots数量\n- `ma_mask` 等于数组长度减一，它被用来计算slot的索引。在查找元素的一个 key 时，使用 `slot = key_hash & mask` 就能直接获得哈希槽序号\n- `ma_table` 一个 PyDictEntry 结构体的数组， PyDictEntry 包含 key 对象、value 对象，以及 key 的散列值\n- `ma_lookup` 一个用于查找 key 的函数指针\n- `ma_smalltable` 是一个初始大小为8的数组。\n\nCpython中，使用如下算法来进行二次探查序列查找空闲slot\n\n```\ni = (5 * i + perturb + 1)\nslot_index = i & ma_mask\nperturb >>= 5\n```\n\n## 字典的使用\n\n### 字典初始化\n\n第一次创建一个字典，PyDict_New()函数会被调用\n\n```\nreturns new dictionary object\nfunction PyDict_New:\n    allocate new dictionary object\n    clear dictionary's table\n    set dictionary's number of used slots + dummy slots (ma_fill) to 0\n    set dictionary's number of active slots (ma_used) to 0\n    set dictionary's mask (ma_value) to dictionary size - 1 = 7\n    set dictionary's lookup function to lookdict_string\n    return allocated dictionary object\n```\n\n### 添加项\n\n当添加一个新键值对时PyDict_SetItem()被调用，该函数带一个指向字典对象的指针和一个键值对作为参数。它检查该键是否为字符串并计算它的hash值（如果这个键的哈希值已经被缓存了则用缓存值）。然后insertdict()函数被调用来添加新的键/值对，如果使用了的slots和dummy slots的总量超过了数组大小的2/3则重新调整字典的大小。\n\n```\narguments: dictionary, key, value\nreturn: 0 if OK or -1\nfunction PyDict_SetItem:\n    if key's hash cached:\n        use hash\n    else:\n        calculate hash\n    call insertdict with dictionary object, key, hash and value\n    if key/value pair added successfully and capacity orver 2/3:\n        call dictresize to resize dictionary's table\n```\n\n`insertdict()` `使用查找函数 `lookdict_string`来寻找空闲的slot，这和寻找key的函数是一样的。`lookdict_string()``函数利用hash和mask值计算slot的索引，如果它不能在slot索引（=hash & mask）中找到这个key，它便开始如上述伪码描述循环来探测直到找到一个可用的空闲slot。第一次探测时，如果key为空(null)，那么如果找到了dummy slot则返回之\n\n下面一个列子，如何将{'a': 1, 'b': 2, 'z': 26, 'y': 25, 'c': 5, 'x': 24} 键值对添加到字典里面。(字典结构的表大小为8)\n\n```\nPyDict_SetItem: key='a', value = 1\n    hash = hash('a') = 12416037344\n    insertdict\n        lookdict_string\n            slot index = hash & mask = 12416037344 & 7 = 0\n            slot 0 is not used so return it\n        init entry at index 0 with key, value and hash\n        ma_used = 1, ma_fill = 1\nPyDict_SetItem: key='b', value = 2\n    hash = hash('b') = 12544037731\n    insertdict\n        lookdict_string\n            slot index = hash & mask = 12544037731 & 7 = 3\n            slot 3 is not used so return it\n        init entry at index 3 with key, value and hash\n        ma_used = 2, ma_fill = 2\nPyDict_SetItem: key='z', value = 26\n    hash = hash('z') = 15616046971\n    insertdict\n        lookdict_string\n            slot index = hash & mask = 15616046971 & 7 = 3\n            slot 3 is used so probe for a different slot: 5 is free\n        init entry at index 5 with key, value and hash\n        ma_used = 3, ma_fill = 3\nPyDict_SetItem: key='y', value = 25\n    hash = hash('y') = 15488046584\n    insertdict\n        lookdict_string\n            slot index = hash & mask = 15488046584 & 7 = 0\n            slot 0 is used so probe for a different slot: 1 is free\n        init entry at index 1 with key, value and hash\n        ma_used = 4, ma_fill = 4\nPyDict_SetItem: key='c', value = 3\n    hash = hash('c') = 12672038114\n    insertdict\n        lookdict_string\n            slot index = hash & mask = 12672038114 & 7 = 2\n            slot 2 is not used so return it\n        init entry at index 2 with key, value and hash\n        ma_used = 5, ma_fill = 5\nPyDict_SetItem: key='x', value = 24\n    hash = hash('x') = 15360046201\n    insertdict\n        lookdict_string\n            slot index = hash & mask = 15360046201 & 7 = 1\n            slot 1 is used so probe for a different slot: 7 is free\n        init entry at index 7 with key, value and hash\n        ma_used = 6, ma_fill = 6\n```\n\n![hashtable_items](http://www.laurentluce.com/images/blog/dict/insert.png)\n\n### 移除项\n\n`PyDict_DelItem()`被用来删除一个字典项。key的散列值被计算出来作为查找函数的参数，删除后这个slot就成为了dummy slot。\n\n## 参考\n\n[Python dictionary implementation](http://www.laurentluce.com/posts/python-dictionary-implementation/)\n\n[Fluent Python](https://www.amazon.com/Fluent-Python-Concise-Effective-Programming/dp/1491946008/ref=sr_1_1?ie=UTF8&qid=1500368395&sr=8-1&keywords=fluent+python)\n","slug":"Python-dict¿‡–Õµƒ µœ÷","published":1,"updated":"2017-07-21T07:05:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3oe002yzd68xvzpqzbv","content":"<p>程序员们的经验里面，通常都会认为字典和集合的速度是非常快的，字典的搜索的时间复杂读为O(1)，</p>\n<p>为什么能有这么快呢？在于字典和集合的后台实现。</p>\n<h2 id=\"散列表-Hash-table\"><a href=\"#散列表-Hash-table\" class=\"headerlink\" title=\"散列表 Hash table\"></a>散列表 Hash table</h2><p>散列表是一个稀疏数组，散列表里面的单元叫做表元 <code>bucket</code>， 在dict的散列表中，每个键值对都占用一个表元，每个表元有两个部分：一个对键值的引用，一个对值的引用。因为所有表元大小一致，可以通过偏移量来读取某个表元。由于是稀疏数组，python会设法保证还有大约三分之一的表元是空的，快要到达这个阈值的时候，会把原有的散列表复制到一个更大的空间里面。</p>\n<a id=\"more\"></a>\n<p>如果要把一个对象放入散列表，那么需要先计算这个元素的散列值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map(hash, (<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\"><span class=\"comment\"># [0, 1, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">map(hash, (<span class=\"string\">\"namea\"</span>, <span class=\"string\">\"nameb\"</span>, <span class=\"string\">\"namec\"</span>, <span class=\"string\">\"named\"</span>))</span><br><span class=\"line\"><span class=\"comment\"># [6674681622036885098, -1135453951840843879, 3071659021342785694, 5386947181042036450]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"常用构造hash函数的方法\"><a href=\"#常用构造hash函数的方法\" class=\"headerlink\" title=\"常用构造hash函数的方法\"></a>常用构造hash函数的方法</h2><p>构造散列函数有多种方式，比如直接寻址法、数字分析法、平方取中法、折叠法、随机数法、除留余数法等。著名的hash算法: MD5 和 SHA-1 是应用最广泛的Hash算法。</p>\n<h3 id=\"直接寻址法\"><a href=\"#直接寻址法\" class=\"headerlink\" title=\"直接寻址法\"></a>直接寻址法</h3><p>取keyword或keyword的某个线性函数值为散列地址。即H(key)=key或H(key) = a*key + b，当中a和b为常数（这样的散列函数叫做自身函数）</p>\n<h3 id=\"数字分析法\"><a href=\"#数字分析法\" class=\"headerlink\" title=\"数字分析法\"></a>数字分析法</h3><p>分析一组数据，比方一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体同样，这种话，出现冲突的几率就会非常大，可是我们发现年月日的后几位表示月份和详细日期的数字区别非常大，假设用后面的数字来构成散列地址，则冲突的几率会明显减少。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</p>\n<h3 id=\"平方取中法\"><a href=\"#平方取中法\" class=\"headerlink\" title=\"平方取中法\"></a>平方取中法</h3><p>取keyword平方后的中间几位作为散列地址。</p>\n<h3 id=\"折叠法\"><a href=\"#折叠法\" class=\"headerlink\" title=\"折叠法\"></a>折叠法</h3><p>将keyword切割成位数同样的几部分，最后一部分位数能够不同，然后取这几部分的叠加和（去除进位）作为散列地址。</p>\n<h3 id=\"随机数法\"><a href=\"#随机数法\" class=\"headerlink\" title=\"随机数法\"></a>随机数法</h3><p>选择一随机函数，取keyword的随机值作为散列地址，通经常使用于keyword长度不同的场合。</p>\n<h3 id=\"除留余数法\"><a href=\"#除留余数法\" class=\"headerlink\" title=\"除留余数法\"></a>除留余数法</h3><p>取keyword被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p&lt;=m。不仅能够对keyword直接取模，也可在折叠、平方取中等运算之后取模。对p的选择非常重要，一般取素数或m，若p选的不好，easy产生同义词。</p>\n<h2 id=\"散列表算法\"><a href=\"#散列表算法\" class=\"headerlink\" title=\"散列表算法\"></a>散列表算法</h2><p>为了获取my_dict[search_key] 的值， Python会调用hash(search_key) 来计算散列值，把这个值的最低几位数字当做偏移量，在散列表里面查找表元，如果摘到的表元是空的，则抛出KeyError异常，若不是空的， 表元里会有一对found_key: found_value，然后Python会检查search_key是否等于found_key，如果相等，就返回found_value。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/hash_search.png\" alt=\"从字典取值流程图\"></p>\n<p>如果search_key和found_key不匹配的话，就叫做散列冲突。</p>\n<h2 id=\"散列冲突解决方法\"><a href=\"#散列冲突解决方法\" class=\"headerlink\" title=\"散列冲突解决方法\"></a>散列冲突解决方法</h2><h3 id=\"开放寻址法-Open-addressing\"><a href=\"#开放寻址法-Open-addressing\" class=\"headerlink\" title=\"开放寻址法 Open addressing\"></a>开放寻址法 Open addressing</h3><p>Python是使用开放寻址法中的二次探查来解决冲突的。如果使用的容量超过数组大小的2/3，就申请更大的容量。数组大小较小的时候resize为<em>4，较大的时候resize</em>2。实际上是用左移的形式。</p>\n<h2 id=\"字典的C数据结构\"><a href=\"#字典的C数据结构\" class=\"headerlink\" title=\"字典的C数据结构\"></a>字典的C数据结构</h2><p>下面的C结构体来存储一个字典项，包括散列值、键和值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    Py_ssize_t me_hash;</span><br><span class=\"line\">    PyObject *me_key;</span><br><span class=\"line\">    PyObject *me_value;</span><br><span class=\"line\">&#125; PyDictEntry;</span><br></pre></td></tr></table></figure>\n<p>下面的结构代表了一个字典</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">dictobject</span> <span class=\"title\">PyDictObject</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">dictobject</span> &#123;</span></span><br><span class=\"line\">    PyObject_HEAD</span><br><span class=\"line\">    Py_ssize_t ma_fill;</span><br><span class=\"line\">    Py_ssize_t ma_used;</span><br><span class=\"line\">    Py_ssize_t ma_mask;</span><br><span class=\"line\">    PyDictEntry *ma_table;</span><br><span class=\"line\">    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, <span class=\"keyword\">long</span> hash);</span><br><span class=\"line\">    PyDictEntry ma_smalltable[PyDict_MINSIZE];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>ma_fill</code> 是使用了的slots加 dummy slots的数量和。当一个键值对被移除了时，它占据的那个slot会被标记为dummy。如果添加一个新的 key 并且新 key 不属于dummy，则 <code>ma_fill</code> 增加 1</li>\n<li><code>ma_used</code> 是被占用了（即活跃的）的slots数量</li>\n<li><code>ma_mask</code> 等于数组长度减一，它被用来计算slot的索引。在查找元素的一个 key 时，使用 <code>slot = key_hash &amp; mask</code> 就能直接获得哈希槽序号</li>\n<li><code>ma_table</code> 一个 PyDictEntry 结构体的数组， PyDictEntry 包含 key 对象、value 对象，以及 key 的散列值</li>\n<li><code>ma_lookup</code> 一个用于查找 key 的函数指针</li>\n<li><code>ma_smalltable</code> 是一个初始大小为8的数组。</li>\n</ul>\n<p>Cpython中，使用如下算法来进行二次探查序列查找空闲slot</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (5 * i + perturb + 1)</span><br><span class=\"line\">slot_index = i &amp; ma_mask</span><br><span class=\"line\">perturb &gt;&gt;= 5</span><br></pre></td></tr></table></figure>\n<h2 id=\"字典的使用\"><a href=\"#字典的使用\" class=\"headerlink\" title=\"字典的使用\"></a>字典的使用</h2><h3 id=\"字典初始化\"><a href=\"#字典初始化\" class=\"headerlink\" title=\"字典初始化\"></a>字典初始化</h3><p>第一次创建一个字典，PyDict_New()函数会被调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">returns new dictionary object</span><br><span class=\"line\">function PyDict_New:</span><br><span class=\"line\">    allocate new dictionary object</span><br><span class=\"line\">    clear dictionary&apos;s table</span><br><span class=\"line\">    set dictionary&apos;s number of used slots + dummy slots (ma_fill) to 0</span><br><span class=\"line\">    set dictionary&apos;s number of active slots (ma_used) to 0</span><br><span class=\"line\">    set dictionary&apos;s mask (ma_value) to dictionary size - 1 = 7</span><br><span class=\"line\">    set dictionary&apos;s lookup function to lookdict_string</span><br><span class=\"line\">    return allocated dictionary object</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加项\"><a href=\"#添加项\" class=\"headerlink\" title=\"添加项\"></a>添加项</h3><p>当添加一个新键值对时PyDict_SetItem()被调用，该函数带一个指向字典对象的指针和一个键值对作为参数。它检查该键是否为字符串并计算它的hash值（如果这个键的哈希值已经被缓存了则用缓存值）。然后insertdict()函数被调用来添加新的键/值对，如果使用了的slots和dummy slots的总量超过了数组大小的2/3则重新调整字典的大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arguments: dictionary, key, value</span><br><span class=\"line\">return: 0 if OK or -1</span><br><span class=\"line\">function PyDict_SetItem:</span><br><span class=\"line\">    if key&apos;s hash cached:</span><br><span class=\"line\">        use hash</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        calculate hash</span><br><span class=\"line\">    call insertdict with dictionary object, key, hash and value</span><br><span class=\"line\">    if key/value pair added successfully and capacity orver 2/3:</span><br><span class=\"line\">        call dictresize to resize dictionary&apos;s table</span><br></pre></td></tr></table></figure>\n<p><code>insertdict()</code> <code>使用查找函数</code>lookdict_string<code>来寻找空闲的slot，这和寻找key的函数是一样的。</code>lookdict_string()<code></code>函数利用hash和mask值计算slot的索引，如果它不能在slot索引（=hash &amp; mask）中找到这个key，它便开始如上述伪码描述循环来探测直到找到一个可用的空闲slot。第一次探测时，如果key为空(null)，那么如果找到了dummy slot则返回之</p>\n<p>下面一个列子，如何将{‘a’: 1, ‘b’: 2, ‘z’: 26, ‘y’: 25, ‘c’: 5, ‘x’: 24} 键值对添加到字典里面。(字典结构的表大小为8)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PyDict_SetItem: key=&apos;a&apos;, value = 1</span><br><span class=\"line\">    hash = hash(&apos;a&apos;) = 12416037344</span><br><span class=\"line\">    insertdict</span><br><span class=\"line\">        lookdict_string</span><br><span class=\"line\">            slot index = hash &amp; mask = 12416037344 &amp; 7 = 0</span><br><span class=\"line\">            slot 0 is not used so return it</span><br><span class=\"line\">        init entry at index 0 with key, value and hash</span><br><span class=\"line\">        ma_used = 1, ma_fill = 1</span><br><span class=\"line\">PyDict_SetItem: key=&apos;b&apos;, value = 2</span><br><span class=\"line\">    hash = hash(&apos;b&apos;) = 12544037731</span><br><span class=\"line\">    insertdict</span><br><span class=\"line\">        lookdict_string</span><br><span class=\"line\">            slot index = hash &amp; mask = 12544037731 &amp; 7 = 3</span><br><span class=\"line\">            slot 3 is not used so return it</span><br><span class=\"line\">        init entry at index 3 with key, value and hash</span><br><span class=\"line\">        ma_used = 2, ma_fill = 2</span><br><span class=\"line\">PyDict_SetItem: key=&apos;z&apos;, value = 26</span><br><span class=\"line\">    hash = hash(&apos;z&apos;) = 15616046971</span><br><span class=\"line\">    insertdict</span><br><span class=\"line\">        lookdict_string</span><br><span class=\"line\">            slot index = hash &amp; mask = 15616046971 &amp; 7 = 3</span><br><span class=\"line\">            slot 3 is used so probe for a different slot: 5 is free</span><br><span class=\"line\">        init entry at index 5 with key, value and hash</span><br><span class=\"line\">        ma_used = 3, ma_fill = 3</span><br><span class=\"line\">PyDict_SetItem: key=&apos;y&apos;, value = 25</span><br><span class=\"line\">    hash = hash(&apos;y&apos;) = 15488046584</span><br><span class=\"line\">    insertdict</span><br><span class=\"line\">        lookdict_string</span><br><span class=\"line\">            slot index = hash &amp; mask = 15488046584 &amp; 7 = 0</span><br><span class=\"line\">            slot 0 is used so probe for a different slot: 1 is free</span><br><span class=\"line\">        init entry at index 1 with key, value and hash</span><br><span class=\"line\">        ma_used = 4, ma_fill = 4</span><br><span class=\"line\">PyDict_SetItem: key=&apos;c&apos;, value = 3</span><br><span class=\"line\">    hash = hash(&apos;c&apos;) = 12672038114</span><br><span class=\"line\">    insertdict</span><br><span class=\"line\">        lookdict_string</span><br><span class=\"line\">            slot index = hash &amp; mask = 12672038114 &amp; 7 = 2</span><br><span class=\"line\">            slot 2 is not used so return it</span><br><span class=\"line\">        init entry at index 2 with key, value and hash</span><br><span class=\"line\">        ma_used = 5, ma_fill = 5</span><br><span class=\"line\">PyDict_SetItem: key=&apos;x&apos;, value = 24</span><br><span class=\"line\">    hash = hash(&apos;x&apos;) = 15360046201</span><br><span class=\"line\">    insertdict</span><br><span class=\"line\">        lookdict_string</span><br><span class=\"line\">            slot index = hash &amp; mask = 15360046201 &amp; 7 = 1</span><br><span class=\"line\">            slot 1 is used so probe for a different slot: 7 is free</span><br><span class=\"line\">        init entry at index 7 with key, value and hash</span><br><span class=\"line\">        ma_used = 6, ma_fill = 6</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.laurentluce.com/images/blog/dict/insert.png\" alt=\"hashtable_items\"></p>\n<h3 id=\"移除项\"><a href=\"#移除项\" class=\"headerlink\" title=\"移除项\"></a>移除项</h3><p><code>PyDict_DelItem()</code>被用来删除一个字典项。key的散列值被计算出来作为查找函数的参数，删除后这个slot就成为了dummy slot。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.laurentluce.com/posts/python-dictionary-implementation/\" target=\"_blank\" rel=\"noopener\">Python dictionary implementation</a></p>\n<p><a href=\"https://www.amazon.com/Fluent-Python-Concise-Effective-Programming/dp/1491946008/ref=sr_1_1?ie=UTF8&amp;qid=1500368395&amp;sr=8-1&amp;keywords=fluent+python\" target=\"_blank\" rel=\"noopener\">Fluent Python</a></p>\n","site":{"data":{}},"excerpt":"<p>程序员们的经验里面，通常都会认为字典和集合的速度是非常快的，字典的搜索的时间复杂读为O(1)，</p>\n<p>为什么能有这么快呢？在于字典和集合的后台实现。</p>\n<h2 id=\"散列表-Hash-table\"><a href=\"#散列表-Hash-table\" class=\"headerlink\" title=\"散列表 Hash table\"></a>散列表 Hash table</h2><p>散列表是一个稀疏数组，散列表里面的单元叫做表元 <code>bucket</code>， 在dict的散列表中，每个键值对都占用一个表元，每个表元有两个部分：一个对键值的引用，一个对值的引用。因为所有表元大小一致，可以通过偏移量来读取某个表元。由于是稀疏数组，python会设法保证还有大约三分之一的表元是空的，快要到达这个阈值的时候，会把原有的散列表复制到一个更大的空间里面。</p>","more":"<p>如果要把一个对象放入散列表，那么需要先计算这个元素的散列值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map(hash, (<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\"><span class=\"comment\"># [0, 1, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">map(hash, (<span class=\"string\">\"namea\"</span>, <span class=\"string\">\"nameb\"</span>, <span class=\"string\">\"namec\"</span>, <span class=\"string\">\"named\"</span>))</span><br><span class=\"line\"><span class=\"comment\"># [6674681622036885098, -1135453951840843879, 3071659021342785694, 5386947181042036450]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"常用构造hash函数的方法\"><a href=\"#常用构造hash函数的方法\" class=\"headerlink\" title=\"常用构造hash函数的方法\"></a>常用构造hash函数的方法</h2><p>构造散列函数有多种方式，比如直接寻址法、数字分析法、平方取中法、折叠法、随机数法、除留余数法等。著名的hash算法: MD5 和 SHA-1 是应用最广泛的Hash算法。</p>\n<h3 id=\"直接寻址法\"><a href=\"#直接寻址法\" class=\"headerlink\" title=\"直接寻址法\"></a>直接寻址法</h3><p>取keyword或keyword的某个线性函数值为散列地址。即H(key)=key或H(key) = a*key + b，当中a和b为常数（这样的散列函数叫做自身函数）</p>\n<h3 id=\"数字分析法\"><a href=\"#数字分析法\" class=\"headerlink\" title=\"数字分析法\"></a>数字分析法</h3><p>分析一组数据，比方一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体同样，这种话，出现冲突的几率就会非常大，可是我们发现年月日的后几位表示月份和详细日期的数字区别非常大，假设用后面的数字来构成散列地址，则冲突的几率会明显减少。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</p>\n<h3 id=\"平方取中法\"><a href=\"#平方取中法\" class=\"headerlink\" title=\"平方取中法\"></a>平方取中法</h3><p>取keyword平方后的中间几位作为散列地址。</p>\n<h3 id=\"折叠法\"><a href=\"#折叠法\" class=\"headerlink\" title=\"折叠法\"></a>折叠法</h3><p>将keyword切割成位数同样的几部分，最后一部分位数能够不同，然后取这几部分的叠加和（去除进位）作为散列地址。</p>\n<h3 id=\"随机数法\"><a href=\"#随机数法\" class=\"headerlink\" title=\"随机数法\"></a>随机数法</h3><p>选择一随机函数，取keyword的随机值作为散列地址，通经常使用于keyword长度不同的场合。</p>\n<h3 id=\"除留余数法\"><a href=\"#除留余数法\" class=\"headerlink\" title=\"除留余数法\"></a>除留余数法</h3><p>取keyword被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p&lt;=m。不仅能够对keyword直接取模，也可在折叠、平方取中等运算之后取模。对p的选择非常重要，一般取素数或m，若p选的不好，easy产生同义词。</p>\n<h2 id=\"散列表算法\"><a href=\"#散列表算法\" class=\"headerlink\" title=\"散列表算法\"></a>散列表算法</h2><p>为了获取my_dict[search_key] 的值， Python会调用hash(search_key) 来计算散列值，把这个值的最低几位数字当做偏移量，在散列表里面查找表元，如果摘到的表元是空的，则抛出KeyError异常，若不是空的， 表元里会有一对found_key: found_value，然后Python会检查search_key是否等于found_key，如果相等，就返回found_value。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/hash_search.png\" alt=\"从字典取值流程图\"></p>\n<p>如果search_key和found_key不匹配的话，就叫做散列冲突。</p>\n<h2 id=\"散列冲突解决方法\"><a href=\"#散列冲突解决方法\" class=\"headerlink\" title=\"散列冲突解决方法\"></a>散列冲突解决方法</h2><h3 id=\"开放寻址法-Open-addressing\"><a href=\"#开放寻址法-Open-addressing\" class=\"headerlink\" title=\"开放寻址法 Open addressing\"></a>开放寻址法 Open addressing</h3><p>Python是使用开放寻址法中的二次探查来解决冲突的。如果使用的容量超过数组大小的2/3，就申请更大的容量。数组大小较小的时候resize为<em>4，较大的时候resize</em>2。实际上是用左移的形式。</p>\n<h2 id=\"字典的C数据结构\"><a href=\"#字典的C数据结构\" class=\"headerlink\" title=\"字典的C数据结构\"></a>字典的C数据结构</h2><p>下面的C结构体来存储一个字典项，包括散列值、键和值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    Py_ssize_t me_hash;</span><br><span class=\"line\">    PyObject *me_key;</span><br><span class=\"line\">    PyObject *me_value;</span><br><span class=\"line\">&#125; PyDictEntry;</span><br></pre></td></tr></table></figure>\n<p>下面的结构代表了一个字典</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">dictobject</span> <span class=\"title\">PyDictObject</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">dictobject</span> &#123;</span></span><br><span class=\"line\">    PyObject_HEAD</span><br><span class=\"line\">    Py_ssize_t ma_fill;</span><br><span class=\"line\">    Py_ssize_t ma_used;</span><br><span class=\"line\">    Py_ssize_t ma_mask;</span><br><span class=\"line\">    PyDictEntry *ma_table;</span><br><span class=\"line\">    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, <span class=\"keyword\">long</span> hash);</span><br><span class=\"line\">    PyDictEntry ma_smalltable[PyDict_MINSIZE];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>ma_fill</code> 是使用了的slots加 dummy slots的数量和。当一个键值对被移除了时，它占据的那个slot会被标记为dummy。如果添加一个新的 key 并且新 key 不属于dummy，则 <code>ma_fill</code> 增加 1</li>\n<li><code>ma_used</code> 是被占用了（即活跃的）的slots数量</li>\n<li><code>ma_mask</code> 等于数组长度减一，它被用来计算slot的索引。在查找元素的一个 key 时，使用 <code>slot = key_hash &amp; mask</code> 就能直接获得哈希槽序号</li>\n<li><code>ma_table</code> 一个 PyDictEntry 结构体的数组， PyDictEntry 包含 key 对象、value 对象，以及 key 的散列值</li>\n<li><code>ma_lookup</code> 一个用于查找 key 的函数指针</li>\n<li><code>ma_smalltable</code> 是一个初始大小为8的数组。</li>\n</ul>\n<p>Cpython中，使用如下算法来进行二次探查序列查找空闲slot</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (5 * i + perturb + 1)</span><br><span class=\"line\">slot_index = i &amp; ma_mask</span><br><span class=\"line\">perturb &gt;&gt;= 5</span><br></pre></td></tr></table></figure>\n<h2 id=\"字典的使用\"><a href=\"#字典的使用\" class=\"headerlink\" title=\"字典的使用\"></a>字典的使用</h2><h3 id=\"字典初始化\"><a href=\"#字典初始化\" class=\"headerlink\" title=\"字典初始化\"></a>字典初始化</h3><p>第一次创建一个字典，PyDict_New()函数会被调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">returns new dictionary object</span><br><span class=\"line\">function PyDict_New:</span><br><span class=\"line\">    allocate new dictionary object</span><br><span class=\"line\">    clear dictionary&apos;s table</span><br><span class=\"line\">    set dictionary&apos;s number of used slots + dummy slots (ma_fill) to 0</span><br><span class=\"line\">    set dictionary&apos;s number of active slots (ma_used) to 0</span><br><span class=\"line\">    set dictionary&apos;s mask (ma_value) to dictionary size - 1 = 7</span><br><span class=\"line\">    set dictionary&apos;s lookup function to lookdict_string</span><br><span class=\"line\">    return allocated dictionary object</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加项\"><a href=\"#添加项\" class=\"headerlink\" title=\"添加项\"></a>添加项</h3><p>当添加一个新键值对时PyDict_SetItem()被调用，该函数带一个指向字典对象的指针和一个键值对作为参数。它检查该键是否为字符串并计算它的hash值（如果这个键的哈希值已经被缓存了则用缓存值）。然后insertdict()函数被调用来添加新的键/值对，如果使用了的slots和dummy slots的总量超过了数组大小的2/3则重新调整字典的大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arguments: dictionary, key, value</span><br><span class=\"line\">return: 0 if OK or -1</span><br><span class=\"line\">function PyDict_SetItem:</span><br><span class=\"line\">    if key&apos;s hash cached:</span><br><span class=\"line\">        use hash</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        calculate hash</span><br><span class=\"line\">    call insertdict with dictionary object, key, hash and value</span><br><span class=\"line\">    if key/value pair added successfully and capacity orver 2/3:</span><br><span class=\"line\">        call dictresize to resize dictionary&apos;s table</span><br></pre></td></tr></table></figure>\n<p><code>insertdict()</code> <code>使用查找函数</code>lookdict_string<code>来寻找空闲的slot，这和寻找key的函数是一样的。</code>lookdict_string()<code></code>函数利用hash和mask值计算slot的索引，如果它不能在slot索引（=hash &amp; mask）中找到这个key，它便开始如上述伪码描述循环来探测直到找到一个可用的空闲slot。第一次探测时，如果key为空(null)，那么如果找到了dummy slot则返回之</p>\n<p>下面一个列子，如何将{‘a’: 1, ‘b’: 2, ‘z’: 26, ‘y’: 25, ‘c’: 5, ‘x’: 24} 键值对添加到字典里面。(字典结构的表大小为8)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PyDict_SetItem: key=&apos;a&apos;, value = 1</span><br><span class=\"line\">    hash = hash(&apos;a&apos;) = 12416037344</span><br><span class=\"line\">    insertdict</span><br><span class=\"line\">        lookdict_string</span><br><span class=\"line\">            slot index = hash &amp; mask = 12416037344 &amp; 7 = 0</span><br><span class=\"line\">            slot 0 is not used so return it</span><br><span class=\"line\">        init entry at index 0 with key, value and hash</span><br><span class=\"line\">        ma_used = 1, ma_fill = 1</span><br><span class=\"line\">PyDict_SetItem: key=&apos;b&apos;, value = 2</span><br><span class=\"line\">    hash = hash(&apos;b&apos;) = 12544037731</span><br><span class=\"line\">    insertdict</span><br><span class=\"line\">        lookdict_string</span><br><span class=\"line\">            slot index = hash &amp; mask = 12544037731 &amp; 7 = 3</span><br><span class=\"line\">            slot 3 is not used so return it</span><br><span class=\"line\">        init entry at index 3 with key, value and hash</span><br><span class=\"line\">        ma_used = 2, ma_fill = 2</span><br><span class=\"line\">PyDict_SetItem: key=&apos;z&apos;, value = 26</span><br><span class=\"line\">    hash = hash(&apos;z&apos;) = 15616046971</span><br><span class=\"line\">    insertdict</span><br><span class=\"line\">        lookdict_string</span><br><span class=\"line\">            slot index = hash &amp; mask = 15616046971 &amp; 7 = 3</span><br><span class=\"line\">            slot 3 is used so probe for a different slot: 5 is free</span><br><span class=\"line\">        init entry at index 5 with key, value and hash</span><br><span class=\"line\">        ma_used = 3, ma_fill = 3</span><br><span class=\"line\">PyDict_SetItem: key=&apos;y&apos;, value = 25</span><br><span class=\"line\">    hash = hash(&apos;y&apos;) = 15488046584</span><br><span class=\"line\">    insertdict</span><br><span class=\"line\">        lookdict_string</span><br><span class=\"line\">            slot index = hash &amp; mask = 15488046584 &amp; 7 = 0</span><br><span class=\"line\">            slot 0 is used so probe for a different slot: 1 is free</span><br><span class=\"line\">        init entry at index 1 with key, value and hash</span><br><span class=\"line\">        ma_used = 4, ma_fill = 4</span><br><span class=\"line\">PyDict_SetItem: key=&apos;c&apos;, value = 3</span><br><span class=\"line\">    hash = hash(&apos;c&apos;) = 12672038114</span><br><span class=\"line\">    insertdict</span><br><span class=\"line\">        lookdict_string</span><br><span class=\"line\">            slot index = hash &amp; mask = 12672038114 &amp; 7 = 2</span><br><span class=\"line\">            slot 2 is not used so return it</span><br><span class=\"line\">        init entry at index 2 with key, value and hash</span><br><span class=\"line\">        ma_used = 5, ma_fill = 5</span><br><span class=\"line\">PyDict_SetItem: key=&apos;x&apos;, value = 24</span><br><span class=\"line\">    hash = hash(&apos;x&apos;) = 15360046201</span><br><span class=\"line\">    insertdict</span><br><span class=\"line\">        lookdict_string</span><br><span class=\"line\">            slot index = hash &amp; mask = 15360046201 &amp; 7 = 1</span><br><span class=\"line\">            slot 1 is used so probe for a different slot: 7 is free</span><br><span class=\"line\">        init entry at index 7 with key, value and hash</span><br><span class=\"line\">        ma_used = 6, ma_fill = 6</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.laurentluce.com/images/blog/dict/insert.png\" alt=\"hashtable_items\"></p>\n<h3 id=\"移除项\"><a href=\"#移除项\" class=\"headerlink\" title=\"移除项\"></a>移除项</h3><p><code>PyDict_DelItem()</code>被用来删除一个字典项。key的散列值被计算出来作为查找函数的参数，删除后这个slot就成为了dummy slot。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.laurentluce.com/posts/python-dictionary-implementation/\" target=\"_blank\" rel=\"noopener\">Python dictionary implementation</a></p>\n<p><a href=\"https://www.amazon.com/Fluent-Python-Concise-Effective-Programming/dp/1491946008/ref=sr_1_1?ie=UTF8&amp;qid=1500368395&amp;sr=8-1&amp;keywords=fluent+python\" target=\"_blank\" rel=\"noopener\">Fluent Python</a></p>"},{"title":"Python 浅复制与深复制","date":"2017-07-31T03:48:31.000Z","_content":"\n> Python中，万物皆对象。\n\n在介绍Python的浅复制和深复制之前，先来歪个楼，说明一下Python的可变对象和不可变对象。提到这里，有两个坑不得不拿出来说一下。\n\n## 坑1：可变对象作为函数默认值\n\n先介绍一个Python里面常见的坑：\n\n``` python\ndef append_to_list(value, def_list=[]):\n    def_list.append(value)\n    return def_list\n\nmy_list = append_to_list(1)\nmy_other_list = append_to_list(2)\nprint my_other_list\n```\n\n这时候的输出是什么呢？\n\n<!-- more -->\n\n```\n[1, 2]\n```\n\n意不意外？惊不惊喜？ :) 为什么呢？这是因为这个默认值是在函数建立的时候就生成了, 每次调用都是用了这个对象的”缓存”。下面图表示第二次调用函数 `append_to_list`时候的引用状况：\n\n![ref_realtion](http://7xkfga.com1.z0.glb.clouddn.com/mutable_object_ref.png)\n\n这就是一条避坑指南：**不要使用可变对象作为函数默认值**\n\n``` python\ndef append_to_list(value, def_list=None):\n    if def_list is None:\n        def_list = []\n    def_list.append(value)\n    return def_list\n```\n\n## 坑2：list `+=` 的不同行为\n\n``` python\na1 = range(3)\na2 = a1\na2 += [3]\nprint a1, a2\n\na1 = range(3)\na3 = a1\na3 = a3 + [3]\nprint a1, a3\n```\n\n你会发现第一段代码的结果a1和a2都为[0,1,2,3]，而第二段的代码a1为[0,1,2] a3为[0,1,2,3]。为什么两次会不同呢？上学时候老师不是说 `a+=b` 等价于 `a=a+b` 的吗？\n\n## 可变和不可变数据类型\n\nPython中，对象分为可变(`mutable`)和不可变(`immutable`)两种类型\n\n1. 字典型(dictionary)和列表型(list)的对象是可变对象\n2. 元组（tuple)、数值型（number)、字符串(string)均为不可变对象\n\n下面验证一下这两种类型，可变对象一旦创建之后还可改变但是地址不会发生改变，即该变量指向的还是原来的对象。而不可变对象则相反，创建之后不能更改，如果更改则变量会指向一个新的对象。\n\n``` python\ns = 'abc' # 不可变对象\nprint(id(s))\n# 45068120\ns += 'd'\nprint(id(s))\n# 75648536\n\nl = ['a','b','c']\nprint(id(l)) # 可变对象\n# 74842504\nl += 'd'\nprint(id(l))\n# 74842504\n```\n\n这个案列也就解释了上面坑2的原因，原因：对于可变对象，例子中的list， += 操作调用 `__iadd__` 方法，相当于 `a1 = a1.__iadd__([3])`，是直接在 a2(a1的引用)上面直接更新。而对于 +操作来说，会调用 `__add__` 方法，返回一个新的对象。所以对于可变对象来说 `a+=b` 是不等价于 `a=a+b` 的。\n\n好了，下面进入正题，如何复制一个对象。\n\n## 浅复制\n\nPython中对象之间的赋值是按引用传递的 (**敲黑板！**)\n\n标识一个对象唯一身份的是：对象的id(内存地址)，对象类型，对象值，而浅拷贝就是创建一个具有相同类型，相同值但不同id的新对象\n\n如果需要复制对象，可以使用标准库中的copy模块，copy.copy是浅复制，只会复制父对象，而不会复制对象内部的子对象；\n\n对于list对象，使用 list() 构造方法或者切片的方式，做的是浅复制，复制了外层容器，副本中的元素其实是源容器中元素的 **引用**\n\n``` python\nl1 = [3, [55, 44], (7, 8, 9)]\nl2 = list(l1)\n\nprint(id(l1), id(l2))\nprint(id(l1[1]), id(l2[1]))\n# 2148206816520 2148206718344\n# 2148206717768 2148206717768\n```\n\n![copyObject](http://7xkfga.com1.z0.glb.clouddn.com/copyObject.png)\n\n## 深复制\n\ncopy.deepcopy是深复制，会复制对象及其子对象。\n\n``` python\nimport copy\n\norigin_list = [0, 1, 2, [3, 4]]\ncopy_list = copy.copy(origin_list)\ndeepcopy_list = copy.deepcopy(origin_list)\n\norigin_list.append('hhh')\norigin_list[3].append('aaa')\n\nprint(origin_list, copy_list, deepcopy_list)\n```\n\n看了下面的引用关系，结果就猜不错了\n\n![deepcopyred](http://7xkfga.com1.z0.glb.clouddn.com/deepcopy_ref.png)\n\n在原列表后面添加一个元素，不会对复制的两个列表有影响；浅复制列表中最后一个元素是原列表最后一个元素的引用，所以添加一个元素也影响浅复制的列表。结果为\n\n```\norigin_list:   [0, 1, 2, [3, 4, 'aaa'], 'hhh']\ncopy_list:     [0, 1, 2, [3, 4, 'aaa']]\ndeepcopy_list: [0, 1, 2, [3, 4]]\n```\n","source":"_posts/Python-«≥∏¥÷∆”Î…Ó∏¥÷∆.md","raw":"---\ntitle: Python 浅复制与深复制\ndate: 2017-07-31 11:48:31\ntags:\n- Python\n- Reference\n---\n\n> Python中，万物皆对象。\n\n在介绍Python的浅复制和深复制之前，先来歪个楼，说明一下Python的可变对象和不可变对象。提到这里，有两个坑不得不拿出来说一下。\n\n## 坑1：可变对象作为函数默认值\n\n先介绍一个Python里面常见的坑：\n\n``` python\ndef append_to_list(value, def_list=[]):\n    def_list.append(value)\n    return def_list\n\nmy_list = append_to_list(1)\nmy_other_list = append_to_list(2)\nprint my_other_list\n```\n\n这时候的输出是什么呢？\n\n<!-- more -->\n\n```\n[1, 2]\n```\n\n意不意外？惊不惊喜？ :) 为什么呢？这是因为这个默认值是在函数建立的时候就生成了, 每次调用都是用了这个对象的”缓存”。下面图表示第二次调用函数 `append_to_list`时候的引用状况：\n\n![ref_realtion](http://7xkfga.com1.z0.glb.clouddn.com/mutable_object_ref.png)\n\n这就是一条避坑指南：**不要使用可变对象作为函数默认值**\n\n``` python\ndef append_to_list(value, def_list=None):\n    if def_list is None:\n        def_list = []\n    def_list.append(value)\n    return def_list\n```\n\n## 坑2：list `+=` 的不同行为\n\n``` python\na1 = range(3)\na2 = a1\na2 += [3]\nprint a1, a2\n\na1 = range(3)\na3 = a1\na3 = a3 + [3]\nprint a1, a3\n```\n\n你会发现第一段代码的结果a1和a2都为[0,1,2,3]，而第二段的代码a1为[0,1,2] a3为[0,1,2,3]。为什么两次会不同呢？上学时候老师不是说 `a+=b` 等价于 `a=a+b` 的吗？\n\n## 可变和不可变数据类型\n\nPython中，对象分为可变(`mutable`)和不可变(`immutable`)两种类型\n\n1. 字典型(dictionary)和列表型(list)的对象是可变对象\n2. 元组（tuple)、数值型（number)、字符串(string)均为不可变对象\n\n下面验证一下这两种类型，可变对象一旦创建之后还可改变但是地址不会发生改变，即该变量指向的还是原来的对象。而不可变对象则相反，创建之后不能更改，如果更改则变量会指向一个新的对象。\n\n``` python\ns = 'abc' # 不可变对象\nprint(id(s))\n# 45068120\ns += 'd'\nprint(id(s))\n# 75648536\n\nl = ['a','b','c']\nprint(id(l)) # 可变对象\n# 74842504\nl += 'd'\nprint(id(l))\n# 74842504\n```\n\n这个案列也就解释了上面坑2的原因，原因：对于可变对象，例子中的list， += 操作调用 `__iadd__` 方法，相当于 `a1 = a1.__iadd__([3])`，是直接在 a2(a1的引用)上面直接更新。而对于 +操作来说，会调用 `__add__` 方法，返回一个新的对象。所以对于可变对象来说 `a+=b` 是不等价于 `a=a+b` 的。\n\n好了，下面进入正题，如何复制一个对象。\n\n## 浅复制\n\nPython中对象之间的赋值是按引用传递的 (**敲黑板！**)\n\n标识一个对象唯一身份的是：对象的id(内存地址)，对象类型，对象值，而浅拷贝就是创建一个具有相同类型，相同值但不同id的新对象\n\n如果需要复制对象，可以使用标准库中的copy模块，copy.copy是浅复制，只会复制父对象，而不会复制对象内部的子对象；\n\n对于list对象，使用 list() 构造方法或者切片的方式，做的是浅复制，复制了外层容器，副本中的元素其实是源容器中元素的 **引用**\n\n``` python\nl1 = [3, [55, 44], (7, 8, 9)]\nl2 = list(l1)\n\nprint(id(l1), id(l2))\nprint(id(l1[1]), id(l2[1]))\n# 2148206816520 2148206718344\n# 2148206717768 2148206717768\n```\n\n![copyObject](http://7xkfga.com1.z0.glb.clouddn.com/copyObject.png)\n\n## 深复制\n\ncopy.deepcopy是深复制，会复制对象及其子对象。\n\n``` python\nimport copy\n\norigin_list = [0, 1, 2, [3, 4]]\ncopy_list = copy.copy(origin_list)\ndeepcopy_list = copy.deepcopy(origin_list)\n\norigin_list.append('hhh')\norigin_list[3].append('aaa')\n\nprint(origin_list, copy_list, deepcopy_list)\n```\n\n看了下面的引用关系，结果就猜不错了\n\n![deepcopyred](http://7xkfga.com1.z0.glb.clouddn.com/deepcopy_ref.png)\n\n在原列表后面添加一个元素，不会对复制的两个列表有影响；浅复制列表中最后一个元素是原列表最后一个元素的引用，所以添加一个元素也影响浅复制的列表。结果为\n\n```\norigin_list:   [0, 1, 2, [3, 4, 'aaa'], 'hhh']\ncopy_list:     [0, 1, 2, [3, 4, 'aaa']]\ndeepcopy_list: [0, 1, 2, [3, 4]]\n```\n","slug":"Python-«≥∏¥÷∆”Î…Ó∏¥÷∆","published":1,"updated":"2017-08-09T10:41:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3of0031zd68jg4f0gcp","content":"<blockquote>\n<p>Python中，万物皆对象。</p>\n</blockquote>\n<p>在介绍Python的浅复制和深复制之前，先来歪个楼，说明一下Python的可变对象和不可变对象。提到这里，有两个坑不得不拿出来说一下。</p>\n<h2 id=\"坑1：可变对象作为函数默认值\"><a href=\"#坑1：可变对象作为函数默认值\" class=\"headerlink\" title=\"坑1：可变对象作为函数默认值\"></a>坑1：可变对象作为函数默认值</h2><p>先介绍一个Python里面常见的坑：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">append_to_list</span><span class=\"params\">(value, def_list=[])</span>:</span></span><br><span class=\"line\">    def_list.append(value)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> def_list</span><br><span class=\"line\"></span><br><span class=\"line\">my_list = append_to_list(<span class=\"number\">1</span>)</span><br><span class=\"line\">my_other_list = append_to_list(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> my_other_list</span><br></pre></td></tr></table></figure>\n<p>这时候的输出是什么呢？</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2]</span><br></pre></td></tr></table></figure>\n<p>意不意外？惊不惊喜？ :) 为什么呢？这是因为这个默认值是在函数建立的时候就生成了, 每次调用都是用了这个对象的”缓存”。下面图表示第二次调用函数 <code>append_to_list</code>时候的引用状况：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/mutable_object_ref.png\" alt=\"ref_realtion\"></p>\n<p>这就是一条避坑指南：<strong>不要使用可变对象作为函数默认值</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">append_to_list</span><span class=\"params\">(value, def_list=None)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> def_list <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        def_list = []</span><br><span class=\"line\">    def_list.append(value)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> def_list</span><br></pre></td></tr></table></figure>\n<h2 id=\"坑2：list-的不同行为\"><a href=\"#坑2：list-的不同行为\" class=\"headerlink\" title=\"坑2：list += 的不同行为\"></a>坑2：list <code>+=</code> 的不同行为</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a1 = range(<span class=\"number\">3</span>)</span><br><span class=\"line\">a2 = a1</span><br><span class=\"line\">a2 += [<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">print</span> a1, a2</span><br><span class=\"line\"></span><br><span class=\"line\">a1 = range(<span class=\"number\">3</span>)</span><br><span class=\"line\">a3 = a1</span><br><span class=\"line\">a3 = a3 + [<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">print</span> a1, a3</span><br></pre></td></tr></table></figure>\n<p>你会发现第一段代码的结果a1和a2都为[0,1,2,3]，而第二段的代码a1为[0,1,2] a3为[0,1,2,3]。为什么两次会不同呢？上学时候老师不是说 <code>a+=b</code> 等价于 <code>a=a+b</code> 的吗？</p>\n<h2 id=\"可变和不可变数据类型\"><a href=\"#可变和不可变数据类型\" class=\"headerlink\" title=\"可变和不可变数据类型\"></a>可变和不可变数据类型</h2><p>Python中，对象分为可变(<code>mutable</code>)和不可变(<code>immutable</code>)两种类型</p>\n<ol>\n<li>字典型(dictionary)和列表型(list)的对象是可变对象</li>\n<li>元组（tuple)、数值型（number)、字符串(string)均为不可变对象</li>\n</ol>\n<p>下面验证一下这两种类型，可变对象一旦创建之后还可改变但是地址不会发生改变，即该变量指向的还是原来的对象。而不可变对象则相反，创建之后不能更改，如果更改则变量会指向一个新的对象。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'abc'</span> <span class=\"comment\"># 不可变对象</span></span><br><span class=\"line\">print(id(s))</span><br><span class=\"line\"><span class=\"comment\"># 45068120</span></span><br><span class=\"line\">s += <span class=\"string\">'d'</span></span><br><span class=\"line\">print(id(s))</span><br><span class=\"line\"><span class=\"comment\"># 75648536</span></span><br><span class=\"line\"></span><br><span class=\"line\">l = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>]</span><br><span class=\"line\">print(id(l)) <span class=\"comment\"># 可变对象</span></span><br><span class=\"line\"><span class=\"comment\"># 74842504</span></span><br><span class=\"line\">l += <span class=\"string\">'d'</span></span><br><span class=\"line\">print(id(l))</span><br><span class=\"line\"><span class=\"comment\"># 74842504</span></span><br></pre></td></tr></table></figure>\n<p>这个案列也就解释了上面坑2的原因，原因：对于可变对象，例子中的list， += 操作调用 <code>__iadd__</code> 方法，相当于 <code>a1 = a1.__iadd__([3])</code>，是直接在 a2(a1的引用)上面直接更新。而对于 +操作来说，会调用 <code>__add__</code> 方法，返回一个新的对象。所以对于可变对象来说 <code>a+=b</code> 是不等价于 <code>a=a+b</code> 的。</p>\n<p>好了，下面进入正题，如何复制一个对象。</p>\n<h2 id=\"浅复制\"><a href=\"#浅复制\" class=\"headerlink\" title=\"浅复制\"></a>浅复制</h2><p>Python中对象之间的赋值是按引用传递的 (<strong>敲黑板！</strong>)</p>\n<p>标识一个对象唯一身份的是：对象的id(内存地址)，对象类型，对象值，而浅拷贝就是创建一个具有相同类型，相同值但不同id的新对象</p>\n<p>如果需要复制对象，可以使用标准库中的copy模块，copy.copy是浅复制，只会复制父对象，而不会复制对象内部的子对象；</p>\n<p>对于list对象，使用 list() 构造方法或者切片的方式，做的是浅复制，复制了外层容器，副本中的元素其实是源容器中元素的 <strong>引用</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">l1 = [<span class=\"number\">3</span>, [<span class=\"number\">55</span>, <span class=\"number\">44</span>], (<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)]</span><br><span class=\"line\">l2 = list(l1)</span><br><span class=\"line\"></span><br><span class=\"line\">print(id(l1), id(l2))</span><br><span class=\"line\">print(id(l1[<span class=\"number\">1</span>]), id(l2[<span class=\"number\">1</span>]))</span><br><span class=\"line\"><span class=\"comment\"># 2148206816520 2148206718344</span></span><br><span class=\"line\"><span class=\"comment\"># 2148206717768 2148206717768</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/copyObject.png\" alt=\"copyObject\"></p>\n<h2 id=\"深复制\"><a href=\"#深复制\" class=\"headerlink\" title=\"深复制\"></a>深复制</h2><p>copy.deepcopy是深复制，会复制对象及其子对象。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\"></span><br><span class=\"line\">origin_list = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]</span><br><span class=\"line\">copy_list = copy.copy(origin_list)</span><br><span class=\"line\">deepcopy_list = copy.deepcopy(origin_list)</span><br><span class=\"line\"></span><br><span class=\"line\">origin_list.append(<span class=\"string\">'hhh'</span>)</span><br><span class=\"line\">origin_list[<span class=\"number\">3</span>].append(<span class=\"string\">'aaa'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(origin_list, copy_list, deepcopy_list)</span><br></pre></td></tr></table></figure>\n<p>看了下面的引用关系，结果就猜不错了</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/deepcopy_ref.png\" alt=\"deepcopyred\"></p>\n<p>在原列表后面添加一个元素，不会对复制的两个列表有影响；浅复制列表中最后一个元素是原列表最后一个元素的引用，所以添加一个元素也影响浅复制的列表。结果为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">origin_list:   [0, 1, 2, [3, 4, &apos;aaa&apos;], &apos;hhh&apos;]</span><br><span class=\"line\">copy_list:     [0, 1, 2, [3, 4, &apos;aaa&apos;]]</span><br><span class=\"line\">deepcopy_list: [0, 1, 2, [3, 4]]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Python中，万物皆对象。</p>\n</blockquote>\n<p>在介绍Python的浅复制和深复制之前，先来歪个楼，说明一下Python的可变对象和不可变对象。提到这里，有两个坑不得不拿出来说一下。</p>\n<h2 id=\"坑1：可变对象作为函数默认值\"><a href=\"#坑1：可变对象作为函数默认值\" class=\"headerlink\" title=\"坑1：可变对象作为函数默认值\"></a>坑1：可变对象作为函数默认值</h2><p>先介绍一个Python里面常见的坑：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">append_to_list</span><span class=\"params\">(value, def_list=[])</span>:</span></span><br><span class=\"line\">    def_list.append(value)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> def_list</span><br><span class=\"line\"></span><br><span class=\"line\">my_list = append_to_list(<span class=\"number\">1</span>)</span><br><span class=\"line\">my_other_list = append_to_list(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> my_other_list</span><br></pre></td></tr></table></figure>\n<p>这时候的输出是什么呢？</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2]</span><br></pre></td></tr></table></figure>\n<p>意不意外？惊不惊喜？ :) 为什么呢？这是因为这个默认值是在函数建立的时候就生成了, 每次调用都是用了这个对象的”缓存”。下面图表示第二次调用函数 <code>append_to_list</code>时候的引用状况：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/mutable_object_ref.png\" alt=\"ref_realtion\"></p>\n<p>这就是一条避坑指南：<strong>不要使用可变对象作为函数默认值</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">append_to_list</span><span class=\"params\">(value, def_list=None)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> def_list <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        def_list = []</span><br><span class=\"line\">    def_list.append(value)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> def_list</span><br></pre></td></tr></table></figure>\n<h2 id=\"坑2：list-的不同行为\"><a href=\"#坑2：list-的不同行为\" class=\"headerlink\" title=\"坑2：list += 的不同行为\"></a>坑2：list <code>+=</code> 的不同行为</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a1 = range(<span class=\"number\">3</span>)</span><br><span class=\"line\">a2 = a1</span><br><span class=\"line\">a2 += [<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">print</span> a1, a2</span><br><span class=\"line\"></span><br><span class=\"line\">a1 = range(<span class=\"number\">3</span>)</span><br><span class=\"line\">a3 = a1</span><br><span class=\"line\">a3 = a3 + [<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">print</span> a1, a3</span><br></pre></td></tr></table></figure>\n<p>你会发现第一段代码的结果a1和a2都为[0,1,2,3]，而第二段的代码a1为[0,1,2] a3为[0,1,2,3]。为什么两次会不同呢？上学时候老师不是说 <code>a+=b</code> 等价于 <code>a=a+b</code> 的吗？</p>\n<h2 id=\"可变和不可变数据类型\"><a href=\"#可变和不可变数据类型\" class=\"headerlink\" title=\"可变和不可变数据类型\"></a>可变和不可变数据类型</h2><p>Python中，对象分为可变(<code>mutable</code>)和不可变(<code>immutable</code>)两种类型</p>\n<ol>\n<li>字典型(dictionary)和列表型(list)的对象是可变对象</li>\n<li>元组（tuple)、数值型（number)、字符串(string)均为不可变对象</li>\n</ol>\n<p>下面验证一下这两种类型，可变对象一旦创建之后还可改变但是地址不会发生改变，即该变量指向的还是原来的对象。而不可变对象则相反，创建之后不能更改，如果更改则变量会指向一个新的对象。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'abc'</span> <span class=\"comment\"># 不可变对象</span></span><br><span class=\"line\">print(id(s))</span><br><span class=\"line\"><span class=\"comment\"># 45068120</span></span><br><span class=\"line\">s += <span class=\"string\">'d'</span></span><br><span class=\"line\">print(id(s))</span><br><span class=\"line\"><span class=\"comment\"># 75648536</span></span><br><span class=\"line\"></span><br><span class=\"line\">l = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>]</span><br><span class=\"line\">print(id(l)) <span class=\"comment\"># 可变对象</span></span><br><span class=\"line\"><span class=\"comment\"># 74842504</span></span><br><span class=\"line\">l += <span class=\"string\">'d'</span></span><br><span class=\"line\">print(id(l))</span><br><span class=\"line\"><span class=\"comment\"># 74842504</span></span><br></pre></td></tr></table></figure>\n<p>这个案列也就解释了上面坑2的原因，原因：对于可变对象，例子中的list， += 操作调用 <code>__iadd__</code> 方法，相当于 <code>a1 = a1.__iadd__([3])</code>，是直接在 a2(a1的引用)上面直接更新。而对于 +操作来说，会调用 <code>__add__</code> 方法，返回一个新的对象。所以对于可变对象来说 <code>a+=b</code> 是不等价于 <code>a=a+b</code> 的。</p>\n<p>好了，下面进入正题，如何复制一个对象。</p>\n<h2 id=\"浅复制\"><a href=\"#浅复制\" class=\"headerlink\" title=\"浅复制\"></a>浅复制</h2><p>Python中对象之间的赋值是按引用传递的 (<strong>敲黑板！</strong>)</p>\n<p>标识一个对象唯一身份的是：对象的id(内存地址)，对象类型，对象值，而浅拷贝就是创建一个具有相同类型，相同值但不同id的新对象</p>\n<p>如果需要复制对象，可以使用标准库中的copy模块，copy.copy是浅复制，只会复制父对象，而不会复制对象内部的子对象；</p>\n<p>对于list对象，使用 list() 构造方法或者切片的方式，做的是浅复制，复制了外层容器，副本中的元素其实是源容器中元素的 <strong>引用</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">l1 = [<span class=\"number\">3</span>, [<span class=\"number\">55</span>, <span class=\"number\">44</span>], (<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)]</span><br><span class=\"line\">l2 = list(l1)</span><br><span class=\"line\"></span><br><span class=\"line\">print(id(l1), id(l2))</span><br><span class=\"line\">print(id(l1[<span class=\"number\">1</span>]), id(l2[<span class=\"number\">1</span>]))</span><br><span class=\"line\"><span class=\"comment\"># 2148206816520 2148206718344</span></span><br><span class=\"line\"><span class=\"comment\"># 2148206717768 2148206717768</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/copyObject.png\" alt=\"copyObject\"></p>\n<h2 id=\"深复制\"><a href=\"#深复制\" class=\"headerlink\" title=\"深复制\"></a>深复制</h2><p>copy.deepcopy是深复制，会复制对象及其子对象。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\"></span><br><span class=\"line\">origin_list = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]</span><br><span class=\"line\">copy_list = copy.copy(origin_list)</span><br><span class=\"line\">deepcopy_list = copy.deepcopy(origin_list)</span><br><span class=\"line\"></span><br><span class=\"line\">origin_list.append(<span class=\"string\">'hhh'</span>)</span><br><span class=\"line\">origin_list[<span class=\"number\">3</span>].append(<span class=\"string\">'aaa'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(origin_list, copy_list, deepcopy_list)</span><br></pre></td></tr></table></figure>\n<p>看了下面的引用关系，结果就猜不错了</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/deepcopy_ref.png\" alt=\"deepcopyred\"></p>\n<p>在原列表后面添加一个元素，不会对复制的两个列表有影响；浅复制列表中最后一个元素是原列表最后一个元素的引用，所以添加一个元素也影响浅复制的列表。结果为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">origin_list:   [0, 1, 2, [3, 4, &apos;aaa&apos;], &apos;hhh&apos;]</span><br><span class=\"line\">copy_list:     [0, 1, 2, [3, 4, &apos;aaa&apos;]]</span><br><span class=\"line\">deepcopy_list: [0, 1, 2, [3, 4]]</span><br></pre></td></tr></table></figure>"},{"title":"(转)Python基础知识面试题","date":"2017-06-12T09:27:09.000Z","_content":"\n\n下面总结了一下常见的、易错的Python面试题\n\n\n\n## Question 1\n\n如下代码的输出是什么\n\n```python\ndef extendList(val, list=[]):\n    list.append(val)\n    return list\n\nlist1 = extendList(10)\nlist2 = extendList(123,[])\nlist3 = extendList('a')\n\nprint \"list1 = %s\" % list1\nprint \"list2 = %s\" % list2\nprint \"list3 = %s\" % list3\n```\n\n<!-- more -->\n\n### 答案：\n\n```\nlist1 = [10, 'a']\nlist2 = [123]\nlist3 = [10, 'a']\n```\n\n<!-- more -->\n\n### 解释\n\nThe new default list is created only once when the function is defined, and that same list is then used subsequently whenever extendList is invoked without a list argument being specified. This is because expressions in default arguments are calculated when the function is defined, not when it’s called.\n\nlist1 and list3 are therefore operating on the same default list, whereas list2 is operating on a separate list that it created (by passing its own empty list as the value for the list parameter).\n\nThe definition of the extendList function could be modified as follows, though, to always begin a new list when no list argument is specified, which is more likely to have been the desired behavior:\n\n``` python\ndef extendList(val, list=None):\n    if list is None: \n        list = []\n    list.append(val)\n    return list\n\n# list1 = [10]\n# list2 = [123]\n# list3 = ['a']\n```\n\n## Python的函数参数传递\n\n``` python\na = 1\ndef fun(a):\n    a = 2\nfun(a)\nprint a  # 1\n\na = []\ndef fun(a):\n    a.append(1)\nfun(a)\nprint a  # [1]\n```\n\n类型是属于对象的，而不是变量。而对象有两种, 可更改 (mutable) 与 不可更改(immutable)对象。在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改。\n\n## Question 2\n\n下面代码输出\n\n``` python\ndef multipliers():\n    return [lambda x : i * x for i in range(4)]\n    \nprint [m(2) for m in multipliers()]\n```\n\nThe output of the above code will be `[6, 6, 6, 6]` (not `[0, 2, 4, 6]`).\n\nThe reason for this is that Python’s closures are late binding. This means that the values of variables used in closures are looked up at the time the inner function is called. So as a result, when any of the functions returned by multipliers() are called, the value of i is looked up in the surrounding scope at that time. By then, regardless of which of the returned functions is called, the for loop has completed and i is left with its final value of 3. Therefore, every returned function multiplies the value it is passed by 3, so since a value of 2 is passed in the above code, they all return a value of 6 (i.e., 3 x 2).\n\n(Incidentally, as pointed out in The Hitchhiker’s Guide to Python, there is a somewhat widespread misconception that this has something to do with lambdas, which is not the case. Functions created with a lambda expression are in no way special and the same behavior is exhibited by functions created using an ordinary def.)\n\nBelow are a few examples of ways to circumvent this issue.\n\nOne solution would be use a Python generator as follows:\n\n``` python\ndef multipliers():\n    for i in range(4):\n        yield lambda x : i * x\n```\n\nAnother solution is to create a closure that binds immediately to its arguments by using a default argument. For example:\n\n``` python\ndef multipliers():\n    return [lambda x, i=i : i * x for i in range(4)]\n```\n\nOr alternatively, you can use the `functools.partial` function:\n\n``` python\nfrom functools import partial\nfrom operator import mul\n\ndef multipliers():\n    return [partial(mul, i) for i in range(4)]\n```\n\n## 迭代器和生成器\n\n\n\n## Question 3\n\n``` python\nclass Parent(object):\n    x = 1\n\nclass Child1(Parent):\n    pass\n\nclass Child2(Parent):\n    pass\n\nprint Parent.x, Child1.x, Child2.x\nChild1.x = 2\nprint Parent.x, Child1.x, Child2.x\nParent.x = 3\nprint Parent.x, Child1.x, Child2.x\n\n# 1, 1, 1\n# 2, 1, 2\n# 3, 2, 3\n```\n\n### 解释\n\nin Python, class variables are internally handled as dictionaries. If a variable name is not found in the dictionary of the current class, the class hierarchy (i.e., its parent classes) are searched until the referenced variable name is found (if the referenced variable name is not found in the class itself or anywhere in its hierarchy, an AttributeError occurs).\n\nTherefore, setting x = 1 in the Parent class makes the class variable x (with a value of 1) referenceable in that class and any of its children. That’s why the first print statement outputs 1 1 1.\n\nSubsequently, **if any of its child classes overrides that value (for example, when we execute the statement Child1.x = 2), then the value is changed in that child only**. That’s why the second print statement outputs 1 2 1.\n\nFinally, **if the value is then changed in the Parent (for example, when we execute the statement Parent.x = 3), that change is reflected also by any children that have not yet overridden the value** (which in this case would be Child2). That’s why the third print statement outputs 3 2 3.\n\n\n## Question 4\n\n在 Python2 中下面代码输出是什么\n\n``` python\ndef div1(x,y):\n    print \"%s/%s = %s\" % (x, y, x/y)\n    \ndef div2(x,y):\n    print \"%s//%s = %s\" % (x, y, x//y)\n\ndiv1(5,2)\ndiv1(5.,2)\ndiv2(5,2)\ndiv2(5.,2.)\n\n# 5/2 = 2\n# 5.0/2 = 2.5\n# 5//2 = 2\n# 5.0//2.0 = 2.0\n```\n\nBy default, Python 2 automatically performs integer arithmetic if both operands are integers. As a result, 5/2 yields 2, while 5./2 yields 2.5.\n\nNote that you can override this behavior in Python 2 by adding the following import:\n\n``` python \nfrom __future__ import division\n```\n\nAlso note that the “double-slash” (//) operator will always perform integer division, regardless of the operand types. That’s why 5.0//2.0 yields 2.0 even in Python 2.\n\nPython 3, however, does not have this behavior; i.e., it does not perform integer arithmetic if both operands are integers. Therefore, in Python 3, the output will be as follows:\n\n```\n5/2 = 2.5\n5.0/2 = 2.5\n5//2 = 2\n5.0//2.0 = 2.0\n```\n\n## Question 5\n\n``` python\nlist = ['a', 'b', 'c', 'd', 'e']\nprint list[10:]\n\n# []\n```\n\n输出为空list, 不会报 `IndexError`错误\n\nAs one would expect, attempting to access a member of a list using an index that exceeds the number of members (e.g., attempting to access list[10] in the list above) results in an IndexError. However, attempting to access a slice of a list at a starting index that exceeds the number of members in the list will not result in an IndexError and will simply return an empty list.\n\nWhat makes this a particularly nasty gotcha is that it can lead to bugs that are really hard to track down since no error is raised at runtime.\n\n## Question 6\n\n``` python\nlist = [ [] ] * 5\nlist  # output?\nlist[0].append(10)\nlist  # output?\nlist[1].append(20)\nlist  # output?\nlist.append(30)\nlist  # output?\n```\n\n### 答案\n\n```\n[[], [], [], [], []]\n[[10], [10], [10], [10], [10]]\n[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]\n[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]\n```\n\nlist = [ [ ] ] * 5 simply creates a list of 5 lists.\n\nHowever, the key thing to understand here is that the **statement list = [ [ ] ] * 5 does NOT create a list containing 5 distinct lists; rather, it creates a a list of 5 references to the same list**\n\n``` python\nprint id(list[0]) == id(list[1])\n# True\n```\n\n`list[0].append(10)` appends 10 to the first list. But since all 5 lists refer to the same list, the output is: [[10], [10], [10], [10], [10]].\n\nSimilarly, `list[1].append(20)` appends 20 to the second list. But again, since all 5 lists refer to the same list, the output is now: [[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]].\n\nIn contrast, `list.append(30)` is appending an entirely new element to the “outer” list, which therefore yields the output: [[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30].\n\n\n## Question 7\n\nGiven a list of N numbers, use a single list comprehension to produce a new list that only contains those values that are:\n\n1. even numbers, and\n2. from elements in the original list that had even indices\n\n### 答案\n\n``` python\n#        0   1   2   3    4    5    6    7    8\nlist = [ 1 , 3 , 5 , 8 , 10 , 13 , 18 , 36 , 78 ]\n\nprint [x for x in list[::2] if x%2==0]\n# [10, 18, 78]\n```\n\n\n## `*args` and `**kwargs`\n\n当你不确定你的函数里将要传递多少参数时你可以用*args.例如,它可以传递任意数量的参数:\n\n``` python\ndef print_everything(*args):\n    for count, thing in enumerate(args):\n        print '{0}. {1}'.format(count, thing)\n\nprint_everything('apple', 'banana', 'cabbage')\n# 0. apple\n# 1. banana\n# 2. cabbage\n```\n\n相似的, `**kwargs`允许你使用没有事先定义的参数名:\n\n``` python\ndef table_things(**kwargs):\n    for name, value in kwargs.items():\n        print '{0} = {1}'.format(name, value)\n\ntable_things(apple = 'fruit', cabbage = 'vegetable')\n# cabbage = vegetable\n# apple = fruit\n```\n\n你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给*args和**kwargs.命名参数在列表的最前端.例如:\n\ndef table_things(titlestring, **kwargs)\n*args和**kwargs可以同时在函数的定义中,但是*args必须在**kwargs前面.\n\n当调用函数时你也可以用*和**语法.例如:\n\n``` python\ndef print_three_things(a, b, c):\n    print 'a = {0}, b = {1}, c = {2}'.format(a,b,c)\n\nmylist = ['aardvark', 'baboon', 'cat']\nprint_three_things(*mylist)\n\na = aardvark, b = baboon, c = cat\n```\n\n## Python里的拷贝\n\n引用和copy(),deepcopy()的区别\n\n``` python\nimport copy\na = [1, 2, 3, 4, ['a', 'b']]  #原始对象\n\nb = a  #赋值，传对象的引用\nc = copy.copy(a)  #对象拷贝，浅拷贝\nd = copy.deepcopy(a)  #对象拷贝，深拷贝\n\na.append(5)  #修改对象a\na[4].append('c')  #修改对象a中的['a', 'b']数组对象\n\nprint 'a = ', a\nprint 'b = ', b\nprint 'c = ', c\nprint 'd = ', d\n\n# 输出结果：\n# a =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]\n# b =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]\n# c =  [1, 2, 3, 4, ['a', 'b', 'c']]\n# d =  [1, 2, 3, 4, ['a', 'b']]\n```","source":"_posts/Pythonª˘¥°÷™ ∂√Ê ‘Ã‚.md","raw":"---\ntitle: (转)Python基础知识面试题\ntags:\n  - 面试\ndate: 2017-06-12 17:27:09\n---\n\n\n下面总结了一下常见的、易错的Python面试题\n\n\n\n## Question 1\n\n如下代码的输出是什么\n\n```python\ndef extendList(val, list=[]):\n    list.append(val)\n    return list\n\nlist1 = extendList(10)\nlist2 = extendList(123,[])\nlist3 = extendList('a')\n\nprint \"list1 = %s\" % list1\nprint \"list2 = %s\" % list2\nprint \"list3 = %s\" % list3\n```\n\n<!-- more -->\n\n### 答案：\n\n```\nlist1 = [10, 'a']\nlist2 = [123]\nlist3 = [10, 'a']\n```\n\n<!-- more -->\n\n### 解释\n\nThe new default list is created only once when the function is defined, and that same list is then used subsequently whenever extendList is invoked without a list argument being specified. This is because expressions in default arguments are calculated when the function is defined, not when it’s called.\n\nlist1 and list3 are therefore operating on the same default list, whereas list2 is operating on a separate list that it created (by passing its own empty list as the value for the list parameter).\n\nThe definition of the extendList function could be modified as follows, though, to always begin a new list when no list argument is specified, which is more likely to have been the desired behavior:\n\n``` python\ndef extendList(val, list=None):\n    if list is None: \n        list = []\n    list.append(val)\n    return list\n\n# list1 = [10]\n# list2 = [123]\n# list3 = ['a']\n```\n\n## Python的函数参数传递\n\n``` python\na = 1\ndef fun(a):\n    a = 2\nfun(a)\nprint a  # 1\n\na = []\ndef fun(a):\n    a.append(1)\nfun(a)\nprint a  # [1]\n```\n\n类型是属于对象的，而不是变量。而对象有两种, 可更改 (mutable) 与 不可更改(immutable)对象。在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改。\n\n## Question 2\n\n下面代码输出\n\n``` python\ndef multipliers():\n    return [lambda x : i * x for i in range(4)]\n    \nprint [m(2) for m in multipliers()]\n```\n\nThe output of the above code will be `[6, 6, 6, 6]` (not `[0, 2, 4, 6]`).\n\nThe reason for this is that Python’s closures are late binding. This means that the values of variables used in closures are looked up at the time the inner function is called. So as a result, when any of the functions returned by multipliers() are called, the value of i is looked up in the surrounding scope at that time. By then, regardless of which of the returned functions is called, the for loop has completed and i is left with its final value of 3. Therefore, every returned function multiplies the value it is passed by 3, so since a value of 2 is passed in the above code, they all return a value of 6 (i.e., 3 x 2).\n\n(Incidentally, as pointed out in The Hitchhiker’s Guide to Python, there is a somewhat widespread misconception that this has something to do with lambdas, which is not the case. Functions created with a lambda expression are in no way special and the same behavior is exhibited by functions created using an ordinary def.)\n\nBelow are a few examples of ways to circumvent this issue.\n\nOne solution would be use a Python generator as follows:\n\n``` python\ndef multipliers():\n    for i in range(4):\n        yield lambda x : i * x\n```\n\nAnother solution is to create a closure that binds immediately to its arguments by using a default argument. For example:\n\n``` python\ndef multipliers():\n    return [lambda x, i=i : i * x for i in range(4)]\n```\n\nOr alternatively, you can use the `functools.partial` function:\n\n``` python\nfrom functools import partial\nfrom operator import mul\n\ndef multipliers():\n    return [partial(mul, i) for i in range(4)]\n```\n\n## 迭代器和生成器\n\n\n\n## Question 3\n\n``` python\nclass Parent(object):\n    x = 1\n\nclass Child1(Parent):\n    pass\n\nclass Child2(Parent):\n    pass\n\nprint Parent.x, Child1.x, Child2.x\nChild1.x = 2\nprint Parent.x, Child1.x, Child2.x\nParent.x = 3\nprint Parent.x, Child1.x, Child2.x\n\n# 1, 1, 1\n# 2, 1, 2\n# 3, 2, 3\n```\n\n### 解释\n\nin Python, class variables are internally handled as dictionaries. If a variable name is not found in the dictionary of the current class, the class hierarchy (i.e., its parent classes) are searched until the referenced variable name is found (if the referenced variable name is not found in the class itself or anywhere in its hierarchy, an AttributeError occurs).\n\nTherefore, setting x = 1 in the Parent class makes the class variable x (with a value of 1) referenceable in that class and any of its children. That’s why the first print statement outputs 1 1 1.\n\nSubsequently, **if any of its child classes overrides that value (for example, when we execute the statement Child1.x = 2), then the value is changed in that child only**. That’s why the second print statement outputs 1 2 1.\n\nFinally, **if the value is then changed in the Parent (for example, when we execute the statement Parent.x = 3), that change is reflected also by any children that have not yet overridden the value** (which in this case would be Child2). That’s why the third print statement outputs 3 2 3.\n\n\n## Question 4\n\n在 Python2 中下面代码输出是什么\n\n``` python\ndef div1(x,y):\n    print \"%s/%s = %s\" % (x, y, x/y)\n    \ndef div2(x,y):\n    print \"%s//%s = %s\" % (x, y, x//y)\n\ndiv1(5,2)\ndiv1(5.,2)\ndiv2(5,2)\ndiv2(5.,2.)\n\n# 5/2 = 2\n# 5.0/2 = 2.5\n# 5//2 = 2\n# 5.0//2.0 = 2.0\n```\n\nBy default, Python 2 automatically performs integer arithmetic if both operands are integers. As a result, 5/2 yields 2, while 5./2 yields 2.5.\n\nNote that you can override this behavior in Python 2 by adding the following import:\n\n``` python \nfrom __future__ import division\n```\n\nAlso note that the “double-slash” (//) operator will always perform integer division, regardless of the operand types. That’s why 5.0//2.0 yields 2.0 even in Python 2.\n\nPython 3, however, does not have this behavior; i.e., it does not perform integer arithmetic if both operands are integers. Therefore, in Python 3, the output will be as follows:\n\n```\n5/2 = 2.5\n5.0/2 = 2.5\n5//2 = 2\n5.0//2.0 = 2.0\n```\n\n## Question 5\n\n``` python\nlist = ['a', 'b', 'c', 'd', 'e']\nprint list[10:]\n\n# []\n```\n\n输出为空list, 不会报 `IndexError`错误\n\nAs one would expect, attempting to access a member of a list using an index that exceeds the number of members (e.g., attempting to access list[10] in the list above) results in an IndexError. However, attempting to access a slice of a list at a starting index that exceeds the number of members in the list will not result in an IndexError and will simply return an empty list.\n\nWhat makes this a particularly nasty gotcha is that it can lead to bugs that are really hard to track down since no error is raised at runtime.\n\n## Question 6\n\n``` python\nlist = [ [] ] * 5\nlist  # output?\nlist[0].append(10)\nlist  # output?\nlist[1].append(20)\nlist  # output?\nlist.append(30)\nlist  # output?\n```\n\n### 答案\n\n```\n[[], [], [], [], []]\n[[10], [10], [10], [10], [10]]\n[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]\n[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]\n```\n\nlist = [ [ ] ] * 5 simply creates a list of 5 lists.\n\nHowever, the key thing to understand here is that the **statement list = [ [ ] ] * 5 does NOT create a list containing 5 distinct lists; rather, it creates a a list of 5 references to the same list**\n\n``` python\nprint id(list[0]) == id(list[1])\n# True\n```\n\n`list[0].append(10)` appends 10 to the first list. But since all 5 lists refer to the same list, the output is: [[10], [10], [10], [10], [10]].\n\nSimilarly, `list[1].append(20)` appends 20 to the second list. But again, since all 5 lists refer to the same list, the output is now: [[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]].\n\nIn contrast, `list.append(30)` is appending an entirely new element to the “outer” list, which therefore yields the output: [[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30].\n\n\n## Question 7\n\nGiven a list of N numbers, use a single list comprehension to produce a new list that only contains those values that are:\n\n1. even numbers, and\n2. from elements in the original list that had even indices\n\n### 答案\n\n``` python\n#        0   1   2   3    4    5    6    7    8\nlist = [ 1 , 3 , 5 , 8 , 10 , 13 , 18 , 36 , 78 ]\n\nprint [x for x in list[::2] if x%2==0]\n# [10, 18, 78]\n```\n\n\n## `*args` and `**kwargs`\n\n当你不确定你的函数里将要传递多少参数时你可以用*args.例如,它可以传递任意数量的参数:\n\n``` python\ndef print_everything(*args):\n    for count, thing in enumerate(args):\n        print '{0}. {1}'.format(count, thing)\n\nprint_everything('apple', 'banana', 'cabbage')\n# 0. apple\n# 1. banana\n# 2. cabbage\n```\n\n相似的, `**kwargs`允许你使用没有事先定义的参数名:\n\n``` python\ndef table_things(**kwargs):\n    for name, value in kwargs.items():\n        print '{0} = {1}'.format(name, value)\n\ntable_things(apple = 'fruit', cabbage = 'vegetable')\n# cabbage = vegetable\n# apple = fruit\n```\n\n你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给*args和**kwargs.命名参数在列表的最前端.例如:\n\ndef table_things(titlestring, **kwargs)\n*args和**kwargs可以同时在函数的定义中,但是*args必须在**kwargs前面.\n\n当调用函数时你也可以用*和**语法.例如:\n\n``` python\ndef print_three_things(a, b, c):\n    print 'a = {0}, b = {1}, c = {2}'.format(a,b,c)\n\nmylist = ['aardvark', 'baboon', 'cat']\nprint_three_things(*mylist)\n\na = aardvark, b = baboon, c = cat\n```\n\n## Python里的拷贝\n\n引用和copy(),deepcopy()的区别\n\n``` python\nimport copy\na = [1, 2, 3, 4, ['a', 'b']]  #原始对象\n\nb = a  #赋值，传对象的引用\nc = copy.copy(a)  #对象拷贝，浅拷贝\nd = copy.deepcopy(a)  #对象拷贝，深拷贝\n\na.append(5)  #修改对象a\na[4].append('c')  #修改对象a中的['a', 'b']数组对象\n\nprint 'a = ', a\nprint 'b = ', b\nprint 'c = ', c\nprint 'd = ', d\n\n# 输出结果：\n# a =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]\n# b =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]\n# c =  [1, 2, 3, 4, ['a', 'b', 'c']]\n# d =  [1, 2, 3, 4, ['a', 'b']]\n```","slug":"Pythonª˘¥°÷™ ∂√Ê ‘Ã‚","published":1,"updated":"2017-06-16T07:51:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3oh0035zd68ksy0430p","content":"<p>下面总结了一下常见的、易错的Python面试题</p>\n<h2 id=\"Question-1\"><a href=\"#Question-1\" class=\"headerlink\" title=\"Question 1\"></a>Question 1</h2><p>如下代码的输出是什么</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">extendList</span><span class=\"params\">(val, list=[])</span>:</span></span><br><span class=\"line\">    list.append(val)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list</span><br><span class=\"line\"></span><br><span class=\"line\">list1 = extendList(<span class=\"number\">10</span>)</span><br><span class=\"line\">list2 = extendList(<span class=\"number\">123</span>,[])</span><br><span class=\"line\">list3 = extendList(<span class=\"string\">'a'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"list1 = %s\"</span> % list1</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"list2 = %s\"</span> % list2</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"list3 = %s\"</span> % list3</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"答案：\"><a href=\"#答案：\" class=\"headerlink\" title=\"答案：\"></a>答案：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 = [10, &apos;a&apos;]</span><br><span class=\"line\">list2 = [123]</span><br><span class=\"line\">list3 = [10, &apos;a&apos;]</span><br></pre></td></tr></table></figure>\n<!-- more -->\n<h3 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h3><p>The new default list is created only once when the function is defined, and that same list is then used subsequently whenever extendList is invoked without a list argument being specified. This is because expressions in default arguments are calculated when the function is defined, not when it’s called.</p>\n<p>list1 and list3 are therefore operating on the same default list, whereas list2 is operating on a separate list that it created (by passing its own empty list as the value for the list parameter).</p>\n<p>The definition of the extendList function could be modified as follows, though, to always begin a new list when no list argument is specified, which is more likely to have been the desired behavior:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">extendList</span><span class=\"params\">(val, list=None)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> list <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>: </span><br><span class=\"line\">        list = []</span><br><span class=\"line\">    list.append(val)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># list1 = [10]</span></span><br><span class=\"line\"><span class=\"comment\"># list2 = [123]</span></span><br><span class=\"line\"><span class=\"comment\"># list3 = ['a']</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Python的函数参数传递\"><a href=\"#Python的函数参数传递\" class=\"headerlink\" title=\"Python的函数参数传递\"></a>Python的函数参数传递</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun</span><span class=\"params\">(a)</span>:</span></span><br><span class=\"line\">    a = <span class=\"number\">2</span></span><br><span class=\"line\">fun(a)</span><br><span class=\"line\"><span class=\"keyword\">print</span> a  <span class=\"comment\"># 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = []</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun</span><span class=\"params\">(a)</span>:</span></span><br><span class=\"line\">    a.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">fun(a)</span><br><span class=\"line\"><span class=\"keyword\">print</span> a  <span class=\"comment\"># [1]</span></span><br></pre></td></tr></table></figure>\n<p>类型是属于对象的，而不是变量。而对象有两种, 可更改 (mutable) 与 不可更改(immutable)对象。在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改。</p>\n<h2 id=\"Question-2\"><a href=\"#Question-2\" class=\"headerlink\" title=\"Question 2\"></a>Question 2</h2><p>下面代码输出</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multipliers</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">lambda</span> x : i * x <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>)]</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">print</span> [m(<span class=\"number\">2</span>) <span class=\"keyword\">for</span> m <span class=\"keyword\">in</span> multipliers()]</span><br></pre></td></tr></table></figure>\n<p>The output of the above code will be <code>[6, 6, 6, 6]</code> (not <code>[0, 2, 4, 6]</code>).</p>\n<p>The reason for this is that Python’s closures are late binding. This means that the values of variables used in closures are looked up at the time the inner function is called. So as a result, when any of the functions returned by multipliers() are called, the value of i is looked up in the surrounding scope at that time. By then, regardless of which of the returned functions is called, the for loop has completed and i is left with its final value of 3. Therefore, every returned function multiplies the value it is passed by 3, so since a value of 2 is passed in the above code, they all return a value of 6 (i.e., 3 x 2).</p>\n<p>(Incidentally, as pointed out in The Hitchhiker’s Guide to Python, there is a somewhat widespread misconception that this has something to do with lambdas, which is not the case. Functions created with a lambda expression are in no way special and the same behavior is exhibited by functions created using an ordinary def.)</p>\n<p>Below are a few examples of ways to circumvent this issue.</p>\n<p>One solution would be use a Python generator as follows:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multipliers</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"keyword\">lambda</span> x : i * x</span><br></pre></td></tr></table></figure>\n<p>Another solution is to create a closure that binds immediately to its arguments by using a default argument. For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multipliers</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">lambda</span> x, i=i : i * x <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>)]</span><br></pre></td></tr></table></figure>\n<p>Or alternatively, you can use the <code>functools.partial</code> function:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> partial</span><br><span class=\"line\"><span class=\"keyword\">from</span> operator <span class=\"keyword\">import</span> mul</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multipliers</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [partial(mul, i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>)]</span><br></pre></td></tr></table></figure>\n<h2 id=\"迭代器和生成器\"><a href=\"#迭代器和生成器\" class=\"headerlink\" title=\"迭代器和生成器\"></a>迭代器和生成器</h2><h2 id=\"Question-3\"><a href=\"#Question-3\" class=\"headerlink\" title=\"Question 3\"></a>Question 3</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    x = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child1</span><span class=\"params\">(Parent)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child2</span><span class=\"params\">(Parent)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> Parent.x, Child1.x, Child2.x</span><br><span class=\"line\">Child1.x = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> Parent.x, Child1.x, Child2.x</span><br><span class=\"line\">Parent.x = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> Parent.x, Child1.x, Child2.x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1, 1, 1</span></span><br><span class=\"line\"><span class=\"comment\"># 2, 1, 2</span></span><br><span class=\"line\"><span class=\"comment\"># 3, 2, 3</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"解释-1\"><a href=\"#解释-1\" class=\"headerlink\" title=\"解释\"></a>解释</h3><p>in Python, class variables are internally handled as dictionaries. If a variable name is not found in the dictionary of the current class, the class hierarchy (i.e., its parent classes) are searched until the referenced variable name is found (if the referenced variable name is not found in the class itself or anywhere in its hierarchy, an AttributeError occurs).</p>\n<p>Therefore, setting x = 1 in the Parent class makes the class variable x (with a value of 1) referenceable in that class and any of its children. That’s why the first print statement outputs 1 1 1.</p>\n<p>Subsequently, <strong>if any of its child classes overrides that value (for example, when we execute the statement Child1.x = 2), then the value is changed in that child only</strong>. That’s why the second print statement outputs 1 2 1.</p>\n<p>Finally, <strong>if the value is then changed in the Parent (for example, when we execute the statement Parent.x = 3), that change is reflected also by any children that have not yet overridden the value</strong> (which in this case would be Child2). That’s why the third print statement outputs 3 2 3.</p>\n<h2 id=\"Question-4\"><a href=\"#Question-4\" class=\"headerlink\" title=\"Question 4\"></a>Question 4</h2><p>在 Python2 中下面代码输出是什么</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">div1</span><span class=\"params\">(x,y)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"%s/%s = %s\"</span> % (x, y, x/y)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">div2</span><span class=\"params\">(x,y)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"%s//%s = %s\"</span> % (x, y, x//y)</span><br><span class=\"line\"></span><br><span class=\"line\">div1(<span class=\"number\">5</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">div1(<span class=\"number\">5.</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">div2(<span class=\"number\">5</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">div2(<span class=\"number\">5.</span>,<span class=\"number\">2.</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5/2 = 2</span></span><br><span class=\"line\"><span class=\"comment\"># 5.0/2 = 2.5</span></span><br><span class=\"line\"><span class=\"comment\"># 5//2 = 2</span></span><br><span class=\"line\"><span class=\"comment\"># 5.0//2.0 = 2.0</span></span><br></pre></td></tr></table></figure>\n<p>By default, Python 2 automatically performs integer arithmetic if both operands are integers. As a result, 5/2 yields 2, while 5./2 yields 2.5.</p>\n<p>Note that you can override this behavior in Python 2 by adding the following import:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> __future__ <span class=\"keyword\">import</span> division</span><br></pre></td></tr></table></figure>\n<p>Also note that the “double-slash” (//) operator will always perform integer division, regardless of the operand types. That’s why 5.0//2.0 yields 2.0 even in Python 2.</p>\n<p>Python 3, however, does not have this behavior; i.e., it does not perform integer arithmetic if both operands are integers. Therefore, in Python 3, the output will be as follows:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5/2 = 2.5</span><br><span class=\"line\">5.0/2 = 2.5</span><br><span class=\"line\">5//2 = 2</span><br><span class=\"line\">5.0//2.0 = 2.0</span><br></pre></td></tr></table></figure>\n<h2 id=\"Question-5\"><a href=\"#Question-5\" class=\"headerlink\" title=\"Question 5\"></a>Question 5</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>]</span><br><span class=\"line\"><span class=\"keyword\">print</span> list[<span class=\"number\">10</span>:]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># []</span></span><br></pre></td></tr></table></figure>\n<p>输出为空list, 不会报 <code>IndexError</code>错误</p>\n<p>As one would expect, attempting to access a member of a list using an index that exceeds the number of members (e.g., attempting to access list[10] in the list above) results in an IndexError. However, attempting to access a slice of a list at a starting index that exceeds the number of members in the list will not result in an IndexError and will simply return an empty list.</p>\n<p>What makes this a particularly nasty gotcha is that it can lead to bugs that are really hard to track down since no error is raised at runtime.</p>\n<h2 id=\"Question-6\"><a href=\"#Question-6\" class=\"headerlink\" title=\"Question 6\"></a>Question 6</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list = [ [] ] * <span class=\"number\">5</span></span><br><span class=\"line\">list  <span class=\"comment\"># output?</span></span><br><span class=\"line\">list[<span class=\"number\">0</span>].append(<span class=\"number\">10</span>)</span><br><span class=\"line\">list  <span class=\"comment\"># output?</span></span><br><span class=\"line\">list[<span class=\"number\">1</span>].append(<span class=\"number\">20</span>)</span><br><span class=\"line\">list  <span class=\"comment\"># output?</span></span><br><span class=\"line\">list.append(<span class=\"number\">30</span>)</span><br><span class=\"line\">list  <span class=\"comment\"># output?</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[], [], [], [], []]</span><br><span class=\"line\">[[10], [10], [10], [10], [10]]</span><br><span class=\"line\">[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]</span><br><span class=\"line\">[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]</span><br></pre></td></tr></table></figure>\n<p>list = [ [ ] ] * 5 simply creates a list of 5 lists.</p>\n<p>However, the key thing to understand here is that the <strong>statement list = [ [ ] ] * 5 does NOT create a list containing 5 distinct lists; rather, it creates a a list of 5 references to the same list</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">print</span> id(list[<span class=\"number\">0</span>]) == id(list[<span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"comment\"># True</span></span><br></pre></td></tr></table></figure>\n<p><code>list[0].append(10)</code> appends 10 to the first list. But since all 5 lists refer to the same list, the output is: [[10], [10], [10], [10], [10]].</p>\n<p>Similarly, <code>list[1].append(20)</code> appends 20 to the second list. But again, since all 5 lists refer to the same list, the output is now: [[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]].</p>\n<p>In contrast, <code>list.append(30)</code> is appending an entirely new element to the “outer” list, which therefore yields the output: [[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30].</p>\n<h2 id=\"Question-7\"><a href=\"#Question-7\" class=\"headerlink\" title=\"Question 7\"></a>Question 7</h2><p>Given a list of N numbers, use a single list comprehension to produce a new list that only contains those values that are:</p>\n<ol>\n<li>even numbers, and</li>\n<li>from elements in the original list that had even indices</li>\n</ol>\n<h3 id=\"答案-1\"><a href=\"#答案-1\" class=\"headerlink\" title=\"答案\"></a>答案</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#        0   1   2   3    4    5    6    7    8</span></span><br><span class=\"line\">list = [ <span class=\"number\">1</span> , <span class=\"number\">3</span> , <span class=\"number\">5</span> , <span class=\"number\">8</span> , <span class=\"number\">10</span> , <span class=\"number\">13</span> , <span class=\"number\">18</span> , <span class=\"number\">36</span> , <span class=\"number\">78</span> ]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> list[::<span class=\"number\">2</span>] <span class=\"keyword\">if</span> x%<span class=\"number\">2</span>==<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"comment\"># [10, 18, 78]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"args-and-kwargs\"><a href=\"#args-and-kwargs\" class=\"headerlink\" title=\"*args and **kwargs\"></a><code>*args</code> and <code>**kwargs</code></h2><p>当你不确定你的函数里将要传递多少参数时你可以用*args.例如,它可以传递任意数量的参数:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_everything</span><span class=\"params\">(*args)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> count, thing <span class=\"keyword\">in</span> enumerate(args):</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'&#123;0&#125;. &#123;1&#125;'</span>.format(count, thing)</span><br><span class=\"line\"></span><br><span class=\"line\">print_everything(<span class=\"string\">'apple'</span>, <span class=\"string\">'banana'</span>, <span class=\"string\">'cabbage'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 0. apple</span></span><br><span class=\"line\"><span class=\"comment\"># 1. banana</span></span><br><span class=\"line\"><span class=\"comment\"># 2. cabbage</span></span><br></pre></td></tr></table></figure>\n<p>相似的, <code>**kwargs</code>允许你使用没有事先定义的参数名:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">table_things</span><span class=\"params\">(**kwargs)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> kwargs.items():</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'&#123;0&#125; = &#123;1&#125;'</span>.format(name, value)</span><br><span class=\"line\"></span><br><span class=\"line\">table_things(apple = <span class=\"string\">'fruit'</span>, cabbage = <span class=\"string\">'vegetable'</span>)</span><br><span class=\"line\"><span class=\"comment\"># cabbage = vegetable</span></span><br><span class=\"line\"><span class=\"comment\"># apple = fruit</span></span><br></pre></td></tr></table></figure>\n<p>你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给*args和**kwargs.命名参数在列表的最前端.例如:</p>\n<p>def table_things(titlestring, <strong>kwargs)<br>*args和</strong>kwargs可以同时在函数的定义中,但是*args必须在**kwargs前面.</p>\n<p>当调用函数时你也可以用*和**语法.例如:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_three_things</span><span class=\"params\">(a, b, c)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'a = &#123;0&#125;, b = &#123;1&#125;, c = &#123;2&#125;'</span>.format(a,b,c)</span><br><span class=\"line\"></span><br><span class=\"line\">mylist = [<span class=\"string\">'aardvark'</span>, <span class=\"string\">'baboon'</span>, <span class=\"string\">'cat'</span>]</span><br><span class=\"line\">print_three_things(*mylist)</span><br><span class=\"line\"></span><br><span class=\"line\">a = aardvark, b = baboon, c = cat</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python里的拷贝\"><a href=\"#Python里的拷贝\" class=\"headerlink\" title=\"Python里的拷贝\"></a>Python里的拷贝</h2><p>引用和copy(),deepcopy()的区别</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\">a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]]  <span class=\"comment\">#原始对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">b = a  <span class=\"comment\">#赋值，传对象的引用</span></span><br><span class=\"line\">c = copy.copy(a)  <span class=\"comment\">#对象拷贝，浅拷贝</span></span><br><span class=\"line\">d = copy.deepcopy(a)  <span class=\"comment\">#对象拷贝，深拷贝</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.append(<span class=\"number\">5</span>)  <span class=\"comment\">#修改对象a</span></span><br><span class=\"line\">a[<span class=\"number\">4</span>].append(<span class=\"string\">'c'</span>)  <span class=\"comment\">#修改对象a中的['a', 'b']数组对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'a = '</span>, a</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'b = '</span>, b</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'c = '</span>, c</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'d = '</span>, d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出结果：</span></span><br><span class=\"line\"><span class=\"comment\"># a =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]</span></span><br><span class=\"line\"><span class=\"comment\"># b =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]</span></span><br><span class=\"line\"><span class=\"comment\"># c =  [1, 2, 3, 4, ['a', 'b', 'c']]</span></span><br><span class=\"line\"><span class=\"comment\"># d =  [1, 2, 3, 4, ['a', 'b']]</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>下面总结了一下常见的、易错的Python面试题</p>\n<h2 id=\"Question-1\"><a href=\"#Question-1\" class=\"headerlink\" title=\"Question 1\"></a>Question 1</h2><p>如下代码的输出是什么</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">extendList</span><span class=\"params\">(val, list=[])</span>:</span></span><br><span class=\"line\">    list.append(val)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list</span><br><span class=\"line\"></span><br><span class=\"line\">list1 = extendList(<span class=\"number\">10</span>)</span><br><span class=\"line\">list2 = extendList(<span class=\"number\">123</span>,[])</span><br><span class=\"line\">list3 = extendList(<span class=\"string\">'a'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"list1 = %s\"</span> % list1</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"list2 = %s\"</span> % list2</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">\"list3 = %s\"</span> % list3</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"答案：\"><a href=\"#答案：\" class=\"headerlink\" title=\"答案：\"></a>答案：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 = [10, &apos;a&apos;]</span><br><span class=\"line\">list2 = [123]</span><br><span class=\"line\">list3 = [10, &apos;a&apos;]</span><br></pre></td></tr></table></figure>\n<!-- more -->\n<h3 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h3><p>The new default list is created only once when the function is defined, and that same list is then used subsequently whenever extendList is invoked without a list argument being specified. This is because expressions in default arguments are calculated when the function is defined, not when it’s called.</p>\n<p>list1 and list3 are therefore operating on the same default list, whereas list2 is operating on a separate list that it created (by passing its own empty list as the value for the list parameter).</p>\n<p>The definition of the extendList function could be modified as follows, though, to always begin a new list when no list argument is specified, which is more likely to have been the desired behavior:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">extendList</span><span class=\"params\">(val, list=None)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> list <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>: </span><br><span class=\"line\">        list = []</span><br><span class=\"line\">    list.append(val)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># list1 = [10]</span></span><br><span class=\"line\"><span class=\"comment\"># list2 = [123]</span></span><br><span class=\"line\"><span class=\"comment\"># list3 = ['a']</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Python的函数参数传递\"><a href=\"#Python的函数参数传递\" class=\"headerlink\" title=\"Python的函数参数传递\"></a>Python的函数参数传递</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun</span><span class=\"params\">(a)</span>:</span></span><br><span class=\"line\">    a = <span class=\"number\">2</span></span><br><span class=\"line\">fun(a)</span><br><span class=\"line\"><span class=\"keyword\">print</span> a  <span class=\"comment\"># 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = []</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun</span><span class=\"params\">(a)</span>:</span></span><br><span class=\"line\">    a.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">fun(a)</span><br><span class=\"line\"><span class=\"keyword\">print</span> a  <span class=\"comment\"># [1]</span></span><br></pre></td></tr></table></figure>\n<p>类型是属于对象的，而不是变量。而对象有两种, 可更改 (mutable) 与 不可更改(immutable)对象。在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改。</p>\n<h2 id=\"Question-2\"><a href=\"#Question-2\" class=\"headerlink\" title=\"Question 2\"></a>Question 2</h2><p>下面代码输出</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multipliers</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">lambda</span> x : i * x <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>)]</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">print</span> [m(<span class=\"number\">2</span>) <span class=\"keyword\">for</span> m <span class=\"keyword\">in</span> multipliers()]</span><br></pre></td></tr></table></figure>\n<p>The output of the above code will be <code>[6, 6, 6, 6]</code> (not <code>[0, 2, 4, 6]</code>).</p>\n<p>The reason for this is that Python’s closures are late binding. This means that the values of variables used in closures are looked up at the time the inner function is called. So as a result, when any of the functions returned by multipliers() are called, the value of i is looked up in the surrounding scope at that time. By then, regardless of which of the returned functions is called, the for loop has completed and i is left with its final value of 3. Therefore, every returned function multiplies the value it is passed by 3, so since a value of 2 is passed in the above code, they all return a value of 6 (i.e., 3 x 2).</p>\n<p>(Incidentally, as pointed out in The Hitchhiker’s Guide to Python, there is a somewhat widespread misconception that this has something to do with lambdas, which is not the case. Functions created with a lambda expression are in no way special and the same behavior is exhibited by functions created using an ordinary def.)</p>\n<p>Below are a few examples of ways to circumvent this issue.</p>\n<p>One solution would be use a Python generator as follows:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multipliers</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"keyword\">lambda</span> x : i * x</span><br></pre></td></tr></table></figure>\n<p>Another solution is to create a closure that binds immediately to its arguments by using a default argument. For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multipliers</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">lambda</span> x, i=i : i * x <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>)]</span><br></pre></td></tr></table></figure>\n<p>Or alternatively, you can use the <code>functools.partial</code> function:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> partial</span><br><span class=\"line\"><span class=\"keyword\">from</span> operator <span class=\"keyword\">import</span> mul</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multipliers</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [partial(mul, i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>)]</span><br></pre></td></tr></table></figure>\n<h2 id=\"迭代器和生成器\"><a href=\"#迭代器和生成器\" class=\"headerlink\" title=\"迭代器和生成器\"></a>迭代器和生成器</h2><h2 id=\"Question-3\"><a href=\"#Question-3\" class=\"headerlink\" title=\"Question 3\"></a>Question 3</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    x = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child1</span><span class=\"params\">(Parent)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child2</span><span class=\"params\">(Parent)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> Parent.x, Child1.x, Child2.x</span><br><span class=\"line\">Child1.x = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> Parent.x, Child1.x, Child2.x</span><br><span class=\"line\">Parent.x = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> Parent.x, Child1.x, Child2.x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1, 1, 1</span></span><br><span class=\"line\"><span class=\"comment\"># 2, 1, 2</span></span><br><span class=\"line\"><span class=\"comment\"># 3, 2, 3</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"解释-1\"><a href=\"#解释-1\" class=\"headerlink\" title=\"解释\"></a>解释</h3><p>in Python, class variables are internally handled as dictionaries. If a variable name is not found in the dictionary of the current class, the class hierarchy (i.e., its parent classes) are searched until the referenced variable name is found (if the referenced variable name is not found in the class itself or anywhere in its hierarchy, an AttributeError occurs).</p>\n<p>Therefore, setting x = 1 in the Parent class makes the class variable x (with a value of 1) referenceable in that class and any of its children. That’s why the first print statement outputs 1 1 1.</p>\n<p>Subsequently, <strong>if any of its child classes overrides that value (for example, when we execute the statement Child1.x = 2), then the value is changed in that child only</strong>. That’s why the second print statement outputs 1 2 1.</p>\n<p>Finally, <strong>if the value is then changed in the Parent (for example, when we execute the statement Parent.x = 3), that change is reflected also by any children that have not yet overridden the value</strong> (which in this case would be Child2). That’s why the third print statement outputs 3 2 3.</p>\n<h2 id=\"Question-4\"><a href=\"#Question-4\" class=\"headerlink\" title=\"Question 4\"></a>Question 4</h2><p>在 Python2 中下面代码输出是什么</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">div1</span><span class=\"params\">(x,y)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"%s/%s = %s\"</span> % (x, y, x/y)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">div2</span><span class=\"params\">(x,y)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"%s//%s = %s\"</span> % (x, y, x//y)</span><br><span class=\"line\"></span><br><span class=\"line\">div1(<span class=\"number\">5</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">div1(<span class=\"number\">5.</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">div2(<span class=\"number\">5</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">div2(<span class=\"number\">5.</span>,<span class=\"number\">2.</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5/2 = 2</span></span><br><span class=\"line\"><span class=\"comment\"># 5.0/2 = 2.5</span></span><br><span class=\"line\"><span class=\"comment\"># 5//2 = 2</span></span><br><span class=\"line\"><span class=\"comment\"># 5.0//2.0 = 2.0</span></span><br></pre></td></tr></table></figure>\n<p>By default, Python 2 automatically performs integer arithmetic if both operands are integers. As a result, 5/2 yields 2, while 5./2 yields 2.5.</p>\n<p>Note that you can override this behavior in Python 2 by adding the following import:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> __future__ <span class=\"keyword\">import</span> division</span><br></pre></td></tr></table></figure>\n<p>Also note that the “double-slash” (//) operator will always perform integer division, regardless of the operand types. That’s why 5.0//2.0 yields 2.0 even in Python 2.</p>\n<p>Python 3, however, does not have this behavior; i.e., it does not perform integer arithmetic if both operands are integers. Therefore, in Python 3, the output will be as follows:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5/2 = 2.5</span><br><span class=\"line\">5.0/2 = 2.5</span><br><span class=\"line\">5//2 = 2</span><br><span class=\"line\">5.0//2.0 = 2.0</span><br></pre></td></tr></table></figure>\n<h2 id=\"Question-5\"><a href=\"#Question-5\" class=\"headerlink\" title=\"Question 5\"></a>Question 5</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>]</span><br><span class=\"line\"><span class=\"keyword\">print</span> list[<span class=\"number\">10</span>:]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># []</span></span><br></pre></td></tr></table></figure>\n<p>输出为空list, 不会报 <code>IndexError</code>错误</p>\n<p>As one would expect, attempting to access a member of a list using an index that exceeds the number of members (e.g., attempting to access list[10] in the list above) results in an IndexError. However, attempting to access a slice of a list at a starting index that exceeds the number of members in the list will not result in an IndexError and will simply return an empty list.</p>\n<p>What makes this a particularly nasty gotcha is that it can lead to bugs that are really hard to track down since no error is raised at runtime.</p>\n<h2 id=\"Question-6\"><a href=\"#Question-6\" class=\"headerlink\" title=\"Question 6\"></a>Question 6</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list = [ [] ] * <span class=\"number\">5</span></span><br><span class=\"line\">list  <span class=\"comment\"># output?</span></span><br><span class=\"line\">list[<span class=\"number\">0</span>].append(<span class=\"number\">10</span>)</span><br><span class=\"line\">list  <span class=\"comment\"># output?</span></span><br><span class=\"line\">list[<span class=\"number\">1</span>].append(<span class=\"number\">20</span>)</span><br><span class=\"line\">list  <span class=\"comment\"># output?</span></span><br><span class=\"line\">list.append(<span class=\"number\">30</span>)</span><br><span class=\"line\">list  <span class=\"comment\"># output?</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[], [], [], [], []]</span><br><span class=\"line\">[[10], [10], [10], [10], [10]]</span><br><span class=\"line\">[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]</span><br><span class=\"line\">[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]</span><br></pre></td></tr></table></figure>\n<p>list = [ [ ] ] * 5 simply creates a list of 5 lists.</p>\n<p>However, the key thing to understand here is that the <strong>statement list = [ [ ] ] * 5 does NOT create a list containing 5 distinct lists; rather, it creates a a list of 5 references to the same list</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">print</span> id(list[<span class=\"number\">0</span>]) == id(list[<span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"comment\"># True</span></span><br></pre></td></tr></table></figure>\n<p><code>list[0].append(10)</code> appends 10 to the first list. But since all 5 lists refer to the same list, the output is: [[10], [10], [10], [10], [10]].</p>\n<p>Similarly, <code>list[1].append(20)</code> appends 20 to the second list. But again, since all 5 lists refer to the same list, the output is now: [[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]].</p>\n<p>In contrast, <code>list.append(30)</code> is appending an entirely new element to the “outer” list, which therefore yields the output: [[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30].</p>\n<h2 id=\"Question-7\"><a href=\"#Question-7\" class=\"headerlink\" title=\"Question 7\"></a>Question 7</h2><p>Given a list of N numbers, use a single list comprehension to produce a new list that only contains those values that are:</p>\n<ol>\n<li>even numbers, and</li>\n<li>from elements in the original list that had even indices</li>\n</ol>\n<h3 id=\"答案-1\"><a href=\"#答案-1\" class=\"headerlink\" title=\"答案\"></a>答案</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#        0   1   2   3    4    5    6    7    8</span></span><br><span class=\"line\">list = [ <span class=\"number\">1</span> , <span class=\"number\">3</span> , <span class=\"number\">5</span> , <span class=\"number\">8</span> , <span class=\"number\">10</span> , <span class=\"number\">13</span> , <span class=\"number\">18</span> , <span class=\"number\">36</span> , <span class=\"number\">78</span> ]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> list[::<span class=\"number\">2</span>] <span class=\"keyword\">if</span> x%<span class=\"number\">2</span>==<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"comment\"># [10, 18, 78]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"args-and-kwargs\"><a href=\"#args-and-kwargs\" class=\"headerlink\" title=\"*args and **kwargs\"></a><code>*args</code> and <code>**kwargs</code></h2><p>当你不确定你的函数里将要传递多少参数时你可以用*args.例如,它可以传递任意数量的参数:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_everything</span><span class=\"params\">(*args)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> count, thing <span class=\"keyword\">in</span> enumerate(args):</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'&#123;0&#125;. &#123;1&#125;'</span>.format(count, thing)</span><br><span class=\"line\"></span><br><span class=\"line\">print_everything(<span class=\"string\">'apple'</span>, <span class=\"string\">'banana'</span>, <span class=\"string\">'cabbage'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 0. apple</span></span><br><span class=\"line\"><span class=\"comment\"># 1. banana</span></span><br><span class=\"line\"><span class=\"comment\"># 2. cabbage</span></span><br></pre></td></tr></table></figure>\n<p>相似的, <code>**kwargs</code>允许你使用没有事先定义的参数名:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">table_things</span><span class=\"params\">(**kwargs)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> kwargs.items():</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'&#123;0&#125; = &#123;1&#125;'</span>.format(name, value)</span><br><span class=\"line\"></span><br><span class=\"line\">table_things(apple = <span class=\"string\">'fruit'</span>, cabbage = <span class=\"string\">'vegetable'</span>)</span><br><span class=\"line\"><span class=\"comment\"># cabbage = vegetable</span></span><br><span class=\"line\"><span class=\"comment\"># apple = fruit</span></span><br></pre></td></tr></table></figure>\n<p>你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给*args和**kwargs.命名参数在列表的最前端.例如:</p>\n<p>def table_things(titlestring, <strong>kwargs)<br>*args和</strong>kwargs可以同时在函数的定义中,但是*args必须在**kwargs前面.</p>\n<p>当调用函数时你也可以用*和**语法.例如:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_three_things</span><span class=\"params\">(a, b, c)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'a = &#123;0&#125;, b = &#123;1&#125;, c = &#123;2&#125;'</span>.format(a,b,c)</span><br><span class=\"line\"></span><br><span class=\"line\">mylist = [<span class=\"string\">'aardvark'</span>, <span class=\"string\">'baboon'</span>, <span class=\"string\">'cat'</span>]</span><br><span class=\"line\">print_three_things(*mylist)</span><br><span class=\"line\"></span><br><span class=\"line\">a = aardvark, b = baboon, c = cat</span><br></pre></td></tr></table></figure>\n<h2 id=\"Python里的拷贝\"><a href=\"#Python里的拷贝\" class=\"headerlink\" title=\"Python里的拷贝\"></a>Python里的拷贝</h2><p>引用和copy(),deepcopy()的区别</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\">a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]]  <span class=\"comment\">#原始对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">b = a  <span class=\"comment\">#赋值，传对象的引用</span></span><br><span class=\"line\">c = copy.copy(a)  <span class=\"comment\">#对象拷贝，浅拷贝</span></span><br><span class=\"line\">d = copy.deepcopy(a)  <span class=\"comment\">#对象拷贝，深拷贝</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.append(<span class=\"number\">5</span>)  <span class=\"comment\">#修改对象a</span></span><br><span class=\"line\">a[<span class=\"number\">4</span>].append(<span class=\"string\">'c'</span>)  <span class=\"comment\">#修改对象a中的['a', 'b']数组对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'a = '</span>, a</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'b = '</span>, b</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'c = '</span>, c</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'d = '</span>, d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出结果：</span></span><br><span class=\"line\"><span class=\"comment\"># a =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]</span></span><br><span class=\"line\"><span class=\"comment\"># b =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]</span></span><br><span class=\"line\"><span class=\"comment\"># c =  [1, 2, 3, 4, ['a', 'b', 'c']]</span></span><br><span class=\"line\"><span class=\"comment\"># d =  [1, 2, 3, 4, ['a', 'b']]</span></span><br></pre></td></tr></table></figure>"},{"title":"Python内置数据结构","date":"2017-05-27T10:27:32.000Z","_content":"\n\nPython 内置数据类型包括 `list`, `tuple`, `dict`, `set`\n\n## List\n\nPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素\n\n列表常用操作及其复杂度\n\nOperation  | big O | description |\n--|-- |-- |\nindex [] |\tO(1) |\t索引操作\nindex assignment\t|\tO(1)| \t索引赋值操作\nappend\t|\tO(1)|\t在列表末尾添加新的对象\npop()\t|\tO(1)|\t移除列表中的一个元素（默认最后一个元素），并且返回该元素的值\npop(i)\t|\tO(n)|\t移除列表中索引位置的值，并且返回该元素的值\ninsert(i,item)\t|\tO(n)|\t将对象插入列表索引i位置\ndel operator\t|\tO(n)|\t删除列表的的元素\niteration\t|\tO(n)|\ncontains (in)\t|\tO(n)|\nget slice [x:y]\t|\tO(k)|\ndel slice\t|\tO(n)|\nset slice\t|\tO(n+k)|\nreverse\t|\tO(n)|\t反向列表中元素\nremove | O(n) | 移除列表中某个值的第一个匹配项\nconcatenate\t|\tO(k)|\nsort\t|\tO(n log n)|\t列表排序\nmultiply\t|\tO(nk)|\n\n\n<!-- more -->\n\n\n## Dictionary\n\nPython内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。dict内部存放的顺序和key放入的顺序是没有关系的。\ndict的key必须是**不可变对象**。这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为**哈希算法**（Hash）\n\ndict: `{'A': 1, 'Z': -1}` 创建方式\n\n``` python\na = dict(A=1, Z=-1)\nb = {'A': 1, 'Z': -1}\nc = dict(zip(['A', 'Z'], [1, -1]))\nd = dict([('A', 1), ('Z', -1)])\ne = dict({'Z': -1, 'A': 1})\na == b == c == d == e\n# True\n```\n\n和list比较，dict有以下几个特点：\n\n- 查找和插入的速度极快，不会随着key的增加而变慢；\n- 需要占用大量的内存，内存浪费多。\n\n而list相反：\n\n- 查找和插入的时间随着元素的增加而增加；\n- 占用空间小，浪费内存很少。\n\n所以，dict是用空间来换取时间的一种方法\n\n遍历一个`dict`，实际上是在遍历它的所有的Key的集合，然后用这个Key来获得对应的Value\n\n``` python\nd = {'Adam': 95, 'Lisa': 85, 'Bart': 59, 'Paul': 75}\n\nprint d['Adam']\n# 95\nprint d.get('Jason')\n# None\n\nfor key in d :\n    print key, ':', d.get(key)\n# Lisa : 85\n# Paul : 75\n# Adam : 95\n# Bart : 59\n```\n\n## Tuple\n\n`tuple`和`list`非常类似，但是tuple一旦初始化就不能修改\n\n#### Tuple 的不可变性\n\n元组一旦创建，它的元素就是不可变的， 例如如下：\n\n``` python\nt = ('a', 'b', ['A', 'B'])\nt[2][0] = 'X'\nt[2][1] = 'Y'\nprint t\n```\n\n![createTuple1](assets/Basic_DataStructure_Python-21a4b.png)\n\n当我们把list的元素'A'和'B'修改为'X'和'Y'后，tuple变为：\n\n![createTuple2](assets/Basic_DataStructure_Python-277bd.png)\n\nTuple的每个元素，指向永远不变，其中如果某个元素本身是可变的，那么元素内部也是可变的，但是元组的指向却是没有变化\n\n\n## Set\n\n`set`和`dict`类似，也是一组key的集合，但不存储value。由于key不能重复，所以，**在set中，没有重复的key**。\n\n\n`set`可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：\n\n``` python\ns1 = set([1, 2, 3])\ns2 = set([2, 3, 4])\n\ns1 & s2\n# set([2, 3])\ns1 | s2\n# set([1, 2, 3, 4])\n```\n\nset和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，\n所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。","source":"_posts/Pythonƒ⁄÷√ ˝æ›Ω·ππ.md","raw":"---\ntitle: Python内置数据结构\ndate: 2017-05-27 18:27:32\ntags: \n- Data Structure\n- Python\n---\n\n\nPython 内置数据类型包括 `list`, `tuple`, `dict`, `set`\n\n## List\n\nPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素\n\n列表常用操作及其复杂度\n\nOperation  | big O | description |\n--|-- |-- |\nindex [] |\tO(1) |\t索引操作\nindex assignment\t|\tO(1)| \t索引赋值操作\nappend\t|\tO(1)|\t在列表末尾添加新的对象\npop()\t|\tO(1)|\t移除列表中的一个元素（默认最后一个元素），并且返回该元素的值\npop(i)\t|\tO(n)|\t移除列表中索引位置的值，并且返回该元素的值\ninsert(i,item)\t|\tO(n)|\t将对象插入列表索引i位置\ndel operator\t|\tO(n)|\t删除列表的的元素\niteration\t|\tO(n)|\ncontains (in)\t|\tO(n)|\nget slice [x:y]\t|\tO(k)|\ndel slice\t|\tO(n)|\nset slice\t|\tO(n+k)|\nreverse\t|\tO(n)|\t反向列表中元素\nremove | O(n) | 移除列表中某个值的第一个匹配项\nconcatenate\t|\tO(k)|\nsort\t|\tO(n log n)|\t列表排序\nmultiply\t|\tO(nk)|\n\n\n<!-- more -->\n\n\n## Dictionary\n\nPython内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。dict内部存放的顺序和key放入的顺序是没有关系的。\ndict的key必须是**不可变对象**。这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为**哈希算法**（Hash）\n\ndict: `{'A': 1, 'Z': -1}` 创建方式\n\n``` python\na = dict(A=1, Z=-1)\nb = {'A': 1, 'Z': -1}\nc = dict(zip(['A', 'Z'], [1, -1]))\nd = dict([('A', 1), ('Z', -1)])\ne = dict({'Z': -1, 'A': 1})\na == b == c == d == e\n# True\n```\n\n和list比较，dict有以下几个特点：\n\n- 查找和插入的速度极快，不会随着key的增加而变慢；\n- 需要占用大量的内存，内存浪费多。\n\n而list相反：\n\n- 查找和插入的时间随着元素的增加而增加；\n- 占用空间小，浪费内存很少。\n\n所以，dict是用空间来换取时间的一种方法\n\n遍历一个`dict`，实际上是在遍历它的所有的Key的集合，然后用这个Key来获得对应的Value\n\n``` python\nd = {'Adam': 95, 'Lisa': 85, 'Bart': 59, 'Paul': 75}\n\nprint d['Adam']\n# 95\nprint d.get('Jason')\n# None\n\nfor key in d :\n    print key, ':', d.get(key)\n# Lisa : 85\n# Paul : 75\n# Adam : 95\n# Bart : 59\n```\n\n## Tuple\n\n`tuple`和`list`非常类似，但是tuple一旦初始化就不能修改\n\n#### Tuple 的不可变性\n\n元组一旦创建，它的元素就是不可变的， 例如如下：\n\n``` python\nt = ('a', 'b', ['A', 'B'])\nt[2][0] = 'X'\nt[2][1] = 'Y'\nprint t\n```\n\n![createTuple1](assets/Basic_DataStructure_Python-21a4b.png)\n\n当我们把list的元素'A'和'B'修改为'X'和'Y'后，tuple变为：\n\n![createTuple2](assets/Basic_DataStructure_Python-277bd.png)\n\nTuple的每个元素，指向永远不变，其中如果某个元素本身是可变的，那么元素内部也是可变的，但是元组的指向却是没有变化\n\n\n## Set\n\n`set`和`dict`类似，也是一组key的集合，但不存储value。由于key不能重复，所以，**在set中，没有重复的key**。\n\n\n`set`可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：\n\n``` python\ns1 = set([1, 2, 3])\ns2 = set([2, 3, 4])\n\ns1 & s2\n# set([2, 3])\ns1 | s2\n# set([1, 2, 3, 4])\n```\n\nset和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，\n所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。","slug":"Pythonƒ⁄÷√ ˝æ›Ω·ππ","published":1,"updated":"2017-05-31T03:00:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3oj0038zd6829stm37j","content":"<p>Python 内置数据类型包括 <code>list</code>, <code>tuple</code>, <code>dict</code>, <code>set</code></p>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素</p>\n<p>列表常用操作及其复杂度</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>big O</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>index []</td>\n<td>O(1)</td>\n<td>索引操作</td>\n</tr>\n<tr>\n<td>index assignment</td>\n<td>O(1)</td>\n<td>索引赋值操作</td>\n</tr>\n<tr>\n<td>append</td>\n<td>O(1)</td>\n<td>在列表末尾添加新的对象</td>\n</tr>\n<tr>\n<td>pop()</td>\n<td>O(1)</td>\n<td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>\n</tr>\n<tr>\n<td>pop(i)</td>\n<td>O(n)</td>\n<td>移除列表中索引位置的值，并且返回该元素的值</td>\n</tr>\n<tr>\n<td>insert(i,item)</td>\n<td>O(n)</td>\n<td>将对象插入列表索引i位置</td>\n</tr>\n<tr>\n<td>del operator</td>\n<td>O(n)</td>\n<td>删除列表的的元素</td>\n</tr>\n<tr>\n<td>iteration</td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td>contains (in)</td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td>get slice [x:y]</td>\n<td>O(k)</td>\n<td></td>\n</tr>\n<tr>\n<td>del slice</td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td>set slice</td>\n<td>O(n+k)</td>\n<td></td>\n</tr>\n<tr>\n<td>reverse</td>\n<td>O(n)</td>\n<td>反向列表中元素</td>\n</tr>\n<tr>\n<td>remove</td>\n<td>O(n)</td>\n<td>移除列表中某个值的第一个匹配项</td>\n</tr>\n<tr>\n<td>concatenate</td>\n<td>O(k)</td>\n<td></td>\n</tr>\n<tr>\n<td>sort</td>\n<td>O(n log n)</td>\n<td>列表排序</td>\n</tr>\n<tr>\n<td>multiply</td>\n<td>O(nk)</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<h2 id=\"Dictionary\"><a href=\"#Dictionary\" class=\"headerlink\" title=\"Dictionary\"></a>Dictionary</h2><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。dict内部存放的顺序和key放入的顺序是没有关系的。<br>dict的key必须是<strong>不可变对象</strong>。这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为<strong>哈希算法</strong>（Hash）</p>\n<p>dict: <code>{&#39;A&#39;: 1, &#39;Z&#39;: -1}</code> 创建方式</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = dict(A=<span class=\"number\">1</span>, Z=<span class=\"number\">-1</span>)</span><br><span class=\"line\">b = &#123;<span class=\"string\">'A'</span>: <span class=\"number\">1</span>, <span class=\"string\">'Z'</span>: <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\">c = dict(zip([<span class=\"string\">'A'</span>, <span class=\"string\">'Z'</span>], [<span class=\"number\">1</span>, <span class=\"number\">-1</span>]))</span><br><span class=\"line\">d = dict([(<span class=\"string\">'A'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'Z'</span>, <span class=\"number\">-1</span>)])</span><br><span class=\"line\">e = dict(&#123;<span class=\"string\">'Z'</span>: <span class=\"number\">-1</span>, <span class=\"string\">'A'</span>: <span class=\"number\">1</span>&#125;)</span><br><span class=\"line\">a == b == c == d == e</span><br><span class=\"line\"><span class=\"comment\"># True</span></span><br></pre></td></tr></table></figure>\n<p>和list比较，dict有以下几个特点：</p>\n<ul>\n<li>查找和插入的速度极快，不会随着key的增加而变慢；</li>\n<li>需要占用大量的内存，内存浪费多。</li>\n</ul>\n<p>而list相反：</p>\n<ul>\n<li>查找和插入的时间随着元素的增加而增加；</li>\n<li>占用空间小，浪费内存很少。</li>\n</ul>\n<p>所以，dict是用空间来换取时间的一种方法</p>\n<p>遍历一个<code>dict</code>，实际上是在遍历它的所有的Key的集合，然后用这个Key来获得对应的Value</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = &#123;<span class=\"string\">'Adam'</span>: <span class=\"number\">95</span>, <span class=\"string\">'Lisa'</span>: <span class=\"number\">85</span>, <span class=\"string\">'Bart'</span>: <span class=\"number\">59</span>, <span class=\"string\">'Paul'</span>: <span class=\"number\">75</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> d[<span class=\"string\">'Adam'</span>]</span><br><span class=\"line\"><span class=\"comment\"># 95</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> d.get(<span class=\"string\">'Jason'</span>)</span><br><span class=\"line\"><span class=\"comment\"># None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> d :</span><br><span class=\"line\">    <span class=\"keyword\">print</span> key, <span class=\"string\">':'</span>, d.get(key)</span><br><span class=\"line\"><span class=\"comment\"># Lisa : 85</span></span><br><span class=\"line\"><span class=\"comment\"># Paul : 75</span></span><br><span class=\"line\"><span class=\"comment\"># Adam : 95</span></span><br><span class=\"line\"><span class=\"comment\"># Bart : 59</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Tuple\"><a href=\"#Tuple\" class=\"headerlink\" title=\"Tuple\"></a>Tuple</h2><p><code>tuple</code>和<code>list</code>非常类似，但是tuple一旦初始化就不能修改</p>\n<h4 id=\"Tuple-的不可变性\"><a href=\"#Tuple-的不可变性\" class=\"headerlink\" title=\"Tuple 的不可变性\"></a>Tuple 的不可变性</h4><p>元组一旦创建，它的元素就是不可变的， 例如如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t = (<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>])</span><br><span class=\"line\">t[<span class=\"number\">2</span>][<span class=\"number\">0</span>] = <span class=\"string\">'X'</span></span><br><span class=\"line\">t[<span class=\"number\">2</span>][<span class=\"number\">1</span>] = <span class=\"string\">'Y'</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> t</span><br></pre></td></tr></table></figure>\n<p><img src=\"assets/Basic_DataStructure_Python-21a4b.png\" alt=\"createTuple1\"></p>\n<p>当我们把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为：</p>\n<p><img src=\"assets/Basic_DataStructure_Python-277bd.png\" alt=\"createTuple2\"></p>\n<p>Tuple的每个元素，指向永远不变，其中如果某个元素本身是可变的，那么元素内部也是可变的，但是元组的指向却是没有变化</p>\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p><code>set</code>和<code>dict</code>类似，也是一组key的集合，但不存储value。由于key不能重复，所以，<strong>在set中，没有重复的key</strong>。</p>\n<p><code>set</code>可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s1 = set([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\">s2 = set([<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">s1 &amp; s2</span><br><span class=\"line\"><span class=\"comment\"># set([2, 3])</span></span><br><span class=\"line\">s1 | s2</span><br><span class=\"line\"><span class=\"comment\"># set([1, 2, 3, 4])</span></span><br></pre></td></tr></table></figure>\n<p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，<br>所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。</p>\n","site":{"data":{}},"excerpt":"<p>Python 内置数据类型包括 <code>list</code>, <code>tuple</code>, <code>dict</code>, <code>set</code></p>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素</p>\n<p>列表常用操作及其复杂度</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>big O</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>index []</td>\n<td>O(1)</td>\n<td>索引操作</td>\n</tr>\n<tr>\n<td>index assignment</td>\n<td>O(1)</td>\n<td>索引赋值操作</td>\n</tr>\n<tr>\n<td>append</td>\n<td>O(1)</td>\n<td>在列表末尾添加新的对象</td>\n</tr>\n<tr>\n<td>pop()</td>\n<td>O(1)</td>\n<td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>\n</tr>\n<tr>\n<td>pop(i)</td>\n<td>O(n)</td>\n<td>移除列表中索引位置的值，并且返回该元素的值</td>\n</tr>\n<tr>\n<td>insert(i,item)</td>\n<td>O(n)</td>\n<td>将对象插入列表索引i位置</td>\n</tr>\n<tr>\n<td>del operator</td>\n<td>O(n)</td>\n<td>删除列表的的元素</td>\n</tr>\n<tr>\n<td>iteration</td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td>contains (in)</td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td>get slice [x:y]</td>\n<td>O(k)</td>\n<td></td>\n</tr>\n<tr>\n<td>del slice</td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td>set slice</td>\n<td>O(n+k)</td>\n<td></td>\n</tr>\n<tr>\n<td>reverse</td>\n<td>O(n)</td>\n<td>反向列表中元素</td>\n</tr>\n<tr>\n<td>remove</td>\n<td>O(n)</td>\n<td>移除列表中某个值的第一个匹配项</td>\n</tr>\n<tr>\n<td>concatenate</td>\n<td>O(k)</td>\n<td></td>\n</tr>\n<tr>\n<td>sort</td>\n<td>O(n log n)</td>\n<td>列表排序</td>\n</tr>\n<tr>\n<td>multiply</td>\n<td>O(nk)</td>\n<td></td>\n</tr>\n</tbody>\n</table>","more":"<h2 id=\"Dictionary\"><a href=\"#Dictionary\" class=\"headerlink\" title=\"Dictionary\"></a>Dictionary</h2><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。dict内部存放的顺序和key放入的顺序是没有关系的。<br>dict的key必须是<strong>不可变对象</strong>。这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为<strong>哈希算法</strong>（Hash）</p>\n<p>dict: <code>{&#39;A&#39;: 1, &#39;Z&#39;: -1}</code> 创建方式</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = dict(A=<span class=\"number\">1</span>, Z=<span class=\"number\">-1</span>)</span><br><span class=\"line\">b = &#123;<span class=\"string\">'A'</span>: <span class=\"number\">1</span>, <span class=\"string\">'Z'</span>: <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\">c = dict(zip([<span class=\"string\">'A'</span>, <span class=\"string\">'Z'</span>], [<span class=\"number\">1</span>, <span class=\"number\">-1</span>]))</span><br><span class=\"line\">d = dict([(<span class=\"string\">'A'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'Z'</span>, <span class=\"number\">-1</span>)])</span><br><span class=\"line\">e = dict(&#123;<span class=\"string\">'Z'</span>: <span class=\"number\">-1</span>, <span class=\"string\">'A'</span>: <span class=\"number\">1</span>&#125;)</span><br><span class=\"line\">a == b == c == d == e</span><br><span class=\"line\"><span class=\"comment\"># True</span></span><br></pre></td></tr></table></figure>\n<p>和list比较，dict有以下几个特点：</p>\n<ul>\n<li>查找和插入的速度极快，不会随着key的增加而变慢；</li>\n<li>需要占用大量的内存，内存浪费多。</li>\n</ul>\n<p>而list相反：</p>\n<ul>\n<li>查找和插入的时间随着元素的增加而增加；</li>\n<li>占用空间小，浪费内存很少。</li>\n</ul>\n<p>所以，dict是用空间来换取时间的一种方法</p>\n<p>遍历一个<code>dict</code>，实际上是在遍历它的所有的Key的集合，然后用这个Key来获得对应的Value</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = &#123;<span class=\"string\">'Adam'</span>: <span class=\"number\">95</span>, <span class=\"string\">'Lisa'</span>: <span class=\"number\">85</span>, <span class=\"string\">'Bart'</span>: <span class=\"number\">59</span>, <span class=\"string\">'Paul'</span>: <span class=\"number\">75</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> d[<span class=\"string\">'Adam'</span>]</span><br><span class=\"line\"><span class=\"comment\"># 95</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> d.get(<span class=\"string\">'Jason'</span>)</span><br><span class=\"line\"><span class=\"comment\"># None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> d :</span><br><span class=\"line\">    <span class=\"keyword\">print</span> key, <span class=\"string\">':'</span>, d.get(key)</span><br><span class=\"line\"><span class=\"comment\"># Lisa : 85</span></span><br><span class=\"line\"><span class=\"comment\"># Paul : 75</span></span><br><span class=\"line\"><span class=\"comment\"># Adam : 95</span></span><br><span class=\"line\"><span class=\"comment\"># Bart : 59</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Tuple\"><a href=\"#Tuple\" class=\"headerlink\" title=\"Tuple\"></a>Tuple</h2><p><code>tuple</code>和<code>list</code>非常类似，但是tuple一旦初始化就不能修改</p>\n<h4 id=\"Tuple-的不可变性\"><a href=\"#Tuple-的不可变性\" class=\"headerlink\" title=\"Tuple 的不可变性\"></a>Tuple 的不可变性</h4><p>元组一旦创建，它的元素就是不可变的， 例如如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t = (<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>])</span><br><span class=\"line\">t[<span class=\"number\">2</span>][<span class=\"number\">0</span>] = <span class=\"string\">'X'</span></span><br><span class=\"line\">t[<span class=\"number\">2</span>][<span class=\"number\">1</span>] = <span class=\"string\">'Y'</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> t</span><br></pre></td></tr></table></figure>\n<p><img src=\"assets/Basic_DataStructure_Python-21a4b.png\" alt=\"createTuple1\"></p>\n<p>当我们把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为：</p>\n<p><img src=\"assets/Basic_DataStructure_Python-277bd.png\" alt=\"createTuple2\"></p>\n<p>Tuple的每个元素，指向永远不变，其中如果某个元素本身是可变的，那么元素内部也是可变的，但是元组的指向却是没有变化</p>\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p><code>set</code>和<code>dict</code>类似，也是一组key的集合，但不存储value。由于key不能重复，所以，<strong>在set中，没有重复的key</strong>。</p>\n<p><code>set</code>可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s1 = set([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\">s2 = set([<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">s1 &amp; s2</span><br><span class=\"line\"><span class=\"comment\"># set([2, 3])</span></span><br><span class=\"line\">s1 | s2</span><br><span class=\"line\"><span class=\"comment\"># set([1, 2, 3, 4])</span></span><br></pre></td></tr></table></figure>\n<p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，<br>所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。</p>"},{"title":"SQL Server数据库分页","date":"2017-05-27T10:39:03.000Z","_content":"\n\n在编写Web应用程序等系统时，会涉及到与数据库的交互，如果数据库中数据量很大的话，一次检索所有的记录，会占用系统很大的资源，因此常常采用分页语句：需要多少数据就只从数据库中取多少条记录。\n\n常见的对大数据量查询的解决方案有以下两种：\n\n1. 将全部数据先查询到内存中，然后在内存中进行分页，这种方式对内存占用较大，必须限制一次查询的数据量。\n\n2. 采用存储过程在数据库中进行分页，这种方式对数据库的依赖较大，不同的数据库实现机制不通，并且查询效率不够理想。以上两种方式对用户来说都不够友好。\n\n<!-- more -->\n\n## 使用ROW_NUMBER()函数分页\n\nSQL Server 2005之后引入了 `ROW_NUMBER()` 函数，通过该函数根据定好的排序字段规则，产生记录序号\n\n``` sql\nSELECT  ROW_NUMBER() OVER ( ORDER BY dbo.Products.ProductID DESC ) AS rownum\n      , *\nFROM    dbo.Products\n```\n\n``` sql\nSELECT  *\nFROM    ( SELECT TOP ( @pageSize * @pageIndex )\n                    ROW_NUMBER() OVER ( ORDER BY dbo.Products.UnitPrice DESC ) AS rownum ,\n                    *\n          FROM      dbo.Products\n        ) AS temp\nWHERE   temp.rownum > ( @pageSize * ( @pageIndex - 1 ) )\nORDER BY temp.UnitPrice\n```\n\n## 使用OFFSET FETCH子句分页\n\nSQL Server 2012中引入了`OFFSET-FETCH`语句，可以通过使用`OFFSET-FETCH`过滤器来实现分页\n\n``` sql\nSELECT  * \nFROM    dbo.Products \nORDER   BY UnitPrice DESC \nOFFSET  ( @pageSize * ( @pageIndex - 1 )) ROWS \nFETCH NEXT @pageSize ROWS ONLY;\n```","source":"_posts/SQL-Server ˝æ›ø‚∑÷“≥.md","raw":"---\ntitle: SQL Server数据库分页\ndate: 2017-05-27 18:39:03\ntags: \n- Database\n---\n\n\n在编写Web应用程序等系统时，会涉及到与数据库的交互，如果数据库中数据量很大的话，一次检索所有的记录，会占用系统很大的资源，因此常常采用分页语句：需要多少数据就只从数据库中取多少条记录。\n\n常见的对大数据量查询的解决方案有以下两种：\n\n1. 将全部数据先查询到内存中，然后在内存中进行分页，这种方式对内存占用较大，必须限制一次查询的数据量。\n\n2. 采用存储过程在数据库中进行分页，这种方式对数据库的依赖较大，不同的数据库实现机制不通，并且查询效率不够理想。以上两种方式对用户来说都不够友好。\n\n<!-- more -->\n\n## 使用ROW_NUMBER()函数分页\n\nSQL Server 2005之后引入了 `ROW_NUMBER()` 函数，通过该函数根据定好的排序字段规则，产生记录序号\n\n``` sql\nSELECT  ROW_NUMBER() OVER ( ORDER BY dbo.Products.ProductID DESC ) AS rownum\n      , *\nFROM    dbo.Products\n```\n\n``` sql\nSELECT  *\nFROM    ( SELECT TOP ( @pageSize * @pageIndex )\n                    ROW_NUMBER() OVER ( ORDER BY dbo.Products.UnitPrice DESC ) AS rownum ,\n                    *\n          FROM      dbo.Products\n        ) AS temp\nWHERE   temp.rownum > ( @pageSize * ( @pageIndex - 1 ) )\nORDER BY temp.UnitPrice\n```\n\n## 使用OFFSET FETCH子句分页\n\nSQL Server 2012中引入了`OFFSET-FETCH`语句，可以通过使用`OFFSET-FETCH`过滤器来实现分页\n\n``` sql\nSELECT  * \nFROM    dbo.Products \nORDER   BY UnitPrice DESC \nOFFSET  ( @pageSize * ( @pageIndex - 1 )) ROWS \nFETCH NEXT @pageSize ROWS ONLY;\n```","slug":"SQL-Server ˝æ›ø‚∑÷“≥","published":1,"updated":"2017-05-31T03:00:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3ol003bzd68zvbp4q14","content":"<p>在编写Web应用程序等系统时，会涉及到与数据库的交互，如果数据库中数据量很大的话，一次检索所有的记录，会占用系统很大的资源，因此常常采用分页语句：需要多少数据就只从数据库中取多少条记录。</p>\n<p>常见的对大数据量查询的解决方案有以下两种：</p>\n<ol>\n<li><p>将全部数据先查询到内存中，然后在内存中进行分页，这种方式对内存占用较大，必须限制一次查询的数据量。</p>\n</li>\n<li><p>采用存储过程在数据库中进行分页，这种方式对数据库的依赖较大，不同的数据库实现机制不通，并且查询效率不够理想。以上两种方式对用户来说都不够友好。</p>\n</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"使用ROW-NUMBER-函数分页\"><a href=\"#使用ROW-NUMBER-函数分页\" class=\"headerlink\" title=\"使用ROW_NUMBER()函数分页\"></a>使用ROW_NUMBER()函数分页</h2><p>SQL Server 2005之后引入了 <code>ROW_NUMBER()</code> 函数，通过该函数根据定好的排序字段规则，产生记录序号</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span>  ROW_NUMBER() <span class=\"keyword\">OVER</span> ( <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> dbo.Products.ProductID <span class=\"keyword\">DESC</span> ) <span class=\"keyword\">AS</span> <span class=\"keyword\">rownum</span></span><br><span class=\"line\">      , *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>    dbo.Products</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span>  *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>    ( <span class=\"keyword\">SELECT</span> TOP ( @pageSize * @pageIndex )</span><br><span class=\"line\">                    ROW_NUMBER() <span class=\"keyword\">OVER</span> ( <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> dbo.Products.UnitPrice <span class=\"keyword\">DESC</span> ) <span class=\"keyword\">AS</span> <span class=\"keyword\">rownum</span> ,</span><br><span class=\"line\">                    *</span><br><span class=\"line\">          <span class=\"keyword\">FROM</span>      dbo.Products</span><br><span class=\"line\">        ) <span class=\"keyword\">AS</span> temp</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span>   temp.rownum &gt; ( @pageSize * ( @pageIndex - <span class=\"number\">1</span> ) )</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> temp.UnitPrice</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用OFFSET-FETCH子句分页\"><a href=\"#使用OFFSET-FETCH子句分页\" class=\"headerlink\" title=\"使用OFFSET FETCH子句分页\"></a>使用OFFSET FETCH子句分页</h2><p>SQL Server 2012中引入了<code>OFFSET-FETCH</code>语句，可以通过使用<code>OFFSET-FETCH</code>过滤器来实现分页</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span>  * </span><br><span class=\"line\"><span class=\"keyword\">FROM</span>    dbo.Products </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span>   <span class=\"keyword\">BY</span> UnitPrice <span class=\"keyword\">DESC</span> </span><br><span class=\"line\"><span class=\"keyword\">OFFSET</span>  ( @pageSize * ( @pageIndex - <span class=\"number\">1</span> )) <span class=\"keyword\">ROWS</span> </span><br><span class=\"line\"><span class=\"keyword\">FETCH</span> <span class=\"keyword\">NEXT</span> @pageSize <span class=\"keyword\">ROWS</span> <span class=\"keyword\">ONLY</span>;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>在编写Web应用程序等系统时，会涉及到与数据库的交互，如果数据库中数据量很大的话，一次检索所有的记录，会占用系统很大的资源，因此常常采用分页语句：需要多少数据就只从数据库中取多少条记录。</p>\n<p>常见的对大数据量查询的解决方案有以下两种：</p>\n<ol>\n<li><p>将全部数据先查询到内存中，然后在内存中进行分页，这种方式对内存占用较大，必须限制一次查询的数据量。</p>\n</li>\n<li><p>采用存储过程在数据库中进行分页，这种方式对数据库的依赖较大，不同的数据库实现机制不通，并且查询效率不够理想。以上两种方式对用户来说都不够友好。</p>\n</li>\n</ol>","more":"<h2 id=\"使用ROW-NUMBER-函数分页\"><a href=\"#使用ROW-NUMBER-函数分页\" class=\"headerlink\" title=\"使用ROW_NUMBER()函数分页\"></a>使用ROW_NUMBER()函数分页</h2><p>SQL Server 2005之后引入了 <code>ROW_NUMBER()</code> 函数，通过该函数根据定好的排序字段规则，产生记录序号</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span>  ROW_NUMBER() <span class=\"keyword\">OVER</span> ( <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> dbo.Products.ProductID <span class=\"keyword\">DESC</span> ) <span class=\"keyword\">AS</span> <span class=\"keyword\">rownum</span></span><br><span class=\"line\">      , *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>    dbo.Products</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span>  *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>    ( <span class=\"keyword\">SELECT</span> TOP ( @pageSize * @pageIndex )</span><br><span class=\"line\">                    ROW_NUMBER() <span class=\"keyword\">OVER</span> ( <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> dbo.Products.UnitPrice <span class=\"keyword\">DESC</span> ) <span class=\"keyword\">AS</span> <span class=\"keyword\">rownum</span> ,</span><br><span class=\"line\">                    *</span><br><span class=\"line\">          <span class=\"keyword\">FROM</span>      dbo.Products</span><br><span class=\"line\">        ) <span class=\"keyword\">AS</span> temp</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span>   temp.rownum &gt; ( @pageSize * ( @pageIndex - <span class=\"number\">1</span> ) )</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> temp.UnitPrice</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用OFFSET-FETCH子句分页\"><a href=\"#使用OFFSET-FETCH子句分页\" class=\"headerlink\" title=\"使用OFFSET FETCH子句分页\"></a>使用OFFSET FETCH子句分页</h2><p>SQL Server 2012中引入了<code>OFFSET-FETCH</code>语句，可以通过使用<code>OFFSET-FETCH</code>过滤器来实现分页</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span>  * </span><br><span class=\"line\"><span class=\"keyword\">FROM</span>    dbo.Products </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span>   <span class=\"keyword\">BY</span> UnitPrice <span class=\"keyword\">DESC</span> </span><br><span class=\"line\"><span class=\"keyword\">OFFSET</span>  ( @pageSize * ( @pageIndex - <span class=\"number\">1</span> )) <span class=\"keyword\">ROWS</span> </span><br><span class=\"line\"><span class=\"keyword\">FETCH</span> <span class=\"keyword\">NEXT</span> @pageSize <span class=\"keyword\">ROWS</span> <span class=\"keyword\">ONLY</span>;</span><br></pre></td></tr></table></figure>"},{"title":"SQL Server Slide Window partition","date":"2017-06-22T03:06:12.000Z","_content":"\n\n[上篇文章](https://lvraikkonen.github.io/2017/06/21/SQL-Server%E8%A1%A8%E5%88%86%E5%8C%BA/)详细介绍了表分区的概念和如何创建分区表。\n\n\n一个分区表创建好之后，随着数据量的逐渐增长，历史数据越来越不受待见：查询和更新频率越来越低，那么把这些历史数据进行归档就十分必要了。如果使用常规的SELECT、INSERT、DELETE进行历史数据归档的话，会出现以下的一系列问题：\n\n- DELETE效率太低\n\n  由于DELETE单个语句是一个事务性的语句，要么全部成功，要么全部失败。那么可想如果删除的是亿级别的数据，那么日志增长,IO负荷非常的大。\n\n- 迁移过程表会被锁住，这样可能会出现死锁，一旦迁移失败，又会造成更大的IO问题。\n\n这时候，在SQL Server中分区表有一个非常实用的语句 `ALTER TABLE …SWITCH`，这个DDL可以快速的将同文件组的表的某个分区迅速的转移到另外的表。这个是利用数据的位置偏移量的指针的转移到新表的方法来实现的。这种方案转移数据非常快。\n\n<!-- more -->\n\n## 滑动窗口 Sliding Window\n\n滑动窗口是为了在一个分区表上维持固定分区的方法，当新数据来的时候，创建新的数据分区、老的分区被移出分区表被删除或者被归档。由于滑动窗口操作在SQL Server中是元数据操作，所以速度会非常快。\n\n下面以AdventureWorks数据库中表FactResellerSales出发，从0开始将该表进行分区，并且以滑动窗口的方式进行动态分区的维护并归档历史数据。\n\n## Table Partition实践\n\n### 创建测试数据库\n\n这个测试数据库有两个文件组，PRIMARY文件组在E盘，SECONDARY文件组在D盘，用于归档数据用。\n\n``` sql\nCREATE DATABASE [PartitionDB]\nCONTAINMENT = NONE\nON  PRIMARY\n(NAME = N'PartitionDB', FILENAME = N'E:\\SQLServerData\\PartitionDB.mdf', SIZE = 10240KB, FILEGROWTH = 1024KB ),\nFILEGROUP [SECONDARY]\n(NAME = N'PartitionDBArchive', FILENAME = N'D:\\SQLServerData\\PartitionDBArchive.ndf', SIZE = 4096KB, FILEGROWTH = 1024KB )\nLOG ON\n(NAME = N'PartitionDB_log', FILENAME = N'E:\\SQLServerData\\PartitionDB_log.ldf', SIZE = 1024KB, FILEGROWTH = 10%)\nGO\n\nUSE [PartitionDB]\nGO\nIF NOT EXISTS (SELECT name FROM sys.filegroups\n                WHERE is_default=1 AND name = N'PRIMARY')\n    ALTER DATABASE [PartitionDB] MODIFY FILEGROUP [PRIMARY] DEFAULT\nGO\n```\n\n![DatabaseFileGroups](http://7xkfga.com1.z0.glb.clouddn.com/DBFileGroups.png)\n\n### 创建测试数据表\n\n以AdventureWorks的FactResellerSales表为例\n\n``` sql\nSelect * INTO FactResellerSales\nFROM [AdventureWorksDW2014].[dbo].[FactResellerSales]\n```\n\n在测试表数据导入之后，查看一下当前的表分区情况\n\n``` sql\nSELECT o.name objectname,i.name indexname, partition_id, partition_number, [rows]\nFROM sys.partitions p\nINNER JOIN sys.objects o ON o.object_id=p.object_id\nINNER JOIN sys.indexes i ON i.object_id=p.object_id and p.index_id=i.index_id\nWHERE o.name LIKE '%FactResellerSales%'\n```\n\n如下图：\n\n![startPartition](http://7xkfga.com1.z0.glb.clouddn.com/startPartitionStatus.png)\n\n可以看见，现在这个表有一个默认的分区，并且全部数据都在这个分区里面。\n\n### 在现有表上创建分区\n\n现在要在这个表上创建两个分区，根据OrderDate字段分为两个分区，一个小于2016-01-01，另外分区的数据大于等于这个时间(2016-01-01的数据分配到右面的分区)。按照上面文章写的步骤创建分区\n\n步骤1： 创建分区函数\n\n``` sql\nCREATE PARTITION FUNCTION [myPartitionRange] (DATETIME)\n    AS RANGE RIGHT FOR VALUES ('2016-01-01')\nGO\n```\n\n步骤2：创建分区方案\n\n在上面的两个文件组(PRIMARY, SECONDARY)上创建分区方案\n\n``` sql\nCREATE PARTITION SCHEME myPartitionScheme\n    AS PARTITION [myPartitionRange]\n    TO ([SECONDARY],[PRIMARY])\n```\n\n步骤3：在表上创建聚集索引并将分区方案作用在该字段上\n\n这里由于要根据字段 `OrderDate` 进行分区并归档，所以在该字段上创建聚集索引。\n\n``` sql\nCREATE CLUSTERED INDEX IX_FactResellerSales_OrderDate\n  ON FactResellerSales (OrderDate)\n  WITH (STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF,\n         ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON)\n  ON myPartitionScheme(OrderDate) -- AssignPartitionScheme\n```\n\n在创建好索引并应用分区方案后，再查看一下现在的表分区状态\n\n``` sql\nSELECT o.name objectname,i.name indexname, partition_id, partition_number, [rows]\nFROM sys.partitions p\nINNER JOIN sys.objects o ON o.object_id=p.object_id\nINNER JOIN sys.indexes i ON i.object_id=p.object_id and p.index_id=i.index_id\nWHERE o.name LIKE '%FactResellerSales%'\n```\n\n![newPartitionStatus](http://7xkfga.com1.z0.glb.clouddn.com/newPartitionStatus.png)\n\n可以看见，现在有两个分区：1、2，其中全部数据都在第一个分区里面，一共有60855条，也就是说60855条销售数据的OrderDate < '2016-01-01'\n\n### 测试新数据\n\n现在分区已经创建好，向这个表插入三条新的2016-01-01之后的数据\n\n``` sql\nINSERT INTO dbo.FactResellerSales\n(ProductKey, OrderDateKey, DueDateKey, ShipDateKey, ResellerKey, EmployeeKey, PromotionKey, CurrencyKey ,SalesTerritoryKey\n , SalesOrderNumber, SalesOrderLineNumber, RevisionNumber, OrderQuantity, UnitPrice, ExtendedAmount, UnitPriceDiscountPct, DiscountAmount\n , ProductStandardCost, TotalProductCost, SalesAmount, TaxAmt, Freight, CarrierTrackingNumber, CustomerPONumber, OrderDate, DueDate, ShipDate)\nVALUES\n(592, 20160101, 20160101, 20160101, 490, 281, 16, 100, 4, 'SO71952', 42, 1, 3, 20, 60, 0, 0, 50, 60, 2, 0, 0, '9490-4552-81', 'PO9715163911', '2016-01-01 00:00:00.000',  \n'2016-01-01 00:00:00.000', '2016-01-01 00:00:00.000')\n, (592, 20160101, 20160101, 20160101, 490, 281, 16, 100, 4, 'SO71952', 42, 1, 3, 20, 60, 0, 0, 50, 60, 2, 0, 0, '9490-4552-81', 'PO9715163911', '2016-01-02 00:00:00.000',  \n'2016-01-02 00:00:00.000', '2016-01-02 00:00:00.000')\n, (592, 20160101, 20160101, 20160101, 490, 281, 16, 100, 4, 'SO71952', 42, 1, 3, 20, 60, 0, 0, 50, 60, 2, 0, 0, '9490-4552-81', 'PO9715163911', '2016-01-03 00:00:00.000',  \n'2016-01-03 00:00:00.000', '2016-01-03 00:00:00.000')\n```\n\n\n在观察一下分区的情况，发现新插入的3条数据都在第二个分区里面\n\n![newPartitionData](http://7xkfga.com1.z0.glb.clouddn.com/newPartitionData.png)\n\n### 滑动窗口\n\n假设销售数据到了2017年，现在的任务就是把现有的两个分区合并，2016年以及以前的数据放到老的分区里面(D盘上面的那个文件组中)，2017年的数据插入到新的分区里面。\n\n在split partition之前，必须使用alter partition scheme 指定一个NEXT USED FileGroup。如果Partiton Scheme没有指定 next used filegroup，那么alter partition function split range command 执行失败\n\n``` sql\nDECLARE @CurrentYear DATETIME='2017-01-01'\nDECLARE @PrevMax DATETIME=(SELECT CONVERT(DATETIME,Value) FROM sys.partition_functions f\n                           INNER JOIN sys.partition_range_values r   \n                           ON f.function_id = r.function_id\n                           WHERE f.name = 'myPartitionRange')\nIF @PrevMax<@CurrentYear\nBEGIN TRY\nBEGIN TRAN\n-- Merge Old Partitions\nALTER PARTITION FUNCTION myPartitionRange()\nMERGE RANGE (@PrevMax)\n\n-- Assign NEXT USED filegroup\nALTER PARTITION SCHEME myPartitionScheme\nNEXT USED [PRIMARY]\n\n-- Split partition\nALTER PARTITION FUNCTION myPartitionRange()\nSPLIT RANGE (@CurrentYear)\n\nCOMMIT TRAN\nPRINT 'COMITIINGGGGGG'\nEND TRY\n\nBEGIN CATCH\nIF @@TRANCOUNT>0\nROLLBACK TRAN\nEND CATCH\n```\n\n执行完上面的步骤后，你会发现，2016年的那3条数据也被合并到第一个分区里面了，新的分区2数据为空，留给2017年\n\n![mergePartition](http://7xkfga.com1.z0.glb.clouddn.com/mergePartitionData.png)\n\n再插入3条2017年的数据试验一下\n\n``` sql\nINSERT INTO dbo.FactResellerSales\n(ProductKey, OrderDateKey, DueDateKey, ShipDateKey, ResellerKey, EmployeeKey, PromotionKey, CurrencyKey, SalesTerritoryKey,\nSalesOrderNumber, SalesOrderLineNumber, RevisionNumber, OrderQuantity, UnitPrice, ExtendedAmount, UnitPriceDiscountPct, DiscountAmount\n, ProductStandardCost, TotalProductCost, SalesAmount, TaxAmt, Freight, CarrierTrackingNumber, CustomerPONumber, OrderDate, DueDate, ShipDate)\nVALUES\n(592, 20170101, 20170101, 20170101, 490, 281, 16, 100, 4, 'SO71952', 42, 1, 3, 20, 60, 0, 0, 50, 60, 2, 0, 0, '9490-4552-81', 'PO9715163911', '2017-01-01 00:00:00.000',  \n'2017-01-01 00:00:00.000', '2017-01-01 00:00:00.000')\n, (592, 20170102, 20170102, 20170102, 490, 281, 16, 100, 4, 'SO71952', 42, 1, 3, 20, 60, 0, 0, 50, 60, 2, 0, 0, '9490-4552-81', 'PO9715163911', '2017-01-02 00:00:00.000',  \n'2017-01-02 00:00:00.000', '2017-01-02 00:00:00.000')\n, (592, 20170103, 20170103, 20170103, 490, 281, 16, 100, 4, 'SO71952', 42, 1, 3, 20, 60, 0, 0, 50, 60, 2, 0, 0, '9490-4552-81', 'PO9715163911', '2017-01-03 00:00:00.000',  \n'2017-01-03 00:00:00.000', '2017-01-03 00:00:00.000')\n```\n\n![2017PartitionData](http://7xkfga.com1.z0.glb.clouddn.com/2017PartitionData.png)\n\n\n现在，2016年以及更久之前的数据保存在分区1中，文件组存储在D盘上，而2017年最新的数据在分区2中，存储在E盘上，这样，就把新老数据在存储上分开，利用更好存储设备的性能查询和更新操作等。而对于查询或者操作这个表的用户来说，逻辑上这还是一张表。\n\n\n当然，还有另外一种方式进行老数据的归档操作，那就是两张物理表，一张仅存储最新数据，另一张存储归档数据\n","source":"_posts/SQL-Server-Slide-Window-partition.md","raw":"---\ntitle: SQL Server Slide Window partition\ndate: 2017-06-22 11:06:12\ntags:\n- SQL Server\n- Database\n- 表分区\n---\n\n\n[上篇文章](https://lvraikkonen.github.io/2017/06/21/SQL-Server%E8%A1%A8%E5%88%86%E5%8C%BA/)详细介绍了表分区的概念和如何创建分区表。\n\n\n一个分区表创建好之后，随着数据量的逐渐增长，历史数据越来越不受待见：查询和更新频率越来越低，那么把这些历史数据进行归档就十分必要了。如果使用常规的SELECT、INSERT、DELETE进行历史数据归档的话，会出现以下的一系列问题：\n\n- DELETE效率太低\n\n  由于DELETE单个语句是一个事务性的语句，要么全部成功，要么全部失败。那么可想如果删除的是亿级别的数据，那么日志增长,IO负荷非常的大。\n\n- 迁移过程表会被锁住，这样可能会出现死锁，一旦迁移失败，又会造成更大的IO问题。\n\n这时候，在SQL Server中分区表有一个非常实用的语句 `ALTER TABLE …SWITCH`，这个DDL可以快速的将同文件组的表的某个分区迅速的转移到另外的表。这个是利用数据的位置偏移量的指针的转移到新表的方法来实现的。这种方案转移数据非常快。\n\n<!-- more -->\n\n## 滑动窗口 Sliding Window\n\n滑动窗口是为了在一个分区表上维持固定分区的方法，当新数据来的时候，创建新的数据分区、老的分区被移出分区表被删除或者被归档。由于滑动窗口操作在SQL Server中是元数据操作，所以速度会非常快。\n\n下面以AdventureWorks数据库中表FactResellerSales出发，从0开始将该表进行分区，并且以滑动窗口的方式进行动态分区的维护并归档历史数据。\n\n## Table Partition实践\n\n### 创建测试数据库\n\n这个测试数据库有两个文件组，PRIMARY文件组在E盘，SECONDARY文件组在D盘，用于归档数据用。\n\n``` sql\nCREATE DATABASE [PartitionDB]\nCONTAINMENT = NONE\nON  PRIMARY\n(NAME = N'PartitionDB', FILENAME = N'E:\\SQLServerData\\PartitionDB.mdf', SIZE = 10240KB, FILEGROWTH = 1024KB ),\nFILEGROUP [SECONDARY]\n(NAME = N'PartitionDBArchive', FILENAME = N'D:\\SQLServerData\\PartitionDBArchive.ndf', SIZE = 4096KB, FILEGROWTH = 1024KB )\nLOG ON\n(NAME = N'PartitionDB_log', FILENAME = N'E:\\SQLServerData\\PartitionDB_log.ldf', SIZE = 1024KB, FILEGROWTH = 10%)\nGO\n\nUSE [PartitionDB]\nGO\nIF NOT EXISTS (SELECT name FROM sys.filegroups\n                WHERE is_default=1 AND name = N'PRIMARY')\n    ALTER DATABASE [PartitionDB] MODIFY FILEGROUP [PRIMARY] DEFAULT\nGO\n```\n\n![DatabaseFileGroups](http://7xkfga.com1.z0.glb.clouddn.com/DBFileGroups.png)\n\n### 创建测试数据表\n\n以AdventureWorks的FactResellerSales表为例\n\n``` sql\nSelect * INTO FactResellerSales\nFROM [AdventureWorksDW2014].[dbo].[FactResellerSales]\n```\n\n在测试表数据导入之后，查看一下当前的表分区情况\n\n``` sql\nSELECT o.name objectname,i.name indexname, partition_id, partition_number, [rows]\nFROM sys.partitions p\nINNER JOIN sys.objects o ON o.object_id=p.object_id\nINNER JOIN sys.indexes i ON i.object_id=p.object_id and p.index_id=i.index_id\nWHERE o.name LIKE '%FactResellerSales%'\n```\n\n如下图：\n\n![startPartition](http://7xkfga.com1.z0.glb.clouddn.com/startPartitionStatus.png)\n\n可以看见，现在这个表有一个默认的分区，并且全部数据都在这个分区里面。\n\n### 在现有表上创建分区\n\n现在要在这个表上创建两个分区，根据OrderDate字段分为两个分区，一个小于2016-01-01，另外分区的数据大于等于这个时间(2016-01-01的数据分配到右面的分区)。按照上面文章写的步骤创建分区\n\n步骤1： 创建分区函数\n\n``` sql\nCREATE PARTITION FUNCTION [myPartitionRange] (DATETIME)\n    AS RANGE RIGHT FOR VALUES ('2016-01-01')\nGO\n```\n\n步骤2：创建分区方案\n\n在上面的两个文件组(PRIMARY, SECONDARY)上创建分区方案\n\n``` sql\nCREATE PARTITION SCHEME myPartitionScheme\n    AS PARTITION [myPartitionRange]\n    TO ([SECONDARY],[PRIMARY])\n```\n\n步骤3：在表上创建聚集索引并将分区方案作用在该字段上\n\n这里由于要根据字段 `OrderDate` 进行分区并归档，所以在该字段上创建聚集索引。\n\n``` sql\nCREATE CLUSTERED INDEX IX_FactResellerSales_OrderDate\n  ON FactResellerSales (OrderDate)\n  WITH (STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF,\n         ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON)\n  ON myPartitionScheme(OrderDate) -- AssignPartitionScheme\n```\n\n在创建好索引并应用分区方案后，再查看一下现在的表分区状态\n\n``` sql\nSELECT o.name objectname,i.name indexname, partition_id, partition_number, [rows]\nFROM sys.partitions p\nINNER JOIN sys.objects o ON o.object_id=p.object_id\nINNER JOIN sys.indexes i ON i.object_id=p.object_id and p.index_id=i.index_id\nWHERE o.name LIKE '%FactResellerSales%'\n```\n\n![newPartitionStatus](http://7xkfga.com1.z0.glb.clouddn.com/newPartitionStatus.png)\n\n可以看见，现在有两个分区：1、2，其中全部数据都在第一个分区里面，一共有60855条，也就是说60855条销售数据的OrderDate < '2016-01-01'\n\n### 测试新数据\n\n现在分区已经创建好，向这个表插入三条新的2016-01-01之后的数据\n\n``` sql\nINSERT INTO dbo.FactResellerSales\n(ProductKey, OrderDateKey, DueDateKey, ShipDateKey, ResellerKey, EmployeeKey, PromotionKey, CurrencyKey ,SalesTerritoryKey\n , SalesOrderNumber, SalesOrderLineNumber, RevisionNumber, OrderQuantity, UnitPrice, ExtendedAmount, UnitPriceDiscountPct, DiscountAmount\n , ProductStandardCost, TotalProductCost, SalesAmount, TaxAmt, Freight, CarrierTrackingNumber, CustomerPONumber, OrderDate, DueDate, ShipDate)\nVALUES\n(592, 20160101, 20160101, 20160101, 490, 281, 16, 100, 4, 'SO71952', 42, 1, 3, 20, 60, 0, 0, 50, 60, 2, 0, 0, '9490-4552-81', 'PO9715163911', '2016-01-01 00:00:00.000',  \n'2016-01-01 00:00:00.000', '2016-01-01 00:00:00.000')\n, (592, 20160101, 20160101, 20160101, 490, 281, 16, 100, 4, 'SO71952', 42, 1, 3, 20, 60, 0, 0, 50, 60, 2, 0, 0, '9490-4552-81', 'PO9715163911', '2016-01-02 00:00:00.000',  \n'2016-01-02 00:00:00.000', '2016-01-02 00:00:00.000')\n, (592, 20160101, 20160101, 20160101, 490, 281, 16, 100, 4, 'SO71952', 42, 1, 3, 20, 60, 0, 0, 50, 60, 2, 0, 0, '9490-4552-81', 'PO9715163911', '2016-01-03 00:00:00.000',  \n'2016-01-03 00:00:00.000', '2016-01-03 00:00:00.000')\n```\n\n\n在观察一下分区的情况，发现新插入的3条数据都在第二个分区里面\n\n![newPartitionData](http://7xkfga.com1.z0.glb.clouddn.com/newPartitionData.png)\n\n### 滑动窗口\n\n假设销售数据到了2017年，现在的任务就是把现有的两个分区合并，2016年以及以前的数据放到老的分区里面(D盘上面的那个文件组中)，2017年的数据插入到新的分区里面。\n\n在split partition之前，必须使用alter partition scheme 指定一个NEXT USED FileGroup。如果Partiton Scheme没有指定 next used filegroup，那么alter partition function split range command 执行失败\n\n``` sql\nDECLARE @CurrentYear DATETIME='2017-01-01'\nDECLARE @PrevMax DATETIME=(SELECT CONVERT(DATETIME,Value) FROM sys.partition_functions f\n                           INNER JOIN sys.partition_range_values r   \n                           ON f.function_id = r.function_id\n                           WHERE f.name = 'myPartitionRange')\nIF @PrevMax<@CurrentYear\nBEGIN TRY\nBEGIN TRAN\n-- Merge Old Partitions\nALTER PARTITION FUNCTION myPartitionRange()\nMERGE RANGE (@PrevMax)\n\n-- Assign NEXT USED filegroup\nALTER PARTITION SCHEME myPartitionScheme\nNEXT USED [PRIMARY]\n\n-- Split partition\nALTER PARTITION FUNCTION myPartitionRange()\nSPLIT RANGE (@CurrentYear)\n\nCOMMIT TRAN\nPRINT 'COMITIINGGGGGG'\nEND TRY\n\nBEGIN CATCH\nIF @@TRANCOUNT>0\nROLLBACK TRAN\nEND CATCH\n```\n\n执行完上面的步骤后，你会发现，2016年的那3条数据也被合并到第一个分区里面了，新的分区2数据为空，留给2017年\n\n![mergePartition](http://7xkfga.com1.z0.glb.clouddn.com/mergePartitionData.png)\n\n再插入3条2017年的数据试验一下\n\n``` sql\nINSERT INTO dbo.FactResellerSales\n(ProductKey, OrderDateKey, DueDateKey, ShipDateKey, ResellerKey, EmployeeKey, PromotionKey, CurrencyKey, SalesTerritoryKey,\nSalesOrderNumber, SalesOrderLineNumber, RevisionNumber, OrderQuantity, UnitPrice, ExtendedAmount, UnitPriceDiscountPct, DiscountAmount\n, ProductStandardCost, TotalProductCost, SalesAmount, TaxAmt, Freight, CarrierTrackingNumber, CustomerPONumber, OrderDate, DueDate, ShipDate)\nVALUES\n(592, 20170101, 20170101, 20170101, 490, 281, 16, 100, 4, 'SO71952', 42, 1, 3, 20, 60, 0, 0, 50, 60, 2, 0, 0, '9490-4552-81', 'PO9715163911', '2017-01-01 00:00:00.000',  \n'2017-01-01 00:00:00.000', '2017-01-01 00:00:00.000')\n, (592, 20170102, 20170102, 20170102, 490, 281, 16, 100, 4, 'SO71952', 42, 1, 3, 20, 60, 0, 0, 50, 60, 2, 0, 0, '9490-4552-81', 'PO9715163911', '2017-01-02 00:00:00.000',  \n'2017-01-02 00:00:00.000', '2017-01-02 00:00:00.000')\n, (592, 20170103, 20170103, 20170103, 490, 281, 16, 100, 4, 'SO71952', 42, 1, 3, 20, 60, 0, 0, 50, 60, 2, 0, 0, '9490-4552-81', 'PO9715163911', '2017-01-03 00:00:00.000',  \n'2017-01-03 00:00:00.000', '2017-01-03 00:00:00.000')\n```\n\n![2017PartitionData](http://7xkfga.com1.z0.glb.clouddn.com/2017PartitionData.png)\n\n\n现在，2016年以及更久之前的数据保存在分区1中，文件组存储在D盘上，而2017年最新的数据在分区2中，存储在E盘上，这样，就把新老数据在存储上分开，利用更好存储设备的性能查询和更新操作等。而对于查询或者操作这个表的用户来说，逻辑上这还是一张表。\n\n\n当然，还有另外一种方式进行老数据的归档操作，那就是两张物理表，一张仅存储最新数据，另一张存储归档数据\n","slug":"SQL-Server-Slide-Window-partition","published":1,"updated":"2017-06-28T06:21:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3om003dzd68es6tcgjc","content":"<p><a href=\"https://lvraikkonen.github.io/2017/06/21/SQL-Server%E8%A1%A8%E5%88%86%E5%8C%BA/\">上篇文章</a>详细介绍了表分区的概念和如何创建分区表。</p>\n<p>一个分区表创建好之后，随着数据量的逐渐增长，历史数据越来越不受待见：查询和更新频率越来越低，那么把这些历史数据进行归档就十分必要了。如果使用常规的SELECT、INSERT、DELETE进行历史数据归档的话，会出现以下的一系列问题：</p>\n<ul>\n<li><p>DELETE效率太低</p>\n<p>由于DELETE单个语句是一个事务性的语句，要么全部成功，要么全部失败。那么可想如果删除的是亿级别的数据，那么日志增长,IO负荷非常的大。</p>\n</li>\n<li><p>迁移过程表会被锁住，这样可能会出现死锁，一旦迁移失败，又会造成更大的IO问题。</p>\n</li>\n</ul>\n<p>这时候，在SQL Server中分区表有一个非常实用的语句 <code>ALTER TABLE …SWITCH</code>，这个DDL可以快速的将同文件组的表的某个分区迅速的转移到另外的表。这个是利用数据的位置偏移量的指针的转移到新表的方法来实现的。这种方案转移数据非常快。</p>\n<a id=\"more\"></a>\n<h2 id=\"滑动窗口-Sliding-Window\"><a href=\"#滑动窗口-Sliding-Window\" class=\"headerlink\" title=\"滑动窗口 Sliding Window\"></a>滑动窗口 Sliding Window</h2><p>滑动窗口是为了在一个分区表上维持固定分区的方法，当新数据来的时候，创建新的数据分区、老的分区被移出分区表被删除或者被归档。由于滑动窗口操作在SQL Server中是元数据操作，所以速度会非常快。</p>\n<p>下面以AdventureWorks数据库中表FactResellerSales出发，从0开始将该表进行分区，并且以滑动窗口的方式进行动态分区的维护并归档历史数据。</p>\n<h2 id=\"Table-Partition实践\"><a href=\"#Table-Partition实践\" class=\"headerlink\" title=\"Table Partition实践\"></a>Table Partition实践</h2><h3 id=\"创建测试数据库\"><a href=\"#创建测试数据库\" class=\"headerlink\" title=\"创建测试数据库\"></a>创建测试数据库</h3><p>这个测试数据库有两个文件组，PRIMARY文件组在E盘，SECONDARY文件组在D盘，用于归档数据用。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">DATABASE</span> [PartitionDB]</span><br><span class=\"line\">CONTAINMENT = <span class=\"keyword\">NONE</span></span><br><span class=\"line\"><span class=\"keyword\">ON</span>  PRIMARY</span><br><span class=\"line\">(<span class=\"keyword\">NAME</span> = N<span class=\"string\">'PartitionDB'</span>, FILENAME = N<span class=\"string\">'E:\\SQLServerData\\PartitionDB.mdf'</span>, <span class=\"keyword\">SIZE</span> = <span class=\"number\">10240</span>KB, FILEGROWTH = <span class=\"number\">1024</span>KB ),</span><br><span class=\"line\">FILEGROUP [SECONDARY]</span><br><span class=\"line\">(<span class=\"keyword\">NAME</span> = N<span class=\"string\">'PartitionDBArchive'</span>, FILENAME = N<span class=\"string\">'D:\\SQLServerData\\PartitionDBArchive.ndf'</span>, <span class=\"keyword\">SIZE</span> = <span class=\"number\">4096</span>KB, FILEGROWTH = <span class=\"number\">1024</span>KB )</span><br><span class=\"line\"><span class=\"keyword\">LOG</span> <span class=\"keyword\">ON</span></span><br><span class=\"line\">(<span class=\"keyword\">NAME</span> = N<span class=\"string\">'PartitionDB_log'</span>, FILENAME = N<span class=\"string\">'E:\\SQLServerData\\PartitionDB_log.ldf'</span>, <span class=\"keyword\">SIZE</span> = <span class=\"number\">1024</span>KB, FILEGROWTH = <span class=\"number\">10</span>%)</span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">USE</span> [PartitionDB]</span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br><span class=\"line\"><span class=\"keyword\">IF</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> (<span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span> <span class=\"keyword\">FROM</span> sys.filegroups</span><br><span class=\"line\">                <span class=\"keyword\">WHERE</span> is_default=<span class=\"number\">1</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">name</span> = N<span class=\"string\">'PRIMARY'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> [PartitionDB] <span class=\"keyword\">MODIFY</span> FILEGROUP [PRIMARY] <span class=\"keyword\">DEFAULT</span></span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/DBFileGroups.png\" alt=\"DatabaseFileGroups\"></p>\n<h3 id=\"创建测试数据表\"><a href=\"#创建测试数据表\" class=\"headerlink\" title=\"创建测试数据表\"></a>创建测试数据表</h3><p>以AdventureWorks的FactResellerSales表为例</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> * <span class=\"keyword\">INTO</span> FactResellerSales</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> [AdventureWorksDW2014].[dbo].[FactResellerSales]</span><br></pre></td></tr></table></figure>\n<p>在测试表数据导入之后，查看一下当前的表分区情况</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> o.name objectname,i.name indexname, partition_id, partition_number, [<span class=\"keyword\">rows</span>]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> sys.partitions p</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> sys.objects o <span class=\"keyword\">ON</span> o.object_id=p.object_id</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> sys.indexes i <span class=\"keyword\">ON</span> i.object_id=p.object_id <span class=\"keyword\">and</span> p.index_id=i.index_id</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> o.name <span class=\"keyword\">LIKE</span> <span class=\"string\">'%FactResellerSales%'</span></span><br></pre></td></tr></table></figure>\n<p>如下图：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/startPartitionStatus.png\" alt=\"startPartition\"></p>\n<p>可以看见，现在这个表有一个默认的分区，并且全部数据都在这个分区里面。</p>\n<h3 id=\"在现有表上创建分区\"><a href=\"#在现有表上创建分区\" class=\"headerlink\" title=\"在现有表上创建分区\"></a>在现有表上创建分区</h3><p>现在要在这个表上创建两个分区，根据OrderDate字段分为两个分区，一个小于2016-01-01，另外分区的数据大于等于这个时间(2016-01-01的数据分配到右面的分区)。按照上面文章写的步骤创建分区</p>\n<p>步骤1： 创建分区函数</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">FUNCTION</span> [myPartitionRange] (DATETIME)</span><br><span class=\"line\">    <span class=\"keyword\">AS</span> <span class=\"keyword\">RANGE</span> <span class=\"keyword\">RIGHT</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'2016-01-01'</span>)</span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br></pre></td></tr></table></figure>\n<p>步骤2：创建分区方案</p>\n<p>在上面的两个文件组(PRIMARY, SECONDARY)上创建分区方案</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PARTITION</span> SCHEME myPartitionScheme</span><br><span class=\"line\">    <span class=\"keyword\">AS</span> <span class=\"keyword\">PARTITION</span> [myPartitionRange]</span><br><span class=\"line\">    <span class=\"keyword\">TO</span> ([SECONDARY],[PRIMARY])</span><br></pre></td></tr></table></figure>\n<p>步骤3：在表上创建聚集索引并将分区方案作用在该字段上</p>\n<p>这里由于要根据字段 <code>OrderDate</code> 进行分区并归档，所以在该字段上创建聚集索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> CLUSTERED <span class=\"keyword\">INDEX</span> IX_FactResellerSales_OrderDate</span><br><span class=\"line\">  <span class=\"keyword\">ON</span> FactResellerSales (OrderDate)</span><br><span class=\"line\">  <span class=\"keyword\">WITH</span> (STATISTICS_NORECOMPUTE = <span class=\"keyword\">OFF</span>, IGNORE_DUP_KEY = <span class=\"keyword\">OFF</span>,</span><br><span class=\"line\">         ALLOW_ROW_LOCKS = <span class=\"keyword\">ON</span>, ALLOW_PAGE_LOCKS = <span class=\"keyword\">ON</span>)</span><br><span class=\"line\">  <span class=\"keyword\">ON</span> myPartitionScheme(OrderDate) <span class=\"comment\">-- AssignPartitionScheme</span></span><br></pre></td></tr></table></figure>\n<p>在创建好索引并应用分区方案后，再查看一下现在的表分区状态</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> o.name objectname,i.name indexname, partition_id, partition_number, [<span class=\"keyword\">rows</span>]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> sys.partitions p</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> sys.objects o <span class=\"keyword\">ON</span> o.object_id=p.object_id</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> sys.indexes i <span class=\"keyword\">ON</span> i.object_id=p.object_id <span class=\"keyword\">and</span> p.index_id=i.index_id</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> o.name <span class=\"keyword\">LIKE</span> <span class=\"string\">'%FactResellerSales%'</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/newPartitionStatus.png\" alt=\"newPartitionStatus\"></p>\n<p>可以看见，现在有两个分区：1、2，其中全部数据都在第一个分区里面，一共有60855条，也就是说60855条销售数据的OrderDate &lt; ‘2016-01-01’</p>\n<h3 id=\"测试新数据\"><a href=\"#测试新数据\" class=\"headerlink\" title=\"测试新数据\"></a>测试新数据</h3><p>现在分区已经创建好，向这个表插入三条新的2016-01-01之后的数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> dbo.FactResellerSales</span><br><span class=\"line\">(ProductKey, OrderDateKey, DueDateKey, ShipDateKey, ResellerKey, EmployeeKey, PromotionKey, CurrencyKey ,SalesTerritoryKey</span><br><span class=\"line\"> , SalesOrderNumber, SalesOrderLineNumber, RevisionNumber, OrderQuantity, UnitPrice, ExtendedAmount, UnitPriceDiscountPct, DiscountAmount</span><br><span class=\"line\"> , ProductStandardCost, TotalProductCost, SalesAmount, TaxAmt, Freight, CarrierTrackingNumber, CustomerPONumber, OrderDate, DueDate, ShipDate)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span></span><br><span class=\"line\">(<span class=\"number\">592</span>, <span class=\"number\">20160101</span>, <span class=\"number\">20160101</span>, <span class=\"number\">20160101</span>, <span class=\"number\">490</span>, <span class=\"number\">281</span>, <span class=\"number\">16</span>, <span class=\"number\">100</span>, <span class=\"number\">4</span>, <span class=\"string\">'SO71952'</span>, <span class=\"number\">42</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'9490-4552-81'</span>, <span class=\"string\">'PO9715163911'</span>, <span class=\"string\">'2016-01-01 00:00:00.000'</span>,  </span><br><span class=\"line\"><span class=\"string\">'2016-01-01 00:00:00.000'</span>, <span class=\"string\">'2016-01-01 00:00:00.000'</span>)</span><br><span class=\"line\">, (<span class=\"number\">592</span>, <span class=\"number\">20160101</span>, <span class=\"number\">20160101</span>, <span class=\"number\">20160101</span>, <span class=\"number\">490</span>, <span class=\"number\">281</span>, <span class=\"number\">16</span>, <span class=\"number\">100</span>, <span class=\"number\">4</span>, <span class=\"string\">'SO71952'</span>, <span class=\"number\">42</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'9490-4552-81'</span>, <span class=\"string\">'PO9715163911'</span>, <span class=\"string\">'2016-01-02 00:00:00.000'</span>,  </span><br><span class=\"line\"><span class=\"string\">'2016-01-02 00:00:00.000'</span>, <span class=\"string\">'2016-01-02 00:00:00.000'</span>)</span><br><span class=\"line\">, (<span class=\"number\">592</span>, <span class=\"number\">20160101</span>, <span class=\"number\">20160101</span>, <span class=\"number\">20160101</span>, <span class=\"number\">490</span>, <span class=\"number\">281</span>, <span class=\"number\">16</span>, <span class=\"number\">100</span>, <span class=\"number\">4</span>, <span class=\"string\">'SO71952'</span>, <span class=\"number\">42</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'9490-4552-81'</span>, <span class=\"string\">'PO9715163911'</span>, <span class=\"string\">'2016-01-03 00:00:00.000'</span>,  </span><br><span class=\"line\"><span class=\"string\">'2016-01-03 00:00:00.000'</span>, <span class=\"string\">'2016-01-03 00:00:00.000'</span>)</span><br></pre></td></tr></table></figure>\n<p>在观察一下分区的情况，发现新插入的3条数据都在第二个分区里面</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/newPartitionData.png\" alt=\"newPartitionData\"></p>\n<h3 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h3><p>假设销售数据到了2017年，现在的任务就是把现有的两个分区合并，2016年以及以前的数据放到老的分区里面(D盘上面的那个文件组中)，2017年的数据插入到新的分区里面。</p>\n<p>在split partition之前，必须使用alter partition scheme 指定一个NEXT USED FileGroup。如果Partiton Scheme没有指定 next used filegroup，那么alter partition function split range command 执行失败</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span> @CurrentYear DATETIME=<span class=\"string\">'2017-01-01'</span></span><br><span class=\"line\"><span class=\"keyword\">DECLARE</span> @PrevMax DATETIME=(<span class=\"keyword\">SELECT</span> <span class=\"keyword\">CONVERT</span>(DATETIME,<span class=\"keyword\">Value</span>) <span class=\"keyword\">FROM</span> sys.partition_functions f</span><br><span class=\"line\">                           <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> sys.partition_range_values r   </span><br><span class=\"line\">                           <span class=\"keyword\">ON</span> f.function_id = r.function_id</span><br><span class=\"line\">                           <span class=\"keyword\">WHERE</span> f.name = <span class=\"string\">'myPartitionRange'</span>)</span><br><span class=\"line\"><span class=\"keyword\">IF</span> @PrevMax&lt;@CurrentYear</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span> TRY</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span> TRAN</span><br><span class=\"line\"><span class=\"comment\">-- Merge Old Partitions</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">FUNCTION</span> myPartitionRange()</span><br><span class=\"line\"><span class=\"keyword\">MERGE</span> <span class=\"keyword\">RANGE</span> (@PrevMax)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- Assign NEXT USED filegroup</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">PARTITION</span> SCHEME myPartitionScheme</span><br><span class=\"line\"><span class=\"keyword\">NEXT</span> USED [PRIMARY]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- Split partition</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">FUNCTION</span> myPartitionRange()</span><br><span class=\"line\"><span class=\"keyword\">SPLIT</span> <span class=\"keyword\">RANGE</span> (@CurrentYear)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span> TRAN</span><br><span class=\"line\">PRINT <span class=\"string\">'COMITIINGGGGGG'</span></span><br><span class=\"line\"><span class=\"keyword\">END</span> TRY</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span> CATCH</span><br><span class=\"line\"><span class=\"keyword\">IF</span> @@TRANCOUNT&gt;<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">ROLLBACK</span> TRAN</span><br><span class=\"line\"><span class=\"keyword\">END</span> CATCH</span><br></pre></td></tr></table></figure>\n<p>执行完上面的步骤后，你会发现，2016年的那3条数据也被合并到第一个分区里面了，新的分区2数据为空，留给2017年</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/mergePartitionData.png\" alt=\"mergePartition\"></p>\n<p>再插入3条2017年的数据试验一下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> dbo.FactResellerSales</span><br><span class=\"line\">(ProductKey, OrderDateKey, DueDateKey, ShipDateKey, ResellerKey, EmployeeKey, PromotionKey, CurrencyKey, SalesTerritoryKey,</span><br><span class=\"line\">SalesOrderNumber, SalesOrderLineNumber, RevisionNumber, OrderQuantity, UnitPrice, ExtendedAmount, UnitPriceDiscountPct, DiscountAmount</span><br><span class=\"line\">, ProductStandardCost, TotalProductCost, SalesAmount, TaxAmt, Freight, CarrierTrackingNumber, CustomerPONumber, OrderDate, DueDate, ShipDate)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span></span><br><span class=\"line\">(<span class=\"number\">592</span>, <span class=\"number\">20170101</span>, <span class=\"number\">20170101</span>, <span class=\"number\">20170101</span>, <span class=\"number\">490</span>, <span class=\"number\">281</span>, <span class=\"number\">16</span>, <span class=\"number\">100</span>, <span class=\"number\">4</span>, <span class=\"string\">'SO71952'</span>, <span class=\"number\">42</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'9490-4552-81'</span>, <span class=\"string\">'PO9715163911'</span>, <span class=\"string\">'2017-01-01 00:00:00.000'</span>,  </span><br><span class=\"line\"><span class=\"string\">'2017-01-01 00:00:00.000'</span>, <span class=\"string\">'2017-01-01 00:00:00.000'</span>)</span><br><span class=\"line\">, (<span class=\"number\">592</span>, <span class=\"number\">20170102</span>, <span class=\"number\">20170102</span>, <span class=\"number\">20170102</span>, <span class=\"number\">490</span>, <span class=\"number\">281</span>, <span class=\"number\">16</span>, <span class=\"number\">100</span>, <span class=\"number\">4</span>, <span class=\"string\">'SO71952'</span>, <span class=\"number\">42</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'9490-4552-81'</span>, <span class=\"string\">'PO9715163911'</span>, <span class=\"string\">'2017-01-02 00:00:00.000'</span>,  </span><br><span class=\"line\"><span class=\"string\">'2017-01-02 00:00:00.000'</span>, <span class=\"string\">'2017-01-02 00:00:00.000'</span>)</span><br><span class=\"line\">, (<span class=\"number\">592</span>, <span class=\"number\">20170103</span>, <span class=\"number\">20170103</span>, <span class=\"number\">20170103</span>, <span class=\"number\">490</span>, <span class=\"number\">281</span>, <span class=\"number\">16</span>, <span class=\"number\">100</span>, <span class=\"number\">4</span>, <span class=\"string\">'SO71952'</span>, <span class=\"number\">42</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'9490-4552-81'</span>, <span class=\"string\">'PO9715163911'</span>, <span class=\"string\">'2017-01-03 00:00:00.000'</span>,  </span><br><span class=\"line\"><span class=\"string\">'2017-01-03 00:00:00.000'</span>, <span class=\"string\">'2017-01-03 00:00:00.000'</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/2017PartitionData.png\" alt=\"2017PartitionData\"></p>\n<p>现在，2016年以及更久之前的数据保存在分区1中，文件组存储在D盘上，而2017年最新的数据在分区2中，存储在E盘上，这样，就把新老数据在存储上分开，利用更好存储设备的性能查询和更新操作等。而对于查询或者操作这个表的用户来说，逻辑上这还是一张表。</p>\n<p>当然，还有另外一种方式进行老数据的归档操作，那就是两张物理表，一张仅存储最新数据，另一张存储归档数据</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://lvraikkonen.github.io/2017/06/21/SQL-Server%E8%A1%A8%E5%88%86%E5%8C%BA/\">上篇文章</a>详细介绍了表分区的概念和如何创建分区表。</p>\n<p>一个分区表创建好之后，随着数据量的逐渐增长，历史数据越来越不受待见：查询和更新频率越来越低，那么把这些历史数据进行归档就十分必要了。如果使用常规的SELECT、INSERT、DELETE进行历史数据归档的话，会出现以下的一系列问题：</p>\n<ul>\n<li><p>DELETE效率太低</p>\n<p>由于DELETE单个语句是一个事务性的语句，要么全部成功，要么全部失败。那么可想如果删除的是亿级别的数据，那么日志增长,IO负荷非常的大。</p>\n</li>\n<li><p>迁移过程表会被锁住，这样可能会出现死锁，一旦迁移失败，又会造成更大的IO问题。</p>\n</li>\n</ul>\n<p>这时候，在SQL Server中分区表有一个非常实用的语句 <code>ALTER TABLE …SWITCH</code>，这个DDL可以快速的将同文件组的表的某个分区迅速的转移到另外的表。这个是利用数据的位置偏移量的指针的转移到新表的方法来实现的。这种方案转移数据非常快。</p>","more":"<h2 id=\"滑动窗口-Sliding-Window\"><a href=\"#滑动窗口-Sliding-Window\" class=\"headerlink\" title=\"滑动窗口 Sliding Window\"></a>滑动窗口 Sliding Window</h2><p>滑动窗口是为了在一个分区表上维持固定分区的方法，当新数据来的时候，创建新的数据分区、老的分区被移出分区表被删除或者被归档。由于滑动窗口操作在SQL Server中是元数据操作，所以速度会非常快。</p>\n<p>下面以AdventureWorks数据库中表FactResellerSales出发，从0开始将该表进行分区，并且以滑动窗口的方式进行动态分区的维护并归档历史数据。</p>\n<h2 id=\"Table-Partition实践\"><a href=\"#Table-Partition实践\" class=\"headerlink\" title=\"Table Partition实践\"></a>Table Partition实践</h2><h3 id=\"创建测试数据库\"><a href=\"#创建测试数据库\" class=\"headerlink\" title=\"创建测试数据库\"></a>创建测试数据库</h3><p>这个测试数据库有两个文件组，PRIMARY文件组在E盘，SECONDARY文件组在D盘，用于归档数据用。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">DATABASE</span> [PartitionDB]</span><br><span class=\"line\">CONTAINMENT = <span class=\"keyword\">NONE</span></span><br><span class=\"line\"><span class=\"keyword\">ON</span>  PRIMARY</span><br><span class=\"line\">(<span class=\"keyword\">NAME</span> = N<span class=\"string\">'PartitionDB'</span>, FILENAME = N<span class=\"string\">'E:\\SQLServerData\\PartitionDB.mdf'</span>, <span class=\"keyword\">SIZE</span> = <span class=\"number\">10240</span>KB, FILEGROWTH = <span class=\"number\">1024</span>KB ),</span><br><span class=\"line\">FILEGROUP [SECONDARY]</span><br><span class=\"line\">(<span class=\"keyword\">NAME</span> = N<span class=\"string\">'PartitionDBArchive'</span>, FILENAME = N<span class=\"string\">'D:\\SQLServerData\\PartitionDBArchive.ndf'</span>, <span class=\"keyword\">SIZE</span> = <span class=\"number\">4096</span>KB, FILEGROWTH = <span class=\"number\">1024</span>KB )</span><br><span class=\"line\"><span class=\"keyword\">LOG</span> <span class=\"keyword\">ON</span></span><br><span class=\"line\">(<span class=\"keyword\">NAME</span> = N<span class=\"string\">'PartitionDB_log'</span>, FILENAME = N<span class=\"string\">'E:\\SQLServerData\\PartitionDB_log.ldf'</span>, <span class=\"keyword\">SIZE</span> = <span class=\"number\">1024</span>KB, FILEGROWTH = <span class=\"number\">10</span>%)</span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">USE</span> [PartitionDB]</span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br><span class=\"line\"><span class=\"keyword\">IF</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> (<span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span> <span class=\"keyword\">FROM</span> sys.filegroups</span><br><span class=\"line\">                <span class=\"keyword\">WHERE</span> is_default=<span class=\"number\">1</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">name</span> = N<span class=\"string\">'PRIMARY'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> [PartitionDB] <span class=\"keyword\">MODIFY</span> FILEGROUP [PRIMARY] <span class=\"keyword\">DEFAULT</span></span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/DBFileGroups.png\" alt=\"DatabaseFileGroups\"></p>\n<h3 id=\"创建测试数据表\"><a href=\"#创建测试数据表\" class=\"headerlink\" title=\"创建测试数据表\"></a>创建测试数据表</h3><p>以AdventureWorks的FactResellerSales表为例</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> * <span class=\"keyword\">INTO</span> FactResellerSales</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> [AdventureWorksDW2014].[dbo].[FactResellerSales]</span><br></pre></td></tr></table></figure>\n<p>在测试表数据导入之后，查看一下当前的表分区情况</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> o.name objectname,i.name indexname, partition_id, partition_number, [<span class=\"keyword\">rows</span>]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> sys.partitions p</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> sys.objects o <span class=\"keyword\">ON</span> o.object_id=p.object_id</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> sys.indexes i <span class=\"keyword\">ON</span> i.object_id=p.object_id <span class=\"keyword\">and</span> p.index_id=i.index_id</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> o.name <span class=\"keyword\">LIKE</span> <span class=\"string\">'%FactResellerSales%'</span></span><br></pre></td></tr></table></figure>\n<p>如下图：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/startPartitionStatus.png\" alt=\"startPartition\"></p>\n<p>可以看见，现在这个表有一个默认的分区，并且全部数据都在这个分区里面。</p>\n<h3 id=\"在现有表上创建分区\"><a href=\"#在现有表上创建分区\" class=\"headerlink\" title=\"在现有表上创建分区\"></a>在现有表上创建分区</h3><p>现在要在这个表上创建两个分区，根据OrderDate字段分为两个分区，一个小于2016-01-01，另外分区的数据大于等于这个时间(2016-01-01的数据分配到右面的分区)。按照上面文章写的步骤创建分区</p>\n<p>步骤1： 创建分区函数</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">FUNCTION</span> [myPartitionRange] (DATETIME)</span><br><span class=\"line\">    <span class=\"keyword\">AS</span> <span class=\"keyword\">RANGE</span> <span class=\"keyword\">RIGHT</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'2016-01-01'</span>)</span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br></pre></td></tr></table></figure>\n<p>步骤2：创建分区方案</p>\n<p>在上面的两个文件组(PRIMARY, SECONDARY)上创建分区方案</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PARTITION</span> SCHEME myPartitionScheme</span><br><span class=\"line\">    <span class=\"keyword\">AS</span> <span class=\"keyword\">PARTITION</span> [myPartitionRange]</span><br><span class=\"line\">    <span class=\"keyword\">TO</span> ([SECONDARY],[PRIMARY])</span><br></pre></td></tr></table></figure>\n<p>步骤3：在表上创建聚集索引并将分区方案作用在该字段上</p>\n<p>这里由于要根据字段 <code>OrderDate</code> 进行分区并归档，所以在该字段上创建聚集索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> CLUSTERED <span class=\"keyword\">INDEX</span> IX_FactResellerSales_OrderDate</span><br><span class=\"line\">  <span class=\"keyword\">ON</span> FactResellerSales (OrderDate)</span><br><span class=\"line\">  <span class=\"keyword\">WITH</span> (STATISTICS_NORECOMPUTE = <span class=\"keyword\">OFF</span>, IGNORE_DUP_KEY = <span class=\"keyword\">OFF</span>,</span><br><span class=\"line\">         ALLOW_ROW_LOCKS = <span class=\"keyword\">ON</span>, ALLOW_PAGE_LOCKS = <span class=\"keyword\">ON</span>)</span><br><span class=\"line\">  <span class=\"keyword\">ON</span> myPartitionScheme(OrderDate) <span class=\"comment\">-- AssignPartitionScheme</span></span><br></pre></td></tr></table></figure>\n<p>在创建好索引并应用分区方案后，再查看一下现在的表分区状态</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> o.name objectname,i.name indexname, partition_id, partition_number, [<span class=\"keyword\">rows</span>]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> sys.partitions p</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> sys.objects o <span class=\"keyword\">ON</span> o.object_id=p.object_id</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> sys.indexes i <span class=\"keyword\">ON</span> i.object_id=p.object_id <span class=\"keyword\">and</span> p.index_id=i.index_id</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> o.name <span class=\"keyword\">LIKE</span> <span class=\"string\">'%FactResellerSales%'</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/newPartitionStatus.png\" alt=\"newPartitionStatus\"></p>\n<p>可以看见，现在有两个分区：1、2，其中全部数据都在第一个分区里面，一共有60855条，也就是说60855条销售数据的OrderDate &lt; ‘2016-01-01’</p>\n<h3 id=\"测试新数据\"><a href=\"#测试新数据\" class=\"headerlink\" title=\"测试新数据\"></a>测试新数据</h3><p>现在分区已经创建好，向这个表插入三条新的2016-01-01之后的数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> dbo.FactResellerSales</span><br><span class=\"line\">(ProductKey, OrderDateKey, DueDateKey, ShipDateKey, ResellerKey, EmployeeKey, PromotionKey, CurrencyKey ,SalesTerritoryKey</span><br><span class=\"line\"> , SalesOrderNumber, SalesOrderLineNumber, RevisionNumber, OrderQuantity, UnitPrice, ExtendedAmount, UnitPriceDiscountPct, DiscountAmount</span><br><span class=\"line\"> , ProductStandardCost, TotalProductCost, SalesAmount, TaxAmt, Freight, CarrierTrackingNumber, CustomerPONumber, OrderDate, DueDate, ShipDate)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span></span><br><span class=\"line\">(<span class=\"number\">592</span>, <span class=\"number\">20160101</span>, <span class=\"number\">20160101</span>, <span class=\"number\">20160101</span>, <span class=\"number\">490</span>, <span class=\"number\">281</span>, <span class=\"number\">16</span>, <span class=\"number\">100</span>, <span class=\"number\">4</span>, <span class=\"string\">'SO71952'</span>, <span class=\"number\">42</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'9490-4552-81'</span>, <span class=\"string\">'PO9715163911'</span>, <span class=\"string\">'2016-01-01 00:00:00.000'</span>,  </span><br><span class=\"line\"><span class=\"string\">'2016-01-01 00:00:00.000'</span>, <span class=\"string\">'2016-01-01 00:00:00.000'</span>)</span><br><span class=\"line\">, (<span class=\"number\">592</span>, <span class=\"number\">20160101</span>, <span class=\"number\">20160101</span>, <span class=\"number\">20160101</span>, <span class=\"number\">490</span>, <span class=\"number\">281</span>, <span class=\"number\">16</span>, <span class=\"number\">100</span>, <span class=\"number\">4</span>, <span class=\"string\">'SO71952'</span>, <span class=\"number\">42</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'9490-4552-81'</span>, <span class=\"string\">'PO9715163911'</span>, <span class=\"string\">'2016-01-02 00:00:00.000'</span>,  </span><br><span class=\"line\"><span class=\"string\">'2016-01-02 00:00:00.000'</span>, <span class=\"string\">'2016-01-02 00:00:00.000'</span>)</span><br><span class=\"line\">, (<span class=\"number\">592</span>, <span class=\"number\">20160101</span>, <span class=\"number\">20160101</span>, <span class=\"number\">20160101</span>, <span class=\"number\">490</span>, <span class=\"number\">281</span>, <span class=\"number\">16</span>, <span class=\"number\">100</span>, <span class=\"number\">4</span>, <span class=\"string\">'SO71952'</span>, <span class=\"number\">42</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'9490-4552-81'</span>, <span class=\"string\">'PO9715163911'</span>, <span class=\"string\">'2016-01-03 00:00:00.000'</span>,  </span><br><span class=\"line\"><span class=\"string\">'2016-01-03 00:00:00.000'</span>, <span class=\"string\">'2016-01-03 00:00:00.000'</span>)</span><br></pre></td></tr></table></figure>\n<p>在观察一下分区的情况，发现新插入的3条数据都在第二个分区里面</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/newPartitionData.png\" alt=\"newPartitionData\"></p>\n<h3 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h3><p>假设销售数据到了2017年，现在的任务就是把现有的两个分区合并，2016年以及以前的数据放到老的分区里面(D盘上面的那个文件组中)，2017年的数据插入到新的分区里面。</p>\n<p>在split partition之前，必须使用alter partition scheme 指定一个NEXT USED FileGroup。如果Partiton Scheme没有指定 next used filegroup，那么alter partition function split range command 执行失败</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span> @CurrentYear DATETIME=<span class=\"string\">'2017-01-01'</span></span><br><span class=\"line\"><span class=\"keyword\">DECLARE</span> @PrevMax DATETIME=(<span class=\"keyword\">SELECT</span> <span class=\"keyword\">CONVERT</span>(DATETIME,<span class=\"keyword\">Value</span>) <span class=\"keyword\">FROM</span> sys.partition_functions f</span><br><span class=\"line\">                           <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> sys.partition_range_values r   </span><br><span class=\"line\">                           <span class=\"keyword\">ON</span> f.function_id = r.function_id</span><br><span class=\"line\">                           <span class=\"keyword\">WHERE</span> f.name = <span class=\"string\">'myPartitionRange'</span>)</span><br><span class=\"line\"><span class=\"keyword\">IF</span> @PrevMax&lt;@CurrentYear</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span> TRY</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span> TRAN</span><br><span class=\"line\"><span class=\"comment\">-- Merge Old Partitions</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">FUNCTION</span> myPartitionRange()</span><br><span class=\"line\"><span class=\"keyword\">MERGE</span> <span class=\"keyword\">RANGE</span> (@PrevMax)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- Assign NEXT USED filegroup</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">PARTITION</span> SCHEME myPartitionScheme</span><br><span class=\"line\"><span class=\"keyword\">NEXT</span> USED [PRIMARY]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- Split partition</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">FUNCTION</span> myPartitionRange()</span><br><span class=\"line\"><span class=\"keyword\">SPLIT</span> <span class=\"keyword\">RANGE</span> (@CurrentYear)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span> TRAN</span><br><span class=\"line\">PRINT <span class=\"string\">'COMITIINGGGGGG'</span></span><br><span class=\"line\"><span class=\"keyword\">END</span> TRY</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span> CATCH</span><br><span class=\"line\"><span class=\"keyword\">IF</span> @@TRANCOUNT&gt;<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">ROLLBACK</span> TRAN</span><br><span class=\"line\"><span class=\"keyword\">END</span> CATCH</span><br></pre></td></tr></table></figure>\n<p>执行完上面的步骤后，你会发现，2016年的那3条数据也被合并到第一个分区里面了，新的分区2数据为空，留给2017年</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/mergePartitionData.png\" alt=\"mergePartition\"></p>\n<p>再插入3条2017年的数据试验一下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> dbo.FactResellerSales</span><br><span class=\"line\">(ProductKey, OrderDateKey, DueDateKey, ShipDateKey, ResellerKey, EmployeeKey, PromotionKey, CurrencyKey, SalesTerritoryKey,</span><br><span class=\"line\">SalesOrderNumber, SalesOrderLineNumber, RevisionNumber, OrderQuantity, UnitPrice, ExtendedAmount, UnitPriceDiscountPct, DiscountAmount</span><br><span class=\"line\">, ProductStandardCost, TotalProductCost, SalesAmount, TaxAmt, Freight, CarrierTrackingNumber, CustomerPONumber, OrderDate, DueDate, ShipDate)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span></span><br><span class=\"line\">(<span class=\"number\">592</span>, <span class=\"number\">20170101</span>, <span class=\"number\">20170101</span>, <span class=\"number\">20170101</span>, <span class=\"number\">490</span>, <span class=\"number\">281</span>, <span class=\"number\">16</span>, <span class=\"number\">100</span>, <span class=\"number\">4</span>, <span class=\"string\">'SO71952'</span>, <span class=\"number\">42</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'9490-4552-81'</span>, <span class=\"string\">'PO9715163911'</span>, <span class=\"string\">'2017-01-01 00:00:00.000'</span>,  </span><br><span class=\"line\"><span class=\"string\">'2017-01-01 00:00:00.000'</span>, <span class=\"string\">'2017-01-01 00:00:00.000'</span>)</span><br><span class=\"line\">, (<span class=\"number\">592</span>, <span class=\"number\">20170102</span>, <span class=\"number\">20170102</span>, <span class=\"number\">20170102</span>, <span class=\"number\">490</span>, <span class=\"number\">281</span>, <span class=\"number\">16</span>, <span class=\"number\">100</span>, <span class=\"number\">4</span>, <span class=\"string\">'SO71952'</span>, <span class=\"number\">42</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'9490-4552-81'</span>, <span class=\"string\">'PO9715163911'</span>, <span class=\"string\">'2017-01-02 00:00:00.000'</span>,  </span><br><span class=\"line\"><span class=\"string\">'2017-01-02 00:00:00.000'</span>, <span class=\"string\">'2017-01-02 00:00:00.000'</span>)</span><br><span class=\"line\">, (<span class=\"number\">592</span>, <span class=\"number\">20170103</span>, <span class=\"number\">20170103</span>, <span class=\"number\">20170103</span>, <span class=\"number\">490</span>, <span class=\"number\">281</span>, <span class=\"number\">16</span>, <span class=\"number\">100</span>, <span class=\"number\">4</span>, <span class=\"string\">'SO71952'</span>, <span class=\"number\">42</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'9490-4552-81'</span>, <span class=\"string\">'PO9715163911'</span>, <span class=\"string\">'2017-01-03 00:00:00.000'</span>,  </span><br><span class=\"line\"><span class=\"string\">'2017-01-03 00:00:00.000'</span>, <span class=\"string\">'2017-01-03 00:00:00.000'</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/2017PartitionData.png\" alt=\"2017PartitionData\"></p>\n<p>现在，2016年以及更久之前的数据保存在分区1中，文件组存储在D盘上，而2017年最新的数据在分区2中，存储在E盘上，这样，就把新老数据在存储上分开，利用更好存储设备的性能查询和更新操作等。而对于查询或者操作这个表的用户来说，逻辑上这还是一张表。</p>\n<p>当然，还有另外一种方式进行老数据的归档操作，那就是两张物理表，一张仅存储最新数据，另一张存储归档数据</p>"},{"title":"SQL Server窗口函数使用","date":"2017-06-12T07:43:28.000Z","_content":"\n\n## 什么是窗口函数 Windows Function\n\n窗口函数属于集合函数，作用在行集上，下面这段关于窗口函数的介绍来自 [PostgreSQL intro windows function](https://www.postgresql.org/docs/9.1/static/tutorial-window.html)\n\n> A window function performs a calculation across a set of table rows that are somehow related to the current row. This is comparable to the type of calculation that can be done with an aggregate function. But unlike regular aggregate functions, use of a window function does not cause rows to become grouped into a single output row — the rows retain their separate identities. Behind the scenes, the window function is able to access more than just the current row of the query result.\n\n\n窗口函数在SQL:2003标准中被添加，并在SQL:2008标准中被细化。传统的关系型数据库：Oracle、Sybase和DB2都已经支持窗口函数，像开源的PostgreSQL里面也已经有了对窗口函数的完整的实现。SQL Server 2005开始对窗口函数有了最初的支持，从SQL Server 2012开始，窗口函数也被SQL Server完全支持。\n\n<!-- more -->\n\n## SQL Server窗口函数\n\n窗口函数的应用非常广泛，像分页、去重、分组的基础上返回 Top N 的行、计算 Running Totals、Gaps and islands、百分率, Hierarchy 排序、Pivoting 等等。\n\n窗口函数是整个SQL语句最后被执行的部分，这意味着窗口函数是在SQL查询的结果集上进行的，因此不会受到Group By， Having，Where子句的影响\n\nSQL Server 窗口函数主要用来处理由 OVER 子句定义的行集, 主要用来分析和处理\n\n- Running totals\n- Moving averages\n- Gaps and islands\n\n\n在标准的SQL中，Window Function 的OVER语句中有三个非常重要的元素:\n- Partitioning\n- Ordering\n- Framing\n\n这三种元素的作用可以限制窗口集中的行，如果没有指定任何元素，那么窗口中包含的就是查询结果集中所有的行。\n\n窗口函数的语法：\n\n```\n-- Syntax for SQL Server, Azure SQL Database, and Azure SQL Data Warehouse  \n\nOVER (   \n       [ <PARTITION BY clause> ]  \n       [ <ORDER BY clause> ]   \n       [ <ROW or RANGE clause> ]  \n      ) \n```\n\n### Partition\n\n> Divides the query result set into partitions. The window function is applied to each partition separately and computation restarts for each partition.\n\n通过PARTITION BY 得到的窗口集是基于当前查询结果的当前行的一个集，比如说 PARTITION BY CustomerID，当前行的 CustomerID = 1，那么对于当前行的这个 Window 集就是在当前查询结果之上再加上 CustomerID = 1 的一个查询结果。\n\n\n### Order\n\n> Defines the logical order of the rows within each partition of the result set. That is, it specifies the logical order in which the window function calculation is performed.\n\nOrder By子句对于诸如Row_Number()，Rank()，Lead()，LAG()等函数是必须的，因为如果数据无序，这些函数的结果就没有任何意义\n\n### ROW / RANGE\n\n> Further limits the rows within the partition by specifying start and end points within the partition. This is done by specifying a range of rows with respect to the current row either by logical association or physical association. Physical association is achieved by using the ROWS clause.\n\nROWS 子句通过指定当前行之前或之后的固定数目的行，限制分区中的行数。 RANGE 子句通过指定针对当前行中的值的某一范围的值，从逻辑上限制分区中的行数\n\n```\nROWS BETWEEN UNBOUNDED PRECEDING |\n                   <n> PRECEDING |\n                   <n> FOLLOWING |\n             CURRENT ROW\nor\n\nROWS BETWEEN UNBOUNDED FOLLOWING |\n                   <n> PRECEDING |\n                   <n> FOLLOWING |\n             CURRENT ROW\n```\n\n- UNBOUNDED PRECEDING 指的是相对于当前行来说之前的所有的行\n- UNBOUNDED FOLLOWING 指的是相对于当前行来说之后的所有的行\n- CURRENT ROW 就是当前行\n\n## 简单的例子\n\n下面用一个简单的例子表示传统的聚合函数和窗口函数的区别\n\n有一个需求：将AdventureWorks示例数据库中的Employee表按照性别进行聚合，希望得到的结果是：\"登录名，性别，该性别所有员工的总数\"\n\n那么传统的写法是用子查询获得按照性别进行聚合的值，然后再关联\n\n``` sql\nSELECT  [LoginID]\n      , [Gender]\n      , (SELECT COUNT(*) FROM [AdventureWorks2012].[HumanResources].[Employee] a WHERE a.Gender=b.Gender) AS GenderTotal\nFROM [AdventureWorks2012].[HumanResources].[Employee] b\n```\n\n如果使用窗口函数完成这个功能，代码如下：\n\n``` sql\nSELECT [LoginID]\n     , [Gender]\n     , COUNT(*) OVER(PARTITION BY Gender) AS GenderTotal\nFROM [AdventureWorks2012].[HumanResources].[Employee]\n```\n\n![ExecutionPlanCompare](http://7xkfga.com1.z0.glb.clouddn.com/executionCompare1.png)\n\n\n## 窗口函数与 Group, 子查询语句的比较\n\n对于Group来说，SELECT语句中的列必须是Group子句中出现的列或者是聚合列，那么如果需要同时在 SELECT 语句中查询其它的非 Group 或者非聚合列, 那么就需要额外的子查询。\n\n一个和上面例子很相似的情景，比如要查询每个客户的每个订单的值，以及这个订单于这个订单客户的所有订单总和比，以及这个订单与这个客户所有订单平均值的差。\n\n一个SELECT语句肯定是搞不定的，如下面代码：\n\n``` sql\nWITH Aggregates AS\n(\n   SELECT custid\n        , SUM(val) AS sumval\n        , AVG(val) AS avgval\n   FROM Sales.OrderValues\n   GROUP BY custid\n)\nSELECT O.orderid\n     , O.custid\n     , O.val\n     , CAST(100. * O.val / A.sumval AS NUMERIC(5, 2)) AS pctcust\n     , O.val - A.avgval AS diffcust\nFROM Sales.OrderValues AS O\nJOIN Aggregates AS A\nON O.custid = A.custid;\n```\n\n因为没有办法在一个Group查询中同时显示 Detail和汇总的信息\n\n如果这时再加一个比 - 单个订单与总订单额/平均额比，这时汇总的级别又不相同了， 需要单独再汇总一次\n\n额~ 又要添加一层子查询聚合\n\n如果提出更多的聚合和比较，查询语句会越来越复杂，并且查询优化器也不能确定每次是否都访问的是同一个数据集，因此需要分别访问数据集，造成性能下降。\n\n通过使用窗口函数可以很容易解决这些问题，因为可以为每一种聚合定义一个窗口上下文。\n\n``` sql\nSELECT orderid\n     , custid\n     , val\n     , CAST(100.* val/ SUM(val) OVER(PARTITION BY custid) AS NUMERIC(5,2)) AS pctcut\n     , val - AVG(val) OVER(PARTITION BY custid) AS diffcust\n     , CAST(100.* val/ SUM(val) OVER() AS NUMERIC(5,2)) AS pctall\n     , val - AVG(val) OVER() AS diffall\nFROM Sales.OrderValues\n```\n\n## 使用窗口函数的例子\n\n### 将 OVER 子句与 ROW_NUMBER 函数结合使用\n\n下面的脚本将 OVER 子句与 ROW_NUMBER 函数一起使用来显示分区内各行的行号，分区由 `PARTITION BY PostalCode`确定\n\n``` sql\nSELECT ROW_NUMBER() OVER(PARTITION BY PostalCode ORDER BY SalesYTD DESC) AS \"Row Number\"\n     , p.LastName\n     , s.SalesYTD\n     , a.PostalCode  \nFROM Sales.SalesPerson AS s   \nINNER JOIN Person.Person AS p   \n  ON s.BusinessEntityID = p.BusinessEntityID  \nINNER JOIN Person.Address AS a   \n  ON a.AddressID = p.BusinessEntityID  \nWHERE TerritoryID IS NOT NULL AND SalesYTD <> 0  \nORDER BY PostalCode;\n```\n\n![rowNumber](http://7xkfga.com1.z0.glb.clouddn.com/rowNumber.png)\n\n用这种分配行号的方法，可以完成例如分页、去除重复元素、返回每组前N条数据等实际需求\n\n### 将 OVER 子句与聚合函数结合使用\n\n``` sql\nSELECT SalesOrderID, ProductID, OrderQty  \n     , SUM(OrderQty) OVER(PARTITION BY SalesOrderID) AS Total  \n     , AVG(OrderQty) OVER(PARTITION BY SalesOrderID) AS \"Avg\"  \n     , COUNT(OrderQty) OVER(PARTITION BY SalesOrderID) AS \"Count\"  \n     , MIN(OrderQty) OVER(PARTITION BY SalesOrderID) AS \"Min\"  \n     , MAX(OrderQty) OVER(PARTITION BY SalesOrderID) AS \"Max\"  \nFROM Sales.SalesOrderDetail   \nWHERE SalesOrderID IN(43659,43664);  \n```\n\n![partitionGroup](http://7xkfga.com1.z0.glb.clouddn.com/partitionGroup.png)\n\n### 生成移动平均值和累计合计\n\n下面的示例将 AVG 和 SUM 函数与 OVER 子句结合使用，以便为 Sales.SalesPerson 表中的每个地区提供年度销售额的累计合计。 数据按 TerritoryID 分区并在逻辑上按 SalesYTD 排序\n\n``` sql\nSELECT BusinessEntityID\n     , TerritoryID   \n     , DATEPART(yy,ModifiedDate) AS SalesYear  \n     , CONVERT(varchar(20),SalesYTD,1) AS  SalesYTD  \n     , CONVERT(varchar(20),AVG(SalesYTD) OVER (PARTITION BY TerritoryID   \n                                            ORDER BY DATEPART(yy,ModifiedDate)   \n                                           ),1) AS MovingAvg  \n     , CONVERT(varchar(20),SUM(SalesYTD) OVER (PARTITION BY TerritoryID   \n                                            ORDER BY DATEPART(yy,ModifiedDate)   \n                                            ),1) AS CumulativeTotal  \nFROM Sales.SalesPerson  \nWHERE TerritoryID IS NULL OR TerritoryID < 5  \nORDER BY TerritoryID, SalesYear; \n```\n\n在 OVER 子句中指定的 ORDER BY 子句将确定应用 AVG 函数的逻辑顺序。\n\n再往下，ORDER BY之后也可以指定 ROWS 子句进一步限制窗口的大小\n\n``` sql\nSELECT BusinessEntityID, TerritoryID   \n     , DATEPART(yy,ModifiedDate) AS SalesYear  \n     , CONVERT(varchar(20),SalesYTD,1) AS  SalesYTD  \n     , CONVERT(varchar(20),SUM(SalesYTD) OVER (PARTITION BY TerritoryID   \n                                             ORDER BY DATEPART(yy,ModifiedDate)   \n                                             ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING ),1) AS CumulativeTotal  \nFROM Sales.SalesPerson  \nWHERE TerritoryID IS NULL OR TerritoryID < 5; \n```\n\n\n在这个例子里面， ROWS子句 `ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING` 限制窗口为： **当前行的行** 对其 **下面1行**\n\n所以查询结果为：\n\n![rowsWindow](http://7xkfga.com1.z0.glb.clouddn.com/rowsWindow.png)\n\n``` sql\nSELECT t.OrderYear\n     , t.OrderMonth\n     , t.TotalDue\n     , SUM(t.TotalDue) OVER(PARTITION BY OrderYear, OrderMonth\n                            ORDER BY t.OrderYear, t.OrderMonth\n                            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS 'RunningTotal'\nFROM\n(\n\tSELECT YEAR(OrderDate) AS 'OrderYear'\n         , MONTH(OrderDate) AS 'OrderMonth'\n         , SalesPersonID\n         , TotalDue\n\tFROM Sales.SalesOrderHeader \n) AS t\nWHERE t.SalesPersonID = 274 AND t.OrderYear = 2005\n```\n\n在这个例子中，窗口被限制为：第一行 (`UNBOUNDED PRECEDING`) 到当前行 (`CURRENT ROW`)\n\n查询结果为：\n\n![row2](http://7xkfga.com1.z0.glb.clouddn.com/rows2.png)\n\n所以11月份的累计总和为4723 和 7140`(4723.1073+2417.4793)`\n\n如果把`ROWS`限制改成`RANGE`会怎么样呢?\n\n结果如下：\n\n![rangeWindows](http://7xkfga.com1.z0.glb.clouddn.com/RANGE2.png)\n\nRANGE选项包含窗口里的所有行，和当前行有相同ORDER BY值。上面的例子里面，对于2005年11月的2条记录你拿到同个汇总，因为这2行有**同样的ORDER BY值（2005年11月）**\n\n**note: 使用ROWS选项你在物理级别定义在你窗口里有多少行。使用RANGE选项取决于ORDER BY值在窗口里有多少行被包含**","source":"_posts/SQL-Server¥∞ø⁄∫Ø ˝ π”√.md","raw":"---\ntitle: SQL Server窗口函数使用\ntags:\n  - SQL\n  - SQL Server\ndate: 2017-06-12 15:43:28\n---\n\n\n## 什么是窗口函数 Windows Function\n\n窗口函数属于集合函数，作用在行集上，下面这段关于窗口函数的介绍来自 [PostgreSQL intro windows function](https://www.postgresql.org/docs/9.1/static/tutorial-window.html)\n\n> A window function performs a calculation across a set of table rows that are somehow related to the current row. This is comparable to the type of calculation that can be done with an aggregate function. But unlike regular aggregate functions, use of a window function does not cause rows to become grouped into a single output row — the rows retain their separate identities. Behind the scenes, the window function is able to access more than just the current row of the query result.\n\n\n窗口函数在SQL:2003标准中被添加，并在SQL:2008标准中被细化。传统的关系型数据库：Oracle、Sybase和DB2都已经支持窗口函数，像开源的PostgreSQL里面也已经有了对窗口函数的完整的实现。SQL Server 2005开始对窗口函数有了最初的支持，从SQL Server 2012开始，窗口函数也被SQL Server完全支持。\n\n<!-- more -->\n\n## SQL Server窗口函数\n\n窗口函数的应用非常广泛，像分页、去重、分组的基础上返回 Top N 的行、计算 Running Totals、Gaps and islands、百分率, Hierarchy 排序、Pivoting 等等。\n\n窗口函数是整个SQL语句最后被执行的部分，这意味着窗口函数是在SQL查询的结果集上进行的，因此不会受到Group By， Having，Where子句的影响\n\nSQL Server 窗口函数主要用来处理由 OVER 子句定义的行集, 主要用来分析和处理\n\n- Running totals\n- Moving averages\n- Gaps and islands\n\n\n在标准的SQL中，Window Function 的OVER语句中有三个非常重要的元素:\n- Partitioning\n- Ordering\n- Framing\n\n这三种元素的作用可以限制窗口集中的行，如果没有指定任何元素，那么窗口中包含的就是查询结果集中所有的行。\n\n窗口函数的语法：\n\n```\n-- Syntax for SQL Server, Azure SQL Database, and Azure SQL Data Warehouse  \n\nOVER (   \n       [ <PARTITION BY clause> ]  \n       [ <ORDER BY clause> ]   \n       [ <ROW or RANGE clause> ]  \n      ) \n```\n\n### Partition\n\n> Divides the query result set into partitions. The window function is applied to each partition separately and computation restarts for each partition.\n\n通过PARTITION BY 得到的窗口集是基于当前查询结果的当前行的一个集，比如说 PARTITION BY CustomerID，当前行的 CustomerID = 1，那么对于当前行的这个 Window 集就是在当前查询结果之上再加上 CustomerID = 1 的一个查询结果。\n\n\n### Order\n\n> Defines the logical order of the rows within each partition of the result set. That is, it specifies the logical order in which the window function calculation is performed.\n\nOrder By子句对于诸如Row_Number()，Rank()，Lead()，LAG()等函数是必须的，因为如果数据无序，这些函数的结果就没有任何意义\n\n### ROW / RANGE\n\n> Further limits the rows within the partition by specifying start and end points within the partition. This is done by specifying a range of rows with respect to the current row either by logical association or physical association. Physical association is achieved by using the ROWS clause.\n\nROWS 子句通过指定当前行之前或之后的固定数目的行，限制分区中的行数。 RANGE 子句通过指定针对当前行中的值的某一范围的值，从逻辑上限制分区中的行数\n\n```\nROWS BETWEEN UNBOUNDED PRECEDING |\n                   <n> PRECEDING |\n                   <n> FOLLOWING |\n             CURRENT ROW\nor\n\nROWS BETWEEN UNBOUNDED FOLLOWING |\n                   <n> PRECEDING |\n                   <n> FOLLOWING |\n             CURRENT ROW\n```\n\n- UNBOUNDED PRECEDING 指的是相对于当前行来说之前的所有的行\n- UNBOUNDED FOLLOWING 指的是相对于当前行来说之后的所有的行\n- CURRENT ROW 就是当前行\n\n## 简单的例子\n\n下面用一个简单的例子表示传统的聚合函数和窗口函数的区别\n\n有一个需求：将AdventureWorks示例数据库中的Employee表按照性别进行聚合，希望得到的结果是：\"登录名，性别，该性别所有员工的总数\"\n\n那么传统的写法是用子查询获得按照性别进行聚合的值，然后再关联\n\n``` sql\nSELECT  [LoginID]\n      , [Gender]\n      , (SELECT COUNT(*) FROM [AdventureWorks2012].[HumanResources].[Employee] a WHERE a.Gender=b.Gender) AS GenderTotal\nFROM [AdventureWorks2012].[HumanResources].[Employee] b\n```\n\n如果使用窗口函数完成这个功能，代码如下：\n\n``` sql\nSELECT [LoginID]\n     , [Gender]\n     , COUNT(*) OVER(PARTITION BY Gender) AS GenderTotal\nFROM [AdventureWorks2012].[HumanResources].[Employee]\n```\n\n![ExecutionPlanCompare](http://7xkfga.com1.z0.glb.clouddn.com/executionCompare1.png)\n\n\n## 窗口函数与 Group, 子查询语句的比较\n\n对于Group来说，SELECT语句中的列必须是Group子句中出现的列或者是聚合列，那么如果需要同时在 SELECT 语句中查询其它的非 Group 或者非聚合列, 那么就需要额外的子查询。\n\n一个和上面例子很相似的情景，比如要查询每个客户的每个订单的值，以及这个订单于这个订单客户的所有订单总和比，以及这个订单与这个客户所有订单平均值的差。\n\n一个SELECT语句肯定是搞不定的，如下面代码：\n\n``` sql\nWITH Aggregates AS\n(\n   SELECT custid\n        , SUM(val) AS sumval\n        , AVG(val) AS avgval\n   FROM Sales.OrderValues\n   GROUP BY custid\n)\nSELECT O.orderid\n     , O.custid\n     , O.val\n     , CAST(100. * O.val / A.sumval AS NUMERIC(5, 2)) AS pctcust\n     , O.val - A.avgval AS diffcust\nFROM Sales.OrderValues AS O\nJOIN Aggregates AS A\nON O.custid = A.custid;\n```\n\n因为没有办法在一个Group查询中同时显示 Detail和汇总的信息\n\n如果这时再加一个比 - 单个订单与总订单额/平均额比，这时汇总的级别又不相同了， 需要单独再汇总一次\n\n额~ 又要添加一层子查询聚合\n\n如果提出更多的聚合和比较，查询语句会越来越复杂，并且查询优化器也不能确定每次是否都访问的是同一个数据集，因此需要分别访问数据集，造成性能下降。\n\n通过使用窗口函数可以很容易解决这些问题，因为可以为每一种聚合定义一个窗口上下文。\n\n``` sql\nSELECT orderid\n     , custid\n     , val\n     , CAST(100.* val/ SUM(val) OVER(PARTITION BY custid) AS NUMERIC(5,2)) AS pctcut\n     , val - AVG(val) OVER(PARTITION BY custid) AS diffcust\n     , CAST(100.* val/ SUM(val) OVER() AS NUMERIC(5,2)) AS pctall\n     , val - AVG(val) OVER() AS diffall\nFROM Sales.OrderValues\n```\n\n## 使用窗口函数的例子\n\n### 将 OVER 子句与 ROW_NUMBER 函数结合使用\n\n下面的脚本将 OVER 子句与 ROW_NUMBER 函数一起使用来显示分区内各行的行号，分区由 `PARTITION BY PostalCode`确定\n\n``` sql\nSELECT ROW_NUMBER() OVER(PARTITION BY PostalCode ORDER BY SalesYTD DESC) AS \"Row Number\"\n     , p.LastName\n     , s.SalesYTD\n     , a.PostalCode  \nFROM Sales.SalesPerson AS s   \nINNER JOIN Person.Person AS p   \n  ON s.BusinessEntityID = p.BusinessEntityID  \nINNER JOIN Person.Address AS a   \n  ON a.AddressID = p.BusinessEntityID  \nWHERE TerritoryID IS NOT NULL AND SalesYTD <> 0  \nORDER BY PostalCode;\n```\n\n![rowNumber](http://7xkfga.com1.z0.glb.clouddn.com/rowNumber.png)\n\n用这种分配行号的方法，可以完成例如分页、去除重复元素、返回每组前N条数据等实际需求\n\n### 将 OVER 子句与聚合函数结合使用\n\n``` sql\nSELECT SalesOrderID, ProductID, OrderQty  \n     , SUM(OrderQty) OVER(PARTITION BY SalesOrderID) AS Total  \n     , AVG(OrderQty) OVER(PARTITION BY SalesOrderID) AS \"Avg\"  \n     , COUNT(OrderQty) OVER(PARTITION BY SalesOrderID) AS \"Count\"  \n     , MIN(OrderQty) OVER(PARTITION BY SalesOrderID) AS \"Min\"  \n     , MAX(OrderQty) OVER(PARTITION BY SalesOrderID) AS \"Max\"  \nFROM Sales.SalesOrderDetail   \nWHERE SalesOrderID IN(43659,43664);  \n```\n\n![partitionGroup](http://7xkfga.com1.z0.glb.clouddn.com/partitionGroup.png)\n\n### 生成移动平均值和累计合计\n\n下面的示例将 AVG 和 SUM 函数与 OVER 子句结合使用，以便为 Sales.SalesPerson 表中的每个地区提供年度销售额的累计合计。 数据按 TerritoryID 分区并在逻辑上按 SalesYTD 排序\n\n``` sql\nSELECT BusinessEntityID\n     , TerritoryID   \n     , DATEPART(yy,ModifiedDate) AS SalesYear  \n     , CONVERT(varchar(20),SalesYTD,1) AS  SalesYTD  \n     , CONVERT(varchar(20),AVG(SalesYTD) OVER (PARTITION BY TerritoryID   \n                                            ORDER BY DATEPART(yy,ModifiedDate)   \n                                           ),1) AS MovingAvg  \n     , CONVERT(varchar(20),SUM(SalesYTD) OVER (PARTITION BY TerritoryID   \n                                            ORDER BY DATEPART(yy,ModifiedDate)   \n                                            ),1) AS CumulativeTotal  \nFROM Sales.SalesPerson  \nWHERE TerritoryID IS NULL OR TerritoryID < 5  \nORDER BY TerritoryID, SalesYear; \n```\n\n在 OVER 子句中指定的 ORDER BY 子句将确定应用 AVG 函数的逻辑顺序。\n\n再往下，ORDER BY之后也可以指定 ROWS 子句进一步限制窗口的大小\n\n``` sql\nSELECT BusinessEntityID, TerritoryID   \n     , DATEPART(yy,ModifiedDate) AS SalesYear  \n     , CONVERT(varchar(20),SalesYTD,1) AS  SalesYTD  \n     , CONVERT(varchar(20),SUM(SalesYTD) OVER (PARTITION BY TerritoryID   \n                                             ORDER BY DATEPART(yy,ModifiedDate)   \n                                             ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING ),1) AS CumulativeTotal  \nFROM Sales.SalesPerson  \nWHERE TerritoryID IS NULL OR TerritoryID < 5; \n```\n\n\n在这个例子里面， ROWS子句 `ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING` 限制窗口为： **当前行的行** 对其 **下面1行**\n\n所以查询结果为：\n\n![rowsWindow](http://7xkfga.com1.z0.glb.clouddn.com/rowsWindow.png)\n\n``` sql\nSELECT t.OrderYear\n     , t.OrderMonth\n     , t.TotalDue\n     , SUM(t.TotalDue) OVER(PARTITION BY OrderYear, OrderMonth\n                            ORDER BY t.OrderYear, t.OrderMonth\n                            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS 'RunningTotal'\nFROM\n(\n\tSELECT YEAR(OrderDate) AS 'OrderYear'\n         , MONTH(OrderDate) AS 'OrderMonth'\n         , SalesPersonID\n         , TotalDue\n\tFROM Sales.SalesOrderHeader \n) AS t\nWHERE t.SalesPersonID = 274 AND t.OrderYear = 2005\n```\n\n在这个例子中，窗口被限制为：第一行 (`UNBOUNDED PRECEDING`) 到当前行 (`CURRENT ROW`)\n\n查询结果为：\n\n![row2](http://7xkfga.com1.z0.glb.clouddn.com/rows2.png)\n\n所以11月份的累计总和为4723 和 7140`(4723.1073+2417.4793)`\n\n如果把`ROWS`限制改成`RANGE`会怎么样呢?\n\n结果如下：\n\n![rangeWindows](http://7xkfga.com1.z0.glb.clouddn.com/RANGE2.png)\n\nRANGE选项包含窗口里的所有行，和当前行有相同ORDER BY值。上面的例子里面，对于2005年11月的2条记录你拿到同个汇总，因为这2行有**同样的ORDER BY值（2005年11月）**\n\n**note: 使用ROWS选项你在物理级别定义在你窗口里有多少行。使用RANGE选项取决于ORDER BY值在窗口里有多少行被包含**","slug":"SQL-Server¥∞ø⁄∫Ø ˝ π”√","published":1,"updated":"2017-06-16T07:54:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3oo003hzd68bxp62rw2","content":"<h2 id=\"什么是窗口函数-Windows-Function\"><a href=\"#什么是窗口函数-Windows-Function\" class=\"headerlink\" title=\"什么是窗口函数 Windows Function\"></a>什么是窗口函数 Windows Function</h2><p>窗口函数属于集合函数，作用在行集上，下面这段关于窗口函数的介绍来自 <a href=\"https://www.postgresql.org/docs/9.1/static/tutorial-window.html\" target=\"_blank\" rel=\"noopener\">PostgreSQL intro windows function</a></p>\n<blockquote>\n<p>A window function performs a calculation across a set of table rows that are somehow related to the current row. This is comparable to the type of calculation that can be done with an aggregate function. But unlike regular aggregate functions, use of a window function does not cause rows to become grouped into a single output row — the rows retain their separate identities. Behind the scenes, the window function is able to access more than just the current row of the query result.</p>\n</blockquote>\n<p>窗口函数在SQL:2003标准中被添加，并在SQL:2008标准中被细化。传统的关系型数据库：Oracle、Sybase和DB2都已经支持窗口函数，像开源的PostgreSQL里面也已经有了对窗口函数的完整的实现。SQL Server 2005开始对窗口函数有了最初的支持，从SQL Server 2012开始，窗口函数也被SQL Server完全支持。</p>\n<a id=\"more\"></a>\n<h2 id=\"SQL-Server窗口函数\"><a href=\"#SQL-Server窗口函数\" class=\"headerlink\" title=\"SQL Server窗口函数\"></a>SQL Server窗口函数</h2><p>窗口函数的应用非常广泛，像分页、去重、分组的基础上返回 Top N 的行、计算 Running Totals、Gaps and islands、百分率, Hierarchy 排序、Pivoting 等等。</p>\n<p>窗口函数是整个SQL语句最后被执行的部分，这意味着窗口函数是在SQL查询的结果集上进行的，因此不会受到Group By， Having，Where子句的影响</p>\n<p>SQL Server 窗口函数主要用来处理由 OVER 子句定义的行集, 主要用来分析和处理</p>\n<ul>\n<li>Running totals</li>\n<li>Moving averages</li>\n<li>Gaps and islands</li>\n</ul>\n<p>在标准的SQL中，Window Function 的OVER语句中有三个非常重要的元素:</p>\n<ul>\n<li>Partitioning</li>\n<li>Ordering</li>\n<li>Framing</li>\n</ul>\n<p>这三种元素的作用可以限制窗口集中的行，如果没有指定任何元素，那么窗口中包含的就是查询结果集中所有的行。</p>\n<p>窗口函数的语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- Syntax for SQL Server, Azure SQL Database, and Azure SQL Data Warehouse  </span><br><span class=\"line\"></span><br><span class=\"line\">OVER (   </span><br><span class=\"line\">       [ &lt;PARTITION BY clause&gt; ]  </span><br><span class=\"line\">       [ &lt;ORDER BY clause&gt; ]   </span><br><span class=\"line\">       [ &lt;ROW or RANGE clause&gt; ]  </span><br><span class=\"line\">      )</span><br></pre></td></tr></table></figure>\n<h3 id=\"Partition\"><a href=\"#Partition\" class=\"headerlink\" title=\"Partition\"></a>Partition</h3><blockquote>\n<p>Divides the query result set into partitions. The window function is applied to each partition separately and computation restarts for each partition.</p>\n</blockquote>\n<p>通过PARTITION BY 得到的窗口集是基于当前查询结果的当前行的一个集，比如说 PARTITION BY CustomerID，当前行的 CustomerID = 1，那么对于当前行的这个 Window 集就是在当前查询结果之上再加上 CustomerID = 1 的一个查询结果。</p>\n<h3 id=\"Order\"><a href=\"#Order\" class=\"headerlink\" title=\"Order\"></a>Order</h3><blockquote>\n<p>Defines the logical order of the rows within each partition of the result set. That is, it specifies the logical order in which the window function calculation is performed.</p>\n</blockquote>\n<p>Order By子句对于诸如Row_Number()，Rank()，Lead()，LAG()等函数是必须的，因为如果数据无序，这些函数的结果就没有任何意义</p>\n<h3 id=\"ROW-RANGE\"><a href=\"#ROW-RANGE\" class=\"headerlink\" title=\"ROW / RANGE\"></a>ROW / RANGE</h3><blockquote>\n<p>Further limits the rows within the partition by specifying start and end points within the partition. This is done by specifying a range of rows with respect to the current row either by logical association or physical association. Physical association is achieved by using the ROWS clause.</p>\n</blockquote>\n<p>ROWS 子句通过指定当前行之前或之后的固定数目的行，限制分区中的行数。 RANGE 子句通过指定针对当前行中的值的某一范围的值，从逻辑上限制分区中的行数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROWS BETWEEN UNBOUNDED PRECEDING |</span><br><span class=\"line\">                   &lt;n&gt; PRECEDING |</span><br><span class=\"line\">                   &lt;n&gt; FOLLOWING |</span><br><span class=\"line\">             CURRENT ROW</span><br><span class=\"line\">or</span><br><span class=\"line\"></span><br><span class=\"line\">ROWS BETWEEN UNBOUNDED FOLLOWING |</span><br><span class=\"line\">                   &lt;n&gt; PRECEDING |</span><br><span class=\"line\">                   &lt;n&gt; FOLLOWING |</span><br><span class=\"line\">             CURRENT ROW</span><br></pre></td></tr></table></figure>\n<ul>\n<li>UNBOUNDED PRECEDING 指的是相对于当前行来说之前的所有的行</li>\n<li>UNBOUNDED FOLLOWING 指的是相对于当前行来说之后的所有的行</li>\n<li>CURRENT ROW 就是当前行</li>\n</ul>\n<h2 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h2><p>下面用一个简单的例子表示传统的聚合函数和窗口函数的区别</p>\n<p>有一个需求：将AdventureWorks示例数据库中的Employee表按照性别进行聚合，希望得到的结果是：”登录名，性别，该性别所有员工的总数”</p>\n<p>那么传统的写法是用子查询获得按照性别进行聚合的值，然后再关联</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span>  [LoginID]</span><br><span class=\"line\">      , [Gender]</span><br><span class=\"line\">      , (<span class=\"keyword\">SELECT</span> <span class=\"keyword\">COUNT</span>(*) <span class=\"keyword\">FROM</span> [AdventureWorks2012].[HumanResources].[Employee] a <span class=\"keyword\">WHERE</span> a.Gender=b.Gender) <span class=\"keyword\">AS</span> GenderTotal</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> [AdventureWorks2012].[HumanResources].[Employee] b</span><br></pre></td></tr></table></figure>\n<p>如果使用窗口函数完成这个功能，代码如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> [LoginID]</span><br><span class=\"line\">     , [Gender]</span><br><span class=\"line\">     , <span class=\"keyword\">COUNT</span>(*) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> Gender) <span class=\"keyword\">AS</span> GenderTotal</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> [AdventureWorks2012].[HumanResources].[Employee]</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/executionCompare1.png\" alt=\"ExecutionPlanCompare\"></p>\n<h2 id=\"窗口函数与-Group-子查询语句的比较\"><a href=\"#窗口函数与-Group-子查询语句的比较\" class=\"headerlink\" title=\"窗口函数与 Group, 子查询语句的比较\"></a>窗口函数与 Group, 子查询语句的比较</h2><p>对于Group来说，SELECT语句中的列必须是Group子句中出现的列或者是聚合列，那么如果需要同时在 SELECT 语句中查询其它的非 Group 或者非聚合列, 那么就需要额外的子查询。</p>\n<p>一个和上面例子很相似的情景，比如要查询每个客户的每个订单的值，以及这个订单于这个订单客户的所有订单总和比，以及这个订单与这个客户所有订单平均值的差。</p>\n<p>一个SELECT语句肯定是搞不定的，如下面代码：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WITH Aggregates AS</span><br><span class=\"line\">(</span><br><span class=\"line\">   <span class=\"keyword\">SELECT</span> custid</span><br><span class=\"line\">        , <span class=\"keyword\">SUM</span>(val) <span class=\"keyword\">AS</span> sumval</span><br><span class=\"line\">        , <span class=\"keyword\">AVG</span>(val) <span class=\"keyword\">AS</span> avgval</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> Sales.OrderValues</span><br><span class=\"line\">   <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> custid</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> O.orderid</span><br><span class=\"line\">     , O.custid</span><br><span class=\"line\">     , O.val</span><br><span class=\"line\">     , <span class=\"keyword\">CAST</span>(<span class=\"number\">100.</span> * O.val / A.sumval <span class=\"keyword\">AS</span> <span class=\"built_in\">NUMERIC</span>(<span class=\"number\">5</span>, <span class=\"number\">2</span>)) <span class=\"keyword\">AS</span> pctcust</span><br><span class=\"line\">     , O.val - A.avgval <span class=\"keyword\">AS</span> diffcust</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.OrderValues <span class=\"keyword\">AS</span> O</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> Aggregates <span class=\"keyword\">AS</span> A</span><br><span class=\"line\"><span class=\"keyword\">ON</span> O.custid = A.custid;</span><br></pre></td></tr></table></figure>\n<p>因为没有办法在一个Group查询中同时显示 Detail和汇总的信息</p>\n<p>如果这时再加一个比 - 单个订单与总订单额/平均额比，这时汇总的级别又不相同了， 需要单独再汇总一次</p>\n<p>额~ 又要添加一层子查询聚合</p>\n<p>如果提出更多的聚合和比较，查询语句会越来越复杂，并且查询优化器也不能确定每次是否都访问的是同一个数据集，因此需要分别访问数据集，造成性能下降。</p>\n<p>通过使用窗口函数可以很容易解决这些问题，因为可以为每一种聚合定义一个窗口上下文。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> orderid</span><br><span class=\"line\">     , custid</span><br><span class=\"line\">     , val</span><br><span class=\"line\">     , <span class=\"keyword\">CAST</span>(<span class=\"number\">100.</span>* val/ <span class=\"keyword\">SUM</span>(val) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> custid) <span class=\"keyword\">AS</span> <span class=\"built_in\">NUMERIC</span>(<span class=\"number\">5</span>,<span class=\"number\">2</span>)) <span class=\"keyword\">AS</span> pctcut</span><br><span class=\"line\">     , val - <span class=\"keyword\">AVG</span>(val) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> custid) <span class=\"keyword\">AS</span> diffcust</span><br><span class=\"line\">     , <span class=\"keyword\">CAST</span>(<span class=\"number\">100.</span>* val/ <span class=\"keyword\">SUM</span>(val) <span class=\"keyword\">OVER</span>() <span class=\"keyword\">AS</span> <span class=\"built_in\">NUMERIC</span>(<span class=\"number\">5</span>,<span class=\"number\">2</span>)) <span class=\"keyword\">AS</span> pctall</span><br><span class=\"line\">     , val - <span class=\"keyword\">AVG</span>(val) <span class=\"keyword\">OVER</span>() <span class=\"keyword\">AS</span> diffall</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.OrderValues</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用窗口函数的例子\"><a href=\"#使用窗口函数的例子\" class=\"headerlink\" title=\"使用窗口函数的例子\"></a>使用窗口函数的例子</h2><h3 id=\"将-OVER-子句与-ROW-NUMBER-函数结合使用\"><a href=\"#将-OVER-子句与-ROW-NUMBER-函数结合使用\" class=\"headerlink\" title=\"将 OVER 子句与 ROW_NUMBER 函数结合使用\"></a>将 OVER 子句与 ROW_NUMBER 函数结合使用</h3><p>下面的脚本将 OVER 子句与 ROW_NUMBER 函数一起使用来显示分区内各行的行号，分区由 <code>PARTITION BY PostalCode</code>确定</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ROW_NUMBER() <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> PostalCode <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> SalesYTD <span class=\"keyword\">DESC</span>) <span class=\"keyword\">AS</span> <span class=\"string\">\"Row Number\"</span></span><br><span class=\"line\">     , p.LastName</span><br><span class=\"line\">     , s.SalesYTD</span><br><span class=\"line\">     , a.PostalCode  </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.SalesPerson <span class=\"keyword\">AS</span> s   </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Person.Person <span class=\"keyword\">AS</span> p   </span><br><span class=\"line\">  <span class=\"keyword\">ON</span> s.BusinessEntityID = p.BusinessEntityID  </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Person.Address <span class=\"keyword\">AS</span> a   </span><br><span class=\"line\">  <span class=\"keyword\">ON</span> a.AddressID = p.BusinessEntityID  </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> TerritoryID <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">AND</span> SalesYTD &lt;&gt; <span class=\"number\">0</span>  </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> PostalCode;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/rowNumber.png\" alt=\"rowNumber\"></p>\n<p>用这种分配行号的方法，可以完成例如分页、去除重复元素、返回每组前N条数据等实际需求</p>\n<h3 id=\"将-OVER-子句与聚合函数结合使用\"><a href=\"#将-OVER-子句与聚合函数结合使用\" class=\"headerlink\" title=\"将 OVER 子句与聚合函数结合使用\"></a>将 OVER 子句与聚合函数结合使用</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> SalesOrderID, ProductID, OrderQty  </span><br><span class=\"line\">     , <span class=\"keyword\">SUM</span>(OrderQty) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> SalesOrderID) <span class=\"keyword\">AS</span> Total  </span><br><span class=\"line\">     , <span class=\"keyword\">AVG</span>(OrderQty) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> SalesOrderID) <span class=\"keyword\">AS</span> <span class=\"string\">\"Avg\"</span>  </span><br><span class=\"line\">     , <span class=\"keyword\">COUNT</span>(OrderQty) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> SalesOrderID) <span class=\"keyword\">AS</span> <span class=\"string\">\"Count\"</span>  </span><br><span class=\"line\">     , <span class=\"keyword\">MIN</span>(OrderQty) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> SalesOrderID) <span class=\"keyword\">AS</span> <span class=\"string\">\"Min\"</span>  </span><br><span class=\"line\">     , <span class=\"keyword\">MAX</span>(OrderQty) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> SalesOrderID) <span class=\"keyword\">AS</span> <span class=\"string\">\"Max\"</span>  </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.SalesOrderDetail   </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> SalesOrderID <span class=\"keyword\">IN</span>(<span class=\"number\">43659</span>,<span class=\"number\">43664</span>);</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/partitionGroup.png\" alt=\"partitionGroup\"></p>\n<h3 id=\"生成移动平均值和累计合计\"><a href=\"#生成移动平均值和累计合计\" class=\"headerlink\" title=\"生成移动平均值和累计合计\"></a>生成移动平均值和累计合计</h3><p>下面的示例将 AVG 和 SUM 函数与 OVER 子句结合使用，以便为 Sales.SalesPerson 表中的每个地区提供年度销售额的累计合计。 数据按 TerritoryID 分区并在逻辑上按 SalesYTD 排序</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> BusinessEntityID</span><br><span class=\"line\">     , TerritoryID   </span><br><span class=\"line\">     , <span class=\"keyword\">DATEPART</span>(yy,ModifiedDate) <span class=\"keyword\">AS</span> SalesYear  </span><br><span class=\"line\">     , <span class=\"keyword\">CONVERT</span>(<span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),SalesYTD,<span class=\"number\">1</span>) <span class=\"keyword\">AS</span>  SalesYTD  </span><br><span class=\"line\">     , <span class=\"keyword\">CONVERT</span>(<span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),<span class=\"keyword\">AVG</span>(SalesYTD) <span class=\"keyword\">OVER</span> (<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> TerritoryID   </span><br><span class=\"line\">                                            <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">DATEPART</span>(yy,ModifiedDate)   </span><br><span class=\"line\">                                           ),<span class=\"number\">1</span>) <span class=\"keyword\">AS</span> MovingAvg  </span><br><span class=\"line\">     , <span class=\"keyword\">CONVERT</span>(<span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),<span class=\"keyword\">SUM</span>(SalesYTD) <span class=\"keyword\">OVER</span> (<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> TerritoryID   </span><br><span class=\"line\">                                            <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">DATEPART</span>(yy,ModifiedDate)   </span><br><span class=\"line\">                                            ),<span class=\"number\">1</span>) <span class=\"keyword\">AS</span> CumulativeTotal  </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.SalesPerson  </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> TerritoryID <span class=\"keyword\">IS</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">OR</span> TerritoryID &lt; <span class=\"number\">5</span>  </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> TerritoryID, SalesYear;</span><br></pre></td></tr></table></figure>\n<p>在 OVER 子句中指定的 ORDER BY 子句将确定应用 AVG 函数的逻辑顺序。</p>\n<p>再往下，ORDER BY之后也可以指定 ROWS 子句进一步限制窗口的大小</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> BusinessEntityID, TerritoryID   </span><br><span class=\"line\">     , <span class=\"keyword\">DATEPART</span>(yy,ModifiedDate) <span class=\"keyword\">AS</span> SalesYear  </span><br><span class=\"line\">     , <span class=\"keyword\">CONVERT</span>(<span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),SalesYTD,<span class=\"number\">1</span>) <span class=\"keyword\">AS</span>  SalesYTD  </span><br><span class=\"line\">     , <span class=\"keyword\">CONVERT</span>(<span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),<span class=\"keyword\">SUM</span>(SalesYTD) <span class=\"keyword\">OVER</span> (<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> TerritoryID   </span><br><span class=\"line\">                                             <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">DATEPART</span>(yy,ModifiedDate)   </span><br><span class=\"line\">                                             <span class=\"keyword\">ROWS</span> <span class=\"keyword\">BETWEEN</span> <span class=\"keyword\">CURRENT</span> <span class=\"keyword\">ROW</span> <span class=\"keyword\">AND</span> <span class=\"number\">1</span> <span class=\"keyword\">FOLLOWING</span> ),<span class=\"number\">1</span>) <span class=\"keyword\">AS</span> CumulativeTotal  </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.SalesPerson  </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> TerritoryID <span class=\"keyword\">IS</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">OR</span> TerritoryID &lt; <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n<p>在这个例子里面， ROWS子句 <code>ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING</code> 限制窗口为： <strong>当前行的行</strong> 对其 <strong>下面1行</strong></p>\n<p>所以查询结果为：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/rowsWindow.png\" alt=\"rowsWindow\"></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> t.OrderYear</span><br><span class=\"line\">     , t.OrderMonth</span><br><span class=\"line\">     , t.TotalDue</span><br><span class=\"line\">     , <span class=\"keyword\">SUM</span>(t.TotalDue) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> OrderYear, OrderMonth</span><br><span class=\"line\">                            <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> t.OrderYear, t.OrderMonth</span><br><span class=\"line\">                            <span class=\"keyword\">ROWS</span> <span class=\"keyword\">BETWEEN</span> <span class=\"keyword\">UNBOUNDED</span> <span class=\"keyword\">PRECEDING</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">CURRENT</span> <span class=\"keyword\">ROW</span>) <span class=\"keyword\">AS</span> <span class=\"string\">'RunningTotal'</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"keyword\">YEAR</span>(OrderDate) <span class=\"keyword\">AS</span> <span class=\"string\">'OrderYear'</span></span><br><span class=\"line\">         , <span class=\"keyword\">MONTH</span>(OrderDate) <span class=\"keyword\">AS</span> <span class=\"string\">'OrderMonth'</span></span><br><span class=\"line\">         , SalesPersonID</span><br><span class=\"line\">         , TotalDue</span><br><span class=\"line\">\t<span class=\"keyword\">FROM</span> Sales.SalesOrderHeader </span><br><span class=\"line\">) <span class=\"keyword\">AS</span> t</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> t.SalesPersonID = <span class=\"number\">274</span> <span class=\"keyword\">AND</span> t.OrderYear = <span class=\"number\">2005</span></span><br></pre></td></tr></table></figure>\n<p>在这个例子中，窗口被限制为：第一行 (<code>UNBOUNDED PRECEDING</code>) 到当前行 (<code>CURRENT ROW</code>)</p>\n<p>查询结果为：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/rows2.png\" alt=\"row2\"></p>\n<p>所以11月份的累计总和为4723 和 7140<code>(4723.1073+2417.4793)</code></p>\n<p>如果把<code>ROWS</code>限制改成<code>RANGE</code>会怎么样呢?</p>\n<p>结果如下：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/RANGE2.png\" alt=\"rangeWindows\"></p>\n<p>RANGE选项包含窗口里的所有行，和当前行有相同ORDER BY值。上面的例子里面，对于2005年11月的2条记录你拿到同个汇总，因为这2行有<strong>同样的ORDER BY值（2005年11月）</strong></p>\n<p><strong>note: 使用ROWS选项你在物理级别定义在你窗口里有多少行。使用RANGE选项取决于ORDER BY值在窗口里有多少行被包含</strong></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是窗口函数-Windows-Function\"><a href=\"#什么是窗口函数-Windows-Function\" class=\"headerlink\" title=\"什么是窗口函数 Windows Function\"></a>什么是窗口函数 Windows Function</h2><p>窗口函数属于集合函数，作用在行集上，下面这段关于窗口函数的介绍来自 <a href=\"https://www.postgresql.org/docs/9.1/static/tutorial-window.html\" target=\"_blank\" rel=\"noopener\">PostgreSQL intro windows function</a></p>\n<blockquote>\n<p>A window function performs a calculation across a set of table rows that are somehow related to the current row. This is comparable to the type of calculation that can be done with an aggregate function. But unlike regular aggregate functions, use of a window function does not cause rows to become grouped into a single output row — the rows retain their separate identities. Behind the scenes, the window function is able to access more than just the current row of the query result.</p>\n</blockquote>\n<p>窗口函数在SQL:2003标准中被添加，并在SQL:2008标准中被细化。传统的关系型数据库：Oracle、Sybase和DB2都已经支持窗口函数，像开源的PostgreSQL里面也已经有了对窗口函数的完整的实现。SQL Server 2005开始对窗口函数有了最初的支持，从SQL Server 2012开始，窗口函数也被SQL Server完全支持。</p>","more":"<h2 id=\"SQL-Server窗口函数\"><a href=\"#SQL-Server窗口函数\" class=\"headerlink\" title=\"SQL Server窗口函数\"></a>SQL Server窗口函数</h2><p>窗口函数的应用非常广泛，像分页、去重、分组的基础上返回 Top N 的行、计算 Running Totals、Gaps and islands、百分率, Hierarchy 排序、Pivoting 等等。</p>\n<p>窗口函数是整个SQL语句最后被执行的部分，这意味着窗口函数是在SQL查询的结果集上进行的，因此不会受到Group By， Having，Where子句的影响</p>\n<p>SQL Server 窗口函数主要用来处理由 OVER 子句定义的行集, 主要用来分析和处理</p>\n<ul>\n<li>Running totals</li>\n<li>Moving averages</li>\n<li>Gaps and islands</li>\n</ul>\n<p>在标准的SQL中，Window Function 的OVER语句中有三个非常重要的元素:</p>\n<ul>\n<li>Partitioning</li>\n<li>Ordering</li>\n<li>Framing</li>\n</ul>\n<p>这三种元素的作用可以限制窗口集中的行，如果没有指定任何元素，那么窗口中包含的就是查询结果集中所有的行。</p>\n<p>窗口函数的语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- Syntax for SQL Server, Azure SQL Database, and Azure SQL Data Warehouse  </span><br><span class=\"line\"></span><br><span class=\"line\">OVER (   </span><br><span class=\"line\">       [ &lt;PARTITION BY clause&gt; ]  </span><br><span class=\"line\">       [ &lt;ORDER BY clause&gt; ]   </span><br><span class=\"line\">       [ &lt;ROW or RANGE clause&gt; ]  </span><br><span class=\"line\">      )</span><br></pre></td></tr></table></figure>\n<h3 id=\"Partition\"><a href=\"#Partition\" class=\"headerlink\" title=\"Partition\"></a>Partition</h3><blockquote>\n<p>Divides the query result set into partitions. The window function is applied to each partition separately and computation restarts for each partition.</p>\n</blockquote>\n<p>通过PARTITION BY 得到的窗口集是基于当前查询结果的当前行的一个集，比如说 PARTITION BY CustomerID，当前行的 CustomerID = 1，那么对于当前行的这个 Window 集就是在当前查询结果之上再加上 CustomerID = 1 的一个查询结果。</p>\n<h3 id=\"Order\"><a href=\"#Order\" class=\"headerlink\" title=\"Order\"></a>Order</h3><blockquote>\n<p>Defines the logical order of the rows within each partition of the result set. That is, it specifies the logical order in which the window function calculation is performed.</p>\n</blockquote>\n<p>Order By子句对于诸如Row_Number()，Rank()，Lead()，LAG()等函数是必须的，因为如果数据无序，这些函数的结果就没有任何意义</p>\n<h3 id=\"ROW-RANGE\"><a href=\"#ROW-RANGE\" class=\"headerlink\" title=\"ROW / RANGE\"></a>ROW / RANGE</h3><blockquote>\n<p>Further limits the rows within the partition by specifying start and end points within the partition. This is done by specifying a range of rows with respect to the current row either by logical association or physical association. Physical association is achieved by using the ROWS clause.</p>\n</blockquote>\n<p>ROWS 子句通过指定当前行之前或之后的固定数目的行，限制分区中的行数。 RANGE 子句通过指定针对当前行中的值的某一范围的值，从逻辑上限制分区中的行数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROWS BETWEEN UNBOUNDED PRECEDING |</span><br><span class=\"line\">                   &lt;n&gt; PRECEDING |</span><br><span class=\"line\">                   &lt;n&gt; FOLLOWING |</span><br><span class=\"line\">             CURRENT ROW</span><br><span class=\"line\">or</span><br><span class=\"line\"></span><br><span class=\"line\">ROWS BETWEEN UNBOUNDED FOLLOWING |</span><br><span class=\"line\">                   &lt;n&gt; PRECEDING |</span><br><span class=\"line\">                   &lt;n&gt; FOLLOWING |</span><br><span class=\"line\">             CURRENT ROW</span><br></pre></td></tr></table></figure>\n<ul>\n<li>UNBOUNDED PRECEDING 指的是相对于当前行来说之前的所有的行</li>\n<li>UNBOUNDED FOLLOWING 指的是相对于当前行来说之后的所有的行</li>\n<li>CURRENT ROW 就是当前行</li>\n</ul>\n<h2 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h2><p>下面用一个简单的例子表示传统的聚合函数和窗口函数的区别</p>\n<p>有一个需求：将AdventureWorks示例数据库中的Employee表按照性别进行聚合，希望得到的结果是：”登录名，性别，该性别所有员工的总数”</p>\n<p>那么传统的写法是用子查询获得按照性别进行聚合的值，然后再关联</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span>  [LoginID]</span><br><span class=\"line\">      , [Gender]</span><br><span class=\"line\">      , (<span class=\"keyword\">SELECT</span> <span class=\"keyword\">COUNT</span>(*) <span class=\"keyword\">FROM</span> [AdventureWorks2012].[HumanResources].[Employee] a <span class=\"keyword\">WHERE</span> a.Gender=b.Gender) <span class=\"keyword\">AS</span> GenderTotal</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> [AdventureWorks2012].[HumanResources].[Employee] b</span><br></pre></td></tr></table></figure>\n<p>如果使用窗口函数完成这个功能，代码如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> [LoginID]</span><br><span class=\"line\">     , [Gender]</span><br><span class=\"line\">     , <span class=\"keyword\">COUNT</span>(*) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> Gender) <span class=\"keyword\">AS</span> GenderTotal</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> [AdventureWorks2012].[HumanResources].[Employee]</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/executionCompare1.png\" alt=\"ExecutionPlanCompare\"></p>\n<h2 id=\"窗口函数与-Group-子查询语句的比较\"><a href=\"#窗口函数与-Group-子查询语句的比较\" class=\"headerlink\" title=\"窗口函数与 Group, 子查询语句的比较\"></a>窗口函数与 Group, 子查询语句的比较</h2><p>对于Group来说，SELECT语句中的列必须是Group子句中出现的列或者是聚合列，那么如果需要同时在 SELECT 语句中查询其它的非 Group 或者非聚合列, 那么就需要额外的子查询。</p>\n<p>一个和上面例子很相似的情景，比如要查询每个客户的每个订单的值，以及这个订单于这个订单客户的所有订单总和比，以及这个订单与这个客户所有订单平均值的差。</p>\n<p>一个SELECT语句肯定是搞不定的，如下面代码：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WITH Aggregates AS</span><br><span class=\"line\">(</span><br><span class=\"line\">   <span class=\"keyword\">SELECT</span> custid</span><br><span class=\"line\">        , <span class=\"keyword\">SUM</span>(val) <span class=\"keyword\">AS</span> sumval</span><br><span class=\"line\">        , <span class=\"keyword\">AVG</span>(val) <span class=\"keyword\">AS</span> avgval</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> Sales.OrderValues</span><br><span class=\"line\">   <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> custid</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> O.orderid</span><br><span class=\"line\">     , O.custid</span><br><span class=\"line\">     , O.val</span><br><span class=\"line\">     , <span class=\"keyword\">CAST</span>(<span class=\"number\">100.</span> * O.val / A.sumval <span class=\"keyword\">AS</span> <span class=\"built_in\">NUMERIC</span>(<span class=\"number\">5</span>, <span class=\"number\">2</span>)) <span class=\"keyword\">AS</span> pctcust</span><br><span class=\"line\">     , O.val - A.avgval <span class=\"keyword\">AS</span> diffcust</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.OrderValues <span class=\"keyword\">AS</span> O</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> Aggregates <span class=\"keyword\">AS</span> A</span><br><span class=\"line\"><span class=\"keyword\">ON</span> O.custid = A.custid;</span><br></pre></td></tr></table></figure>\n<p>因为没有办法在一个Group查询中同时显示 Detail和汇总的信息</p>\n<p>如果这时再加一个比 - 单个订单与总订单额/平均额比，这时汇总的级别又不相同了， 需要单独再汇总一次</p>\n<p>额~ 又要添加一层子查询聚合</p>\n<p>如果提出更多的聚合和比较，查询语句会越来越复杂，并且查询优化器也不能确定每次是否都访问的是同一个数据集，因此需要分别访问数据集，造成性能下降。</p>\n<p>通过使用窗口函数可以很容易解决这些问题，因为可以为每一种聚合定义一个窗口上下文。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> orderid</span><br><span class=\"line\">     , custid</span><br><span class=\"line\">     , val</span><br><span class=\"line\">     , <span class=\"keyword\">CAST</span>(<span class=\"number\">100.</span>* val/ <span class=\"keyword\">SUM</span>(val) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> custid) <span class=\"keyword\">AS</span> <span class=\"built_in\">NUMERIC</span>(<span class=\"number\">5</span>,<span class=\"number\">2</span>)) <span class=\"keyword\">AS</span> pctcut</span><br><span class=\"line\">     , val - <span class=\"keyword\">AVG</span>(val) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> custid) <span class=\"keyword\">AS</span> diffcust</span><br><span class=\"line\">     , <span class=\"keyword\">CAST</span>(<span class=\"number\">100.</span>* val/ <span class=\"keyword\">SUM</span>(val) <span class=\"keyword\">OVER</span>() <span class=\"keyword\">AS</span> <span class=\"built_in\">NUMERIC</span>(<span class=\"number\">5</span>,<span class=\"number\">2</span>)) <span class=\"keyword\">AS</span> pctall</span><br><span class=\"line\">     , val - <span class=\"keyword\">AVG</span>(val) <span class=\"keyword\">OVER</span>() <span class=\"keyword\">AS</span> diffall</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.OrderValues</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用窗口函数的例子\"><a href=\"#使用窗口函数的例子\" class=\"headerlink\" title=\"使用窗口函数的例子\"></a>使用窗口函数的例子</h2><h3 id=\"将-OVER-子句与-ROW-NUMBER-函数结合使用\"><a href=\"#将-OVER-子句与-ROW-NUMBER-函数结合使用\" class=\"headerlink\" title=\"将 OVER 子句与 ROW_NUMBER 函数结合使用\"></a>将 OVER 子句与 ROW_NUMBER 函数结合使用</h3><p>下面的脚本将 OVER 子句与 ROW_NUMBER 函数一起使用来显示分区内各行的行号，分区由 <code>PARTITION BY PostalCode</code>确定</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ROW_NUMBER() <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> PostalCode <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> SalesYTD <span class=\"keyword\">DESC</span>) <span class=\"keyword\">AS</span> <span class=\"string\">\"Row Number\"</span></span><br><span class=\"line\">     , p.LastName</span><br><span class=\"line\">     , s.SalesYTD</span><br><span class=\"line\">     , a.PostalCode  </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.SalesPerson <span class=\"keyword\">AS</span> s   </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Person.Person <span class=\"keyword\">AS</span> p   </span><br><span class=\"line\">  <span class=\"keyword\">ON</span> s.BusinessEntityID = p.BusinessEntityID  </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Person.Address <span class=\"keyword\">AS</span> a   </span><br><span class=\"line\">  <span class=\"keyword\">ON</span> a.AddressID = p.BusinessEntityID  </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> TerritoryID <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">AND</span> SalesYTD &lt;&gt; <span class=\"number\">0</span>  </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> PostalCode;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/rowNumber.png\" alt=\"rowNumber\"></p>\n<p>用这种分配行号的方法，可以完成例如分页、去除重复元素、返回每组前N条数据等实际需求</p>\n<h3 id=\"将-OVER-子句与聚合函数结合使用\"><a href=\"#将-OVER-子句与聚合函数结合使用\" class=\"headerlink\" title=\"将 OVER 子句与聚合函数结合使用\"></a>将 OVER 子句与聚合函数结合使用</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> SalesOrderID, ProductID, OrderQty  </span><br><span class=\"line\">     , <span class=\"keyword\">SUM</span>(OrderQty) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> SalesOrderID) <span class=\"keyword\">AS</span> Total  </span><br><span class=\"line\">     , <span class=\"keyword\">AVG</span>(OrderQty) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> SalesOrderID) <span class=\"keyword\">AS</span> <span class=\"string\">\"Avg\"</span>  </span><br><span class=\"line\">     , <span class=\"keyword\">COUNT</span>(OrderQty) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> SalesOrderID) <span class=\"keyword\">AS</span> <span class=\"string\">\"Count\"</span>  </span><br><span class=\"line\">     , <span class=\"keyword\">MIN</span>(OrderQty) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> SalesOrderID) <span class=\"keyword\">AS</span> <span class=\"string\">\"Min\"</span>  </span><br><span class=\"line\">     , <span class=\"keyword\">MAX</span>(OrderQty) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> SalesOrderID) <span class=\"keyword\">AS</span> <span class=\"string\">\"Max\"</span>  </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.SalesOrderDetail   </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> SalesOrderID <span class=\"keyword\">IN</span>(<span class=\"number\">43659</span>,<span class=\"number\">43664</span>);</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/partitionGroup.png\" alt=\"partitionGroup\"></p>\n<h3 id=\"生成移动平均值和累计合计\"><a href=\"#生成移动平均值和累计合计\" class=\"headerlink\" title=\"生成移动平均值和累计合计\"></a>生成移动平均值和累计合计</h3><p>下面的示例将 AVG 和 SUM 函数与 OVER 子句结合使用，以便为 Sales.SalesPerson 表中的每个地区提供年度销售额的累计合计。 数据按 TerritoryID 分区并在逻辑上按 SalesYTD 排序</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> BusinessEntityID</span><br><span class=\"line\">     , TerritoryID   </span><br><span class=\"line\">     , <span class=\"keyword\">DATEPART</span>(yy,ModifiedDate) <span class=\"keyword\">AS</span> SalesYear  </span><br><span class=\"line\">     , <span class=\"keyword\">CONVERT</span>(<span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),SalesYTD,<span class=\"number\">1</span>) <span class=\"keyword\">AS</span>  SalesYTD  </span><br><span class=\"line\">     , <span class=\"keyword\">CONVERT</span>(<span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),<span class=\"keyword\">AVG</span>(SalesYTD) <span class=\"keyword\">OVER</span> (<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> TerritoryID   </span><br><span class=\"line\">                                            <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">DATEPART</span>(yy,ModifiedDate)   </span><br><span class=\"line\">                                           ),<span class=\"number\">1</span>) <span class=\"keyword\">AS</span> MovingAvg  </span><br><span class=\"line\">     , <span class=\"keyword\">CONVERT</span>(<span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),<span class=\"keyword\">SUM</span>(SalesYTD) <span class=\"keyword\">OVER</span> (<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> TerritoryID   </span><br><span class=\"line\">                                            <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">DATEPART</span>(yy,ModifiedDate)   </span><br><span class=\"line\">                                            ),<span class=\"number\">1</span>) <span class=\"keyword\">AS</span> CumulativeTotal  </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.SalesPerson  </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> TerritoryID <span class=\"keyword\">IS</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">OR</span> TerritoryID &lt; <span class=\"number\">5</span>  </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> TerritoryID, SalesYear;</span><br></pre></td></tr></table></figure>\n<p>在 OVER 子句中指定的 ORDER BY 子句将确定应用 AVG 函数的逻辑顺序。</p>\n<p>再往下，ORDER BY之后也可以指定 ROWS 子句进一步限制窗口的大小</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> BusinessEntityID, TerritoryID   </span><br><span class=\"line\">     , <span class=\"keyword\">DATEPART</span>(yy,ModifiedDate) <span class=\"keyword\">AS</span> SalesYear  </span><br><span class=\"line\">     , <span class=\"keyword\">CONVERT</span>(<span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),SalesYTD,<span class=\"number\">1</span>) <span class=\"keyword\">AS</span>  SalesYTD  </span><br><span class=\"line\">     , <span class=\"keyword\">CONVERT</span>(<span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),<span class=\"keyword\">SUM</span>(SalesYTD) <span class=\"keyword\">OVER</span> (<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> TerritoryID   </span><br><span class=\"line\">                                             <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">DATEPART</span>(yy,ModifiedDate)   </span><br><span class=\"line\">                                             <span class=\"keyword\">ROWS</span> <span class=\"keyword\">BETWEEN</span> <span class=\"keyword\">CURRENT</span> <span class=\"keyword\">ROW</span> <span class=\"keyword\">AND</span> <span class=\"number\">1</span> <span class=\"keyword\">FOLLOWING</span> ),<span class=\"number\">1</span>) <span class=\"keyword\">AS</span> CumulativeTotal  </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.SalesPerson  </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> TerritoryID <span class=\"keyword\">IS</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">OR</span> TerritoryID &lt; <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n<p>在这个例子里面， ROWS子句 <code>ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING</code> 限制窗口为： <strong>当前行的行</strong> 对其 <strong>下面1行</strong></p>\n<p>所以查询结果为：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/rowsWindow.png\" alt=\"rowsWindow\"></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> t.OrderYear</span><br><span class=\"line\">     , t.OrderMonth</span><br><span class=\"line\">     , t.TotalDue</span><br><span class=\"line\">     , <span class=\"keyword\">SUM</span>(t.TotalDue) <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> OrderYear, OrderMonth</span><br><span class=\"line\">                            <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> t.OrderYear, t.OrderMonth</span><br><span class=\"line\">                            <span class=\"keyword\">ROWS</span> <span class=\"keyword\">BETWEEN</span> <span class=\"keyword\">UNBOUNDED</span> <span class=\"keyword\">PRECEDING</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">CURRENT</span> <span class=\"keyword\">ROW</span>) <span class=\"keyword\">AS</span> <span class=\"string\">'RunningTotal'</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"keyword\">YEAR</span>(OrderDate) <span class=\"keyword\">AS</span> <span class=\"string\">'OrderYear'</span></span><br><span class=\"line\">         , <span class=\"keyword\">MONTH</span>(OrderDate) <span class=\"keyword\">AS</span> <span class=\"string\">'OrderMonth'</span></span><br><span class=\"line\">         , SalesPersonID</span><br><span class=\"line\">         , TotalDue</span><br><span class=\"line\">\t<span class=\"keyword\">FROM</span> Sales.SalesOrderHeader </span><br><span class=\"line\">) <span class=\"keyword\">AS</span> t</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> t.SalesPersonID = <span class=\"number\">274</span> <span class=\"keyword\">AND</span> t.OrderYear = <span class=\"number\">2005</span></span><br></pre></td></tr></table></figure>\n<p>在这个例子中，窗口被限制为：第一行 (<code>UNBOUNDED PRECEDING</code>) 到当前行 (<code>CURRENT ROW</code>)</p>\n<p>查询结果为：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/rows2.png\" alt=\"row2\"></p>\n<p>所以11月份的累计总和为4723 和 7140<code>(4723.1073+2417.4793)</code></p>\n<p>如果把<code>ROWS</code>限制改成<code>RANGE</code>会怎么样呢?</p>\n<p>结果如下：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/RANGE2.png\" alt=\"rangeWindows\"></p>\n<p>RANGE选项包含窗口里的所有行，和当前行有相同ORDER BY值。上面的例子里面，对于2005年11月的2条记录你拿到同个汇总，因为这2行有<strong>同样的ORDER BY值（2005年11月）</strong></p>\n<p><strong>note: 使用ROWS选项你在物理级别定义在你窗口里有多少行。使用RANGE选项取决于ORDER BY值在窗口里有多少行被包含</strong></p>"},{"title":"SQL Server表分区","date":"2017-06-21T09:53:27.000Z","_content":"\n某种特定业务下，部分业务数据可能只保留比较短的时间，例如每日的流量日志数据，可能每天亿级别的数据增长，随着数据量的逐渐增长，你会发现数据库能性能越来越慢，查询速度会明显变慢，而这时要想提高数据库的查询速度，你肯定会想到索引这种方式，但是随着索引的引入，数据的插入和更新也会变慢，因为在数据插入的时候，索引也是需要重建的。那怎么办呢？ (其实我觉得这种应用场景更好的解决方法是用流式处理的方式)\n\n一个最简单的解决方法就是把一个大表拆分成多个小表，这个就叫做表分区，表分区有两种：\n\n- 水平分区 (行级)\n- 垂直分区 (列级)\n\n下面主要说的是水平分区。\n\n表分区有以下优点：\n\n1. 改善查询性能：对分区对象的查询可以仅搜索自己关心的分区，提高检索速度。\n2. 增强可用性：如果表的某个分区出现故障，表在其他分区的数据仍然可用；\n3. 维护方便：如果表的某个分区出现故障，需要修复数据，只修复该分区即可；\n4. 均衡I/O：可以把不同的分区映射到磁盘以平衡I/O，改善整个系统性能。\n\n分区表是把数据按某种标准划分成区域存储在不同的文件组中，使用分区可以快速而有效地管理和访问数据子集，从而使大型表或索引更易于管理。合理的使用分区会很大程度上提高数据库的性能。\n\n创建分区需要如下个步骤：\n1. 创建文件组\n2. 创建分区函数\n3. 创建分区方案\n4. 创建或者修改使用分区方案的表\n\n\n<!-- more -->\n\n举一个按照时间分区的案例：\n\n确定分区键列的类型(DATETIME)以及分区的边界值:\n- 2011-01-01\n- 2012-01-01\n- 2013-01-01\n\nN个边界值确定 N+1 个分区\n\n![BorderValue](http://7xkfga.com1.z0.glb.clouddn.com/borderValue.png)\n\n## 创建文件组\n\nT-SQL语法\n\n```\nalter database <数据库名> add filegroup <文件组名>\n```\n\n下面创建4个分区文件组\n\n``` sql\nUSE AdventureWorksDW2014;  \nGO  \n\n-- Adds four new filegroups to the AdventureWorksDW2014 database  \nALTER DATABASE AdventureWorksDW2014  \nADD FILEGROUP test1fg;  \nGO  \nALTER DATABASE AdventureWorksDW2014  \nADD FILEGROUP test2fg;  \nGO  \nALTER DATABASE AdventureWorksDW2014  \nADD FILEGROUP test3fg;  \nGO  \nALTER DATABASE AdventureWorksDW2014  \nADD FILEGROUP test4fg;   \n\n-- Adds one file for each filegroup.  \nALTER DATABASE AdventureWorksDW2014   \nADD FILE   \n(  \n    NAME = test1dat1,  \n    FILENAME = 'E:\\FileGroupsData\\t1dat1.ndf',  \n    SIZE = 5MB,  \n    MAXSIZE = 100MB,  \n    FILEGROWTH = 5MB  \n)  \nTO FILEGROUP test1fg;  \nALTER DATABASE AdventureWorksDW2014   \nADD FILE   \n(  \n    NAME = test2dat2,  \n    FILENAME = 'E:\\FileGroupsData\\t2dat2.ndf',  \n    SIZE = 5MB,  \n    MAXSIZE = 100MB,  \n    FILEGROWTH = 5MB  \n)  \nTO FILEGROUP test2fg;  \nGO  \nALTER DATABASE AdventureWorksDW2014   \nADD FILE   \n(  \n    NAME = test3dat3,  \n    FILENAME = 'E:\\FileGroupsData\\t3dat3.ndf',  \n    SIZE = 5MB,  \n    MAXSIZE = 100MB,  \n    FILEGROWTH = 5MB  \n)  \nTO FILEGROUP test3fg;  \nGO  \nALTER DATABASE AdventureWorksDW2014   \nADD FILE   \n(  \n    NAME = test4dat4,  \n    FILENAME = 'E:\\FileGroupsData\\t4dat4.ndf',  \n    SIZE = 5MB,  \n    MAXSIZE = 100MB,  \n    FILEGROWTH = 5MB  \n)  \nTO FILEGROUP test4fg;  \nGO  \n```\n\n执行上面的脚本，可以创建4个文件组\n\n![fileGroups](http://7xkfga.com1.z0.glb.clouddn.com/createFileGroup.png)\n\n使用样例数据库的FactResellerSales表做一个分区的实验\n\n``` sql\nIF OBJECT_ID('dbo.SalesOrders')IS NOT NULL\nDROP TABLE dbo.SalesOrders\nGO\n\nSELECT * INTO SalesOrders\nFROM [AdventureWorksDW2014].[dbo].[FactResellerSales]\n```\n\n## 创建分区函数\n\n指定分依据区列（依据列唯一），分区数据范围规则，分区数量，然后将数据映射到一组分区上。\n\n创建语法：\n\n```\ncreate partition function 分区函数名(<分区列类型>) as range [left/right]\nfor values (每个分区的边界值,....)\n```\n\n``` sql\nCREATE PARTITION FUNCTION PF_Orders_OrderDateRange(DATETIME)\n    AS RANGE RIGHT FOR VALUES\n    (\n       '2011-01-01',\n       '2012-01-01',\n       '2013-01-01'\n    )\n```\n\n左边界/右边界：就是把临界值划分给上一个分区还是下一个分区。这里2013-01-01就属于下一个分区\n\n> 注意：只有没有应用到分区方案中的分区函数才能被删除。\n\n## 创建分区方案\n\n指定分区对应的文件组。\n\n创建语法：\n\n```\n-- 创建分区方案语法\ncreate partition scheme <分区方案名称> as partition <分区函数名称> [all]to (文件组名称,....)\n```\n\n``` sql\nCREATE PARTITION SCHEME PS_Orders\n    AS PARTITION PF_Orders_OrderDateRange\n    TO (test1fg, test2fg, test3fg, test4fg) ;\nGO   \n```\n\n> 注意：只有没有分区表，或索引使用该分区方案是，才能对其删除。\n\n## 创建使用分区方案的表\n\n创建语法：\n\n```\n--创建分区表语法\ncreate table <表名> (\n  <列定义>\n)on<分区方案名>(分区列名)\n```\n\n下面在已有的表SalesOrders上面应用分区方案，并在OrderDate字段上创建聚集索引\n\n``` sql\nCREATE CLUSTERED INDEX IX_FactResellerSales_OrderDate\n  ON dbo.SalesOrders (OrderDate)\n  WITH (STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF,\n         ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON)\n  ON PS_Orders(OrderDate) -- AssignPartitionScheme  \n-- 这里使用[PS_Orders]分区方案，根据OrderDate列进行分区\n```\n\n\n\n\n**在创建分区表后，需要创建聚集分区索引**\n\n根据订单表Orders 查询时经常使用OrderDate 范围条件来查询的特点，我们最好在Orders.OrderDate 列上建立聚集索引（clustered index）。为了便于进行分区切换（partition swtich)。\n大多数情况下，建议在分区表上建立分区索引。\n\n\n## 查询分区表信息\n\n### 查看分区依据列的指定值所在的分区\n\n``` sql\n-- 查询分区依据列为'2013-01-01'的数据在哪个分区上\nSELECT $partition.PF_Orders_OrderDateRange('2013-01-01')  \n-- 返回值是3，表示此值存在第2个分区\n```\n\n### 查询每个非空分区存在的行数\n\n``` sql\n-- 查看分区表中，每个非空分区存在的行数\nSELECT $partition.PF_Orders_OrderDateRange(OrderDate) as partitionNum\n     , count(*) as recordCount\nFROM dbo.SalesOrders\nGROUP BY $partition.PF_Orders_OrderDateRange(OrderDate)\n```\n\n### 查询各个分区的数据信息\n\n``` sql\nSELECT PARTITION = $PARTITION.PF_Orders_OrderDateRange(OrderDate),\n       ROWS      = COUNT(*),\n       MinVal    = MIN(OrderDate),\n       MaxVal    = MAX(OrderDate)\nFROM [dbo].[SalesOrders]\nGROUP BY $PARTITION.PF_Orders_OrderDateRange(OrderDate)\nORDER BY PARTITION\n```\n\n![partitionStatus](http://7xkfga.com1.z0.glb.clouddn.com/SalesOrderPartitionStatus.png)\n\n## 分区的拆分合并\n\n### 拆分分区\n\n在分区函数中新增一个边界值，即可将一个分区变为2个。\n\n``` sql\n--分区拆分\nalter partition function PF_Orders_OrderDateRange()\nsplit range('2014-01-01')\n```\n\n> 注意：如果分区函数已经指定了分区方案，则分区数需要和分区方案中指定的文件组个数保持对应一致。\n\n\n### 合并分区\n\n与拆分分区相反，去除一个边界值即可。\n\n``` sql\n--合并分区\nalter partition function PF_Orders_OrderDateRange()\nmerge range('2011-01-01')\n```\n\n## 分区数据移动\n\n### 分区数据移动\n\n可以使用 `ALTER TABLE ....... SWITCH` 语句快速有效地移动数据子集：\n\n- 将某个表中的数据移动到另一个表中；\n- 将某个表作为分区添加到现存的已分区表中；\n- 将分区从一个已分区表切换到另一个已分区表；\n- 删除分区以形成单个表。\n\n\n### 切换分区表的一个分区到普通数据表\n\n创建普通表SalesOrder_2012用于存放订单日期为2012年的所有数据。从分区到普通表的切换，最好满足以下条件：\n\n1. **普通表必须建立在分区表切换出的分区所在的文件组上**\n2. **普通表的表结构和分区表一致**\n3. **普通表上的索引要和分区表一致，包括聚集索引和非聚集索引**\n4. **普通表必须是空表**\n\n切换分区为3的数据从分区表到归档表\n\n``` sql\nALTER TABLE dbo.SalesOrders SWITCH PARTITION 3\nTO dbo.SalesOrders_2012\n```\n\n现在再查看一下分区表的分区状态，分区为3的数据已经不在了\n\n![partitionStatusAfterMoveOneOut](http://7xkfga.com1.z0.glb.clouddn.com/partitionStatusAfterOneMoved.png)\n\n### 切换普通表数据到分区表的一个分区中\n\n下面要把上面已经归档的2012年的数据切换回来\n\n按照上面的那种写法先试一下：\n\n```sql\nALTER TABLE dbo.SalesOrders_2012 SWITCH TO\ndbo.SalesOrders PARTITION 3\n```\n\n这时候会遇到错误\n\n```\nMsg 4982, Level 16, State 1, Line 1\nALTER TABLE SWITCH statement failed.\nCheck constraints of source table 'AdventureWorksDW2014.dbo.SalesOrders_2012'\nallow values that are not allowed by range defined by partition 3 on target table 'AdventureWorksDW2014.dbo.SalesOrders'.\n```\n\n这是因为表dbo.SalesOrders 的数据经过分区函数的分区列定义, 各个分区的数据实际上已经经过\n了数据约束检查，符合分区边界范围(Range)的数据才会录入到各个分区中。\n但是在存档表dbo.SalesOrders_2012中的数据实际上是没有边界约束的，比如完全可以手动的插入一条其他年的数据，所以进行SWITCH时肯定是不会成功的，这时候需要增加一个数据约束检查\n\n``` sql\nALTER TABLE dbo.SalesOrders_2012 ADD CONSTRAINT CK_SalesOrders_OrderDate\nCHECK(OrderDate>='2012-01-01' AND OrderDate<'2013-01-01')\n```\n\n这时候再SWITCH，2012年扥分区数据就会到了分区表中。\n\n### 切换分区表数据到分区表\n\n新的存档分区表在结构上和源分区表是一致的，包括分区函数和分区方案，\n但是需要重新创建，不能简单地直接使用dbo.SalesOrders 表上的分区函和分区方案，因为他们之间有绑定关系\n\n创建分区函数和分区方案\n\n``` sql\nIF EXISTS (SELECT * FROM sys.partition_schemes WHERE name = 'PS_SalesOrdersArchive')\nDROP PARTITION SCHEME PS_SalesOrdersArchive\nGO\n\nIF EXISTS (SELECT * FROM sys.partition_functions WHERE name = 'PF_SalesOrdersArchive_OrderDateRange')\nDROP PARTITION FUNCTION PF_SalesOrdersArchive_OrderDateRange\nGO\n\nCREATE PARTITION FUNCTION PF_SalesOrdersArchive_OrderDateRange(DATETIME)\nAS RANGE RIGHT FOR VALUES\n(\n   '2011-01-01',\n   '2012-01-01',\n   '2013-01-01'\n)\nGO\n\nCREATE PARTITION SCHEME PS_SalesOrdersArchive\nAS PARTITION PF_SalesOrdersArchive_OrderDateRange\nTO (test1fg, test2fg, test3fg, test4fg)\nGO\n```\n\n创建归档表\n\n``` sql\nCREATE TABLE [dbo].[SalesOrdersArchive](\n\t[ProductKey] [int] NOT NULL,\n\t[OrderDateKey] [int] NOT NULL,\n\t...\n\t[OrderDate] [datetime] NOT NULL,\n\t[DueDate] [datetime] NULL,\n\t[ShipDate] [datetime] NULL\n) ON PS_SalesOrdersArchive(OrderDate)\n\n\nCREATE CLUSTERED INDEX IXC_SalesOrdersArchive_OrderDate ON dbo.SalesOrdersArchive(OrderDate)\n```\n\n切换分区到归档表\n\n```sql\nALTER TABLE dbo.SalesOrders SWITCH PARTITION 1 TO dbo.SalesOrdersArchive PARTITION 1\nALTER TABLE dbo.SalesOrders SWITCH PARTITION 2 TO dbo.SalesOrdersArchive PARTITION 2\nALTER TABLE dbo.SalesOrders SWITCH PARTITION 3 TO dbo.SalesOrdersArchive PARTITION 3\n```\n\n切换完成后，观察一下原表和归档表的分区数据状况：\n\n原表：\n\n![OriginTablePartitionStatus](http://7xkfga.com1.z0.glb.clouddn.com/OriginTablePatitionStatus.png)\n\n归档表：\n\n![ArchieveTablePatitionStatus](http://7xkfga.com1.z0.glb.clouddn.com/ArchiveTablePatition.png)\n\n## 总结\n\n分区表分区切换并没有真正去移动数据,而是SQL Server 在系统底层改变了表的元数据。因此分区表分区切换是高效、快速、灵活的。利用分区表的分区切换功能，我们可以快速加载数据到分区表、卸载分区数据到普通表，然后TRUNCATE普通表，以实现快速删除分区表数据，快速归档不活跃数据到历史表。\n\n表分区的相关概念和实际操作就介绍到这儿，下一篇重点介绍一下如何实现表分区随着时间窗口的移动而自动维护。\n","source":"_posts/SQL-Server±Ì∑÷«¯.md","raw":"---\ntitle: SQL Server表分区\ndate: 2017-06-21 17:53:27\ntags:\n  - SQL Server\n  - Database\n  - 表分区\n\n---\n\n某种特定业务下，部分业务数据可能只保留比较短的时间，例如每日的流量日志数据，可能每天亿级别的数据增长，随着数据量的逐渐增长，你会发现数据库能性能越来越慢，查询速度会明显变慢，而这时要想提高数据库的查询速度，你肯定会想到索引这种方式，但是随着索引的引入，数据的插入和更新也会变慢，因为在数据插入的时候，索引也是需要重建的。那怎么办呢？ (其实我觉得这种应用场景更好的解决方法是用流式处理的方式)\n\n一个最简单的解决方法就是把一个大表拆分成多个小表，这个就叫做表分区，表分区有两种：\n\n- 水平分区 (行级)\n- 垂直分区 (列级)\n\n下面主要说的是水平分区。\n\n表分区有以下优点：\n\n1. 改善查询性能：对分区对象的查询可以仅搜索自己关心的分区，提高检索速度。\n2. 增强可用性：如果表的某个分区出现故障，表在其他分区的数据仍然可用；\n3. 维护方便：如果表的某个分区出现故障，需要修复数据，只修复该分区即可；\n4. 均衡I/O：可以把不同的分区映射到磁盘以平衡I/O，改善整个系统性能。\n\n分区表是把数据按某种标准划分成区域存储在不同的文件组中，使用分区可以快速而有效地管理和访问数据子集，从而使大型表或索引更易于管理。合理的使用分区会很大程度上提高数据库的性能。\n\n创建分区需要如下个步骤：\n1. 创建文件组\n2. 创建分区函数\n3. 创建分区方案\n4. 创建或者修改使用分区方案的表\n\n\n<!-- more -->\n\n举一个按照时间分区的案例：\n\n确定分区键列的类型(DATETIME)以及分区的边界值:\n- 2011-01-01\n- 2012-01-01\n- 2013-01-01\n\nN个边界值确定 N+1 个分区\n\n![BorderValue](http://7xkfga.com1.z0.glb.clouddn.com/borderValue.png)\n\n## 创建文件组\n\nT-SQL语法\n\n```\nalter database <数据库名> add filegroup <文件组名>\n```\n\n下面创建4个分区文件组\n\n``` sql\nUSE AdventureWorksDW2014;  \nGO  \n\n-- Adds four new filegroups to the AdventureWorksDW2014 database  \nALTER DATABASE AdventureWorksDW2014  \nADD FILEGROUP test1fg;  \nGO  \nALTER DATABASE AdventureWorksDW2014  \nADD FILEGROUP test2fg;  \nGO  \nALTER DATABASE AdventureWorksDW2014  \nADD FILEGROUP test3fg;  \nGO  \nALTER DATABASE AdventureWorksDW2014  \nADD FILEGROUP test4fg;   \n\n-- Adds one file for each filegroup.  \nALTER DATABASE AdventureWorksDW2014   \nADD FILE   \n(  \n    NAME = test1dat1,  \n    FILENAME = 'E:\\FileGroupsData\\t1dat1.ndf',  \n    SIZE = 5MB,  \n    MAXSIZE = 100MB,  \n    FILEGROWTH = 5MB  \n)  \nTO FILEGROUP test1fg;  \nALTER DATABASE AdventureWorksDW2014   \nADD FILE   \n(  \n    NAME = test2dat2,  \n    FILENAME = 'E:\\FileGroupsData\\t2dat2.ndf',  \n    SIZE = 5MB,  \n    MAXSIZE = 100MB,  \n    FILEGROWTH = 5MB  \n)  \nTO FILEGROUP test2fg;  \nGO  \nALTER DATABASE AdventureWorksDW2014   \nADD FILE   \n(  \n    NAME = test3dat3,  \n    FILENAME = 'E:\\FileGroupsData\\t3dat3.ndf',  \n    SIZE = 5MB,  \n    MAXSIZE = 100MB,  \n    FILEGROWTH = 5MB  \n)  \nTO FILEGROUP test3fg;  \nGO  \nALTER DATABASE AdventureWorksDW2014   \nADD FILE   \n(  \n    NAME = test4dat4,  \n    FILENAME = 'E:\\FileGroupsData\\t4dat4.ndf',  \n    SIZE = 5MB,  \n    MAXSIZE = 100MB,  \n    FILEGROWTH = 5MB  \n)  \nTO FILEGROUP test4fg;  \nGO  \n```\n\n执行上面的脚本，可以创建4个文件组\n\n![fileGroups](http://7xkfga.com1.z0.glb.clouddn.com/createFileGroup.png)\n\n使用样例数据库的FactResellerSales表做一个分区的实验\n\n``` sql\nIF OBJECT_ID('dbo.SalesOrders')IS NOT NULL\nDROP TABLE dbo.SalesOrders\nGO\n\nSELECT * INTO SalesOrders\nFROM [AdventureWorksDW2014].[dbo].[FactResellerSales]\n```\n\n## 创建分区函数\n\n指定分依据区列（依据列唯一），分区数据范围规则，分区数量，然后将数据映射到一组分区上。\n\n创建语法：\n\n```\ncreate partition function 分区函数名(<分区列类型>) as range [left/right]\nfor values (每个分区的边界值,....)\n```\n\n``` sql\nCREATE PARTITION FUNCTION PF_Orders_OrderDateRange(DATETIME)\n    AS RANGE RIGHT FOR VALUES\n    (\n       '2011-01-01',\n       '2012-01-01',\n       '2013-01-01'\n    )\n```\n\n左边界/右边界：就是把临界值划分给上一个分区还是下一个分区。这里2013-01-01就属于下一个分区\n\n> 注意：只有没有应用到分区方案中的分区函数才能被删除。\n\n## 创建分区方案\n\n指定分区对应的文件组。\n\n创建语法：\n\n```\n-- 创建分区方案语法\ncreate partition scheme <分区方案名称> as partition <分区函数名称> [all]to (文件组名称,....)\n```\n\n``` sql\nCREATE PARTITION SCHEME PS_Orders\n    AS PARTITION PF_Orders_OrderDateRange\n    TO (test1fg, test2fg, test3fg, test4fg) ;\nGO   \n```\n\n> 注意：只有没有分区表，或索引使用该分区方案是，才能对其删除。\n\n## 创建使用分区方案的表\n\n创建语法：\n\n```\n--创建分区表语法\ncreate table <表名> (\n  <列定义>\n)on<分区方案名>(分区列名)\n```\n\n下面在已有的表SalesOrders上面应用分区方案，并在OrderDate字段上创建聚集索引\n\n``` sql\nCREATE CLUSTERED INDEX IX_FactResellerSales_OrderDate\n  ON dbo.SalesOrders (OrderDate)\n  WITH (STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF,\n         ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON)\n  ON PS_Orders(OrderDate) -- AssignPartitionScheme  \n-- 这里使用[PS_Orders]分区方案，根据OrderDate列进行分区\n```\n\n\n\n\n**在创建分区表后，需要创建聚集分区索引**\n\n根据订单表Orders 查询时经常使用OrderDate 范围条件来查询的特点，我们最好在Orders.OrderDate 列上建立聚集索引（clustered index）。为了便于进行分区切换（partition swtich)。\n大多数情况下，建议在分区表上建立分区索引。\n\n\n## 查询分区表信息\n\n### 查看分区依据列的指定值所在的分区\n\n``` sql\n-- 查询分区依据列为'2013-01-01'的数据在哪个分区上\nSELECT $partition.PF_Orders_OrderDateRange('2013-01-01')  \n-- 返回值是3，表示此值存在第2个分区\n```\n\n### 查询每个非空分区存在的行数\n\n``` sql\n-- 查看分区表中，每个非空分区存在的行数\nSELECT $partition.PF_Orders_OrderDateRange(OrderDate) as partitionNum\n     , count(*) as recordCount\nFROM dbo.SalesOrders\nGROUP BY $partition.PF_Orders_OrderDateRange(OrderDate)\n```\n\n### 查询各个分区的数据信息\n\n``` sql\nSELECT PARTITION = $PARTITION.PF_Orders_OrderDateRange(OrderDate),\n       ROWS      = COUNT(*),\n       MinVal    = MIN(OrderDate),\n       MaxVal    = MAX(OrderDate)\nFROM [dbo].[SalesOrders]\nGROUP BY $PARTITION.PF_Orders_OrderDateRange(OrderDate)\nORDER BY PARTITION\n```\n\n![partitionStatus](http://7xkfga.com1.z0.glb.clouddn.com/SalesOrderPartitionStatus.png)\n\n## 分区的拆分合并\n\n### 拆分分区\n\n在分区函数中新增一个边界值，即可将一个分区变为2个。\n\n``` sql\n--分区拆分\nalter partition function PF_Orders_OrderDateRange()\nsplit range('2014-01-01')\n```\n\n> 注意：如果分区函数已经指定了分区方案，则分区数需要和分区方案中指定的文件组个数保持对应一致。\n\n\n### 合并分区\n\n与拆分分区相反，去除一个边界值即可。\n\n``` sql\n--合并分区\nalter partition function PF_Orders_OrderDateRange()\nmerge range('2011-01-01')\n```\n\n## 分区数据移动\n\n### 分区数据移动\n\n可以使用 `ALTER TABLE ....... SWITCH` 语句快速有效地移动数据子集：\n\n- 将某个表中的数据移动到另一个表中；\n- 将某个表作为分区添加到现存的已分区表中；\n- 将分区从一个已分区表切换到另一个已分区表；\n- 删除分区以形成单个表。\n\n\n### 切换分区表的一个分区到普通数据表\n\n创建普通表SalesOrder_2012用于存放订单日期为2012年的所有数据。从分区到普通表的切换，最好满足以下条件：\n\n1. **普通表必须建立在分区表切换出的分区所在的文件组上**\n2. **普通表的表结构和分区表一致**\n3. **普通表上的索引要和分区表一致，包括聚集索引和非聚集索引**\n4. **普通表必须是空表**\n\n切换分区为3的数据从分区表到归档表\n\n``` sql\nALTER TABLE dbo.SalesOrders SWITCH PARTITION 3\nTO dbo.SalesOrders_2012\n```\n\n现在再查看一下分区表的分区状态，分区为3的数据已经不在了\n\n![partitionStatusAfterMoveOneOut](http://7xkfga.com1.z0.glb.clouddn.com/partitionStatusAfterOneMoved.png)\n\n### 切换普通表数据到分区表的一个分区中\n\n下面要把上面已经归档的2012年的数据切换回来\n\n按照上面的那种写法先试一下：\n\n```sql\nALTER TABLE dbo.SalesOrders_2012 SWITCH TO\ndbo.SalesOrders PARTITION 3\n```\n\n这时候会遇到错误\n\n```\nMsg 4982, Level 16, State 1, Line 1\nALTER TABLE SWITCH statement failed.\nCheck constraints of source table 'AdventureWorksDW2014.dbo.SalesOrders_2012'\nallow values that are not allowed by range defined by partition 3 on target table 'AdventureWorksDW2014.dbo.SalesOrders'.\n```\n\n这是因为表dbo.SalesOrders 的数据经过分区函数的分区列定义, 各个分区的数据实际上已经经过\n了数据约束检查，符合分区边界范围(Range)的数据才会录入到各个分区中。\n但是在存档表dbo.SalesOrders_2012中的数据实际上是没有边界约束的，比如完全可以手动的插入一条其他年的数据，所以进行SWITCH时肯定是不会成功的，这时候需要增加一个数据约束检查\n\n``` sql\nALTER TABLE dbo.SalesOrders_2012 ADD CONSTRAINT CK_SalesOrders_OrderDate\nCHECK(OrderDate>='2012-01-01' AND OrderDate<'2013-01-01')\n```\n\n这时候再SWITCH，2012年扥分区数据就会到了分区表中。\n\n### 切换分区表数据到分区表\n\n新的存档分区表在结构上和源分区表是一致的，包括分区函数和分区方案，\n但是需要重新创建，不能简单地直接使用dbo.SalesOrders 表上的分区函和分区方案，因为他们之间有绑定关系\n\n创建分区函数和分区方案\n\n``` sql\nIF EXISTS (SELECT * FROM sys.partition_schemes WHERE name = 'PS_SalesOrdersArchive')\nDROP PARTITION SCHEME PS_SalesOrdersArchive\nGO\n\nIF EXISTS (SELECT * FROM sys.partition_functions WHERE name = 'PF_SalesOrdersArchive_OrderDateRange')\nDROP PARTITION FUNCTION PF_SalesOrdersArchive_OrderDateRange\nGO\n\nCREATE PARTITION FUNCTION PF_SalesOrdersArchive_OrderDateRange(DATETIME)\nAS RANGE RIGHT FOR VALUES\n(\n   '2011-01-01',\n   '2012-01-01',\n   '2013-01-01'\n)\nGO\n\nCREATE PARTITION SCHEME PS_SalesOrdersArchive\nAS PARTITION PF_SalesOrdersArchive_OrderDateRange\nTO (test1fg, test2fg, test3fg, test4fg)\nGO\n```\n\n创建归档表\n\n``` sql\nCREATE TABLE [dbo].[SalesOrdersArchive](\n\t[ProductKey] [int] NOT NULL,\n\t[OrderDateKey] [int] NOT NULL,\n\t...\n\t[OrderDate] [datetime] NOT NULL,\n\t[DueDate] [datetime] NULL,\n\t[ShipDate] [datetime] NULL\n) ON PS_SalesOrdersArchive(OrderDate)\n\n\nCREATE CLUSTERED INDEX IXC_SalesOrdersArchive_OrderDate ON dbo.SalesOrdersArchive(OrderDate)\n```\n\n切换分区到归档表\n\n```sql\nALTER TABLE dbo.SalesOrders SWITCH PARTITION 1 TO dbo.SalesOrdersArchive PARTITION 1\nALTER TABLE dbo.SalesOrders SWITCH PARTITION 2 TO dbo.SalesOrdersArchive PARTITION 2\nALTER TABLE dbo.SalesOrders SWITCH PARTITION 3 TO dbo.SalesOrdersArchive PARTITION 3\n```\n\n切换完成后，观察一下原表和归档表的分区数据状况：\n\n原表：\n\n![OriginTablePartitionStatus](http://7xkfga.com1.z0.glb.clouddn.com/OriginTablePatitionStatus.png)\n\n归档表：\n\n![ArchieveTablePatitionStatus](http://7xkfga.com1.z0.glb.clouddn.com/ArchiveTablePatition.png)\n\n## 总结\n\n分区表分区切换并没有真正去移动数据,而是SQL Server 在系统底层改变了表的元数据。因此分区表分区切换是高效、快速、灵活的。利用分区表的分区切换功能，我们可以快速加载数据到分区表、卸载分区数据到普通表，然后TRUNCATE普通表，以实现快速删除分区表数据，快速归档不活跃数据到历史表。\n\n表分区的相关概念和实际操作就介绍到这儿，下一篇重点介绍一下如何实现表分区随着时间窗口的移动而自动维护。\n","slug":"SQL-Server±Ì∑÷«¯","published":1,"updated":"2017-06-22T07:09:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3op003izd68aqir8zq4","content":"<p>某种特定业务下，部分业务数据可能只保留比较短的时间，例如每日的流量日志数据，可能每天亿级别的数据增长，随着数据量的逐渐增长，你会发现数据库能性能越来越慢，查询速度会明显变慢，而这时要想提高数据库的查询速度，你肯定会想到索引这种方式，但是随着索引的引入，数据的插入和更新也会变慢，因为在数据插入的时候，索引也是需要重建的。那怎么办呢？ (其实我觉得这种应用场景更好的解决方法是用流式处理的方式)</p>\n<p>一个最简单的解决方法就是把一个大表拆分成多个小表，这个就叫做表分区，表分区有两种：</p>\n<ul>\n<li>水平分区 (行级)</li>\n<li>垂直分区 (列级)</li>\n</ul>\n<p>下面主要说的是水平分区。</p>\n<p>表分区有以下优点：</p>\n<ol>\n<li>改善查询性能：对分区对象的查询可以仅搜索自己关心的分区，提高检索速度。</li>\n<li>增强可用性：如果表的某个分区出现故障，表在其他分区的数据仍然可用；</li>\n<li>维护方便：如果表的某个分区出现故障，需要修复数据，只修复该分区即可；</li>\n<li>均衡I/O：可以把不同的分区映射到磁盘以平衡I/O，改善整个系统性能。</li>\n</ol>\n<p>分区表是把数据按某种标准划分成区域存储在不同的文件组中，使用分区可以快速而有效地管理和访问数据子集，从而使大型表或索引更易于管理。合理的使用分区会很大程度上提高数据库的性能。</p>\n<p>创建分区需要如下个步骤：</p>\n<ol>\n<li>创建文件组</li>\n<li>创建分区函数</li>\n<li>创建分区方案</li>\n<li>创建或者修改使用分区方案的表</li>\n</ol>\n<a id=\"more\"></a>\n<p>举一个按照时间分区的案例：</p>\n<p>确定分区键列的类型(DATETIME)以及分区的边界值:</p>\n<ul>\n<li>2011-01-01</li>\n<li>2012-01-01</li>\n<li>2013-01-01</li>\n</ul>\n<p>N个边界值确定 N+1 个分区</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/borderValue.png\" alt=\"BorderValue\"></p>\n<h2 id=\"创建文件组\"><a href=\"#创建文件组\" class=\"headerlink\" title=\"创建文件组\"></a>创建文件组</h2><p>T-SQL语法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter database &lt;数据库名&gt; add filegroup &lt;文件组名&gt;</span><br></pre></td></tr></table></figure>\n<p>下面创建4个分区文件组</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">USE</span> AdventureWorksDW2014;  </span><br><span class=\"line\">GO  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- Adds four new filegroups to the AdventureWorksDW2014 database  </span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> AdventureWorksDW2014  </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> FILEGROUP test1fg;  </span><br><span class=\"line\">GO  </span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> AdventureWorksDW2014  </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> FILEGROUP test2fg;  </span><br><span class=\"line\">GO  </span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> AdventureWorksDW2014  </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> FILEGROUP test3fg;  </span><br><span class=\"line\">GO  </span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> AdventureWorksDW2014  </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> FILEGROUP test4fg;   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- Adds one file for each filegroup.  </span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> AdventureWorksDW2014   </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> <span class=\"keyword\">FILE</span>   </span><br><span class=\"line\">(  </span><br><span class=\"line\">    <span class=\"keyword\">NAME</span> = test1dat1,  </span><br><span class=\"line\">    FILENAME = <span class=\"string\">'E:\\FileGroupsData\\t1dat1.ndf'</span>,  </span><br><span class=\"line\">    <span class=\"keyword\">SIZE</span> = <span class=\"number\">5</span>MB,  </span><br><span class=\"line\">    <span class=\"keyword\">MAXSIZE</span> = <span class=\"number\">100</span>MB,  </span><br><span class=\"line\">    FILEGROWTH = <span class=\"number\">5</span>MB  </span><br><span class=\"line\">)  </span><br><span class=\"line\"><span class=\"keyword\">TO</span> FILEGROUP test1fg;  </span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> AdventureWorksDW2014   </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> <span class=\"keyword\">FILE</span>   </span><br><span class=\"line\">(  </span><br><span class=\"line\">    <span class=\"keyword\">NAME</span> = test2dat2,  </span><br><span class=\"line\">    FILENAME = <span class=\"string\">'E:\\FileGroupsData\\t2dat2.ndf'</span>,  </span><br><span class=\"line\">    <span class=\"keyword\">SIZE</span> = <span class=\"number\">5</span>MB,  </span><br><span class=\"line\">    <span class=\"keyword\">MAXSIZE</span> = <span class=\"number\">100</span>MB,  </span><br><span class=\"line\">    FILEGROWTH = <span class=\"number\">5</span>MB  </span><br><span class=\"line\">)  </span><br><span class=\"line\"><span class=\"keyword\">TO</span> FILEGROUP test2fg;  </span><br><span class=\"line\">GO  </span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> AdventureWorksDW2014   </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> <span class=\"keyword\">FILE</span>   </span><br><span class=\"line\">(  </span><br><span class=\"line\">    <span class=\"keyword\">NAME</span> = test3dat3,  </span><br><span class=\"line\">    FILENAME = <span class=\"string\">'E:\\FileGroupsData\\t3dat3.ndf'</span>,  </span><br><span class=\"line\">    <span class=\"keyword\">SIZE</span> = <span class=\"number\">5</span>MB,  </span><br><span class=\"line\">    <span class=\"keyword\">MAXSIZE</span> = <span class=\"number\">100</span>MB,  </span><br><span class=\"line\">    FILEGROWTH = <span class=\"number\">5</span>MB  </span><br><span class=\"line\">)  </span><br><span class=\"line\"><span class=\"keyword\">TO</span> FILEGROUP test3fg;  </span><br><span class=\"line\">GO  </span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> AdventureWorksDW2014   </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> <span class=\"keyword\">FILE</span>   </span><br><span class=\"line\">(  </span><br><span class=\"line\">    <span class=\"keyword\">NAME</span> = test4dat4,  </span><br><span class=\"line\">    FILENAME = <span class=\"string\">'E:\\FileGroupsData\\t4dat4.ndf'</span>,  </span><br><span class=\"line\">    <span class=\"keyword\">SIZE</span> = <span class=\"number\">5</span>MB,  </span><br><span class=\"line\">    <span class=\"keyword\">MAXSIZE</span> = <span class=\"number\">100</span>MB,  </span><br><span class=\"line\">    FILEGROWTH = <span class=\"number\">5</span>MB  </span><br><span class=\"line\">)  </span><br><span class=\"line\"><span class=\"keyword\">TO</span> FILEGROUP test4fg;  </span><br><span class=\"line\">GO</span><br></pre></td></tr></table></figure>\n<p>执行上面的脚本，可以创建4个文件组</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/createFileGroup.png\" alt=\"fileGroups\"></p>\n<p>使用样例数据库的FactResellerSales表做一个分区的实验</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF OBJECT_ID('dbo.SalesOrders')IS NOT NULL</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> dbo.SalesOrders</span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">INTO</span> SalesOrders</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> [AdventureWorksDW2014].[dbo].[FactResellerSales]</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建分区函数\"><a href=\"#创建分区函数\" class=\"headerlink\" title=\"创建分区函数\"></a>创建分区函数</h2><p>指定分依据区列（依据列唯一），分区数据范围规则，分区数量，然后将数据映射到一组分区上。</p>\n<p>创建语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create partition function 分区函数名(&lt;分区列类型&gt;) as range [left/right]</span><br><span class=\"line\">for values (每个分区的边界值,....)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">FUNCTION</span> PF_Orders_OrderDateRange(DATETIME)</span><br><span class=\"line\">    <span class=\"keyword\">AS</span> <span class=\"keyword\">RANGE</span> <span class=\"keyword\">RIGHT</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span></span><br><span class=\"line\">    (</span><br><span class=\"line\">       <span class=\"string\">'2011-01-01'</span>,</span><br><span class=\"line\">       <span class=\"string\">'2012-01-01'</span>,</span><br><span class=\"line\">       <span class=\"string\">'2013-01-01'</span></span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure>\n<p>左边界/右边界：就是把临界值划分给上一个分区还是下一个分区。这里2013-01-01就属于下一个分区</p>\n<blockquote>\n<p>注意：只有没有应用到分区方案中的分区函数才能被删除。</p>\n</blockquote>\n<h2 id=\"创建分区方案\"><a href=\"#创建分区方案\" class=\"headerlink\" title=\"创建分区方案\"></a>创建分区方案</h2><p>指定分区对应的文件组。</p>\n<p>创建语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 创建分区方案语法</span><br><span class=\"line\">create partition scheme &lt;分区方案名称&gt; as partition &lt;分区函数名称&gt; [all]to (文件组名称,....)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PARTITION</span> SCHEME PS_Orders</span><br><span class=\"line\">    <span class=\"keyword\">AS</span> <span class=\"keyword\">PARTITION</span> PF_Orders_OrderDateRange</span><br><span class=\"line\">    <span class=\"keyword\">TO</span> (test1fg, test2fg, test3fg, test4fg) ;</span><br><span class=\"line\">GO</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：只有没有分区表，或索引使用该分区方案是，才能对其删除。</p>\n</blockquote>\n<h2 id=\"创建使用分区方案的表\"><a href=\"#创建使用分区方案的表\" class=\"headerlink\" title=\"创建使用分区方案的表\"></a>创建使用分区方案的表</h2><p>创建语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--创建分区表语法</span><br><span class=\"line\">create table &lt;表名&gt; (</span><br><span class=\"line\">  &lt;列定义&gt;</span><br><span class=\"line\">)on&lt;分区方案名&gt;(分区列名)</span><br></pre></td></tr></table></figure>\n<p>下面在已有的表SalesOrders上面应用分区方案，并在OrderDate字段上创建聚集索引</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> CLUSTERED <span class=\"keyword\">INDEX</span> IX_FactResellerSales_OrderDate</span><br><span class=\"line\">  <span class=\"keyword\">ON</span> dbo.SalesOrders (OrderDate)</span><br><span class=\"line\">  <span class=\"keyword\">WITH</span> (STATISTICS_NORECOMPUTE = <span class=\"keyword\">OFF</span>, IGNORE_DUP_KEY = <span class=\"keyword\">OFF</span>,</span><br><span class=\"line\">         ALLOW_ROW_LOCKS = <span class=\"keyword\">ON</span>, ALLOW_PAGE_LOCKS = <span class=\"keyword\">ON</span>)</span><br><span class=\"line\">  <span class=\"keyword\">ON</span> PS_Orders(OrderDate) <span class=\"comment\">-- AssignPartitionScheme  </span></span><br><span class=\"line\"><span class=\"comment\">-- 这里使用[PS_Orders]分区方案，根据OrderDate列进行分区</span></span><br></pre></td></tr></table></figure>\n<p><strong>在创建分区表后，需要创建聚集分区索引</strong></p>\n<p>根据订单表Orders 查询时经常使用OrderDate 范围条件来查询的特点，我们最好在Orders.OrderDate 列上建立聚集索引（clustered index）。为了便于进行分区切换（partition swtich)。<br>大多数情况下，建议在分区表上建立分区索引。</p>\n<h2 id=\"查询分区表信息\"><a href=\"#查询分区表信息\" class=\"headerlink\" title=\"查询分区表信息\"></a>查询分区表信息</h2><h3 id=\"查看分区依据列的指定值所在的分区\"><a href=\"#查看分区依据列的指定值所在的分区\" class=\"headerlink\" title=\"查看分区依据列的指定值所在的分区\"></a>查看分区依据列的指定值所在的分区</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询分区依据列为'2013-01-01'的数据在哪个分区上</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> $partition.PF_Orders_OrderDateRange(<span class=\"string\">'2013-01-01'</span>)  </span><br><span class=\"line\"><span class=\"comment\">-- 返回值是3，表示此值存在第2个分区</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查询每个非空分区存在的行数\"><a href=\"#查询每个非空分区存在的行数\" class=\"headerlink\" title=\"查询每个非空分区存在的行数\"></a>查询每个非空分区存在的行数</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查看分区表中，每个非空分区存在的行数</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> $partition.PF_Orders_OrderDateRange(OrderDate) <span class=\"keyword\">as</span> partitionNum</span><br><span class=\"line\">     , <span class=\"keyword\">count</span>(*) <span class=\"keyword\">as</span> recordCount</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> dbo.SalesOrders</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> $partition.PF_Orders_OrderDateRange(OrderDate)</span><br></pre></td></tr></table></figure>\n<h3 id=\"查询各个分区的数据信息\"><a href=\"#查询各个分区的数据信息\" class=\"headerlink\" title=\"查询各个分区的数据信息\"></a>查询各个分区的数据信息</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">PARTITION</span> = $PARTITION.PF_Orders_OrderDateRange(OrderDate),</span><br><span class=\"line\">       <span class=\"keyword\">ROWS</span>      = <span class=\"keyword\">COUNT</span>(*),</span><br><span class=\"line\">       MinVal    = <span class=\"keyword\">MIN</span>(OrderDate),</span><br><span class=\"line\">       MaxVal    = <span class=\"keyword\">MAX</span>(OrderDate)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> [dbo].[SalesOrders]</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> $PARTITION.PF_Orders_OrderDateRange(OrderDate)</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">PARTITION</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/SalesOrderPartitionStatus.png\" alt=\"partitionStatus\"></p>\n<h2 id=\"分区的拆分合并\"><a href=\"#分区的拆分合并\" class=\"headerlink\" title=\"分区的拆分合并\"></a>分区的拆分合并</h2><h3 id=\"拆分分区\"><a href=\"#拆分分区\" class=\"headerlink\" title=\"拆分分区\"></a>拆分分区</h3><p>在分区函数中新增一个边界值，即可将一个分区变为2个。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--分区拆分</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">partition</span> <span class=\"keyword\">function</span> PF_Orders_OrderDateRange()</span><br><span class=\"line\"><span class=\"keyword\">split</span> <span class=\"keyword\">range</span>(<span class=\"string\">'2014-01-01'</span>)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：如果分区函数已经指定了分区方案，则分区数需要和分区方案中指定的文件组个数保持对应一致。</p>\n</blockquote>\n<h3 id=\"合并分区\"><a href=\"#合并分区\" class=\"headerlink\" title=\"合并分区\"></a>合并分区</h3><p>与拆分分区相反，去除一个边界值即可。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--合并分区</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">partition</span> <span class=\"keyword\">function</span> PF_Orders_OrderDateRange()</span><br><span class=\"line\"><span class=\"keyword\">merge</span> <span class=\"keyword\">range</span>(<span class=\"string\">'2011-01-01'</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"分区数据移动\"><a href=\"#分区数据移动\" class=\"headerlink\" title=\"分区数据移动\"></a>分区数据移动</h2><h3 id=\"分区数据移动-1\"><a href=\"#分区数据移动-1\" class=\"headerlink\" title=\"分区数据移动\"></a>分区数据移动</h3><p>可以使用 <code>ALTER TABLE ....... SWITCH</code> 语句快速有效地移动数据子集：</p>\n<ul>\n<li>将某个表中的数据移动到另一个表中；</li>\n<li>将某个表作为分区添加到现存的已分区表中；</li>\n<li>将分区从一个已分区表切换到另一个已分区表；</li>\n<li>删除分区以形成单个表。</li>\n</ul>\n<h3 id=\"切换分区表的一个分区到普通数据表\"><a href=\"#切换分区表的一个分区到普通数据表\" class=\"headerlink\" title=\"切换分区表的一个分区到普通数据表\"></a>切换分区表的一个分区到普通数据表</h3><p>创建普通表SalesOrder_2012用于存放订单日期为2012年的所有数据。从分区到普通表的切换，最好满足以下条件：</p>\n<ol>\n<li><strong>普通表必须建立在分区表切换出的分区所在的文件组上</strong></li>\n<li><strong>普通表的表结构和分区表一致</strong></li>\n<li><strong>普通表上的索引要和分区表一致，包括聚集索引和非聚集索引</strong></li>\n<li><strong>普通表必须是空表</strong></li>\n</ol>\n<p>切换分区为3的数据从分区表到归档表</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> dbo.SalesOrders <span class=\"keyword\">SWITCH</span> <span class=\"keyword\">PARTITION</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">TO</span> dbo.SalesOrders_2012</span><br></pre></td></tr></table></figure>\n<p>现在再查看一下分区表的分区状态，分区为3的数据已经不在了</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/partitionStatusAfterOneMoved.png\" alt=\"partitionStatusAfterMoveOneOut\"></p>\n<h3 id=\"切换普通表数据到分区表的一个分区中\"><a href=\"#切换普通表数据到分区表的一个分区中\" class=\"headerlink\" title=\"切换普通表数据到分区表的一个分区中\"></a>切换普通表数据到分区表的一个分区中</h3><p>下面要把上面已经归档的2012年的数据切换回来</p>\n<p>按照上面的那种写法先试一下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> dbo.SalesOrders_2012 <span class=\"keyword\">SWITCH</span> <span class=\"keyword\">TO</span></span><br><span class=\"line\">dbo.SalesOrders <span class=\"keyword\">PARTITION</span> <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>这时候会遇到错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Msg 4982, Level 16, State 1, Line 1</span><br><span class=\"line\">ALTER TABLE SWITCH statement failed.</span><br><span class=\"line\">Check constraints of source table &apos;AdventureWorksDW2014.dbo.SalesOrders_2012&apos;</span><br><span class=\"line\">allow values that are not allowed by range defined by partition 3 on target table &apos;AdventureWorksDW2014.dbo.SalesOrders&apos;.</span><br></pre></td></tr></table></figure>\n<p>这是因为表dbo.SalesOrders 的数据经过分区函数的分区列定义, 各个分区的数据实际上已经经过<br>了数据约束检查，符合分区边界范围(Range)的数据才会录入到各个分区中。<br>但是在存档表dbo.SalesOrders_2012中的数据实际上是没有边界约束的，比如完全可以手动的插入一条其他年的数据，所以进行SWITCH时肯定是不会成功的，这时候需要增加一个数据约束检查</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> dbo.SalesOrders_2012 <span class=\"keyword\">ADD</span> <span class=\"keyword\">CONSTRAINT</span> CK_SalesOrders_OrderDate</span><br><span class=\"line\"><span class=\"keyword\">CHECK</span>(OrderDate&gt;=<span class=\"string\">'2012-01-01'</span> <span class=\"keyword\">AND</span> OrderDate&lt;<span class=\"string\">'2013-01-01'</span>)</span><br></pre></td></tr></table></figure>\n<p>这时候再SWITCH，2012年扥分区数据就会到了分区表中。</p>\n<h3 id=\"切换分区表数据到分区表\"><a href=\"#切换分区表数据到分区表\" class=\"headerlink\" title=\"切换分区表数据到分区表\"></a>切换分区表数据到分区表</h3><p>新的存档分区表在结构上和源分区表是一致的，包括分区函数和分区方案，<br>但是需要重新创建，不能简单地直接使用dbo.SalesOrders 表上的分区函和分区方案，因为他们之间有绑定关系</p>\n<p>创建分区函数和分区方案</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF EXISTS (<span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> sys.partition_schemes <span class=\"keyword\">WHERE</span> <span class=\"keyword\">name</span> = <span class=\"string\">'PS_SalesOrdersArchive'</span>)</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">PARTITION</span> SCHEME PS_SalesOrdersArchive</span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> (<span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> sys.partition_functions <span class=\"keyword\">WHERE</span> <span class=\"keyword\">name</span> = <span class=\"string\">'PF_SalesOrdersArchive_OrderDateRange'</span>)</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">FUNCTION</span> PF_SalesOrdersArchive_OrderDateRange</span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">FUNCTION</span> PF_SalesOrdersArchive_OrderDateRange(DATETIME)</span><br><span class=\"line\"><span class=\"keyword\">AS</span> <span class=\"keyword\">RANGE</span> <span class=\"keyword\">RIGHT</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span></span><br><span class=\"line\">(</span><br><span class=\"line\">   <span class=\"string\">'2011-01-01'</span>,</span><br><span class=\"line\">   <span class=\"string\">'2012-01-01'</span>,</span><br><span class=\"line\">   <span class=\"string\">'2013-01-01'</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PARTITION</span> SCHEME PS_SalesOrdersArchive</span><br><span class=\"line\"><span class=\"keyword\">AS</span> <span class=\"keyword\">PARTITION</span> PF_SalesOrdersArchive_OrderDateRange</span><br><span class=\"line\"><span class=\"keyword\">TO</span> (test1fg, test2fg, test3fg, test4fg)</span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br></pre></td></tr></table></figure>\n<p>创建归档表</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> [dbo].[SalesOrdersArchive](</span><br><span class=\"line\">\t[ProductKey] [<span class=\"built_in\">int</span>] <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">\t[OrderDateKey] [<span class=\"built_in\">int</span>] <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t[OrderDate] [datetime] <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">\t[DueDate] [datetime] <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">\t[ShipDate] [datetime] <span class=\"literal\">NULL</span></span><br><span class=\"line\">) <span class=\"keyword\">ON</span> PS_SalesOrdersArchive(OrderDate)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> CLUSTERED <span class=\"keyword\">INDEX</span> IXC_SalesOrdersArchive_OrderDate <span class=\"keyword\">ON</span> dbo.SalesOrdersArchive(OrderDate)</span><br></pre></td></tr></table></figure>\n<p>切换分区到归档表</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> dbo.SalesOrders <span class=\"keyword\">SWITCH</span> <span class=\"keyword\">PARTITION</span> <span class=\"number\">1</span> <span class=\"keyword\">TO</span> dbo.SalesOrdersArchive <span class=\"keyword\">PARTITION</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> dbo.SalesOrders <span class=\"keyword\">SWITCH</span> <span class=\"keyword\">PARTITION</span> <span class=\"number\">2</span> <span class=\"keyword\">TO</span> dbo.SalesOrdersArchive <span class=\"keyword\">PARTITION</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> dbo.SalesOrders <span class=\"keyword\">SWITCH</span> <span class=\"keyword\">PARTITION</span> <span class=\"number\">3</span> <span class=\"keyword\">TO</span> dbo.SalesOrdersArchive <span class=\"keyword\">PARTITION</span> <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>切换完成后，观察一下原表和归档表的分区数据状况：</p>\n<p>原表：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/OriginTablePatitionStatus.png\" alt=\"OriginTablePartitionStatus\"></p>\n<p>归档表：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/ArchiveTablePatition.png\" alt=\"ArchieveTablePatitionStatus\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>分区表分区切换并没有真正去移动数据,而是SQL Server 在系统底层改变了表的元数据。因此分区表分区切换是高效、快速、灵活的。利用分区表的分区切换功能，我们可以快速加载数据到分区表、卸载分区数据到普通表，然后TRUNCATE普通表，以实现快速删除分区表数据，快速归档不活跃数据到历史表。</p>\n<p>表分区的相关概念和实际操作就介绍到这儿，下一篇重点介绍一下如何实现表分区随着时间窗口的移动而自动维护。</p>\n","site":{"data":{}},"excerpt":"<p>某种特定业务下，部分业务数据可能只保留比较短的时间，例如每日的流量日志数据，可能每天亿级别的数据增长，随着数据量的逐渐增长，你会发现数据库能性能越来越慢，查询速度会明显变慢，而这时要想提高数据库的查询速度，你肯定会想到索引这种方式，但是随着索引的引入，数据的插入和更新也会变慢，因为在数据插入的时候，索引也是需要重建的。那怎么办呢？ (其实我觉得这种应用场景更好的解决方法是用流式处理的方式)</p>\n<p>一个最简单的解决方法就是把一个大表拆分成多个小表，这个就叫做表分区，表分区有两种：</p>\n<ul>\n<li>水平分区 (行级)</li>\n<li>垂直分区 (列级)</li>\n</ul>\n<p>下面主要说的是水平分区。</p>\n<p>表分区有以下优点：</p>\n<ol>\n<li>改善查询性能：对分区对象的查询可以仅搜索自己关心的分区，提高检索速度。</li>\n<li>增强可用性：如果表的某个分区出现故障，表在其他分区的数据仍然可用；</li>\n<li>维护方便：如果表的某个分区出现故障，需要修复数据，只修复该分区即可；</li>\n<li>均衡I/O：可以把不同的分区映射到磁盘以平衡I/O，改善整个系统性能。</li>\n</ol>\n<p>分区表是把数据按某种标准划分成区域存储在不同的文件组中，使用分区可以快速而有效地管理和访问数据子集，从而使大型表或索引更易于管理。合理的使用分区会很大程度上提高数据库的性能。</p>\n<p>创建分区需要如下个步骤：</p>\n<ol>\n<li>创建文件组</li>\n<li>创建分区函数</li>\n<li>创建分区方案</li>\n<li>创建或者修改使用分区方案的表</li>\n</ol>","more":"<p>举一个按照时间分区的案例：</p>\n<p>确定分区键列的类型(DATETIME)以及分区的边界值:</p>\n<ul>\n<li>2011-01-01</li>\n<li>2012-01-01</li>\n<li>2013-01-01</li>\n</ul>\n<p>N个边界值确定 N+1 个分区</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/borderValue.png\" alt=\"BorderValue\"></p>\n<h2 id=\"创建文件组\"><a href=\"#创建文件组\" class=\"headerlink\" title=\"创建文件组\"></a>创建文件组</h2><p>T-SQL语法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter database &lt;数据库名&gt; add filegroup &lt;文件组名&gt;</span><br></pre></td></tr></table></figure>\n<p>下面创建4个分区文件组</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">USE</span> AdventureWorksDW2014;  </span><br><span class=\"line\">GO  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- Adds four new filegroups to the AdventureWorksDW2014 database  </span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> AdventureWorksDW2014  </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> FILEGROUP test1fg;  </span><br><span class=\"line\">GO  </span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> AdventureWorksDW2014  </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> FILEGROUP test2fg;  </span><br><span class=\"line\">GO  </span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> AdventureWorksDW2014  </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> FILEGROUP test3fg;  </span><br><span class=\"line\">GO  </span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> AdventureWorksDW2014  </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> FILEGROUP test4fg;   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- Adds one file for each filegroup.  </span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> AdventureWorksDW2014   </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> <span class=\"keyword\">FILE</span>   </span><br><span class=\"line\">(  </span><br><span class=\"line\">    <span class=\"keyword\">NAME</span> = test1dat1,  </span><br><span class=\"line\">    FILENAME = <span class=\"string\">'E:\\FileGroupsData\\t1dat1.ndf'</span>,  </span><br><span class=\"line\">    <span class=\"keyword\">SIZE</span> = <span class=\"number\">5</span>MB,  </span><br><span class=\"line\">    <span class=\"keyword\">MAXSIZE</span> = <span class=\"number\">100</span>MB,  </span><br><span class=\"line\">    FILEGROWTH = <span class=\"number\">5</span>MB  </span><br><span class=\"line\">)  </span><br><span class=\"line\"><span class=\"keyword\">TO</span> FILEGROUP test1fg;  </span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> AdventureWorksDW2014   </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> <span class=\"keyword\">FILE</span>   </span><br><span class=\"line\">(  </span><br><span class=\"line\">    <span class=\"keyword\">NAME</span> = test2dat2,  </span><br><span class=\"line\">    FILENAME = <span class=\"string\">'E:\\FileGroupsData\\t2dat2.ndf'</span>,  </span><br><span class=\"line\">    <span class=\"keyword\">SIZE</span> = <span class=\"number\">5</span>MB,  </span><br><span class=\"line\">    <span class=\"keyword\">MAXSIZE</span> = <span class=\"number\">100</span>MB,  </span><br><span class=\"line\">    FILEGROWTH = <span class=\"number\">5</span>MB  </span><br><span class=\"line\">)  </span><br><span class=\"line\"><span class=\"keyword\">TO</span> FILEGROUP test2fg;  </span><br><span class=\"line\">GO  </span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> AdventureWorksDW2014   </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> <span class=\"keyword\">FILE</span>   </span><br><span class=\"line\">(  </span><br><span class=\"line\">    <span class=\"keyword\">NAME</span> = test3dat3,  </span><br><span class=\"line\">    FILENAME = <span class=\"string\">'E:\\FileGroupsData\\t3dat3.ndf'</span>,  </span><br><span class=\"line\">    <span class=\"keyword\">SIZE</span> = <span class=\"number\">5</span>MB,  </span><br><span class=\"line\">    <span class=\"keyword\">MAXSIZE</span> = <span class=\"number\">100</span>MB,  </span><br><span class=\"line\">    FILEGROWTH = <span class=\"number\">5</span>MB  </span><br><span class=\"line\">)  </span><br><span class=\"line\"><span class=\"keyword\">TO</span> FILEGROUP test3fg;  </span><br><span class=\"line\">GO  </span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">DATABASE</span> AdventureWorksDW2014   </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> <span class=\"keyword\">FILE</span>   </span><br><span class=\"line\">(  </span><br><span class=\"line\">    <span class=\"keyword\">NAME</span> = test4dat4,  </span><br><span class=\"line\">    FILENAME = <span class=\"string\">'E:\\FileGroupsData\\t4dat4.ndf'</span>,  </span><br><span class=\"line\">    <span class=\"keyword\">SIZE</span> = <span class=\"number\">5</span>MB,  </span><br><span class=\"line\">    <span class=\"keyword\">MAXSIZE</span> = <span class=\"number\">100</span>MB,  </span><br><span class=\"line\">    FILEGROWTH = <span class=\"number\">5</span>MB  </span><br><span class=\"line\">)  </span><br><span class=\"line\"><span class=\"keyword\">TO</span> FILEGROUP test4fg;  </span><br><span class=\"line\">GO</span><br></pre></td></tr></table></figure>\n<p>执行上面的脚本，可以创建4个文件组</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/createFileGroup.png\" alt=\"fileGroups\"></p>\n<p>使用样例数据库的FactResellerSales表做一个分区的实验</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF OBJECT_ID('dbo.SalesOrders')IS NOT NULL</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> dbo.SalesOrders</span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">INTO</span> SalesOrders</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> [AdventureWorksDW2014].[dbo].[FactResellerSales]</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建分区函数\"><a href=\"#创建分区函数\" class=\"headerlink\" title=\"创建分区函数\"></a>创建分区函数</h2><p>指定分依据区列（依据列唯一），分区数据范围规则，分区数量，然后将数据映射到一组分区上。</p>\n<p>创建语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create partition function 分区函数名(&lt;分区列类型&gt;) as range [left/right]</span><br><span class=\"line\">for values (每个分区的边界值,....)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">FUNCTION</span> PF_Orders_OrderDateRange(DATETIME)</span><br><span class=\"line\">    <span class=\"keyword\">AS</span> <span class=\"keyword\">RANGE</span> <span class=\"keyword\">RIGHT</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span></span><br><span class=\"line\">    (</span><br><span class=\"line\">       <span class=\"string\">'2011-01-01'</span>,</span><br><span class=\"line\">       <span class=\"string\">'2012-01-01'</span>,</span><br><span class=\"line\">       <span class=\"string\">'2013-01-01'</span></span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure>\n<p>左边界/右边界：就是把临界值划分给上一个分区还是下一个分区。这里2013-01-01就属于下一个分区</p>\n<blockquote>\n<p>注意：只有没有应用到分区方案中的分区函数才能被删除。</p>\n</blockquote>\n<h2 id=\"创建分区方案\"><a href=\"#创建分区方案\" class=\"headerlink\" title=\"创建分区方案\"></a>创建分区方案</h2><p>指定分区对应的文件组。</p>\n<p>创建语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 创建分区方案语法</span><br><span class=\"line\">create partition scheme &lt;分区方案名称&gt; as partition &lt;分区函数名称&gt; [all]to (文件组名称,....)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PARTITION</span> SCHEME PS_Orders</span><br><span class=\"line\">    <span class=\"keyword\">AS</span> <span class=\"keyword\">PARTITION</span> PF_Orders_OrderDateRange</span><br><span class=\"line\">    <span class=\"keyword\">TO</span> (test1fg, test2fg, test3fg, test4fg) ;</span><br><span class=\"line\">GO</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：只有没有分区表，或索引使用该分区方案是，才能对其删除。</p>\n</blockquote>\n<h2 id=\"创建使用分区方案的表\"><a href=\"#创建使用分区方案的表\" class=\"headerlink\" title=\"创建使用分区方案的表\"></a>创建使用分区方案的表</h2><p>创建语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--创建分区表语法</span><br><span class=\"line\">create table &lt;表名&gt; (</span><br><span class=\"line\">  &lt;列定义&gt;</span><br><span class=\"line\">)on&lt;分区方案名&gt;(分区列名)</span><br></pre></td></tr></table></figure>\n<p>下面在已有的表SalesOrders上面应用分区方案，并在OrderDate字段上创建聚集索引</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> CLUSTERED <span class=\"keyword\">INDEX</span> IX_FactResellerSales_OrderDate</span><br><span class=\"line\">  <span class=\"keyword\">ON</span> dbo.SalesOrders (OrderDate)</span><br><span class=\"line\">  <span class=\"keyword\">WITH</span> (STATISTICS_NORECOMPUTE = <span class=\"keyword\">OFF</span>, IGNORE_DUP_KEY = <span class=\"keyword\">OFF</span>,</span><br><span class=\"line\">         ALLOW_ROW_LOCKS = <span class=\"keyword\">ON</span>, ALLOW_PAGE_LOCKS = <span class=\"keyword\">ON</span>)</span><br><span class=\"line\">  <span class=\"keyword\">ON</span> PS_Orders(OrderDate) <span class=\"comment\">-- AssignPartitionScheme  </span></span><br><span class=\"line\"><span class=\"comment\">-- 这里使用[PS_Orders]分区方案，根据OrderDate列进行分区</span></span><br></pre></td></tr></table></figure>\n<p><strong>在创建分区表后，需要创建聚集分区索引</strong></p>\n<p>根据订单表Orders 查询时经常使用OrderDate 范围条件来查询的特点，我们最好在Orders.OrderDate 列上建立聚集索引（clustered index）。为了便于进行分区切换（partition swtich)。<br>大多数情况下，建议在分区表上建立分区索引。</p>\n<h2 id=\"查询分区表信息\"><a href=\"#查询分区表信息\" class=\"headerlink\" title=\"查询分区表信息\"></a>查询分区表信息</h2><h3 id=\"查看分区依据列的指定值所在的分区\"><a href=\"#查看分区依据列的指定值所在的分区\" class=\"headerlink\" title=\"查看分区依据列的指定值所在的分区\"></a>查看分区依据列的指定值所在的分区</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询分区依据列为'2013-01-01'的数据在哪个分区上</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> $partition.PF_Orders_OrderDateRange(<span class=\"string\">'2013-01-01'</span>)  </span><br><span class=\"line\"><span class=\"comment\">-- 返回值是3，表示此值存在第2个分区</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查询每个非空分区存在的行数\"><a href=\"#查询每个非空分区存在的行数\" class=\"headerlink\" title=\"查询每个非空分区存在的行数\"></a>查询每个非空分区存在的行数</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查看分区表中，每个非空分区存在的行数</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> $partition.PF_Orders_OrderDateRange(OrderDate) <span class=\"keyword\">as</span> partitionNum</span><br><span class=\"line\">     , <span class=\"keyword\">count</span>(*) <span class=\"keyword\">as</span> recordCount</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> dbo.SalesOrders</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> $partition.PF_Orders_OrderDateRange(OrderDate)</span><br></pre></td></tr></table></figure>\n<h3 id=\"查询各个分区的数据信息\"><a href=\"#查询各个分区的数据信息\" class=\"headerlink\" title=\"查询各个分区的数据信息\"></a>查询各个分区的数据信息</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">PARTITION</span> = $PARTITION.PF_Orders_OrderDateRange(OrderDate),</span><br><span class=\"line\">       <span class=\"keyword\">ROWS</span>      = <span class=\"keyword\">COUNT</span>(*),</span><br><span class=\"line\">       MinVal    = <span class=\"keyword\">MIN</span>(OrderDate),</span><br><span class=\"line\">       MaxVal    = <span class=\"keyword\">MAX</span>(OrderDate)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> [dbo].[SalesOrders]</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> $PARTITION.PF_Orders_OrderDateRange(OrderDate)</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">PARTITION</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/SalesOrderPartitionStatus.png\" alt=\"partitionStatus\"></p>\n<h2 id=\"分区的拆分合并\"><a href=\"#分区的拆分合并\" class=\"headerlink\" title=\"分区的拆分合并\"></a>分区的拆分合并</h2><h3 id=\"拆分分区\"><a href=\"#拆分分区\" class=\"headerlink\" title=\"拆分分区\"></a>拆分分区</h3><p>在分区函数中新增一个边界值，即可将一个分区变为2个。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--分区拆分</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">partition</span> <span class=\"keyword\">function</span> PF_Orders_OrderDateRange()</span><br><span class=\"line\"><span class=\"keyword\">split</span> <span class=\"keyword\">range</span>(<span class=\"string\">'2014-01-01'</span>)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：如果分区函数已经指定了分区方案，则分区数需要和分区方案中指定的文件组个数保持对应一致。</p>\n</blockquote>\n<h3 id=\"合并分区\"><a href=\"#合并分区\" class=\"headerlink\" title=\"合并分区\"></a>合并分区</h3><p>与拆分分区相反，去除一个边界值即可。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--合并分区</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">partition</span> <span class=\"keyword\">function</span> PF_Orders_OrderDateRange()</span><br><span class=\"line\"><span class=\"keyword\">merge</span> <span class=\"keyword\">range</span>(<span class=\"string\">'2011-01-01'</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"分区数据移动\"><a href=\"#分区数据移动\" class=\"headerlink\" title=\"分区数据移动\"></a>分区数据移动</h2><h3 id=\"分区数据移动-1\"><a href=\"#分区数据移动-1\" class=\"headerlink\" title=\"分区数据移动\"></a>分区数据移动</h3><p>可以使用 <code>ALTER TABLE ....... SWITCH</code> 语句快速有效地移动数据子集：</p>\n<ul>\n<li>将某个表中的数据移动到另一个表中；</li>\n<li>将某个表作为分区添加到现存的已分区表中；</li>\n<li>将分区从一个已分区表切换到另一个已分区表；</li>\n<li>删除分区以形成单个表。</li>\n</ul>\n<h3 id=\"切换分区表的一个分区到普通数据表\"><a href=\"#切换分区表的一个分区到普通数据表\" class=\"headerlink\" title=\"切换分区表的一个分区到普通数据表\"></a>切换分区表的一个分区到普通数据表</h3><p>创建普通表SalesOrder_2012用于存放订单日期为2012年的所有数据。从分区到普通表的切换，最好满足以下条件：</p>\n<ol>\n<li><strong>普通表必须建立在分区表切换出的分区所在的文件组上</strong></li>\n<li><strong>普通表的表结构和分区表一致</strong></li>\n<li><strong>普通表上的索引要和分区表一致，包括聚集索引和非聚集索引</strong></li>\n<li><strong>普通表必须是空表</strong></li>\n</ol>\n<p>切换分区为3的数据从分区表到归档表</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> dbo.SalesOrders <span class=\"keyword\">SWITCH</span> <span class=\"keyword\">PARTITION</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">TO</span> dbo.SalesOrders_2012</span><br></pre></td></tr></table></figure>\n<p>现在再查看一下分区表的分区状态，分区为3的数据已经不在了</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/partitionStatusAfterOneMoved.png\" alt=\"partitionStatusAfterMoveOneOut\"></p>\n<h3 id=\"切换普通表数据到分区表的一个分区中\"><a href=\"#切换普通表数据到分区表的一个分区中\" class=\"headerlink\" title=\"切换普通表数据到分区表的一个分区中\"></a>切换普通表数据到分区表的一个分区中</h3><p>下面要把上面已经归档的2012年的数据切换回来</p>\n<p>按照上面的那种写法先试一下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> dbo.SalesOrders_2012 <span class=\"keyword\">SWITCH</span> <span class=\"keyword\">TO</span></span><br><span class=\"line\">dbo.SalesOrders <span class=\"keyword\">PARTITION</span> <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>这时候会遇到错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Msg 4982, Level 16, State 1, Line 1</span><br><span class=\"line\">ALTER TABLE SWITCH statement failed.</span><br><span class=\"line\">Check constraints of source table &apos;AdventureWorksDW2014.dbo.SalesOrders_2012&apos;</span><br><span class=\"line\">allow values that are not allowed by range defined by partition 3 on target table &apos;AdventureWorksDW2014.dbo.SalesOrders&apos;.</span><br></pre></td></tr></table></figure>\n<p>这是因为表dbo.SalesOrders 的数据经过分区函数的分区列定义, 各个分区的数据实际上已经经过<br>了数据约束检查，符合分区边界范围(Range)的数据才会录入到各个分区中。<br>但是在存档表dbo.SalesOrders_2012中的数据实际上是没有边界约束的，比如完全可以手动的插入一条其他年的数据，所以进行SWITCH时肯定是不会成功的，这时候需要增加一个数据约束检查</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> dbo.SalesOrders_2012 <span class=\"keyword\">ADD</span> <span class=\"keyword\">CONSTRAINT</span> CK_SalesOrders_OrderDate</span><br><span class=\"line\"><span class=\"keyword\">CHECK</span>(OrderDate&gt;=<span class=\"string\">'2012-01-01'</span> <span class=\"keyword\">AND</span> OrderDate&lt;<span class=\"string\">'2013-01-01'</span>)</span><br></pre></td></tr></table></figure>\n<p>这时候再SWITCH，2012年扥分区数据就会到了分区表中。</p>\n<h3 id=\"切换分区表数据到分区表\"><a href=\"#切换分区表数据到分区表\" class=\"headerlink\" title=\"切换分区表数据到分区表\"></a>切换分区表数据到分区表</h3><p>新的存档分区表在结构上和源分区表是一致的，包括分区函数和分区方案，<br>但是需要重新创建，不能简单地直接使用dbo.SalesOrders 表上的分区函和分区方案，因为他们之间有绑定关系</p>\n<p>创建分区函数和分区方案</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF EXISTS (<span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> sys.partition_schemes <span class=\"keyword\">WHERE</span> <span class=\"keyword\">name</span> = <span class=\"string\">'PS_SalesOrdersArchive'</span>)</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">PARTITION</span> SCHEME PS_SalesOrdersArchive</span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> (<span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> sys.partition_functions <span class=\"keyword\">WHERE</span> <span class=\"keyword\">name</span> = <span class=\"string\">'PF_SalesOrdersArchive_OrderDateRange'</span>)</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">FUNCTION</span> PF_SalesOrdersArchive_OrderDateRange</span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">FUNCTION</span> PF_SalesOrdersArchive_OrderDateRange(DATETIME)</span><br><span class=\"line\"><span class=\"keyword\">AS</span> <span class=\"keyword\">RANGE</span> <span class=\"keyword\">RIGHT</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span></span><br><span class=\"line\">(</span><br><span class=\"line\">   <span class=\"string\">'2011-01-01'</span>,</span><br><span class=\"line\">   <span class=\"string\">'2012-01-01'</span>,</span><br><span class=\"line\">   <span class=\"string\">'2013-01-01'</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PARTITION</span> SCHEME PS_SalesOrdersArchive</span><br><span class=\"line\"><span class=\"keyword\">AS</span> <span class=\"keyword\">PARTITION</span> PF_SalesOrdersArchive_OrderDateRange</span><br><span class=\"line\"><span class=\"keyword\">TO</span> (test1fg, test2fg, test3fg, test4fg)</span><br><span class=\"line\"><span class=\"keyword\">GO</span></span><br></pre></td></tr></table></figure>\n<p>创建归档表</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> [dbo].[SalesOrdersArchive](</span><br><span class=\"line\">\t[ProductKey] [<span class=\"built_in\">int</span>] <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">\t[OrderDateKey] [<span class=\"built_in\">int</span>] <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t[OrderDate] [datetime] <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">\t[DueDate] [datetime] <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">\t[ShipDate] [datetime] <span class=\"literal\">NULL</span></span><br><span class=\"line\">) <span class=\"keyword\">ON</span> PS_SalesOrdersArchive(OrderDate)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> CLUSTERED <span class=\"keyword\">INDEX</span> IXC_SalesOrdersArchive_OrderDate <span class=\"keyword\">ON</span> dbo.SalesOrdersArchive(OrderDate)</span><br></pre></td></tr></table></figure>\n<p>切换分区到归档表</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> dbo.SalesOrders <span class=\"keyword\">SWITCH</span> <span class=\"keyword\">PARTITION</span> <span class=\"number\">1</span> <span class=\"keyword\">TO</span> dbo.SalesOrdersArchive <span class=\"keyword\">PARTITION</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> dbo.SalesOrders <span class=\"keyword\">SWITCH</span> <span class=\"keyword\">PARTITION</span> <span class=\"number\">2</span> <span class=\"keyword\">TO</span> dbo.SalesOrdersArchive <span class=\"keyword\">PARTITION</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> dbo.SalesOrders <span class=\"keyword\">SWITCH</span> <span class=\"keyword\">PARTITION</span> <span class=\"number\">3</span> <span class=\"keyword\">TO</span> dbo.SalesOrdersArchive <span class=\"keyword\">PARTITION</span> <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>切换完成后，观察一下原表和归档表的分区数据状况：</p>\n<p>原表：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/OriginTablePatitionStatus.png\" alt=\"OriginTablePartitionStatus\"></p>\n<p>归档表：</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/ArchiveTablePatition.png\" alt=\"ArchieveTablePatitionStatus\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>分区表分区切换并没有真正去移动数据,而是SQL Server 在系统底层改变了表的元数据。因此分区表分区切换是高效、快速、灵活的。利用分区表的分区切换功能，我们可以快速加载数据到分区表、卸载分区数据到普通表，然后TRUNCATE普通表，以实现快速删除分区表数据，快速归档不活跃数据到历史表。</p>\n<p>表分区的相关概念和实际操作就介绍到这儿，下一篇重点介绍一下如何实现表分区随着时间窗口的移动而自动维护。</p>"},{"title":"SQL Server索引","date":"2017-06-02T08:04:35.000Z","_content":"\n索引是与表或视图关联的磁盘上结构，可以加快从表或视图中检索行的速度。在SQL Server中，索引和表（这里指的是加了聚集索引的表）的存储结构是一样的,都是B树，B树是一种用于查找的平衡多叉树。\n\n## 索引的利弊\n\n查询执行的大部分开销是I/O，使用索引提高性能的一个主要目标是避免全表扫描，因为全表扫描需要从磁盘上读取表的每一个数据页，如果有索引指向数据值，则查询只需要读少数次的磁盘就行啦。所以合理的使用索引能加速数据的查询。但是索引并不总是提高系统的性能，带索引的表需要在数据库中占用更多的存储空间，同样用来增删数据的命令运行时间以及维护索引所需的处理时间会更长。所以我们要合理使用索引，及时更新去除次优索引。\n\n## 数据表的基本结构\n\n一个新表被创建之时，系统将在磁盘中分配一段以8K为单位的连续空间，当字段的值从内存写入磁盘时，就在这一既定空间随机保存，当一个 8K用完的时候，数据库指针会自动分配一个8K的空间。这里，每个8K空间被称为一个数据页（Page），又名页面或数据页面，并分配从0-7的页号, 每个文件的第0页记录引导信息，叫文件头（File header）；每8个数据页（64Ｋ）的组合形成扩展区（Extent），称为扩展。全部数据页的组合形成堆（Heap）\n\n\n## 聚集索引和非聚集索引\n\n在SQL SERVER中，聚集索引的存储是以B树存储，B树的叶子直接存储聚集索引的数据\n\n![ClusteredIndex](https://i-technet.sec.s-msft.com/dynimg/IC144198.gif)\n\n非聚集索引与聚集索引具有相同的 B 树结构，它们之间的显著差别在于以下两点：\n- 基础表的数据行不按非聚集键的顺序排序和存储。\n- 非聚集索引的叶层是由索引页而不是由数据页组成。\n\n![NonClusteredIndex](https://i-technet.sec.s-msft.com/dynimg/IC85533.gif)\n\n非聚集索引也是一个B树结构，与聚集索引不同的是，B树的叶子节点存的是指向堆或聚集索引的指针。\n\n## 索引的设计原则\n","source":"_posts/SQL-ServerÀ˜“˝.md","raw":"---\ntitle: SQL Server索引\ntags:\n  - SQL Server\ndate: 2017-06-02 16:04:35\n---\n\n索引是与表或视图关联的磁盘上结构，可以加快从表或视图中检索行的速度。在SQL Server中，索引和表（这里指的是加了聚集索引的表）的存储结构是一样的,都是B树，B树是一种用于查找的平衡多叉树。\n\n## 索引的利弊\n\n查询执行的大部分开销是I/O，使用索引提高性能的一个主要目标是避免全表扫描，因为全表扫描需要从磁盘上读取表的每一个数据页，如果有索引指向数据值，则查询只需要读少数次的磁盘就行啦。所以合理的使用索引能加速数据的查询。但是索引并不总是提高系统的性能，带索引的表需要在数据库中占用更多的存储空间，同样用来增删数据的命令运行时间以及维护索引所需的处理时间会更长。所以我们要合理使用索引，及时更新去除次优索引。\n\n## 数据表的基本结构\n\n一个新表被创建之时，系统将在磁盘中分配一段以8K为单位的连续空间，当字段的值从内存写入磁盘时，就在这一既定空间随机保存，当一个 8K用完的时候，数据库指针会自动分配一个8K的空间。这里，每个8K空间被称为一个数据页（Page），又名页面或数据页面，并分配从0-7的页号, 每个文件的第0页记录引导信息，叫文件头（File header）；每8个数据页（64Ｋ）的组合形成扩展区（Extent），称为扩展。全部数据页的组合形成堆（Heap）\n\n\n## 聚集索引和非聚集索引\n\n在SQL SERVER中，聚集索引的存储是以B树存储，B树的叶子直接存储聚集索引的数据\n\n![ClusteredIndex](https://i-technet.sec.s-msft.com/dynimg/IC144198.gif)\n\n非聚集索引与聚集索引具有相同的 B 树结构，它们之间的显著差别在于以下两点：\n- 基础表的数据行不按非聚集键的顺序排序和存储。\n- 非聚集索引的叶层是由索引页而不是由数据页组成。\n\n![NonClusteredIndex](https://i-technet.sec.s-msft.com/dynimg/IC85533.gif)\n\n非聚集索引也是一个B树结构，与聚集索引不同的是，B树的叶子节点存的是指向堆或聚集索引的指针。\n\n## 索引的设计原则\n","slug":"SQL-ServerÀ˜“˝","published":1,"updated":"2017-06-13T08:26:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3oq003mzd68nnol4j3b","content":"<p>索引是与表或视图关联的磁盘上结构，可以加快从表或视图中检索行的速度。在SQL Server中，索引和表（这里指的是加了聚集索引的表）的存储结构是一样的,都是B树，B树是一种用于查找的平衡多叉树。</p>\n<h2 id=\"索引的利弊\"><a href=\"#索引的利弊\" class=\"headerlink\" title=\"索引的利弊\"></a>索引的利弊</h2><p>查询执行的大部分开销是I/O，使用索引提高性能的一个主要目标是避免全表扫描，因为全表扫描需要从磁盘上读取表的每一个数据页，如果有索引指向数据值，则查询只需要读少数次的磁盘就行啦。所以合理的使用索引能加速数据的查询。但是索引并不总是提高系统的性能，带索引的表需要在数据库中占用更多的存储空间，同样用来增删数据的命令运行时间以及维护索引所需的处理时间会更长。所以我们要合理使用索引，及时更新去除次优索引。</p>\n<h2 id=\"数据表的基本结构\"><a href=\"#数据表的基本结构\" class=\"headerlink\" title=\"数据表的基本结构\"></a>数据表的基本结构</h2><p>一个新表被创建之时，系统将在磁盘中分配一段以8K为单位的连续空间，当字段的值从内存写入磁盘时，就在这一既定空间随机保存，当一个 8K用完的时候，数据库指针会自动分配一个8K的空间。这里，每个8K空间被称为一个数据页（Page），又名页面或数据页面，并分配从0-7的页号, 每个文件的第0页记录引导信息，叫文件头（File header）；每8个数据页（64Ｋ）的组合形成扩展区（Extent），称为扩展。全部数据页的组合形成堆（Heap）</p>\n<h2 id=\"聚集索引和非聚集索引\"><a href=\"#聚集索引和非聚集索引\" class=\"headerlink\" title=\"聚集索引和非聚集索引\"></a>聚集索引和非聚集索引</h2><p>在SQL SERVER中，聚集索引的存储是以B树存储，B树的叶子直接存储聚集索引的数据</p>\n<p><img src=\"https://i-technet.sec.s-msft.com/dynimg/IC144198.gif\" alt=\"ClusteredIndex\"></p>\n<p>非聚集索引与聚集索引具有相同的 B 树结构，它们之间的显著差别在于以下两点：</p>\n<ul>\n<li>基础表的数据行不按非聚集键的顺序排序和存储。</li>\n<li>非聚集索引的叶层是由索引页而不是由数据页组成。</li>\n</ul>\n<p><img src=\"https://i-technet.sec.s-msft.com/dynimg/IC85533.gif\" alt=\"NonClusteredIndex\"></p>\n<p>非聚集索引也是一个B树结构，与聚集索引不同的是，B树的叶子节点存的是指向堆或聚集索引的指针。</p>\n<h2 id=\"索引的设计原则\"><a href=\"#索引的设计原则\" class=\"headerlink\" title=\"索引的设计原则\"></a>索引的设计原则</h2>","site":{"data":{}},"excerpt":"","more":"<p>索引是与表或视图关联的磁盘上结构，可以加快从表或视图中检索行的速度。在SQL Server中，索引和表（这里指的是加了聚集索引的表）的存储结构是一样的,都是B树，B树是一种用于查找的平衡多叉树。</p>\n<h2 id=\"索引的利弊\"><a href=\"#索引的利弊\" class=\"headerlink\" title=\"索引的利弊\"></a>索引的利弊</h2><p>查询执行的大部分开销是I/O，使用索引提高性能的一个主要目标是避免全表扫描，因为全表扫描需要从磁盘上读取表的每一个数据页，如果有索引指向数据值，则查询只需要读少数次的磁盘就行啦。所以合理的使用索引能加速数据的查询。但是索引并不总是提高系统的性能，带索引的表需要在数据库中占用更多的存储空间，同样用来增删数据的命令运行时间以及维护索引所需的处理时间会更长。所以我们要合理使用索引，及时更新去除次优索引。</p>\n<h2 id=\"数据表的基本结构\"><a href=\"#数据表的基本结构\" class=\"headerlink\" title=\"数据表的基本结构\"></a>数据表的基本结构</h2><p>一个新表被创建之时，系统将在磁盘中分配一段以8K为单位的连续空间，当字段的值从内存写入磁盘时，就在这一既定空间随机保存，当一个 8K用完的时候，数据库指针会自动分配一个8K的空间。这里，每个8K空间被称为一个数据页（Page），又名页面或数据页面，并分配从0-7的页号, 每个文件的第0页记录引导信息，叫文件头（File header）；每8个数据页（64Ｋ）的组合形成扩展区（Extent），称为扩展。全部数据页的组合形成堆（Heap）</p>\n<h2 id=\"聚集索引和非聚集索引\"><a href=\"#聚集索引和非聚集索引\" class=\"headerlink\" title=\"聚集索引和非聚集索引\"></a>聚集索引和非聚集索引</h2><p>在SQL SERVER中，聚集索引的存储是以B树存储，B树的叶子直接存储聚集索引的数据</p>\n<p><img src=\"https://i-technet.sec.s-msft.com/dynimg/IC144198.gif\" alt=\"ClusteredIndex\"></p>\n<p>非聚集索引与聚集索引具有相同的 B 树结构，它们之间的显著差别在于以下两点：</p>\n<ul>\n<li>基础表的数据行不按非聚集键的顺序排序和存储。</li>\n<li>非聚集索引的叶层是由索引页而不是由数据页组成。</li>\n</ul>\n<p><img src=\"https://i-technet.sec.s-msft.com/dynimg/IC85533.gif\" alt=\"NonClusteredIndex\"></p>\n<p>非聚集索引也是一个B树结构，与聚集索引不同的是，B树的叶子节点存的是指向堆或聚集索引的指针。</p>\n<h2 id=\"索引的设计原则\"><a href=\"#索引的设计原则\" class=\"headerlink\" title=\"索引的设计原则\"></a>索引的设计原则</h2>"},{"title":"T-SQL查询语句执行顺序","date":"2017-06-06T02:43:35.000Z","_content":"\n\n数据库查询语句可以说是基础中的基础，查询语句是后面查询性能优化的基础，但是很多人并不能很准确的说出数据库查询的逻辑流程。\n\n## SQL 语句中元素\n\n逻辑查询处理，指的是标准SQL定义的如何处理查询和返回最终结果的概念性路径。和其他的语言代码执行顺序不同，SQL 查询不是按照代码顺序来进行逻辑查询。下面这段SQL 查询\n\n``` sql\nSELECT empid\n     , YEAR(orderdate) AS OrderYear\n     , COUNT(*) AS NumOrders\nFROM Sales.Orders\nWHERE custid = 71\nGROUP BY empid, YEAR(orderdate)\nHAVING COUNT(*) > 1\nORDER BY empid, OrderYear\n```\n\n这段SQL 语句其实是按照下面的顺序进行的逻辑处理：\n\n1. **FROM**\n2. **WHERE**\n3. **GROUP BY**\n4. **HAVING**\n5. **SELECT**\n6. **ORDER BY**\n\n<!-- more -->\n\n`FROM` 子句指定要查询的表名称和进行多表运算的表运算符(JOIN)； `WHERE` 子句可以指定一个谓词或者逻辑表达式来筛选由 `FROM`阶段返回的行； `GROUP BY`阶段允许用户把前面阶段返回的行排列到组中； `HAVING` 子句可以指定一个谓词来筛选前面GROUP出的组，而不是筛选单个行； `SELECT` 子句用户指定要返回到查询结果表中属性(列)； `ORDER BY` 子句允许对输出行进行排序。\n\n## 流程图\n\n这里引用 [Itzik Ben-Gan](http://tsql.solidq.com/) 的流程图\n\n![SQLLogicFlowchart](http://7xkfga.com1.z0.glb.clouddn.com/208801.jfif)\n\n## 分步分析\n\n\n### FROM 子句\n\nFROM阶段标识出查询的来源表，并处理表运算符。在涉及到联接运算的查询中（各种join），主要有以下几个步骤：\n\n1. 求笛卡尔积。不论是什么类型的联接运算，首先都是执行交叉连接（cross join），求笛卡儿积，生成虚拟表VT1-J1。\n2. ON筛选器。这个阶段对上个步骤生成的VT1-J1进行筛选，根据ON子句中出现的谓词进行筛选，让谓词取值为true的行通过了考验，插入到VT1-J2。\n3. 添加外部行。如果指定了outer join，还需要将VT1-J2中没有找到匹配的行，作为外部行添加到VT1-J2中，生成VT1-J3。\n\n经过以上步骤，FROM阶段就完成了。概括地讲，FROM阶段就是进行预处理的，根据提供的运算符对语句中提到的各个表进行处理（除了join，还有apply，pivot，unpivot）\n\n### WHERE 子句\n\nWHERE阶段是根据<where_predicate>中条件对VT1中的行进行筛选，让条件成立的行才会插入到VT2中。\n\n### GROUP BY阶段\n\nGROUP阶段按照指定的列名列表，将VT2中的行进行分组，生成VT3。最后每个分组只有一行。\n\n### HAVING阶段\n\n该阶段根据HAVING子句中出现的谓词对VT3的分组进行筛选，并将符合条件的组插入到VT4中。\n\n### SELECT阶段\n\n这个阶段是投影的过程，处理SELECT子句提到的元素，产生VT5。这个步骤一般按下列顺序进行\n\n1. 计算SELECT列表中的表达式，生成VT5-1。\n2. 若有DISTINCT，则删除VT5-1中的重复行，生成VT5-2\n3. 若有TOP，则根据ORDER BY子句定义的逻辑顺序，从VT5-2中选择签名指定数量或者百分比的行，生成VT5-3\n\n### ORDER BY阶段\n\n根据ORDER BY子句中指定的列明列表，对VT5-3中的行，进行排序，生成游标VC6.\n\n当然SQL SERVER在实际的查询过程中，有查询优化器来生成实际的工作计划。以何种顺序来访问表，使用什么方法和索引，应用哪种联接方法，都是由查询优化器来决定的。优化器一般会生成多个工作计划，从中选择开销最小的那个去执行。逻辑查询处理都有非常特定的顺序，但是优化器常常会走捷径。","source":"_posts/T-SQL≤È—Ø”Ôæ‰÷¥––À≥–Ú.md","raw":"---\ntitle: T-SQL查询语句执行顺序\ndate: 2017-06-06 10:43:35\ntags:\n  - SQL\n\n---\n\n\n数据库查询语句可以说是基础中的基础，查询语句是后面查询性能优化的基础，但是很多人并不能很准确的说出数据库查询的逻辑流程。\n\n## SQL 语句中元素\n\n逻辑查询处理，指的是标准SQL定义的如何处理查询和返回最终结果的概念性路径。和其他的语言代码执行顺序不同，SQL 查询不是按照代码顺序来进行逻辑查询。下面这段SQL 查询\n\n``` sql\nSELECT empid\n     , YEAR(orderdate) AS OrderYear\n     , COUNT(*) AS NumOrders\nFROM Sales.Orders\nWHERE custid = 71\nGROUP BY empid, YEAR(orderdate)\nHAVING COUNT(*) > 1\nORDER BY empid, OrderYear\n```\n\n这段SQL 语句其实是按照下面的顺序进行的逻辑处理：\n\n1. **FROM**\n2. **WHERE**\n3. **GROUP BY**\n4. **HAVING**\n5. **SELECT**\n6. **ORDER BY**\n\n<!-- more -->\n\n`FROM` 子句指定要查询的表名称和进行多表运算的表运算符(JOIN)； `WHERE` 子句可以指定一个谓词或者逻辑表达式来筛选由 `FROM`阶段返回的行； `GROUP BY`阶段允许用户把前面阶段返回的行排列到组中； `HAVING` 子句可以指定一个谓词来筛选前面GROUP出的组，而不是筛选单个行； `SELECT` 子句用户指定要返回到查询结果表中属性(列)； `ORDER BY` 子句允许对输出行进行排序。\n\n## 流程图\n\n这里引用 [Itzik Ben-Gan](http://tsql.solidq.com/) 的流程图\n\n![SQLLogicFlowchart](http://7xkfga.com1.z0.glb.clouddn.com/208801.jfif)\n\n## 分步分析\n\n\n### FROM 子句\n\nFROM阶段标识出查询的来源表，并处理表运算符。在涉及到联接运算的查询中（各种join），主要有以下几个步骤：\n\n1. 求笛卡尔积。不论是什么类型的联接运算，首先都是执行交叉连接（cross join），求笛卡儿积，生成虚拟表VT1-J1。\n2. ON筛选器。这个阶段对上个步骤生成的VT1-J1进行筛选，根据ON子句中出现的谓词进行筛选，让谓词取值为true的行通过了考验，插入到VT1-J2。\n3. 添加外部行。如果指定了outer join，还需要将VT1-J2中没有找到匹配的行，作为外部行添加到VT1-J2中，生成VT1-J3。\n\n经过以上步骤，FROM阶段就完成了。概括地讲，FROM阶段就是进行预处理的，根据提供的运算符对语句中提到的各个表进行处理（除了join，还有apply，pivot，unpivot）\n\n### WHERE 子句\n\nWHERE阶段是根据<where_predicate>中条件对VT1中的行进行筛选，让条件成立的行才会插入到VT2中。\n\n### GROUP BY阶段\n\nGROUP阶段按照指定的列名列表，将VT2中的行进行分组，生成VT3。最后每个分组只有一行。\n\n### HAVING阶段\n\n该阶段根据HAVING子句中出现的谓词对VT3的分组进行筛选，并将符合条件的组插入到VT4中。\n\n### SELECT阶段\n\n这个阶段是投影的过程，处理SELECT子句提到的元素，产生VT5。这个步骤一般按下列顺序进行\n\n1. 计算SELECT列表中的表达式，生成VT5-1。\n2. 若有DISTINCT，则删除VT5-1中的重复行，生成VT5-2\n3. 若有TOP，则根据ORDER BY子句定义的逻辑顺序，从VT5-2中选择签名指定数量或者百分比的行，生成VT5-3\n\n### ORDER BY阶段\n\n根据ORDER BY子句中指定的列明列表，对VT5-3中的行，进行排序，生成游标VC6.\n\n当然SQL SERVER在实际的查询过程中，有查询优化器来生成实际的工作计划。以何种顺序来访问表，使用什么方法和索引，应用哪种联接方法，都是由查询优化器来决定的。优化器一般会生成多个工作计划，从中选择开销最小的那个去执行。逻辑查询处理都有非常特定的顺序，但是优化器常常会走捷径。","slug":"T-SQL≤È—Ø”Ôæ‰÷¥––À≥–Ú","published":1,"updated":"2017-06-06T05:37:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3or003nzd68okn7xva8","content":"<p>数据库查询语句可以说是基础中的基础，查询语句是后面查询性能优化的基础，但是很多人并不能很准确的说出数据库查询的逻辑流程。</p>\n<h2 id=\"SQL-语句中元素\"><a href=\"#SQL-语句中元素\" class=\"headerlink\" title=\"SQL 语句中元素\"></a>SQL 语句中元素</h2><p>逻辑查询处理，指的是标准SQL定义的如何处理查询和返回最终结果的概念性路径。和其他的语言代码执行顺序不同，SQL 查询不是按照代码顺序来进行逻辑查询。下面这段SQL 查询</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> empid</span><br><span class=\"line\">     , <span class=\"keyword\">YEAR</span>(orderdate) <span class=\"keyword\">AS</span> OrderYear</span><br><span class=\"line\">     , <span class=\"keyword\">COUNT</span>(*) <span class=\"keyword\">AS</span> NumOrders</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.Orders</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> custid = <span class=\"number\">71</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> empid, <span class=\"keyword\">YEAR</span>(orderdate)</span><br><span class=\"line\"><span class=\"keyword\">HAVING</span> <span class=\"keyword\">COUNT</span>(*) &gt; <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> empid, OrderYear</span><br></pre></td></tr></table></figure>\n<p>这段SQL 语句其实是按照下面的顺序进行的逻辑处理：</p>\n<ol>\n<li><strong>FROM</strong></li>\n<li><strong>WHERE</strong></li>\n<li><strong>GROUP BY</strong></li>\n<li><strong>HAVING</strong></li>\n<li><strong>SELECT</strong></li>\n<li><strong>ORDER BY</strong></li>\n</ol>\n<a id=\"more\"></a>\n<p><code>FROM</code> 子句指定要查询的表名称和进行多表运算的表运算符(JOIN)； <code>WHERE</code> 子句可以指定一个谓词或者逻辑表达式来筛选由 <code>FROM</code>阶段返回的行； <code>GROUP BY</code>阶段允许用户把前面阶段返回的行排列到组中； <code>HAVING</code> 子句可以指定一个谓词来筛选前面GROUP出的组，而不是筛选单个行； <code>SELECT</code> 子句用户指定要返回到查询结果表中属性(列)； <code>ORDER BY</code> 子句允许对输出行进行排序。</p>\n<h2 id=\"流程图\"><a href=\"#流程图\" class=\"headerlink\" title=\"流程图\"></a>流程图</h2><p>这里引用 <a href=\"http://tsql.solidq.com/\" target=\"_blank\" rel=\"noopener\">Itzik Ben-Gan</a> 的流程图</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/208801.jfif\" alt=\"SQLLogicFlowchart\"></p>\n<h2 id=\"分步分析\"><a href=\"#分步分析\" class=\"headerlink\" title=\"分步分析\"></a>分步分析</h2><h3 id=\"FROM-子句\"><a href=\"#FROM-子句\" class=\"headerlink\" title=\"FROM 子句\"></a>FROM 子句</h3><p>FROM阶段标识出查询的来源表，并处理表运算符。在涉及到联接运算的查询中（各种join），主要有以下几个步骤：</p>\n<ol>\n<li>求笛卡尔积。不论是什么类型的联接运算，首先都是执行交叉连接（cross join），求笛卡儿积，生成虚拟表VT1-J1。</li>\n<li>ON筛选器。这个阶段对上个步骤生成的VT1-J1进行筛选，根据ON子句中出现的谓词进行筛选，让谓词取值为true的行通过了考验，插入到VT1-J2。</li>\n<li>添加外部行。如果指定了outer join，还需要将VT1-J2中没有找到匹配的行，作为外部行添加到VT1-J2中，生成VT1-J3。</li>\n</ol>\n<p>经过以上步骤，FROM阶段就完成了。概括地讲，FROM阶段就是进行预处理的，根据提供的运算符对语句中提到的各个表进行处理（除了join，还有apply，pivot，unpivot）</p>\n<h3 id=\"WHERE-子句\"><a href=\"#WHERE-子句\" class=\"headerlink\" title=\"WHERE 子句\"></a>WHERE 子句</h3><p>WHERE阶段是根据&lt;where_predicate&gt;中条件对VT1中的行进行筛选，让条件成立的行才会插入到VT2中。</p>\n<h3 id=\"GROUP-BY阶段\"><a href=\"#GROUP-BY阶段\" class=\"headerlink\" title=\"GROUP BY阶段\"></a>GROUP BY阶段</h3><p>GROUP阶段按照指定的列名列表，将VT2中的行进行分组，生成VT3。最后每个分组只有一行。</p>\n<h3 id=\"HAVING阶段\"><a href=\"#HAVING阶段\" class=\"headerlink\" title=\"HAVING阶段\"></a>HAVING阶段</h3><p>该阶段根据HAVING子句中出现的谓词对VT3的分组进行筛选，并将符合条件的组插入到VT4中。</p>\n<h3 id=\"SELECT阶段\"><a href=\"#SELECT阶段\" class=\"headerlink\" title=\"SELECT阶段\"></a>SELECT阶段</h3><p>这个阶段是投影的过程，处理SELECT子句提到的元素，产生VT5。这个步骤一般按下列顺序进行</p>\n<ol>\n<li>计算SELECT列表中的表达式，生成VT5-1。</li>\n<li>若有DISTINCT，则删除VT5-1中的重复行，生成VT5-2</li>\n<li>若有TOP，则根据ORDER BY子句定义的逻辑顺序，从VT5-2中选择签名指定数量或者百分比的行，生成VT5-3</li>\n</ol>\n<h3 id=\"ORDER-BY阶段\"><a href=\"#ORDER-BY阶段\" class=\"headerlink\" title=\"ORDER BY阶段\"></a>ORDER BY阶段</h3><p>根据ORDER BY子句中指定的列明列表，对VT5-3中的行，进行排序，生成游标VC6.</p>\n<p>当然SQL SERVER在实际的查询过程中，有查询优化器来生成实际的工作计划。以何种顺序来访问表，使用什么方法和索引，应用哪种联接方法，都是由查询优化器来决定的。优化器一般会生成多个工作计划，从中选择开销最小的那个去执行。逻辑查询处理都有非常特定的顺序，但是优化器常常会走捷径。</p>\n","site":{"data":{}},"excerpt":"<p>数据库查询语句可以说是基础中的基础，查询语句是后面查询性能优化的基础，但是很多人并不能很准确的说出数据库查询的逻辑流程。</p>\n<h2 id=\"SQL-语句中元素\"><a href=\"#SQL-语句中元素\" class=\"headerlink\" title=\"SQL 语句中元素\"></a>SQL 语句中元素</h2><p>逻辑查询处理，指的是标准SQL定义的如何处理查询和返回最终结果的概念性路径。和其他的语言代码执行顺序不同，SQL 查询不是按照代码顺序来进行逻辑查询。下面这段SQL 查询</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> empid</span><br><span class=\"line\">     , <span class=\"keyword\">YEAR</span>(orderdate) <span class=\"keyword\">AS</span> OrderYear</span><br><span class=\"line\">     , <span class=\"keyword\">COUNT</span>(*) <span class=\"keyword\">AS</span> NumOrders</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.Orders</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> custid = <span class=\"number\">71</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> empid, <span class=\"keyword\">YEAR</span>(orderdate)</span><br><span class=\"line\"><span class=\"keyword\">HAVING</span> <span class=\"keyword\">COUNT</span>(*) &gt; <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> empid, OrderYear</span><br></pre></td></tr></table></figure>\n<p>这段SQL 语句其实是按照下面的顺序进行的逻辑处理：</p>\n<ol>\n<li><strong>FROM</strong></li>\n<li><strong>WHERE</strong></li>\n<li><strong>GROUP BY</strong></li>\n<li><strong>HAVING</strong></li>\n<li><strong>SELECT</strong></li>\n<li><strong>ORDER BY</strong></li>\n</ol>","more":"<p><code>FROM</code> 子句指定要查询的表名称和进行多表运算的表运算符(JOIN)； <code>WHERE</code> 子句可以指定一个谓词或者逻辑表达式来筛选由 <code>FROM</code>阶段返回的行； <code>GROUP BY</code>阶段允许用户把前面阶段返回的行排列到组中； <code>HAVING</code> 子句可以指定一个谓词来筛选前面GROUP出的组，而不是筛选单个行； <code>SELECT</code> 子句用户指定要返回到查询结果表中属性(列)； <code>ORDER BY</code> 子句允许对输出行进行排序。</p>\n<h2 id=\"流程图\"><a href=\"#流程图\" class=\"headerlink\" title=\"流程图\"></a>流程图</h2><p>这里引用 <a href=\"http://tsql.solidq.com/\" target=\"_blank\" rel=\"noopener\">Itzik Ben-Gan</a> 的流程图</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/208801.jfif\" alt=\"SQLLogicFlowchart\"></p>\n<h2 id=\"分步分析\"><a href=\"#分步分析\" class=\"headerlink\" title=\"分步分析\"></a>分步分析</h2><h3 id=\"FROM-子句\"><a href=\"#FROM-子句\" class=\"headerlink\" title=\"FROM 子句\"></a>FROM 子句</h3><p>FROM阶段标识出查询的来源表，并处理表运算符。在涉及到联接运算的查询中（各种join），主要有以下几个步骤：</p>\n<ol>\n<li>求笛卡尔积。不论是什么类型的联接运算，首先都是执行交叉连接（cross join），求笛卡儿积，生成虚拟表VT1-J1。</li>\n<li>ON筛选器。这个阶段对上个步骤生成的VT1-J1进行筛选，根据ON子句中出现的谓词进行筛选，让谓词取值为true的行通过了考验，插入到VT1-J2。</li>\n<li>添加外部行。如果指定了outer join，还需要将VT1-J2中没有找到匹配的行，作为外部行添加到VT1-J2中，生成VT1-J3。</li>\n</ol>\n<p>经过以上步骤，FROM阶段就完成了。概括地讲，FROM阶段就是进行预处理的，根据提供的运算符对语句中提到的各个表进行处理（除了join，还有apply，pivot，unpivot）</p>\n<h3 id=\"WHERE-子句\"><a href=\"#WHERE-子句\" class=\"headerlink\" title=\"WHERE 子句\"></a>WHERE 子句</h3><p>WHERE阶段是根据&lt;where_predicate&gt;中条件对VT1中的行进行筛选，让条件成立的行才会插入到VT2中。</p>\n<h3 id=\"GROUP-BY阶段\"><a href=\"#GROUP-BY阶段\" class=\"headerlink\" title=\"GROUP BY阶段\"></a>GROUP BY阶段</h3><p>GROUP阶段按照指定的列名列表，将VT2中的行进行分组，生成VT3。最后每个分组只有一行。</p>\n<h3 id=\"HAVING阶段\"><a href=\"#HAVING阶段\" class=\"headerlink\" title=\"HAVING阶段\"></a>HAVING阶段</h3><p>该阶段根据HAVING子句中出现的谓词对VT3的分组进行筛选，并将符合条件的组插入到VT4中。</p>\n<h3 id=\"SELECT阶段\"><a href=\"#SELECT阶段\" class=\"headerlink\" title=\"SELECT阶段\"></a>SELECT阶段</h3><p>这个阶段是投影的过程，处理SELECT子句提到的元素，产生VT5。这个步骤一般按下列顺序进行</p>\n<ol>\n<li>计算SELECT列表中的表达式，生成VT5-1。</li>\n<li>若有DISTINCT，则删除VT5-1中的重复行，生成VT5-2</li>\n<li>若有TOP，则根据ORDER BY子句定义的逻辑顺序，从VT5-2中选择签名指定数量或者百分比的行，生成VT5-3</li>\n</ol>\n<h3 id=\"ORDER-BY阶段\"><a href=\"#ORDER-BY阶段\" class=\"headerlink\" title=\"ORDER BY阶段\"></a>ORDER BY阶段</h3><p>根据ORDER BY子句中指定的列明列表，对VT5-3中的行，进行排序，生成游标VC6.</p>\n<p>当然SQL SERVER在实际的查询过程中，有查询优化器来生成实际的工作计划。以何种顺序来访问表，使用什么方法和索引，应用哪种联接方法，都是由查询优化器来决定的。优化器一般会生成多个工作计划，从中选择开销最小的那个去执行。逻辑查询处理都有非常特定的顺序，但是优化器常常会走捷径。</p>"},{"title":"git 常用命令总结","date":"2016-09-20T03:20:32.000Z","_content":"\nGit，目前主流的版本控制工具，git命令是一些命令行工具的集合，它可以用来跟踪，记录文件的变动。比如你可以进行保存，比对，分析，合并等等。\n\n日常使用，一般记住一下6个命令就好了\n\n![gitCommand](http://7xkfga.com1.z0.glb.clouddn.com/gitPng.png)\n\n- Workspace：工作区\n- Index / Stage：暂存区\n- Repository：仓库区（或本地仓库）\n- Remote：远程仓库\n\n## 基本的git工作流\n\n1. 在工作目录中修改文件\n2. 暂存文件，将文件的快照放入暂存区域\n3. 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录\n\n![git workflow](http://7xkfga.com1.z0.glb.clouddn.com/566304-ddcf785586305023.png)\n\n<!-- more -->\n\n\n## 新建代码库\n\n``` bash\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n\n## 配置\n\nGit的设置文件为 `.gitconfig`，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n``` bash\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n## 增加/删除文件\n\n``` bash\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n\n## 提交版本\n\n现在我们已经添加了这些文件，然后我们将它们提交到仓库。\n\n``` bash\n$ git commit -m \"Adding files\"\n```\n\n如果您不使用-m，会出现编辑器来让你写自己的注释信息。\n当我们修改了很多文件，而不想每一个都add，想commit自动来提交本地修改，我们可以使用-a标识。\n\n``` bash\n$ git commit -a -m \"Changed some files\"\n```\n\ngit commit 命令的-a选项可将所有被修改或者已删除的且已经被git管理的文档提交到仓库中。\n\n\n## 分支\n\n当你在做一个新功能的时候，最好是在一个独立的区域上开发，通常称之为分支。分支之间相互独立，并且拥有自己的历史记录。这样做的原因是：\n\n- 稳定版本的代码不会被破坏\n- 不同的功能可以由不同开发者同时开发\n- 开发者可以专注于自己的分支，不用担心被其他人破坏了环境\n- 在不确定之前，同一个特性可以拥有几个版本，便于比较\n\n``` bash\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n```\n\n## 查看信息\n\n``` bash\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n```\n\n## 远程同步\n\n``` bash\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n\n## 撤销\n\n``` bash\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n```\n\n\n转自阮一峰： http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html","source":"_posts/git π”√–°Ω·.md","raw":"title: git 常用命令总结\ndate: 2016-09-20 11:20:32\ntags: \n  - git\n  - github\ncategories: \n  - 备忘\n\n---\n\nGit，目前主流的版本控制工具，git命令是一些命令行工具的集合，它可以用来跟踪，记录文件的变动。比如你可以进行保存，比对，分析，合并等等。\n\n日常使用，一般记住一下6个命令就好了\n\n![gitCommand](http://7xkfga.com1.z0.glb.clouddn.com/gitPng.png)\n\n- Workspace：工作区\n- Index / Stage：暂存区\n- Repository：仓库区（或本地仓库）\n- Remote：远程仓库\n\n## 基本的git工作流\n\n1. 在工作目录中修改文件\n2. 暂存文件，将文件的快照放入暂存区域\n3. 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录\n\n![git workflow](http://7xkfga.com1.z0.glb.clouddn.com/566304-ddcf785586305023.png)\n\n<!-- more -->\n\n\n## 新建代码库\n\n``` bash\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n\n## 配置\n\nGit的设置文件为 `.gitconfig`，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n``` bash\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n## 增加/删除文件\n\n``` bash\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n\n## 提交版本\n\n现在我们已经添加了这些文件，然后我们将它们提交到仓库。\n\n``` bash\n$ git commit -m \"Adding files\"\n```\n\n如果您不使用-m，会出现编辑器来让你写自己的注释信息。\n当我们修改了很多文件，而不想每一个都add，想commit自动来提交本地修改，我们可以使用-a标识。\n\n``` bash\n$ git commit -a -m \"Changed some files\"\n```\n\ngit commit 命令的-a选项可将所有被修改或者已删除的且已经被git管理的文档提交到仓库中。\n\n\n## 分支\n\n当你在做一个新功能的时候，最好是在一个独立的区域上开发，通常称之为分支。分支之间相互独立，并且拥有自己的历史记录。这样做的原因是：\n\n- 稳定版本的代码不会被破坏\n- 不同的功能可以由不同开发者同时开发\n- 开发者可以专注于自己的分支，不用担心被其他人破坏了环境\n- 在不确定之前，同一个特性可以拥有几个版本，便于比较\n\n``` bash\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n```\n\n## 查看信息\n\n``` bash\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n```\n\n## 远程同步\n\n``` bash\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n\n## 撤销\n\n``` bash\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n```\n\n\n转自阮一峰： http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html","slug":"git π”√–°Ω·","published":1,"updated":"2017-06-06T07:10:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3ot003szd684moshw1f","content":"<p>Git，目前主流的版本控制工具，git命令是一些命令行工具的集合，它可以用来跟踪，记录文件的变动。比如你可以进行保存，比对，分析，合并等等。</p>\n<p>日常使用，一般记住一下6个命令就好了</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/gitPng.png\" alt=\"gitCommand\"></p>\n<ul>\n<li>Workspace：工作区</li>\n<li>Index / Stage：暂存区</li>\n<li>Repository：仓库区（或本地仓库）</li>\n<li>Remote：远程仓库</li>\n</ul>\n<h2 id=\"基本的git工作流\"><a href=\"#基本的git工作流\" class=\"headerlink\" title=\"基本的git工作流\"></a>基本的git工作流</h2><ol>\n<li>在工作目录中修改文件</li>\n<li>暂存文件，将文件的快照放入暂存区域</li>\n<li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录</li>\n</ol>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/566304-ddcf785586305023.png\" alt=\"git workflow\"></p>\n<a id=\"more\"></a>\n<h2 id=\"新建代码库\"><a href=\"#新建代码库\" class=\"headerlink\" title=\"新建代码库\"></a>新建代码库</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在当前目录新建一个Git代码库</span></span><br><span class=\"line\">$ git init</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class=\"line\">$ git init [project-name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载一个项目和它的整个代码历史</span></span><br><span class=\"line\">$ git <span class=\"built_in\">clone</span> [url]</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>Git的设置文件为 <code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示当前的Git配置</span></span><br><span class=\"line\">$ git config --list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编辑Git配置文件</span></span><br><span class=\"line\">$ git config -e [--global]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置提交代码时的用户信息</span></span><br><span class=\"line\">$ git config [--global] user.name <span class=\"string\">\"[name]\"</span></span><br><span class=\"line\">$ git config [--global] user.email <span class=\"string\">\"[email address]\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"增加-删除文件\"><a href=\"#增加-删除文件\" class=\"headerlink\" title=\"增加/删除文件\"></a>增加/删除文件</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加指定文件到暂存区</span></span><br><span class=\"line\">$ git add [file1] [file2] ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加指定目录到暂存区，包括子目录</span></span><br><span class=\"line\">$ git add [dir]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加当前目录的所有文件到暂存区</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加每个变化前，都会要求确认</span></span><br><span class=\"line\"><span class=\"comment\"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class=\"line\">$ git add -p</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class=\"line\">$ git rm [file1] [file2] ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class=\"line\">$ git rm --cached [file]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class=\"line\">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>\n<h2 id=\"提交版本\"><a href=\"#提交版本\" class=\"headerlink\" title=\"提交版本\"></a>提交版本</h2><p>现在我们已经添加了这些文件，然后我们将它们提交到仓库。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m <span class=\"string\">\"Adding files\"</span></span><br></pre></td></tr></table></figure>\n<p>如果您不使用-m，会出现编辑器来让你写自己的注释信息。<br>当我们修改了很多文件，而不想每一个都add，想commit自动来提交本地修改，我们可以使用-a标识。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -a -m <span class=\"string\">\"Changed some files\"</span></span><br></pre></td></tr></table></figure>\n<p>git commit 命令的-a选项可将所有被修改或者已删除的且已经被git管理的文档提交到仓库中。</p>\n<h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><p>当你在做一个新功能的时候，最好是在一个独立的区域上开发，通常称之为分支。分支之间相互独立，并且拥有自己的历史记录。这样做的原因是：</p>\n<ul>\n<li>稳定版本的代码不会被破坏</li>\n<li>不同的功能可以由不同开发者同时开发</li>\n<li>开发者可以专注于自己的分支，不用担心被其他人破坏了环境</li>\n<li>在不确定之前，同一个特性可以拥有几个版本，便于比较</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有本地分支</span></span><br><span class=\"line\">$ git branch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出所有远程分支</span></span><br><span class=\"line\">$ git branch -r</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出所有本地分支和远程分支</span></span><br><span class=\"line\">$ git branch -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，但依然停留在当前分支</span></span><br><span class=\"line\">$ git branch [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，并切换到该分支</span></span><br><span class=\"line\">$ git checkout -b [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，指向指定commit</span></span><br><span class=\"line\">$ git branch [branch] [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class=\"line\">$ git branch --track [branch] [remote-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换到指定分支，并更新工作区</span></span><br><span class=\"line\">$ git checkout [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换到上一个分支</span></span><br><span class=\"line\">$ git checkout -</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class=\"line\">$ git branch --<span class=\"built_in\">set</span>-upstream [branch] [remote-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并指定分支到当前分支</span></span><br><span class=\"line\">$ git merge [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 选择一个commit，合并进当前分支</span></span><br><span class=\"line\">$ git cherry-pick [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除分支</span></span><br><span class=\"line\">$ git branch -d [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除远程分支</span></span><br><span class=\"line\">$ git push origin --delete [branch-name]</span><br><span class=\"line\">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看信息\"><a href=\"#查看信息\" class=\"headerlink\" title=\"查看信息\"></a>查看信息</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示有变更的文件</span></span><br><span class=\"line\">$ git status</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示当前分支的版本历史</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> --<span class=\"built_in\">stat</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索提交历史，根据关键词</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> -S [keyword]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> [tag] HEAD --pretty=format:%s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> [tag] HEAD --grep feature</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> --follow [file]</span><br><span class=\"line\">$ git whatchanged [file]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示指定文件相关的每一次diff</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> -p [file]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示过去5次提交</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> -5 --pretty --oneline</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class=\"line\">$ git shortlog -sn</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class=\"line\">$ git blame [file]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示暂存区和工作区的差异</span></span><br><span class=\"line\">$ git diff</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示暂存区和上一个commit的差异</span></span><br><span class=\"line\">$ git diff --cached [file]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class=\"line\">$ git diff HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示两次提交之间的差异</span></span><br><span class=\"line\">$ git diff [first-branch]...[second-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示今天你写了多少行代码</span></span><br><span class=\"line\">$ git diff --shortstat <span class=\"string\">\"@&#123;0 day ago&#125;\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某次提交的元数据和内容变化</span></span><br><span class=\"line\">$ git show [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某次提交发生变化的文件</span></span><br><span class=\"line\">$ git show --name-only [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某次提交时，某个文件的内容</span></span><br><span class=\"line\">$ git show [commit]:[filename]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示当前分支的最近几次提交</span></span><br><span class=\"line\">$ git reflog</span><br></pre></td></tr></table></figure>\n<h2 id=\"远程同步\"><a href=\"#远程同步\" class=\"headerlink\" title=\"远程同步\"></a>远程同步</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载远程仓库的所有变动</span></span><br><span class=\"line\">$ git fetch [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示所有远程仓库</span></span><br><span class=\"line\">$ git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某个远程仓库的信息</span></span><br><span class=\"line\">$ git remote show [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 增加一个新的远程仓库，并命名</span></span><br><span class=\"line\">$ git remote add [shortname] [url]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class=\"line\">$ git pull [remote] [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 上传本地指定分支到远程仓库</span></span><br><span class=\"line\">$ git push [remote] [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class=\"line\">$ git push [remote] --force</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 推送所有分支到远程仓库</span></span><br><span class=\"line\">$ git push [remote] --all</span><br></pre></td></tr></table></figure>\n<h2 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 恢复暂存区的指定文件到工作区</span></span><br><span class=\"line\">$ git checkout [file]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class=\"line\">$ git checkout [commit] [file]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 恢复暂存区的所有文件到工作区</span></span><br><span class=\"line\">$ git checkout .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class=\"line\">$ git reset [file]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class=\"line\">$ git reset --hard</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class=\"line\">$ git reset [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class=\"line\">$ git reset --hard [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class=\"line\">$ git reset --keep [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个commit，用来撤销指定commit</span></span><br><span class=\"line\"><span class=\"comment\"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class=\"line\">$ git revert [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class=\"line\">$ git stash</span><br><span class=\"line\">$ git stash pop</span><br></pre></td></tr></table></figure>\n<p>转自阮一峰： <a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p>\n","site":{"data":{}},"excerpt":"<p>Git，目前主流的版本控制工具，git命令是一些命令行工具的集合，它可以用来跟踪，记录文件的变动。比如你可以进行保存，比对，分析，合并等等。</p>\n<p>日常使用，一般记住一下6个命令就好了</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/gitPng.png\" alt=\"gitCommand\"></p>\n<ul>\n<li>Workspace：工作区</li>\n<li>Index / Stage：暂存区</li>\n<li>Repository：仓库区（或本地仓库）</li>\n<li>Remote：远程仓库</li>\n</ul>\n<h2 id=\"基本的git工作流\"><a href=\"#基本的git工作流\" class=\"headerlink\" title=\"基本的git工作流\"></a>基本的git工作流</h2><ol>\n<li>在工作目录中修改文件</li>\n<li>暂存文件，将文件的快照放入暂存区域</li>\n<li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录</li>\n</ol>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/566304-ddcf785586305023.png\" alt=\"git workflow\"></p>","more":"<h2 id=\"新建代码库\"><a href=\"#新建代码库\" class=\"headerlink\" title=\"新建代码库\"></a>新建代码库</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在当前目录新建一个Git代码库</span></span><br><span class=\"line\">$ git init</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class=\"line\">$ git init [project-name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载一个项目和它的整个代码历史</span></span><br><span class=\"line\">$ git <span class=\"built_in\">clone</span> [url]</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>Git的设置文件为 <code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示当前的Git配置</span></span><br><span class=\"line\">$ git config --list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编辑Git配置文件</span></span><br><span class=\"line\">$ git config -e [--global]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置提交代码时的用户信息</span></span><br><span class=\"line\">$ git config [--global] user.name <span class=\"string\">\"[name]\"</span></span><br><span class=\"line\">$ git config [--global] user.email <span class=\"string\">\"[email address]\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"增加-删除文件\"><a href=\"#增加-删除文件\" class=\"headerlink\" title=\"增加/删除文件\"></a>增加/删除文件</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加指定文件到暂存区</span></span><br><span class=\"line\">$ git add [file1] [file2] ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加指定目录到暂存区，包括子目录</span></span><br><span class=\"line\">$ git add [dir]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加当前目录的所有文件到暂存区</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加每个变化前，都会要求确认</span></span><br><span class=\"line\"><span class=\"comment\"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class=\"line\">$ git add -p</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class=\"line\">$ git rm [file1] [file2] ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class=\"line\">$ git rm --cached [file]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class=\"line\">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>\n<h2 id=\"提交版本\"><a href=\"#提交版本\" class=\"headerlink\" title=\"提交版本\"></a>提交版本</h2><p>现在我们已经添加了这些文件，然后我们将它们提交到仓库。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m <span class=\"string\">\"Adding files\"</span></span><br></pre></td></tr></table></figure>\n<p>如果您不使用-m，会出现编辑器来让你写自己的注释信息。<br>当我们修改了很多文件，而不想每一个都add，想commit自动来提交本地修改，我们可以使用-a标识。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -a -m <span class=\"string\">\"Changed some files\"</span></span><br></pre></td></tr></table></figure>\n<p>git commit 命令的-a选项可将所有被修改或者已删除的且已经被git管理的文档提交到仓库中。</p>\n<h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><p>当你在做一个新功能的时候，最好是在一个独立的区域上开发，通常称之为分支。分支之间相互独立，并且拥有自己的历史记录。这样做的原因是：</p>\n<ul>\n<li>稳定版本的代码不会被破坏</li>\n<li>不同的功能可以由不同开发者同时开发</li>\n<li>开发者可以专注于自己的分支，不用担心被其他人破坏了环境</li>\n<li>在不确定之前，同一个特性可以拥有几个版本，便于比较</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有本地分支</span></span><br><span class=\"line\">$ git branch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出所有远程分支</span></span><br><span class=\"line\">$ git branch -r</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出所有本地分支和远程分支</span></span><br><span class=\"line\">$ git branch -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，但依然停留在当前分支</span></span><br><span class=\"line\">$ git branch [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，并切换到该分支</span></span><br><span class=\"line\">$ git checkout -b [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，指向指定commit</span></span><br><span class=\"line\">$ git branch [branch] [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class=\"line\">$ git branch --track [branch] [remote-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换到指定分支，并更新工作区</span></span><br><span class=\"line\">$ git checkout [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换到上一个分支</span></span><br><span class=\"line\">$ git checkout -</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class=\"line\">$ git branch --<span class=\"built_in\">set</span>-upstream [branch] [remote-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并指定分支到当前分支</span></span><br><span class=\"line\">$ git merge [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 选择一个commit，合并进当前分支</span></span><br><span class=\"line\">$ git cherry-pick [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除分支</span></span><br><span class=\"line\">$ git branch -d [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除远程分支</span></span><br><span class=\"line\">$ git push origin --delete [branch-name]</span><br><span class=\"line\">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看信息\"><a href=\"#查看信息\" class=\"headerlink\" title=\"查看信息\"></a>查看信息</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示有变更的文件</span></span><br><span class=\"line\">$ git status</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示当前分支的版本历史</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> --<span class=\"built_in\">stat</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索提交历史，根据关键词</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> -S [keyword]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> [tag] HEAD --pretty=format:%s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> [tag] HEAD --grep feature</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> --follow [file]</span><br><span class=\"line\">$ git whatchanged [file]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示指定文件相关的每一次diff</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> -p [file]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示过去5次提交</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> -5 --pretty --oneline</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class=\"line\">$ git shortlog -sn</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class=\"line\">$ git blame [file]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示暂存区和工作区的差异</span></span><br><span class=\"line\">$ git diff</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示暂存区和上一个commit的差异</span></span><br><span class=\"line\">$ git diff --cached [file]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class=\"line\">$ git diff HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示两次提交之间的差异</span></span><br><span class=\"line\">$ git diff [first-branch]...[second-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示今天你写了多少行代码</span></span><br><span class=\"line\">$ git diff --shortstat <span class=\"string\">\"@&#123;0 day ago&#125;\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某次提交的元数据和内容变化</span></span><br><span class=\"line\">$ git show [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某次提交发生变化的文件</span></span><br><span class=\"line\">$ git show --name-only [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某次提交时，某个文件的内容</span></span><br><span class=\"line\">$ git show [commit]:[filename]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示当前分支的最近几次提交</span></span><br><span class=\"line\">$ git reflog</span><br></pre></td></tr></table></figure>\n<h2 id=\"远程同步\"><a href=\"#远程同步\" class=\"headerlink\" title=\"远程同步\"></a>远程同步</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载远程仓库的所有变动</span></span><br><span class=\"line\">$ git fetch [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示所有远程仓库</span></span><br><span class=\"line\">$ git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某个远程仓库的信息</span></span><br><span class=\"line\">$ git remote show [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 增加一个新的远程仓库，并命名</span></span><br><span class=\"line\">$ git remote add [shortname] [url]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class=\"line\">$ git pull [remote] [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 上传本地指定分支到远程仓库</span></span><br><span class=\"line\">$ git push [remote] [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class=\"line\">$ git push [remote] --force</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 推送所有分支到远程仓库</span></span><br><span class=\"line\">$ git push [remote] --all</span><br></pre></td></tr></table></figure>\n<h2 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 恢复暂存区的指定文件到工作区</span></span><br><span class=\"line\">$ git checkout [file]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class=\"line\">$ git checkout [commit] [file]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 恢复暂存区的所有文件到工作区</span></span><br><span class=\"line\">$ git checkout .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class=\"line\">$ git reset [file]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class=\"line\">$ git reset --hard</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class=\"line\">$ git reset [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class=\"line\">$ git reset --hard [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class=\"line\">$ git reset --keep [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个commit，用来撤销指定commit</span></span><br><span class=\"line\"><span class=\"comment\"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class=\"line\">$ git revert [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class=\"line\">$ git stash</span><br><span class=\"line\">$ git stash pop</span><br></pre></td></tr></table></figure>\n<p>转自阮一峰： <a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p>"},{"title":"数组和链表","date":"2017-06-13T08:46:42.000Z","_content":"\n\n需要在内存中存储多项数据时，有两种基本方式：数组和链表\n\n由于数组是连续存储的，在操作数组中的数据时就可以根据离首地址的偏移量直接存取相应位置上的数据，但是如果要在数据组中任意位置上插入一个元素，就需要先把后面的元素集体向后移一位为其空出存储空间。与之相反，链表是离散存储的，所以在插入一个数据时只要申请一片新空间，然后将其中的连接关系做一个修改就可以，但是显然在链表上查找一个数据时就要逐个遍历了。\n\n数组的优势在于能够随机访问，而链表只能顺序访问。\n\n链表的优势在于能够以较高的效率在任意位置插入或删除一个节点。\n\n|      |  数组 |  链表 |\n| ---- |------ | ------|\n| 读取 |  O(1) | O(n) |\n| 插入 |  O(n) | O(1) |\n| 删除 |  O(n) | O(1) |\n\n<!-- more -->","source":"_posts/ ˝◊È∫Õ¡¥±Ì.md","raw":"---\ntitle: 数组和链表\ntags:\n  - Algorithm\n  - Data Structure\n  - 面试\ndate: 2017-06-13 16:46:42\n---\n\n\n需要在内存中存储多项数据时，有两种基本方式：数组和链表\n\n由于数组是连续存储的，在操作数组中的数据时就可以根据离首地址的偏移量直接存取相应位置上的数据，但是如果要在数据组中任意位置上插入一个元素，就需要先把后面的元素集体向后移一位为其空出存储空间。与之相反，链表是离散存储的，所以在插入一个数据时只要申请一片新空间，然后将其中的连接关系做一个修改就可以，但是显然在链表上查找一个数据时就要逐个遍历了。\n\n数组的优势在于能够随机访问，而链表只能顺序访问。\n\n链表的优势在于能够以较高的效率在任意位置插入或删除一个节点。\n\n|      |  数组 |  链表 |\n| ---- |------ | ------|\n| 读取 |  O(1) | O(n) |\n| 插入 |  O(n) | O(1) |\n| 删除 |  O(n) | O(1) |\n\n<!-- more -->","slug":" ˝◊È∫Õ¡¥±Ì","published":1,"updated":"2017-06-13T08:46:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3ov003tzd681j2amu7v","content":"<p>需要在内存中存储多项数据时，有两种基本方式：数组和链表</p>\n<p>由于数组是连续存储的，在操作数组中的数据时就可以根据离首地址的偏移量直接存取相应位置上的数据，但是如果要在数据组中任意位置上插入一个元素，就需要先把后面的元素集体向后移一位为其空出存储空间。与之相反，链表是离散存储的，所以在插入一个数据时只要申请一片新空间，然后将其中的连接关系做一个修改就可以，但是显然在链表上查找一个数据时就要逐个遍历了。</p>\n<p>数组的优势在于能够随机访问，而链表只能顺序访问。</p>\n<p>链表的优势在于能够以较高的效率在任意位置插入或删除一个节点。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>数组</th>\n<th>链表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读取</td>\n<td>O(1)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>插入</td>\n<td>O(n)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>删除</td>\n<td>O(n)</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>","site":{"data":{}},"excerpt":"<p>需要在内存中存储多项数据时，有两种基本方式：数组和链表</p>\n<p>由于数组是连续存储的，在操作数组中的数据时就可以根据离首地址的偏移量直接存取相应位置上的数据，但是如果要在数据组中任意位置上插入一个元素，就需要先把后面的元素集体向后移一位为其空出存储空间。与之相反，链表是离散存储的，所以在插入一个数据时只要申请一片新空间，然后将其中的连接关系做一个修改就可以，但是显然在链表上查找一个数据时就要逐个遍历了。</p>\n<p>数组的优势在于能够随机访问，而链表只能顺序访问。</p>\n<p>链表的优势在于能够以较高的效率在任意位置插入或删除一个节点。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>数组</th>\n<th>链表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读取</td>\n<td>O(1)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>插入</td>\n<td>O(n)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>删除</td>\n<td>O(n)</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>","more":""},{"title":"使用Scrapy编写爬虫","date":"2016-09-18T02:39:32.000Z","_content":"\nScrapy是Python开发的一个快速,高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。\n![Scrapy Logo](http://7xkfga.com1.z0.glb.clouddn.com/Scrapy_logo.png)\n\n[Scrapy Home Site](https://scrapy.org/)\n\n``` shell\npip install scrapy\n```\n\n<!-- more -->\n\n## Scrapy 处理流程图\n\n借个图简单介绍下Scrapy处理的流程(这就是框架，帮我们完成了大部分工作)\n![Scrapy workflow](http://7xkfga.com1.z0.glb.clouddn.com/scrapy_architecture.png)\n\n- 引擎(Scrapy Engine)，用来处理整个系统的数据流处理，触发事务。\n- 调度器(Scheduler)，用来接受引擎发过来的请求，压入队列中，并在引擎再次请求的时候返回。\n- 下载器(Downloader)，用于下载网页内容，并将网页内容返回给蜘蛛。\n- 蜘蛛(Spiders)，蜘蛛是主要干活的，用它来制订特定域名或网页的解析规则。编写用于分析response并提取item(即获取到的item)或额外跟进的URL的类。 每个spider负责处理一个特定(或一些)网站。\n- 项目管道(Item Pipeline)，负责处理有蜘蛛从网页中抽取的项目，他的主要任务是清晰、验证和存储数据。当页面被蜘蛛解析后，将被发送到项目管道，并经过几个特定的次序处理数据。\n- 下载器中间件(Downloader Middlewares)，位于Scrapy引擎和下载器之间的钩子框架，主要是处理Scrapy引擎与下载器之间的请求及响应。\n- 蜘蛛中间件(Spider Middlewares)，介于Scrapy引擎和蜘蛛之间的钩子框架，主要工作是处理蜘蛛的响应输入和请求输出。\n- 调度中间件(Scheduler Middlewares)，介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。\n\n\n接下来简单介绍一下爬虫的写法，从开发爬虫到部署，把爬取的数据写入mongodb:\n\n1. 创建新的Scrapy工程\n2. 定义要抽取的Item对象\n3. 编写一个Spider来爬取某个网站并提取出Item对象\n4. 编写Item Pipeline来存储提取出来的Item对象\n5. 使用Scrapyd-client部署Spider项目\n\n把Aqicn上的北京空气质量的数据爬取下来，为日后分析做准备\n![Beijing Air Quality](http://7xkfga.com1.z0.glb.clouddn.com/Beijing_Aqi.png)\n\n## 创建Scrapy工程\n\n在目录下执行命令\n\n``` shell\nscrapy startproject projectName\n```\n\n创建如下的项目文件夹，目录结构如下\n![Folder](http://7xkfga.com1.z0.glb.clouddn.com/ScrapyProjectFolder.png)\n\n\n## 定义Item对象\n\n创建一个`scrapy.Item`类，将所要爬取的字段定义好\n\n``` python\nimport scrapy\n\nclass AirqualityItem(scrapy.Item):\n    date = scrapy.Field()\n    hour = scrapy.Field()\n    city = scrapy.Field()\n    # area = scrapy.Field()\n    aqivalue = scrapy.Field()\n    aqilevel = scrapy.Field()\n    pm2_5 = scrapy.Field()\n    pm10 = scrapy.Field()\n    co = scrapy.Field()\n    no2 = scrapy.Field()\n    o3 = scrapy.Field()\n    so2 = scrapy.Field()\n    temp = scrapy.Field()\n    dew = scrapy.Field()\n    pressure = scrapy.Field()\n    humidity = scrapy.Field()\n    wind = scrapy.Field()\n    # add field to log spider crawl time\n    crawl_time = scrapy.Field()\n```\n\n## 编写Spider\n\nSpider类里面定义如何从一个domain组中爬取数据，包括：初始化url列表、如何跟踪url和如何解析页面提取Item，定义一个Spider，需要继承scrapy.Spider类\n\n- name: 定义Spider的名称，以后调用爬虫应用时候使用;\n- start_url: 初始化url;\n- parse(): 解析下载后的Response对象，解析并返回页面数据并提取出相应的Item对象\n\n\n### 抽取Item对象内容\n\nScrapy Selector是Scrapy提供的一套选择器，通过特定的XPath或者CSS表达式来选择HTML文件中某个部分 (note: Chrome浏览器自带的copy XPath或者CSS功能非常好用)，在开发过程中，可以使用Scrapy内置的Scrapy-Shell来debug选择器。\n\n爬虫的代码如下\n\n``` python\nclass AirQualitySpider(CrawlSpider):\n    name = \"AqiSpider\"\n    download_delay = 2\n    allowed_domains = ['aqicn.org']\n    start_urls = ['http://aqicn.org/city/beijing/en/']\n\n    def parse(self, response):\n        sel = Selector(response)\n        pm25 = int(sel.xpath('//*[@id=\"cur_pm25\"]/text()').extract()[0])\n        pm10 = int(sel.xpath('//*[@id=\"cur_pm10\"]/text()').extract()[0])\n        o3 = int(sel.xpath('//*[@id=\"cur_o3\"]/text()').extract()[0])\n        no2 = int(sel.xpath('//*[@id=\"cur_no2\"]/text()').extract()[0])\n        so2 = int(sel.xpath('//*[@id=\"cur_so2\"]/text()').extract()[0])\n        co = int(sel.xpath('//*[@id=\"cur_co\"]/text()').extract()[0])\n        item = AirqualityItem()\n        item['date'] = updatetime.strftime(\"%Y%m%d\")\n        item['hour'] = updatetime.hour # strftime(\"%H%M%S\")\n        item['city'] = city\n        item['aqivalue'] = aqivalue\n        item['aqilevel'] = aqilevel\n        item['pm2_5'] = pm25\n        item['pm10'] = pm10\n        item['co'] = co\n        item['no2'] = no2\n        item['o3'] = o3\n        item['so2'] = so2\n        item['temp'] = temp\n        item['dew'] = dew\n        item['pressure'] = pressure\n        item['humidity'] = humidity\n        item['wind'] = wind\n        item['crawl_time'] = cur_time\n        yield item\n```\n\n## 数据存储到MongoDB\n\n在Item已经被爬虫抓取之后，Item被发送到Item Pipeline去做更复杂的处理，比如存储到文件中或者数据库中。Item Pipeline常见的用途如下\n\n- 清洗抓取来的HTML数据\n- 验证抓取来的数据\n- 查询与去除重复数据\n- 将Item存储到数据库中\n\n\n``` python\nclass AirqualityPipeline(object):\n    def __init__(self):\n        connection = pymongo.MongoClient(settings['MONGODB_SERVER'], settings['MONGODB_PORT'])\n        db = connection[settings['MONGODB_DB']]\n        self.collection = db[settings['MONGODB_COLLECTION']]\n\n    def process_item(self, item, spider):\n        # save data into mongodb\n        valid = True\n        if not item:\n            valid = False\n            raise DropItem(\"Missing {0}\".format(item))\n        if valid:\n            self.collection.insert(dict(item))\n            log.msg(\"an aqi data added to MongoDB database!\", level=log.DEBUG, spider=spider)\n        return item\n```\n\n接下来需要在setting.py文件中配置Item Pipeline与数据库信息\n\n``` shell\nITEM_PIPELINES = {\n   'AirQuality.pipelines.AirqualityPipeline': 300,\n}\n\nMONGODB_SERVER = \"localhost\"\nMONGODB_PORT = 27017\nMONGODB_DB = \"aqihistoricaldata\"\nMONGODB_COLLECTION = \"aqidata\"\n```\n\n到此，简单的爬虫就已经写好了，可以使用以下命令来抓取相关页面来测试一下这个爬虫\n\n``` shell\nscrapy crawl AqiSpider\n```\n\n其中，AqiSpider就是在Spider程序中设置的Spider的name属性\n\n## 防止爬虫被禁的几种方法\n\n很多网站都有反爬虫的机制，对于这些网站，可以采用以下的一些办法来绕开反爬虫机制：\n\n1. 使用User Agent池，每次发送请求的时候从池中选取不一样的浏览器头信息\n2. 禁止Cookie，有些网站会根据Cookie识别用户身份\n3. 设置dowload_delay，频繁请求数据肯定会被禁\n\n\n## 使用Scrapyd和Scrapyd-client部署爬虫\n\nscrapyd是一个用于部署和运行scrapy爬虫的程序，它允许你通过JSON API来部署爬虫项目和控制爬虫运行。crapyd是一个守护进程，监听爬虫的运行和请求，然后启动进程来执行它们。\n\n### 安装\n\n``` shell\npip install scrapyd\npip install scrapyd-client\n```\n\n### 启动服务\n\n``` shell\nscrapyd\n```\n\n### 配置服务器信息\n\n编辑scrapy.cfg文件，添加如下内容\n\n``` shell\n[deploy:MySpider]\nurl = http://localhost:6800/\nproject = AirQuality\n```\n\n其中，MySpider是服务器名称， url是服务器地址\n\n检查配置，列出当前可用的服务器\n\n``` shell\nscrapyd-deploy -l\n```\n\n部署Spider项目\n\n``` shell\nscrapyd-deploy MySpider -p AirQuality\n```\n\n部署完成后，在http://localhost:6800 可以看到如下的爬虫部署的监控信息\n![schedule](http://7xkfga.com1.z0.glb.clouddn.com/scrapyd.png)\n\n可以使用curl命令去调用爬虫，也可以使用contab命令来定时的去调用爬虫，来实现定时爬取的任务。\n\n版权声明：<br>\n<hr>\n除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br>\n","source":"_posts/ π”√Scrapy±‡–¥≈¿≥Ê.md","raw":"title: 使用Scrapy编写爬虫\ndate: 2016-09-18 10:39:32\ntags:\n- Python \n- 爬虫\ncategories: [Python, 框架]\n\n---\n\nScrapy是Python开发的一个快速,高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。\n![Scrapy Logo](http://7xkfga.com1.z0.glb.clouddn.com/Scrapy_logo.png)\n\n[Scrapy Home Site](https://scrapy.org/)\n\n``` shell\npip install scrapy\n```\n\n<!-- more -->\n\n## Scrapy 处理流程图\n\n借个图简单介绍下Scrapy处理的流程(这就是框架，帮我们完成了大部分工作)\n![Scrapy workflow](http://7xkfga.com1.z0.glb.clouddn.com/scrapy_architecture.png)\n\n- 引擎(Scrapy Engine)，用来处理整个系统的数据流处理，触发事务。\n- 调度器(Scheduler)，用来接受引擎发过来的请求，压入队列中，并在引擎再次请求的时候返回。\n- 下载器(Downloader)，用于下载网页内容，并将网页内容返回给蜘蛛。\n- 蜘蛛(Spiders)，蜘蛛是主要干活的，用它来制订特定域名或网页的解析规则。编写用于分析response并提取item(即获取到的item)或额外跟进的URL的类。 每个spider负责处理一个特定(或一些)网站。\n- 项目管道(Item Pipeline)，负责处理有蜘蛛从网页中抽取的项目，他的主要任务是清晰、验证和存储数据。当页面被蜘蛛解析后，将被发送到项目管道，并经过几个特定的次序处理数据。\n- 下载器中间件(Downloader Middlewares)，位于Scrapy引擎和下载器之间的钩子框架，主要是处理Scrapy引擎与下载器之间的请求及响应。\n- 蜘蛛中间件(Spider Middlewares)，介于Scrapy引擎和蜘蛛之间的钩子框架，主要工作是处理蜘蛛的响应输入和请求输出。\n- 调度中间件(Scheduler Middlewares)，介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。\n\n\n接下来简单介绍一下爬虫的写法，从开发爬虫到部署，把爬取的数据写入mongodb:\n\n1. 创建新的Scrapy工程\n2. 定义要抽取的Item对象\n3. 编写一个Spider来爬取某个网站并提取出Item对象\n4. 编写Item Pipeline来存储提取出来的Item对象\n5. 使用Scrapyd-client部署Spider项目\n\n把Aqicn上的北京空气质量的数据爬取下来，为日后分析做准备\n![Beijing Air Quality](http://7xkfga.com1.z0.glb.clouddn.com/Beijing_Aqi.png)\n\n## 创建Scrapy工程\n\n在目录下执行命令\n\n``` shell\nscrapy startproject projectName\n```\n\n创建如下的项目文件夹，目录结构如下\n![Folder](http://7xkfga.com1.z0.glb.clouddn.com/ScrapyProjectFolder.png)\n\n\n## 定义Item对象\n\n创建一个`scrapy.Item`类，将所要爬取的字段定义好\n\n``` python\nimport scrapy\n\nclass AirqualityItem(scrapy.Item):\n    date = scrapy.Field()\n    hour = scrapy.Field()\n    city = scrapy.Field()\n    # area = scrapy.Field()\n    aqivalue = scrapy.Field()\n    aqilevel = scrapy.Field()\n    pm2_5 = scrapy.Field()\n    pm10 = scrapy.Field()\n    co = scrapy.Field()\n    no2 = scrapy.Field()\n    o3 = scrapy.Field()\n    so2 = scrapy.Field()\n    temp = scrapy.Field()\n    dew = scrapy.Field()\n    pressure = scrapy.Field()\n    humidity = scrapy.Field()\n    wind = scrapy.Field()\n    # add field to log spider crawl time\n    crawl_time = scrapy.Field()\n```\n\n## 编写Spider\n\nSpider类里面定义如何从一个domain组中爬取数据，包括：初始化url列表、如何跟踪url和如何解析页面提取Item，定义一个Spider，需要继承scrapy.Spider类\n\n- name: 定义Spider的名称，以后调用爬虫应用时候使用;\n- start_url: 初始化url;\n- parse(): 解析下载后的Response对象，解析并返回页面数据并提取出相应的Item对象\n\n\n### 抽取Item对象内容\n\nScrapy Selector是Scrapy提供的一套选择器，通过特定的XPath或者CSS表达式来选择HTML文件中某个部分 (note: Chrome浏览器自带的copy XPath或者CSS功能非常好用)，在开发过程中，可以使用Scrapy内置的Scrapy-Shell来debug选择器。\n\n爬虫的代码如下\n\n``` python\nclass AirQualitySpider(CrawlSpider):\n    name = \"AqiSpider\"\n    download_delay = 2\n    allowed_domains = ['aqicn.org']\n    start_urls = ['http://aqicn.org/city/beijing/en/']\n\n    def parse(self, response):\n        sel = Selector(response)\n        pm25 = int(sel.xpath('//*[@id=\"cur_pm25\"]/text()').extract()[0])\n        pm10 = int(sel.xpath('//*[@id=\"cur_pm10\"]/text()').extract()[0])\n        o3 = int(sel.xpath('//*[@id=\"cur_o3\"]/text()').extract()[0])\n        no2 = int(sel.xpath('//*[@id=\"cur_no2\"]/text()').extract()[0])\n        so2 = int(sel.xpath('//*[@id=\"cur_so2\"]/text()').extract()[0])\n        co = int(sel.xpath('//*[@id=\"cur_co\"]/text()').extract()[0])\n        item = AirqualityItem()\n        item['date'] = updatetime.strftime(\"%Y%m%d\")\n        item['hour'] = updatetime.hour # strftime(\"%H%M%S\")\n        item['city'] = city\n        item['aqivalue'] = aqivalue\n        item['aqilevel'] = aqilevel\n        item['pm2_5'] = pm25\n        item['pm10'] = pm10\n        item['co'] = co\n        item['no2'] = no2\n        item['o3'] = o3\n        item['so2'] = so2\n        item['temp'] = temp\n        item['dew'] = dew\n        item['pressure'] = pressure\n        item['humidity'] = humidity\n        item['wind'] = wind\n        item['crawl_time'] = cur_time\n        yield item\n```\n\n## 数据存储到MongoDB\n\n在Item已经被爬虫抓取之后，Item被发送到Item Pipeline去做更复杂的处理，比如存储到文件中或者数据库中。Item Pipeline常见的用途如下\n\n- 清洗抓取来的HTML数据\n- 验证抓取来的数据\n- 查询与去除重复数据\n- 将Item存储到数据库中\n\n\n``` python\nclass AirqualityPipeline(object):\n    def __init__(self):\n        connection = pymongo.MongoClient(settings['MONGODB_SERVER'], settings['MONGODB_PORT'])\n        db = connection[settings['MONGODB_DB']]\n        self.collection = db[settings['MONGODB_COLLECTION']]\n\n    def process_item(self, item, spider):\n        # save data into mongodb\n        valid = True\n        if not item:\n            valid = False\n            raise DropItem(\"Missing {0}\".format(item))\n        if valid:\n            self.collection.insert(dict(item))\n            log.msg(\"an aqi data added to MongoDB database!\", level=log.DEBUG, spider=spider)\n        return item\n```\n\n接下来需要在setting.py文件中配置Item Pipeline与数据库信息\n\n``` shell\nITEM_PIPELINES = {\n   'AirQuality.pipelines.AirqualityPipeline': 300,\n}\n\nMONGODB_SERVER = \"localhost\"\nMONGODB_PORT = 27017\nMONGODB_DB = \"aqihistoricaldata\"\nMONGODB_COLLECTION = \"aqidata\"\n```\n\n到此，简单的爬虫就已经写好了，可以使用以下命令来抓取相关页面来测试一下这个爬虫\n\n``` shell\nscrapy crawl AqiSpider\n```\n\n其中，AqiSpider就是在Spider程序中设置的Spider的name属性\n\n## 防止爬虫被禁的几种方法\n\n很多网站都有反爬虫的机制，对于这些网站，可以采用以下的一些办法来绕开反爬虫机制：\n\n1. 使用User Agent池，每次发送请求的时候从池中选取不一样的浏览器头信息\n2. 禁止Cookie，有些网站会根据Cookie识别用户身份\n3. 设置dowload_delay，频繁请求数据肯定会被禁\n\n\n## 使用Scrapyd和Scrapyd-client部署爬虫\n\nscrapyd是一个用于部署和运行scrapy爬虫的程序，它允许你通过JSON API来部署爬虫项目和控制爬虫运行。crapyd是一个守护进程，监听爬虫的运行和请求，然后启动进程来执行它们。\n\n### 安装\n\n``` shell\npip install scrapyd\npip install scrapyd-client\n```\n\n### 启动服务\n\n``` shell\nscrapyd\n```\n\n### 配置服务器信息\n\n编辑scrapy.cfg文件，添加如下内容\n\n``` shell\n[deploy:MySpider]\nurl = http://localhost:6800/\nproject = AirQuality\n```\n\n其中，MySpider是服务器名称， url是服务器地址\n\n检查配置，列出当前可用的服务器\n\n``` shell\nscrapyd-deploy -l\n```\n\n部署Spider项目\n\n``` shell\nscrapyd-deploy MySpider -p AirQuality\n```\n\n部署完成后，在http://localhost:6800 可以看到如下的爬虫部署的监控信息\n![schedule](http://7xkfga.com1.z0.glb.clouddn.com/scrapyd.png)\n\n可以使用curl命令去调用爬虫，也可以使用contab命令来定时的去调用爬虫，来实现定时爬取的任务。\n\n版权声明：<br>\n<hr>\n除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br>\n","slug":" π”√Scrapy±‡–¥≈¿≥Ê","published":1,"updated":"2017-07-21T07:05:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3oy003xzd6866w0bjlu","content":"<p>Scrapy是Python开发的一个快速,高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。<br><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/Scrapy_logo.png\" alt=\"Scrapy Logo\"></p>\n<p><a href=\"https://scrapy.org/\" target=\"_blank\" rel=\"noopener\">Scrapy Home Site</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install scrapy</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"Scrapy-处理流程图\"><a href=\"#Scrapy-处理流程图\" class=\"headerlink\" title=\"Scrapy 处理流程图\"></a>Scrapy 处理流程图</h2><p>借个图简单介绍下Scrapy处理的流程(这就是框架，帮我们完成了大部分工作)<br><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/scrapy_architecture.png\" alt=\"Scrapy workflow\"></p>\n<ul>\n<li>引擎(Scrapy Engine)，用来处理整个系统的数据流处理，触发事务。</li>\n<li>调度器(Scheduler)，用来接受引擎发过来的请求，压入队列中，并在引擎再次请求的时候返回。</li>\n<li>下载器(Downloader)，用于下载网页内容，并将网页内容返回给蜘蛛。</li>\n<li>蜘蛛(Spiders)，蜘蛛是主要干活的，用它来制订特定域名或网页的解析规则。编写用于分析response并提取item(即获取到的item)或额外跟进的URL的类。 每个spider负责处理一个特定(或一些)网站。</li>\n<li>项目管道(Item Pipeline)，负责处理有蜘蛛从网页中抽取的项目，他的主要任务是清晰、验证和存储数据。当页面被蜘蛛解析后，将被发送到项目管道，并经过几个特定的次序处理数据。</li>\n<li>下载器中间件(Downloader Middlewares)，位于Scrapy引擎和下载器之间的钩子框架，主要是处理Scrapy引擎与下载器之间的请求及响应。</li>\n<li>蜘蛛中间件(Spider Middlewares)，介于Scrapy引擎和蜘蛛之间的钩子框架，主要工作是处理蜘蛛的响应输入和请求输出。</li>\n<li>调度中间件(Scheduler Middlewares)，介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。</li>\n</ul>\n<p>接下来简单介绍一下爬虫的写法，从开发爬虫到部署，把爬取的数据写入mongodb:</p>\n<ol>\n<li>创建新的Scrapy工程</li>\n<li>定义要抽取的Item对象</li>\n<li>编写一个Spider来爬取某个网站并提取出Item对象</li>\n<li>编写Item Pipeline来存储提取出来的Item对象</li>\n<li>使用Scrapyd-client部署Spider项目</li>\n</ol>\n<p>把Aqicn上的北京空气质量的数据爬取下来，为日后分析做准备<br><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/Beijing_Aqi.png\" alt=\"Beijing Air Quality\"></p>\n<h2 id=\"创建Scrapy工程\"><a href=\"#创建Scrapy工程\" class=\"headerlink\" title=\"创建Scrapy工程\"></a>创建Scrapy工程</h2><p>在目录下执行命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy startproject projectName</span><br></pre></td></tr></table></figure>\n<p>创建如下的项目文件夹，目录结构如下<br><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/ScrapyProjectFolder.png\" alt=\"Folder\"></p>\n<h2 id=\"定义Item对象\"><a href=\"#定义Item对象\" class=\"headerlink\" title=\"定义Item对象\"></a>定义Item对象</h2><p>创建一个<code>scrapy.Item</code>类，将所要爬取的字段定义好</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AirqualityItem</span><span class=\"params\">(scrapy.Item)</span>:</span></span><br><span class=\"line\">    date = scrapy.Field()</span><br><span class=\"line\">    hour = scrapy.Field()</span><br><span class=\"line\">    city = scrapy.Field()</span><br><span class=\"line\">    <span class=\"comment\"># area = scrapy.Field()</span></span><br><span class=\"line\">    aqivalue = scrapy.Field()</span><br><span class=\"line\">    aqilevel = scrapy.Field()</span><br><span class=\"line\">    pm2_5 = scrapy.Field()</span><br><span class=\"line\">    pm10 = scrapy.Field()</span><br><span class=\"line\">    co = scrapy.Field()</span><br><span class=\"line\">    no2 = scrapy.Field()</span><br><span class=\"line\">    o3 = scrapy.Field()</span><br><span class=\"line\">    so2 = scrapy.Field()</span><br><span class=\"line\">    temp = scrapy.Field()</span><br><span class=\"line\">    dew = scrapy.Field()</span><br><span class=\"line\">    pressure = scrapy.Field()</span><br><span class=\"line\">    humidity = scrapy.Field()</span><br><span class=\"line\">    wind = scrapy.Field()</span><br><span class=\"line\">    <span class=\"comment\"># add field to log spider crawl time</span></span><br><span class=\"line\">    crawl_time = scrapy.Field()</span><br></pre></td></tr></table></figure>\n<h2 id=\"编写Spider\"><a href=\"#编写Spider\" class=\"headerlink\" title=\"编写Spider\"></a>编写Spider</h2><p>Spider类里面定义如何从一个domain组中爬取数据，包括：初始化url列表、如何跟踪url和如何解析页面提取Item，定义一个Spider，需要继承scrapy.Spider类</p>\n<ul>\n<li>name: 定义Spider的名称，以后调用爬虫应用时候使用;</li>\n<li>start_url: 初始化url;</li>\n<li>parse(): 解析下载后的Response对象，解析并返回页面数据并提取出相应的Item对象</li>\n</ul>\n<h3 id=\"抽取Item对象内容\"><a href=\"#抽取Item对象内容\" class=\"headerlink\" title=\"抽取Item对象内容\"></a>抽取Item对象内容</h3><p>Scrapy Selector是Scrapy提供的一套选择器，通过特定的XPath或者CSS表达式来选择HTML文件中某个部分 (note: Chrome浏览器自带的copy XPath或者CSS功能非常好用)，在开发过程中，可以使用Scrapy内置的Scrapy-Shell来debug选择器。</p>\n<p>爬虫的代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AirQualitySpider</span><span class=\"params\">(CrawlSpider)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">\"AqiSpider\"</span></span><br><span class=\"line\">    download_delay = <span class=\"number\">2</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">'aqicn.org'</span>]</span><br><span class=\"line\">    start_urls = [<span class=\"string\">'http://aqicn.org/city/beijing/en/'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        sel = Selector(response)</span><br><span class=\"line\">        pm25 = int(sel.xpath(<span class=\"string\">'//*[@id=\"cur_pm25\"]/text()'</span>).extract()[<span class=\"number\">0</span>])</span><br><span class=\"line\">        pm10 = int(sel.xpath(<span class=\"string\">'//*[@id=\"cur_pm10\"]/text()'</span>).extract()[<span class=\"number\">0</span>])</span><br><span class=\"line\">        o3 = int(sel.xpath(<span class=\"string\">'//*[@id=\"cur_o3\"]/text()'</span>).extract()[<span class=\"number\">0</span>])</span><br><span class=\"line\">        no2 = int(sel.xpath(<span class=\"string\">'//*[@id=\"cur_no2\"]/text()'</span>).extract()[<span class=\"number\">0</span>])</span><br><span class=\"line\">        so2 = int(sel.xpath(<span class=\"string\">'//*[@id=\"cur_so2\"]/text()'</span>).extract()[<span class=\"number\">0</span>])</span><br><span class=\"line\">        co = int(sel.xpath(<span class=\"string\">'//*[@id=\"cur_co\"]/text()'</span>).extract()[<span class=\"number\">0</span>])</span><br><span class=\"line\">        item = AirqualityItem()</span><br><span class=\"line\">        item[<span class=\"string\">'date'</span>] = updatetime.strftime(<span class=\"string\">\"%Y%m%d\"</span>)</span><br><span class=\"line\">        item[<span class=\"string\">'hour'</span>] = updatetime.hour <span class=\"comment\"># strftime(\"%H%M%S\")</span></span><br><span class=\"line\">        item[<span class=\"string\">'city'</span>] = city</span><br><span class=\"line\">        item[<span class=\"string\">'aqivalue'</span>] = aqivalue</span><br><span class=\"line\">        item[<span class=\"string\">'aqilevel'</span>] = aqilevel</span><br><span class=\"line\">        item[<span class=\"string\">'pm2_5'</span>] = pm25</span><br><span class=\"line\">        item[<span class=\"string\">'pm10'</span>] = pm10</span><br><span class=\"line\">        item[<span class=\"string\">'co'</span>] = co</span><br><span class=\"line\">        item[<span class=\"string\">'no2'</span>] = no2</span><br><span class=\"line\">        item[<span class=\"string\">'o3'</span>] = o3</span><br><span class=\"line\">        item[<span class=\"string\">'so2'</span>] = so2</span><br><span class=\"line\">        item[<span class=\"string\">'temp'</span>] = temp</span><br><span class=\"line\">        item[<span class=\"string\">'dew'</span>] = dew</span><br><span class=\"line\">        item[<span class=\"string\">'pressure'</span>] = pressure</span><br><span class=\"line\">        item[<span class=\"string\">'humidity'</span>] = humidity</span><br><span class=\"line\">        item[<span class=\"string\">'wind'</span>] = wind</span><br><span class=\"line\">        item[<span class=\"string\">'crawl_time'</span>] = cur_time</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> item</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据存储到MongoDB\"><a href=\"#数据存储到MongoDB\" class=\"headerlink\" title=\"数据存储到MongoDB\"></a>数据存储到MongoDB</h2><p>在Item已经被爬虫抓取之后，Item被发送到Item Pipeline去做更复杂的处理，比如存储到文件中或者数据库中。Item Pipeline常见的用途如下</p>\n<ul>\n<li>清洗抓取来的HTML数据</li>\n<li>验证抓取来的数据</li>\n<li>查询与去除重复数据</li>\n<li>将Item存储到数据库中</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AirqualityPipeline</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        connection = pymongo.MongoClient(settings[<span class=\"string\">'MONGODB_SERVER'</span>], settings[<span class=\"string\">'MONGODB_PORT'</span>])</span><br><span class=\"line\">        db = connection[settings[<span class=\"string\">'MONGODB_DB'</span>]]</span><br><span class=\"line\">        self.collection = db[settings[<span class=\"string\">'MONGODB_COLLECTION'</span>]]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_item</span><span class=\"params\">(self, item, spider)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># save data into mongodb</span></span><br><span class=\"line\">        valid = <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> item:</span><br><span class=\"line\">            valid = <span class=\"keyword\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">raise</span> DropItem(<span class=\"string\">\"Missing &#123;0&#125;\"</span>.format(item))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> valid:</span><br><span class=\"line\">            self.collection.insert(dict(item))</span><br><span class=\"line\">            log.msg(<span class=\"string\">\"an aqi data added to MongoDB database!\"</span>, level=log.DEBUG, spider=spider)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> item</span><br></pre></td></tr></table></figure>\n<p>接下来需要在setting.py文件中配置Item Pipeline与数据库信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ITEM_PIPELINES = &#123;</span><br><span class=\"line\">   'AirQuality.pipelines.AirqualityPipeline': 300,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MONGODB_SERVER = \"localhost\"</span><br><span class=\"line\">MONGODB_PORT = 27017</span><br><span class=\"line\">MONGODB_DB = \"aqihistoricaldata\"</span><br><span class=\"line\">MONGODB_COLLECTION = \"aqidata\"</span><br></pre></td></tr></table></figure>\n<p>到此，简单的爬虫就已经写好了，可以使用以下命令来抓取相关页面来测试一下这个爬虫</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl AqiSpider</span><br></pre></td></tr></table></figure>\n<p>其中，AqiSpider就是在Spider程序中设置的Spider的name属性</p>\n<h2 id=\"防止爬虫被禁的几种方法\"><a href=\"#防止爬虫被禁的几种方法\" class=\"headerlink\" title=\"防止爬虫被禁的几种方法\"></a>防止爬虫被禁的几种方法</h2><p>很多网站都有反爬虫的机制，对于这些网站，可以采用以下的一些办法来绕开反爬虫机制：</p>\n<ol>\n<li>使用User Agent池，每次发送请求的时候从池中选取不一样的浏览器头信息</li>\n<li>禁止Cookie，有些网站会根据Cookie识别用户身份</li>\n<li>设置dowload_delay，频繁请求数据肯定会被禁</li>\n</ol>\n<h2 id=\"使用Scrapyd和Scrapyd-client部署爬虫\"><a href=\"#使用Scrapyd和Scrapyd-client部署爬虫\" class=\"headerlink\" title=\"使用Scrapyd和Scrapyd-client部署爬虫\"></a>使用Scrapyd和Scrapyd-client部署爬虫</h2><p>scrapyd是一个用于部署和运行scrapy爬虫的程序，它允许你通过JSON API来部署爬虫项目和控制爬虫运行。crapyd是一个守护进程，监听爬虫的运行和请求，然后启动进程来执行它们。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install scrapyd</span><br><span class=\"line\">pip install scrapyd-client</span><br></pre></td></tr></table></figure>\n<h3 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapyd</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置服务器信息\"><a href=\"#配置服务器信息\" class=\"headerlink\" title=\"配置服务器信息\"></a>配置服务器信息</h3><p>编辑scrapy.cfg文件，添加如下内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[deploy:MySpider]</span><br><span class=\"line\">url = http://localhost:6800/</span><br><span class=\"line\">project = AirQuality</span><br></pre></td></tr></table></figure>\n<p>其中，MySpider是服务器名称， url是服务器地址</p>\n<p>检查配置，列出当前可用的服务器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapyd-deploy -l</span><br></pre></td></tr></table></figure>\n<p>部署Spider项目</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapyd-deploy MySpider -p AirQuality</span><br></pre></td></tr></table></figure>\n<p>部署完成后，在<a href=\"http://localhost:6800\" target=\"_blank\" rel=\"noopener\">http://localhost:6800</a> 可以看到如下的爬虫部署的监控信息<br><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/scrapyd.png\" alt=\"schedule\"></p>\n<p>可以使用curl命令去调用爬虫，也可以使用contab命令来定时的去调用爬虫，来实现定时爬取的任务。</p>\n<p>版权声明：<br></p>\n<p><hr><br>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>\n","site":{"data":{}},"excerpt":"<p>Scrapy是Python开发的一个快速,高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。<br><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/Scrapy_logo.png\" alt=\"Scrapy Logo\"></p>\n<p><a href=\"https://scrapy.org/\" target=\"_blank\" rel=\"noopener\">Scrapy Home Site</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install scrapy</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"Scrapy-处理流程图\"><a href=\"#Scrapy-处理流程图\" class=\"headerlink\" title=\"Scrapy 处理流程图\"></a>Scrapy 处理流程图</h2><p>借个图简单介绍下Scrapy处理的流程(这就是框架，帮我们完成了大部分工作)<br><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/scrapy_architecture.png\" alt=\"Scrapy workflow\"></p>\n<ul>\n<li>引擎(Scrapy Engine)，用来处理整个系统的数据流处理，触发事务。</li>\n<li>调度器(Scheduler)，用来接受引擎发过来的请求，压入队列中，并在引擎再次请求的时候返回。</li>\n<li>下载器(Downloader)，用于下载网页内容，并将网页内容返回给蜘蛛。</li>\n<li>蜘蛛(Spiders)，蜘蛛是主要干活的，用它来制订特定域名或网页的解析规则。编写用于分析response并提取item(即获取到的item)或额外跟进的URL的类。 每个spider负责处理一个特定(或一些)网站。</li>\n<li>项目管道(Item Pipeline)，负责处理有蜘蛛从网页中抽取的项目，他的主要任务是清晰、验证和存储数据。当页面被蜘蛛解析后，将被发送到项目管道，并经过几个特定的次序处理数据。</li>\n<li>下载器中间件(Downloader Middlewares)，位于Scrapy引擎和下载器之间的钩子框架，主要是处理Scrapy引擎与下载器之间的请求及响应。</li>\n<li>蜘蛛中间件(Spider Middlewares)，介于Scrapy引擎和蜘蛛之间的钩子框架，主要工作是处理蜘蛛的响应输入和请求输出。</li>\n<li>调度中间件(Scheduler Middlewares)，介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。</li>\n</ul>\n<p>接下来简单介绍一下爬虫的写法，从开发爬虫到部署，把爬取的数据写入mongodb:</p>\n<ol>\n<li>创建新的Scrapy工程</li>\n<li>定义要抽取的Item对象</li>\n<li>编写一个Spider来爬取某个网站并提取出Item对象</li>\n<li>编写Item Pipeline来存储提取出来的Item对象</li>\n<li>使用Scrapyd-client部署Spider项目</li>\n</ol>\n<p>把Aqicn上的北京空气质量的数据爬取下来，为日后分析做准备<br><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/Beijing_Aqi.png\" alt=\"Beijing Air Quality\"></p>\n<h2 id=\"创建Scrapy工程\"><a href=\"#创建Scrapy工程\" class=\"headerlink\" title=\"创建Scrapy工程\"></a>创建Scrapy工程</h2><p>在目录下执行命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy startproject projectName</span><br></pre></td></tr></table></figure>\n<p>创建如下的项目文件夹，目录结构如下<br><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/ScrapyProjectFolder.png\" alt=\"Folder\"></p>\n<h2 id=\"定义Item对象\"><a href=\"#定义Item对象\" class=\"headerlink\" title=\"定义Item对象\"></a>定义Item对象</h2><p>创建一个<code>scrapy.Item</code>类，将所要爬取的字段定义好</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AirqualityItem</span><span class=\"params\">(scrapy.Item)</span>:</span></span><br><span class=\"line\">    date = scrapy.Field()</span><br><span class=\"line\">    hour = scrapy.Field()</span><br><span class=\"line\">    city = scrapy.Field()</span><br><span class=\"line\">    <span class=\"comment\"># area = scrapy.Field()</span></span><br><span class=\"line\">    aqivalue = scrapy.Field()</span><br><span class=\"line\">    aqilevel = scrapy.Field()</span><br><span class=\"line\">    pm2_5 = scrapy.Field()</span><br><span class=\"line\">    pm10 = scrapy.Field()</span><br><span class=\"line\">    co = scrapy.Field()</span><br><span class=\"line\">    no2 = scrapy.Field()</span><br><span class=\"line\">    o3 = scrapy.Field()</span><br><span class=\"line\">    so2 = scrapy.Field()</span><br><span class=\"line\">    temp = scrapy.Field()</span><br><span class=\"line\">    dew = scrapy.Field()</span><br><span class=\"line\">    pressure = scrapy.Field()</span><br><span class=\"line\">    humidity = scrapy.Field()</span><br><span class=\"line\">    wind = scrapy.Field()</span><br><span class=\"line\">    <span class=\"comment\"># add field to log spider crawl time</span></span><br><span class=\"line\">    crawl_time = scrapy.Field()</span><br></pre></td></tr></table></figure>\n<h2 id=\"编写Spider\"><a href=\"#编写Spider\" class=\"headerlink\" title=\"编写Spider\"></a>编写Spider</h2><p>Spider类里面定义如何从一个domain组中爬取数据，包括：初始化url列表、如何跟踪url和如何解析页面提取Item，定义一个Spider，需要继承scrapy.Spider类</p>\n<ul>\n<li>name: 定义Spider的名称，以后调用爬虫应用时候使用;</li>\n<li>start_url: 初始化url;</li>\n<li>parse(): 解析下载后的Response对象，解析并返回页面数据并提取出相应的Item对象</li>\n</ul>\n<h3 id=\"抽取Item对象内容\"><a href=\"#抽取Item对象内容\" class=\"headerlink\" title=\"抽取Item对象内容\"></a>抽取Item对象内容</h3><p>Scrapy Selector是Scrapy提供的一套选择器，通过特定的XPath或者CSS表达式来选择HTML文件中某个部分 (note: Chrome浏览器自带的copy XPath或者CSS功能非常好用)，在开发过程中，可以使用Scrapy内置的Scrapy-Shell来debug选择器。</p>\n<p>爬虫的代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AirQualitySpider</span><span class=\"params\">(CrawlSpider)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">\"AqiSpider\"</span></span><br><span class=\"line\">    download_delay = <span class=\"number\">2</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">'aqicn.org'</span>]</span><br><span class=\"line\">    start_urls = [<span class=\"string\">'http://aqicn.org/city/beijing/en/'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        sel = Selector(response)</span><br><span class=\"line\">        pm25 = int(sel.xpath(<span class=\"string\">'//*[@id=\"cur_pm25\"]/text()'</span>).extract()[<span class=\"number\">0</span>])</span><br><span class=\"line\">        pm10 = int(sel.xpath(<span class=\"string\">'//*[@id=\"cur_pm10\"]/text()'</span>).extract()[<span class=\"number\">0</span>])</span><br><span class=\"line\">        o3 = int(sel.xpath(<span class=\"string\">'//*[@id=\"cur_o3\"]/text()'</span>).extract()[<span class=\"number\">0</span>])</span><br><span class=\"line\">        no2 = int(sel.xpath(<span class=\"string\">'//*[@id=\"cur_no2\"]/text()'</span>).extract()[<span class=\"number\">0</span>])</span><br><span class=\"line\">        so2 = int(sel.xpath(<span class=\"string\">'//*[@id=\"cur_so2\"]/text()'</span>).extract()[<span class=\"number\">0</span>])</span><br><span class=\"line\">        co = int(sel.xpath(<span class=\"string\">'//*[@id=\"cur_co\"]/text()'</span>).extract()[<span class=\"number\">0</span>])</span><br><span class=\"line\">        item = AirqualityItem()</span><br><span class=\"line\">        item[<span class=\"string\">'date'</span>] = updatetime.strftime(<span class=\"string\">\"%Y%m%d\"</span>)</span><br><span class=\"line\">        item[<span class=\"string\">'hour'</span>] = updatetime.hour <span class=\"comment\"># strftime(\"%H%M%S\")</span></span><br><span class=\"line\">        item[<span class=\"string\">'city'</span>] = city</span><br><span class=\"line\">        item[<span class=\"string\">'aqivalue'</span>] = aqivalue</span><br><span class=\"line\">        item[<span class=\"string\">'aqilevel'</span>] = aqilevel</span><br><span class=\"line\">        item[<span class=\"string\">'pm2_5'</span>] = pm25</span><br><span class=\"line\">        item[<span class=\"string\">'pm10'</span>] = pm10</span><br><span class=\"line\">        item[<span class=\"string\">'co'</span>] = co</span><br><span class=\"line\">        item[<span class=\"string\">'no2'</span>] = no2</span><br><span class=\"line\">        item[<span class=\"string\">'o3'</span>] = o3</span><br><span class=\"line\">        item[<span class=\"string\">'so2'</span>] = so2</span><br><span class=\"line\">        item[<span class=\"string\">'temp'</span>] = temp</span><br><span class=\"line\">        item[<span class=\"string\">'dew'</span>] = dew</span><br><span class=\"line\">        item[<span class=\"string\">'pressure'</span>] = pressure</span><br><span class=\"line\">        item[<span class=\"string\">'humidity'</span>] = humidity</span><br><span class=\"line\">        item[<span class=\"string\">'wind'</span>] = wind</span><br><span class=\"line\">        item[<span class=\"string\">'crawl_time'</span>] = cur_time</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> item</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据存储到MongoDB\"><a href=\"#数据存储到MongoDB\" class=\"headerlink\" title=\"数据存储到MongoDB\"></a>数据存储到MongoDB</h2><p>在Item已经被爬虫抓取之后，Item被发送到Item Pipeline去做更复杂的处理，比如存储到文件中或者数据库中。Item Pipeline常见的用途如下</p>\n<ul>\n<li>清洗抓取来的HTML数据</li>\n<li>验证抓取来的数据</li>\n<li>查询与去除重复数据</li>\n<li>将Item存储到数据库中</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AirqualityPipeline</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        connection = pymongo.MongoClient(settings[<span class=\"string\">'MONGODB_SERVER'</span>], settings[<span class=\"string\">'MONGODB_PORT'</span>])</span><br><span class=\"line\">        db = connection[settings[<span class=\"string\">'MONGODB_DB'</span>]]</span><br><span class=\"line\">        self.collection = db[settings[<span class=\"string\">'MONGODB_COLLECTION'</span>]]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_item</span><span class=\"params\">(self, item, spider)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># save data into mongodb</span></span><br><span class=\"line\">        valid = <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> item:</span><br><span class=\"line\">            valid = <span class=\"keyword\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">raise</span> DropItem(<span class=\"string\">\"Missing &#123;0&#125;\"</span>.format(item))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> valid:</span><br><span class=\"line\">            self.collection.insert(dict(item))</span><br><span class=\"line\">            log.msg(<span class=\"string\">\"an aqi data added to MongoDB database!\"</span>, level=log.DEBUG, spider=spider)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> item</span><br></pre></td></tr></table></figure>\n<p>接下来需要在setting.py文件中配置Item Pipeline与数据库信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ITEM_PIPELINES = &#123;</span><br><span class=\"line\">   'AirQuality.pipelines.AirqualityPipeline': 300,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MONGODB_SERVER = \"localhost\"</span><br><span class=\"line\">MONGODB_PORT = 27017</span><br><span class=\"line\">MONGODB_DB = \"aqihistoricaldata\"</span><br><span class=\"line\">MONGODB_COLLECTION = \"aqidata\"</span><br></pre></td></tr></table></figure>\n<p>到此，简单的爬虫就已经写好了，可以使用以下命令来抓取相关页面来测试一下这个爬虫</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl AqiSpider</span><br></pre></td></tr></table></figure>\n<p>其中，AqiSpider就是在Spider程序中设置的Spider的name属性</p>\n<h2 id=\"防止爬虫被禁的几种方法\"><a href=\"#防止爬虫被禁的几种方法\" class=\"headerlink\" title=\"防止爬虫被禁的几种方法\"></a>防止爬虫被禁的几种方法</h2><p>很多网站都有反爬虫的机制，对于这些网站，可以采用以下的一些办法来绕开反爬虫机制：</p>\n<ol>\n<li>使用User Agent池，每次发送请求的时候从池中选取不一样的浏览器头信息</li>\n<li>禁止Cookie，有些网站会根据Cookie识别用户身份</li>\n<li>设置dowload_delay，频繁请求数据肯定会被禁</li>\n</ol>\n<h2 id=\"使用Scrapyd和Scrapyd-client部署爬虫\"><a href=\"#使用Scrapyd和Scrapyd-client部署爬虫\" class=\"headerlink\" title=\"使用Scrapyd和Scrapyd-client部署爬虫\"></a>使用Scrapyd和Scrapyd-client部署爬虫</h2><p>scrapyd是一个用于部署和运行scrapy爬虫的程序，它允许你通过JSON API来部署爬虫项目和控制爬虫运行。crapyd是一个守护进程，监听爬虫的运行和请求，然后启动进程来执行它们。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install scrapyd</span><br><span class=\"line\">pip install scrapyd-client</span><br></pre></td></tr></table></figure>\n<h3 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapyd</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置服务器信息\"><a href=\"#配置服务器信息\" class=\"headerlink\" title=\"配置服务器信息\"></a>配置服务器信息</h3><p>编辑scrapy.cfg文件，添加如下内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[deploy:MySpider]</span><br><span class=\"line\">url = http://localhost:6800/</span><br><span class=\"line\">project = AirQuality</span><br></pre></td></tr></table></figure>\n<p>其中，MySpider是服务器名称， url是服务器地址</p>\n<p>检查配置，列出当前可用的服务器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapyd-deploy -l</span><br></pre></td></tr></table></figure>\n<p>部署Spider项目</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapyd-deploy MySpider -p AirQuality</span><br></pre></td></tr></table></figure>\n<p>部署完成后，在<a href=\"http://localhost:6800\" target=\"_blank\" rel=\"noopener\">http://localhost:6800</a> 可以看到如下的爬虫部署的监控信息<br><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/scrapyd.png\" alt=\"schedule\"></p>\n<p>可以使用curl命令去调用爬虫，也可以使用contab命令来定时的去调用爬虫，来实现定时爬取的任务。</p>\n<p>版权声明：<br></p>\n<p><hr><br>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>"},{"title":"使用d3.js绘图","date":"2015-11-28T02:55:16.000Z","_content":"\n\nD3的全称是（Data-Driven Documents），是一个Javascript的函数库，主要用途是用HTML和SVG展现数据。下面简单回顾一下我从0出发把csv文件画在HTML页面上的过程。\n\n## 0. 引入d3.js库\n\n引入js库可以直接引用网站上host的js库，也可以下载到本地folder下引入\n\n``` html\n<script src=\"http://d3js.org/d3.v3.min.js\" charset=\"utf-8\"></script>\n```\n\n\n<!-- more -->\n\n## 1. 创建SCG画布\n\n在 SVG 画布的预定义元素里，有六种基本图形：\n- 矩形\n- 圆形\n- 椭圆\n- 线段\n- 折线\n- 多边形\n\n另外，还有一种比较特殊，也是功能最强的元素：\n\n- 路径\n\n\n画布中的所有图形，都是由以上七种元素组成。在绘制数据图表的时候，都是操作这几种图形元素。\n\n``` javascript\nvar margin = {top: 20, right: 20, bottom: 30, left: 50},\n    width = 960 - margin.left - margin.right,\n    height = 500 - margin.top - margin.bottom;\n\nvar svg = d3.select(\"body\").append(\"svg\")\n            .attr(\"width\", width + margin.left + margin.right)\n            .attr(\"height\", height + margin.top + margin.bottom)\n            .append(\"g\")\n            .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n```\n上面代码的意思是，选取HTML代码中的body元素，再后面添加svg画布元素，然后设置宽度高度等属性，svg的g元素类似于div，在这里作为一组元素的容器，后面加入的元素都放在g里面，g可以设置统一的css，里面的子元素会继承可继承css属性。margin和position对g的定位不起作用，只能使用translate通过位移来定位。\n\n## 2. 定义比例尺\n\n对于画布或者图形的长度，不可能全部写死，需要通过数据的大小关系来动态确定，参考地图的比例尺。d3.js中，比例尺需要定义定义域和值域两个属性\n\n有线性比例尺 `d3.scale.linear()` 和序数比例尺 `d3.scale.ordinal()` ，线性比例尺针对连续的定义域和值域，序数比例尺针对离散的。\n\n\n``` javascript\nvar xScale = d3.time.scale().range([0, width]);\nvar yScale = d3.scale.linear().range([height, 0]);\n```\n\n这里先定义比例尺的值域，由于定义域需要根据数据来确定，所以写到了后面读取数据的部分。\n\n## 3. 定义坐标轴\n\nd3.js中的坐标轴由 `d3.svg.axis()` 来实现，svg的坐标原点是左上角，向右为正，向下为正。\n\n``` javascript\nvar xAxis = d3.svg.axis()\n                  .scale(xScale)\n                  .orient(\"bottom\");\nvar yAxis = d3.svg.axis()\n                  .scale(yScale)\n                  .orient(\"left\");\n```\n\nx轴是日期，这里使用d3.time在时间和字符串之间做转换。y轴使用普通的线性缩放坐标轴。\n\n## 4. 读取数据与绑定数据\n\nd3.js 中自带了读取csv、json等文件的方法。\n\n``` javascript\nd3.json(\"data.json\", function(error, json){\n  // process data\n};\n```\n\nd3.js 中是通过以下两个函数来绑定数据的：\n\n- datum()：绑定一个数据到选择集上\n- data()：绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定\n\n``` javascript\nvar data = json;\n// format date field to date\ndata.forEach(function(d){\n  d.date = new Date(d.date);\n  d.close = d.close;\n});\nxScale.domain(d3.extent(data, function(d){ return d.date;}));\nyScale.domain(d3.extent(data, function(d){ return d.close;}));\n```\n\n在这里，data数据是一个列表对象，需要对列表中每一条数据的字段数据类型进行定义，之后需要做的是上面提到的定义x轴y轴的比例尺的定义域的定义。\n\n## 5. 画线\n\n图形的主题是一条线，需要添加 `path` 元素，path的属性决定了线的路径，下面方法定义线的路径属性。\n\n``` javascript\nvar line = d3.svg.line()\n             .x(function(d) { return xScale(d.date); })\n             .y(function(d) { return yScale(d.close); });\nsvg.append(\"path\")\n   .datum(data)\n   .attr(\"class\", \"line\")\n   .attr(\"d\", function(d){ return line(d);});\n```\n\n## 6. 添加坐标轴\n\n`call()` 函数，其参数是前面定义的坐标轴 `axis`\n\n``` javascript\n// add axis\nsvg.append(\"g\")\n   .attr(\"class\", \"x axis\")\n   .attr(\"transform\", \"translate(0,\" + height + \")\")\n   .call(xAxis);\nsvg.append(\"g\")\n   .attr(\"class\", \"y axis\")\n   .call(yAxis)\n   .append(\"text\")\n   .attr(\"transform\", \"rotate(-90)\")\n   .attr(\"y\", 6)\n   .attr(\"dy\", \".71em\")\n   .style(\"text-anchor\", \"end\")\n   .text(\"Price ($)\");\n```\n\n## 7. 生成图表\n\n上面的js脚本写好了之后，理论上就可以生成折线图了。不过在本地调试中，发现报错：文件没有找到。这个是因为由于安全考虑，浏览器不允许js脚本访问本地文件，解决方法有两个：\n\n1. 在本地开启一个web service\n2. 修改浏览器属性，允许访问本地文件\n\n由于以后是要在网站上展示数据，所以我是用Flask在后台开启一个web服务，把d3所需要的数据生成出来\n\n``` python\nfrom flask import Flask\nfrom flask import render_template\nimport json\nimport pandas as pd\n\napp = Flask(__name__)\n\ndata_path = './sampleData'\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"line_chart.html\")\n\n@app.route('/data')\ndef get_data():\n    with open(data_path + '/line_chart.tsv') as data_file:\n        sample_data = pd.read_csv(data_file, sep='\\t')\n    return sample_data.to_json(orient='records')\n```\n\n这样，在本地运行Flask，就可以展现出折线图了。这大约就是d3.js数据可视化的基本过程。\n\n![linechart](http://7xkfga.com1.z0.glb.clouddn.com/d3_line_chart.JPG)\n\n版权声明：<br>\n<hr>\n除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br>\n","source":"_posts/ π”√d3.jsªÊÕº¡˜ÀÆ’À.md","raw":"---\ntitle: 使用d3.js绘图\ndate: 2015-11-28 10:55:16\ntags: \n- d3.js\n- visualization\n---\n\n\nD3的全称是（Data-Driven Documents），是一个Javascript的函数库，主要用途是用HTML和SVG展现数据。下面简单回顾一下我从0出发把csv文件画在HTML页面上的过程。\n\n## 0. 引入d3.js库\n\n引入js库可以直接引用网站上host的js库，也可以下载到本地folder下引入\n\n``` html\n<script src=\"http://d3js.org/d3.v3.min.js\" charset=\"utf-8\"></script>\n```\n\n\n<!-- more -->\n\n## 1. 创建SCG画布\n\n在 SVG 画布的预定义元素里，有六种基本图形：\n- 矩形\n- 圆形\n- 椭圆\n- 线段\n- 折线\n- 多边形\n\n另外，还有一种比较特殊，也是功能最强的元素：\n\n- 路径\n\n\n画布中的所有图形，都是由以上七种元素组成。在绘制数据图表的时候，都是操作这几种图形元素。\n\n``` javascript\nvar margin = {top: 20, right: 20, bottom: 30, left: 50},\n    width = 960 - margin.left - margin.right,\n    height = 500 - margin.top - margin.bottom;\n\nvar svg = d3.select(\"body\").append(\"svg\")\n            .attr(\"width\", width + margin.left + margin.right)\n            .attr(\"height\", height + margin.top + margin.bottom)\n            .append(\"g\")\n            .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n```\n上面代码的意思是，选取HTML代码中的body元素，再后面添加svg画布元素，然后设置宽度高度等属性，svg的g元素类似于div，在这里作为一组元素的容器，后面加入的元素都放在g里面，g可以设置统一的css，里面的子元素会继承可继承css属性。margin和position对g的定位不起作用，只能使用translate通过位移来定位。\n\n## 2. 定义比例尺\n\n对于画布或者图形的长度，不可能全部写死，需要通过数据的大小关系来动态确定，参考地图的比例尺。d3.js中，比例尺需要定义定义域和值域两个属性\n\n有线性比例尺 `d3.scale.linear()` 和序数比例尺 `d3.scale.ordinal()` ，线性比例尺针对连续的定义域和值域，序数比例尺针对离散的。\n\n\n``` javascript\nvar xScale = d3.time.scale().range([0, width]);\nvar yScale = d3.scale.linear().range([height, 0]);\n```\n\n这里先定义比例尺的值域，由于定义域需要根据数据来确定，所以写到了后面读取数据的部分。\n\n## 3. 定义坐标轴\n\nd3.js中的坐标轴由 `d3.svg.axis()` 来实现，svg的坐标原点是左上角，向右为正，向下为正。\n\n``` javascript\nvar xAxis = d3.svg.axis()\n                  .scale(xScale)\n                  .orient(\"bottom\");\nvar yAxis = d3.svg.axis()\n                  .scale(yScale)\n                  .orient(\"left\");\n```\n\nx轴是日期，这里使用d3.time在时间和字符串之间做转换。y轴使用普通的线性缩放坐标轴。\n\n## 4. 读取数据与绑定数据\n\nd3.js 中自带了读取csv、json等文件的方法。\n\n``` javascript\nd3.json(\"data.json\", function(error, json){\n  // process data\n};\n```\n\nd3.js 中是通过以下两个函数来绑定数据的：\n\n- datum()：绑定一个数据到选择集上\n- data()：绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定\n\n``` javascript\nvar data = json;\n// format date field to date\ndata.forEach(function(d){\n  d.date = new Date(d.date);\n  d.close = d.close;\n});\nxScale.domain(d3.extent(data, function(d){ return d.date;}));\nyScale.domain(d3.extent(data, function(d){ return d.close;}));\n```\n\n在这里，data数据是一个列表对象，需要对列表中每一条数据的字段数据类型进行定义，之后需要做的是上面提到的定义x轴y轴的比例尺的定义域的定义。\n\n## 5. 画线\n\n图形的主题是一条线，需要添加 `path` 元素，path的属性决定了线的路径，下面方法定义线的路径属性。\n\n``` javascript\nvar line = d3.svg.line()\n             .x(function(d) { return xScale(d.date); })\n             .y(function(d) { return yScale(d.close); });\nsvg.append(\"path\")\n   .datum(data)\n   .attr(\"class\", \"line\")\n   .attr(\"d\", function(d){ return line(d);});\n```\n\n## 6. 添加坐标轴\n\n`call()` 函数，其参数是前面定义的坐标轴 `axis`\n\n``` javascript\n// add axis\nsvg.append(\"g\")\n   .attr(\"class\", \"x axis\")\n   .attr(\"transform\", \"translate(0,\" + height + \")\")\n   .call(xAxis);\nsvg.append(\"g\")\n   .attr(\"class\", \"y axis\")\n   .call(yAxis)\n   .append(\"text\")\n   .attr(\"transform\", \"rotate(-90)\")\n   .attr(\"y\", 6)\n   .attr(\"dy\", \".71em\")\n   .style(\"text-anchor\", \"end\")\n   .text(\"Price ($)\");\n```\n\n## 7. 生成图表\n\n上面的js脚本写好了之后，理论上就可以生成折线图了。不过在本地调试中，发现报错：文件没有找到。这个是因为由于安全考虑，浏览器不允许js脚本访问本地文件，解决方法有两个：\n\n1. 在本地开启一个web service\n2. 修改浏览器属性，允许访问本地文件\n\n由于以后是要在网站上展示数据，所以我是用Flask在后台开启一个web服务，把d3所需要的数据生成出来\n\n``` python\nfrom flask import Flask\nfrom flask import render_template\nimport json\nimport pandas as pd\n\napp = Flask(__name__)\n\ndata_path = './sampleData'\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"line_chart.html\")\n\n@app.route('/data')\ndef get_data():\n    with open(data_path + '/line_chart.tsv') as data_file:\n        sample_data = pd.read_csv(data_file, sep='\\t')\n    return sample_data.to_json(orient='records')\n```\n\n这样，在本地运行Flask，就可以展现出折线图了。这大约就是d3.js数据可视化的基本过程。\n\n![linechart](http://7xkfga.com1.z0.glb.clouddn.com/d3_line_chart.JPG)\n\n版权声明：<br>\n<hr>\n除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br>\n","slug":" π”√d3.jsªÊÕº¡˜ÀÆ’À","published":1,"updated":"2017-05-31T03:02:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3oz003zzd68f6gzavmp","content":"<p>D3的全称是（Data-Driven Documents），是一个Javascript的函数库，主要用途是用HTML和SVG展现数据。下面简单回顾一下我从0出发把csv文件画在HTML页面上的过程。</p>\n<h2 id=\"0-引入d3-js库\"><a href=\"#0-引入d3-js库\" class=\"headerlink\" title=\"0. 引入d3.js库\"></a>0. 引入d3.js库</h2><p>引入js库可以直接引用网站上host的js库，也可以下载到本地folder下引入</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://d3js.org/d3.v3.min.js\"</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"1-创建SCG画布\"><a href=\"#1-创建SCG画布\" class=\"headerlink\" title=\"1. 创建SCG画布\"></a>1. 创建SCG画布</h2><p>在 SVG 画布的预定义元素里，有六种基本图形：</p>\n<ul>\n<li>矩形</li>\n<li>圆形</li>\n<li>椭圆</li>\n<li>线段</li>\n<li>折线</li>\n<li>多边形</li>\n</ul>\n<p>另外，还有一种比较特殊，也是功能最强的元素：</p>\n<ul>\n<li>路径</li>\n</ul>\n<p>画布中的所有图形，都是由以上七种元素组成。在绘制数据图表的时候，都是操作这几种图形元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> margin = &#123;<span class=\"attr\">top</span>: <span class=\"number\">20</span>, <span class=\"attr\">right</span>: <span class=\"number\">20</span>, <span class=\"attr\">bottom</span>: <span class=\"number\">30</span>, <span class=\"attr\">left</span>: <span class=\"number\">50</span>&#125;,</span><br><span class=\"line\">    width = <span class=\"number\">960</span> - margin.left - margin.right,</span><br><span class=\"line\">    height = <span class=\"number\">500</span> - margin.top - margin.bottom;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> svg = d3.select(<span class=\"string\">\"body\"</span>).append(<span class=\"string\">\"svg\"</span>)</span><br><span class=\"line\">            .attr(<span class=\"string\">\"width\"</span>, width + margin.left + margin.right)</span><br><span class=\"line\">            .attr(<span class=\"string\">\"height\"</span>, height + margin.top + margin.bottom)</span><br><span class=\"line\">            .append(<span class=\"string\">\"g\"</span>)</span><br><span class=\"line\">            .attr(<span class=\"string\">\"transform\"</span>, <span class=\"string\">\"translate(\"</span> + margin.left + <span class=\"string\">\",\"</span> + margin.top + <span class=\"string\">\")\"</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码的意思是，选取HTML代码中的body元素，再后面添加svg画布元素，然后设置宽度高度等属性，svg的g元素类似于div，在这里作为一组元素的容器，后面加入的元素都放在g里面，g可以设置统一的css，里面的子元素会继承可继承css属性。margin和position对g的定位不起作用，只能使用translate通过位移来定位。</p>\n<h2 id=\"2-定义比例尺\"><a href=\"#2-定义比例尺\" class=\"headerlink\" title=\"2. 定义比例尺\"></a>2. 定义比例尺</h2><p>对于画布或者图形的长度，不可能全部写死，需要通过数据的大小关系来动态确定，参考地图的比例尺。d3.js中，比例尺需要定义定义域和值域两个属性</p>\n<p>有线性比例尺 <code>d3.scale.linear()</code> 和序数比例尺 <code>d3.scale.ordinal()</code> ，线性比例尺针对连续的定义域和值域，序数比例尺针对离散的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xScale = d3.time.scale().range([<span class=\"number\">0</span>, width]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> yScale = d3.scale.linear().range([height, <span class=\"number\">0</span>]);</span><br></pre></td></tr></table></figure>\n<p>这里先定义比例尺的值域，由于定义域需要根据数据来确定，所以写到了后面读取数据的部分。</p>\n<h2 id=\"3-定义坐标轴\"><a href=\"#3-定义坐标轴\" class=\"headerlink\" title=\"3. 定义坐标轴\"></a>3. 定义坐标轴</h2><p>d3.js中的坐标轴由 <code>d3.svg.axis()</code> 来实现，svg的坐标原点是左上角，向右为正，向下为正。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xAxis = d3.svg.axis()</span><br><span class=\"line\">                  .scale(xScale)</span><br><span class=\"line\">                  .orient(<span class=\"string\">\"bottom\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> yAxis = d3.svg.axis()</span><br><span class=\"line\">                  .scale(yScale)</span><br><span class=\"line\">                  .orient(<span class=\"string\">\"left\"</span>);</span><br></pre></td></tr></table></figure>\n<p>x轴是日期，这里使用d3.time在时间和字符串之间做转换。y轴使用普通的线性缩放坐标轴。</p>\n<h2 id=\"4-读取数据与绑定数据\"><a href=\"#4-读取数据与绑定数据\" class=\"headerlink\" title=\"4. 读取数据与绑定数据\"></a>4. 读取数据与绑定数据</h2><p>d3.js 中自带了读取csv、json等文件的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d3.json(<span class=\"string\">\"data.json\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, json</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// process data</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>d3.js 中是通过以下两个函数来绑定数据的：</p>\n<ul>\n<li>datum()：绑定一个数据到选择集上</li>\n<li>data()：绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = json;</span><br><span class=\"line\"><span class=\"comment\">// format date field to date</span></span><br><span class=\"line\">data.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>)</span>&#123;</span><br><span class=\"line\">  d.date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(d.date);</span><br><span class=\"line\">  d.close = d.close;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">xScale.domain(d3.extent(data, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>)</span>&#123; <span class=\"keyword\">return</span> d.date;&#125;));</span><br><span class=\"line\">yScale.domain(d3.extent(data, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>)</span>&#123; <span class=\"keyword\">return</span> d.close;&#125;));</span><br></pre></td></tr></table></figure>\n<p>在这里，data数据是一个列表对象，需要对列表中每一条数据的字段数据类型进行定义，之后需要做的是上面提到的定义x轴y轴的比例尺的定义域的定义。</p>\n<h2 id=\"5-画线\"><a href=\"#5-画线\" class=\"headerlink\" title=\"5. 画线\"></a>5. 画线</h2><p>图形的主题是一条线，需要添加 <code>path</code> 元素，path的属性决定了线的路径，下面方法定义线的路径属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> line = d3.svg.line()</span><br><span class=\"line\">             .x(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>) </span>&#123; <span class=\"keyword\">return</span> xScale(d.date); &#125;)</span><br><span class=\"line\">             .y(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>) </span>&#123; <span class=\"keyword\">return</span> yScale(d.close); &#125;);</span><br><span class=\"line\">svg.append(<span class=\"string\">\"path\"</span>)</span><br><span class=\"line\">   .datum(data)</span><br><span class=\"line\">   .attr(<span class=\"string\">\"class\"</span>, <span class=\"string\">\"line\"</span>)</span><br><span class=\"line\">   .attr(<span class=\"string\">\"d\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>)</span>&#123; <span class=\"keyword\">return</span> line(d);&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-添加坐标轴\"><a href=\"#6-添加坐标轴\" class=\"headerlink\" title=\"6. 添加坐标轴\"></a>6. 添加坐标轴</h2><p><code>call()</code> 函数，其参数是前面定义的坐标轴 <code>axis</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// add axis</span></span><br><span class=\"line\">svg.append(<span class=\"string\">\"g\"</span>)</span><br><span class=\"line\">   .attr(<span class=\"string\">\"class\"</span>, <span class=\"string\">\"x axis\"</span>)</span><br><span class=\"line\">   .attr(<span class=\"string\">\"transform\"</span>, <span class=\"string\">\"translate(0,\"</span> + height + <span class=\"string\">\")\"</span>)</span><br><span class=\"line\">   .call(xAxis);</span><br><span class=\"line\">svg.append(<span class=\"string\">\"g\"</span>)</span><br><span class=\"line\">   .attr(<span class=\"string\">\"class\"</span>, <span class=\"string\">\"y axis\"</span>)</span><br><span class=\"line\">   .call(yAxis)</span><br><span class=\"line\">   .append(<span class=\"string\">\"text\"</span>)</span><br><span class=\"line\">   .attr(<span class=\"string\">\"transform\"</span>, <span class=\"string\">\"rotate(-90)\"</span>)</span><br><span class=\"line\">   .attr(<span class=\"string\">\"y\"</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\">   .attr(<span class=\"string\">\"dy\"</span>, <span class=\"string\">\".71em\"</span>)</span><br><span class=\"line\">   .style(<span class=\"string\">\"text-anchor\"</span>, <span class=\"string\">\"end\"</span>)</span><br><span class=\"line\">   .text(<span class=\"string\">\"Price ($)\"</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-生成图表\"><a href=\"#7-生成图表\" class=\"headerlink\" title=\"7. 生成图表\"></a>7. 生成图表</h2><p>上面的js脚本写好了之后，理论上就可以生成折线图了。不过在本地调试中，发现报错：文件没有找到。这个是因为由于安全考虑，浏览器不允许js脚本访问本地文件，解决方法有两个：</p>\n<ol>\n<li>在本地开启一个web service</li>\n<li>修改浏览器属性，允许访问本地文件</li>\n</ol>\n<p>由于以后是要在网站上展示数据，所以我是用Flask在后台开启一个web服务，把d3所需要的数据生成出来</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> render_template</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\">data_path = <span class=\"string\">'./sampleData'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(\"/\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">index</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">\"line_chart.html\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/data')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_data</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> open(data_path + <span class=\"string\">'/line_chart.tsv'</span>) <span class=\"keyword\">as</span> data_file:</span><br><span class=\"line\">        sample_data = pd.read_csv(data_file, sep=<span class=\"string\">'\\t'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sample_data.to_json(orient=<span class=\"string\">'records'</span>)</span><br></pre></td></tr></table></figure>\n<p>这样，在本地运行Flask，就可以展现出折线图了。这大约就是d3.js数据可视化的基本过程。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/d3_line_chart.JPG\" alt=\"linechart\"></p>\n<p>版权声明：<br></p>\n<p><hr><br>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>\n","site":{"data":{}},"excerpt":"<p>D3的全称是（Data-Driven Documents），是一个Javascript的函数库，主要用途是用HTML和SVG展现数据。下面简单回顾一下我从0出发把csv文件画在HTML页面上的过程。</p>\n<h2 id=\"0-引入d3-js库\"><a href=\"#0-引入d3-js库\" class=\"headerlink\" title=\"0. 引入d3.js库\"></a>0. 引入d3.js库</h2><p>引入js库可以直接引用网站上host的js库，也可以下载到本地folder下引入</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://d3js.org/d3.v3.min.js\"</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>","more":"<h2 id=\"1-创建SCG画布\"><a href=\"#1-创建SCG画布\" class=\"headerlink\" title=\"1. 创建SCG画布\"></a>1. 创建SCG画布</h2><p>在 SVG 画布的预定义元素里，有六种基本图形：</p>\n<ul>\n<li>矩形</li>\n<li>圆形</li>\n<li>椭圆</li>\n<li>线段</li>\n<li>折线</li>\n<li>多边形</li>\n</ul>\n<p>另外，还有一种比较特殊，也是功能最强的元素：</p>\n<ul>\n<li>路径</li>\n</ul>\n<p>画布中的所有图形，都是由以上七种元素组成。在绘制数据图表的时候，都是操作这几种图形元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> margin = &#123;<span class=\"attr\">top</span>: <span class=\"number\">20</span>, <span class=\"attr\">right</span>: <span class=\"number\">20</span>, <span class=\"attr\">bottom</span>: <span class=\"number\">30</span>, <span class=\"attr\">left</span>: <span class=\"number\">50</span>&#125;,</span><br><span class=\"line\">    width = <span class=\"number\">960</span> - margin.left - margin.right,</span><br><span class=\"line\">    height = <span class=\"number\">500</span> - margin.top - margin.bottom;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> svg = d3.select(<span class=\"string\">\"body\"</span>).append(<span class=\"string\">\"svg\"</span>)</span><br><span class=\"line\">            .attr(<span class=\"string\">\"width\"</span>, width + margin.left + margin.right)</span><br><span class=\"line\">            .attr(<span class=\"string\">\"height\"</span>, height + margin.top + margin.bottom)</span><br><span class=\"line\">            .append(<span class=\"string\">\"g\"</span>)</span><br><span class=\"line\">            .attr(<span class=\"string\">\"transform\"</span>, <span class=\"string\">\"translate(\"</span> + margin.left + <span class=\"string\">\",\"</span> + margin.top + <span class=\"string\">\")\"</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码的意思是，选取HTML代码中的body元素，再后面添加svg画布元素，然后设置宽度高度等属性，svg的g元素类似于div，在这里作为一组元素的容器，后面加入的元素都放在g里面，g可以设置统一的css，里面的子元素会继承可继承css属性。margin和position对g的定位不起作用，只能使用translate通过位移来定位。</p>\n<h2 id=\"2-定义比例尺\"><a href=\"#2-定义比例尺\" class=\"headerlink\" title=\"2. 定义比例尺\"></a>2. 定义比例尺</h2><p>对于画布或者图形的长度，不可能全部写死，需要通过数据的大小关系来动态确定，参考地图的比例尺。d3.js中，比例尺需要定义定义域和值域两个属性</p>\n<p>有线性比例尺 <code>d3.scale.linear()</code> 和序数比例尺 <code>d3.scale.ordinal()</code> ，线性比例尺针对连续的定义域和值域，序数比例尺针对离散的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xScale = d3.time.scale().range([<span class=\"number\">0</span>, width]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> yScale = d3.scale.linear().range([height, <span class=\"number\">0</span>]);</span><br></pre></td></tr></table></figure>\n<p>这里先定义比例尺的值域，由于定义域需要根据数据来确定，所以写到了后面读取数据的部分。</p>\n<h2 id=\"3-定义坐标轴\"><a href=\"#3-定义坐标轴\" class=\"headerlink\" title=\"3. 定义坐标轴\"></a>3. 定义坐标轴</h2><p>d3.js中的坐标轴由 <code>d3.svg.axis()</code> 来实现，svg的坐标原点是左上角，向右为正，向下为正。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xAxis = d3.svg.axis()</span><br><span class=\"line\">                  .scale(xScale)</span><br><span class=\"line\">                  .orient(<span class=\"string\">\"bottom\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> yAxis = d3.svg.axis()</span><br><span class=\"line\">                  .scale(yScale)</span><br><span class=\"line\">                  .orient(<span class=\"string\">\"left\"</span>);</span><br></pre></td></tr></table></figure>\n<p>x轴是日期，这里使用d3.time在时间和字符串之间做转换。y轴使用普通的线性缩放坐标轴。</p>\n<h2 id=\"4-读取数据与绑定数据\"><a href=\"#4-读取数据与绑定数据\" class=\"headerlink\" title=\"4. 读取数据与绑定数据\"></a>4. 读取数据与绑定数据</h2><p>d3.js 中自带了读取csv、json等文件的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d3.json(<span class=\"string\">\"data.json\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, json</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// process data</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>d3.js 中是通过以下两个函数来绑定数据的：</p>\n<ul>\n<li>datum()：绑定一个数据到选择集上</li>\n<li>data()：绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = json;</span><br><span class=\"line\"><span class=\"comment\">// format date field to date</span></span><br><span class=\"line\">data.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>)</span>&#123;</span><br><span class=\"line\">  d.date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(d.date);</span><br><span class=\"line\">  d.close = d.close;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">xScale.domain(d3.extent(data, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>)</span>&#123; <span class=\"keyword\">return</span> d.date;&#125;));</span><br><span class=\"line\">yScale.domain(d3.extent(data, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>)</span>&#123; <span class=\"keyword\">return</span> d.close;&#125;));</span><br></pre></td></tr></table></figure>\n<p>在这里，data数据是一个列表对象，需要对列表中每一条数据的字段数据类型进行定义，之后需要做的是上面提到的定义x轴y轴的比例尺的定义域的定义。</p>\n<h2 id=\"5-画线\"><a href=\"#5-画线\" class=\"headerlink\" title=\"5. 画线\"></a>5. 画线</h2><p>图形的主题是一条线，需要添加 <code>path</code> 元素，path的属性决定了线的路径，下面方法定义线的路径属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> line = d3.svg.line()</span><br><span class=\"line\">             .x(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>) </span>&#123; <span class=\"keyword\">return</span> xScale(d.date); &#125;)</span><br><span class=\"line\">             .y(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>) </span>&#123; <span class=\"keyword\">return</span> yScale(d.close); &#125;);</span><br><span class=\"line\">svg.append(<span class=\"string\">\"path\"</span>)</span><br><span class=\"line\">   .datum(data)</span><br><span class=\"line\">   .attr(<span class=\"string\">\"class\"</span>, <span class=\"string\">\"line\"</span>)</span><br><span class=\"line\">   .attr(<span class=\"string\">\"d\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>)</span>&#123; <span class=\"keyword\">return</span> line(d);&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-添加坐标轴\"><a href=\"#6-添加坐标轴\" class=\"headerlink\" title=\"6. 添加坐标轴\"></a>6. 添加坐标轴</h2><p><code>call()</code> 函数，其参数是前面定义的坐标轴 <code>axis</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// add axis</span></span><br><span class=\"line\">svg.append(<span class=\"string\">\"g\"</span>)</span><br><span class=\"line\">   .attr(<span class=\"string\">\"class\"</span>, <span class=\"string\">\"x axis\"</span>)</span><br><span class=\"line\">   .attr(<span class=\"string\">\"transform\"</span>, <span class=\"string\">\"translate(0,\"</span> + height + <span class=\"string\">\")\"</span>)</span><br><span class=\"line\">   .call(xAxis);</span><br><span class=\"line\">svg.append(<span class=\"string\">\"g\"</span>)</span><br><span class=\"line\">   .attr(<span class=\"string\">\"class\"</span>, <span class=\"string\">\"y axis\"</span>)</span><br><span class=\"line\">   .call(yAxis)</span><br><span class=\"line\">   .append(<span class=\"string\">\"text\"</span>)</span><br><span class=\"line\">   .attr(<span class=\"string\">\"transform\"</span>, <span class=\"string\">\"rotate(-90)\"</span>)</span><br><span class=\"line\">   .attr(<span class=\"string\">\"y\"</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\">   .attr(<span class=\"string\">\"dy\"</span>, <span class=\"string\">\".71em\"</span>)</span><br><span class=\"line\">   .style(<span class=\"string\">\"text-anchor\"</span>, <span class=\"string\">\"end\"</span>)</span><br><span class=\"line\">   .text(<span class=\"string\">\"Price ($)\"</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-生成图表\"><a href=\"#7-生成图表\" class=\"headerlink\" title=\"7. 生成图表\"></a>7. 生成图表</h2><p>上面的js脚本写好了之后，理论上就可以生成折线图了。不过在本地调试中，发现报错：文件没有找到。这个是因为由于安全考虑，浏览器不允许js脚本访问本地文件，解决方法有两个：</p>\n<ol>\n<li>在本地开启一个web service</li>\n<li>修改浏览器属性，允许访问本地文件</li>\n</ol>\n<p>由于以后是要在网站上展示数据，所以我是用Flask在后台开启一个web服务，把d3所需要的数据生成出来</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> render_template</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\">data_path = <span class=\"string\">'./sampleData'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(\"/\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">index</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">\"line_chart.html\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/data')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_data</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> open(data_path + <span class=\"string\">'/line_chart.tsv'</span>) <span class=\"keyword\">as</span> data_file:</span><br><span class=\"line\">        sample_data = pd.read_csv(data_file, sep=<span class=\"string\">'\\t'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sample_data.to_json(orient=<span class=\"string\">'records'</span>)</span><br></pre></td></tr></table></figure>\n<p>这样，在本地运行Flask，就可以展现出折线图了。这大约就是d3.js数据可视化的基本过程。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/d3_line_chart.JPG\" alt=\"linechart\"></p>\n<p>版权声明：<br></p>\n<p><hr><br>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>"},{"title":"备份Hexo源文件至GitHub","date":"2016-05-31T02:25:41.000Z","_content":"\n\n本文转自：<http://www.leyar.me/backup-your-blog-to-github/>\n\nHexo是一款基于Node.js的静态博客框架，前一阵俺的笔记本泡水直接退役，但是博客的原文件还在那台死去的机器上，所以备份啊。。。\n本质上，Hexo是将本地的md文件编译成静态文件上传到github上（或者其他），所以建议是将本地的整个Hexo项目（blog）原件同步提交到github或者其他代码托管的站点。\n\n下面记录一下备份、以及在另外的电脑上恢复博客的过程，为了以后备查。\n\n## 前提\n\n已创建有 GitHub 仓库，并且已使用 `hexo-deployer-git` 部署到 `master` 分支。（发布博文并托管到Github上）\n如果不满足请自行 google hexo 部署到 GitHub 的操作方法。\n\n## 备份过程\n\n在Github网站创建一个新仓库(或者使用Github托管博客的仓库，在该仓库下创建一个新的分支)，比如我新建的仓库名为 `HEXOSource`\n\n在本地hexo根目录中， 初始化git仓库\n\n``` shell\ngit init\n```\n\n创建并切换到名为 `hexo_source` 的分支\n\n``` shell\ngit checkout -b hexo_source\n```\n\n创建忽略规则文件 `.gitignore`\n\n``` shell\nvi .gitignore\n```\n\n按需添加如下内容：\n\n```\n.DS_Store\nThumbs.db\ndb.json  \n*.log\n.deploy*/\nnode_modules/\n.npmignore\npublic/\n```\n\n上面最后一行 public 目录，因其已被 hexo 插件同步到 master 分支里，因此不需要再同步，deploy 是 hexo 的 git 配置存放目录，也不需要同步。其他内容可选择忽略也可以选择同步。\n\n添加内容到仓库并提交到远程仓库\n\n``` shell\ngit add .\ngit commit -m \"first commit\"\ngit remote add origin git@github.com:lvraikkonen/HEXOSource.git\t\t# 后面仓库目录改成自己新建的。\ngit push -u origin hexo_source\n```\n\n按照以上的步骤就进行了 hexo 源文件的初次备份。\n以后每次修改了内容之后，都可通过以下几条命令实现同步。\n\n``` shell\ngit add .\ngit commit -m \"...\"\t # 双引号内填写更新内容\ngit push origin hexo_source\t# 或者 git push\n```\n\n## 通过 git submodule 来同步第三方主题\n\n我们一般会选择第三方主题的仓库直接git clone下来。这是一个非常不好的习惯，正确做法是：Fork该第三方主题仓库，这样就会在自己账号下生成一个同名的仓库，并对应一个url，我们应该git clone自己账号下的url。\n\n这样做的原因是：我们很有可能在原来主题基础上做一些自定义的小改动，为了保持多终端的同步，我们需要将这些改动提交到远程仓库。而第三方仓库我们是无法直接push的。\n\n这样就会出现git仓库的嵌套问题，我们通过git submodule来解决这个问题。\n\n``` shell\ngit submodule add git@github.com:lvraikkonen/hexo-theme-next.git themes/next\n```\n\n我们修改主题后:\n\n``` shell\ngit commit -am \"refine themes\"\ngit push origin hexo_source\n```\n\n然后就完成了第三方主题的备份\n\n在其他电脑同步源文件时，需要执行如下命令来同步主题\n\n``` shell\ngit submodule init // 这句很重要\ngit submodule update\n```\n\n## 新机器同步\n\n在一个新机器上写博客，用以下步骤同步至最新状态\n\n新建博客文件夹 `hexo_blog`\n\n在该文件夹下初始化git仓库\n\n``` shell\ngit init\n```\n\n为本地仓库添加远程仓库\n\n``` shell\ngit remote add origin git@github.com:lvraikkonen/HEXOSource.git\n```\n\n切换至hexo_source分支\n\n``` shell\ngit checkout -b hexo_source\n```\n\n获取`hexo_source`分支源文件\n\n``` shell\ngit pull origin hexo_source\n```\n\n然后就是写博客，并将.md博客文件放至_posts文件夹，然后添加修改到本地仓库\n\n``` shell\ngit add .\ngit commit -m \"写了一篇博客\"\ngit push origin hexo_source\n```\n\n至此，已经完成了博客的撰写并修改了远端仓库的博客源文件，然后使用`hexo g`和`hexo d`更新博客就OK啦！\n\n## 新机器安装npm失败解决方案\n\n由于众所周知的原因，好多东西无法安装，可以添加第三方源来解决\n\n``` shell\n# 添加淘宝源\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n# nrm类似包管理器\ncnpm install nrm -g\nnrm ls\n# 使用淘宝\nnrm use taobao\nnpm install -g hexo-cli\n```\n\n\n## 参考\n\n- [关于博客同步的解决办法](http://devtian.me/2015/03/17/blog-sync-solution/)\n- [使用Git Submodule管理子模块](https://segmentfault.com/a/1190000003076028)\n","source":"_posts/±∏∑›Hexo‘¥Œƒº˛÷¡GitHub.md","raw":"---\ntitle: 备份Hexo源文件至GitHub\ndate: 2016-05-31 10:25:41\ntags:\n    - 备忘\n    - hexo\n---\n\n\n本文转自：<http://www.leyar.me/backup-your-blog-to-github/>\n\nHexo是一款基于Node.js的静态博客框架，前一阵俺的笔记本泡水直接退役，但是博客的原文件还在那台死去的机器上，所以备份啊。。。\n本质上，Hexo是将本地的md文件编译成静态文件上传到github上（或者其他），所以建议是将本地的整个Hexo项目（blog）原件同步提交到github或者其他代码托管的站点。\n\n下面记录一下备份、以及在另外的电脑上恢复博客的过程，为了以后备查。\n\n## 前提\n\n已创建有 GitHub 仓库，并且已使用 `hexo-deployer-git` 部署到 `master` 分支。（发布博文并托管到Github上）\n如果不满足请自行 google hexo 部署到 GitHub 的操作方法。\n\n## 备份过程\n\n在Github网站创建一个新仓库(或者使用Github托管博客的仓库，在该仓库下创建一个新的分支)，比如我新建的仓库名为 `HEXOSource`\n\n在本地hexo根目录中， 初始化git仓库\n\n``` shell\ngit init\n```\n\n创建并切换到名为 `hexo_source` 的分支\n\n``` shell\ngit checkout -b hexo_source\n```\n\n创建忽略规则文件 `.gitignore`\n\n``` shell\nvi .gitignore\n```\n\n按需添加如下内容：\n\n```\n.DS_Store\nThumbs.db\ndb.json  \n*.log\n.deploy*/\nnode_modules/\n.npmignore\npublic/\n```\n\n上面最后一行 public 目录，因其已被 hexo 插件同步到 master 分支里，因此不需要再同步，deploy 是 hexo 的 git 配置存放目录，也不需要同步。其他内容可选择忽略也可以选择同步。\n\n添加内容到仓库并提交到远程仓库\n\n``` shell\ngit add .\ngit commit -m \"first commit\"\ngit remote add origin git@github.com:lvraikkonen/HEXOSource.git\t\t# 后面仓库目录改成自己新建的。\ngit push -u origin hexo_source\n```\n\n按照以上的步骤就进行了 hexo 源文件的初次备份。\n以后每次修改了内容之后，都可通过以下几条命令实现同步。\n\n``` shell\ngit add .\ngit commit -m \"...\"\t # 双引号内填写更新内容\ngit push origin hexo_source\t# 或者 git push\n```\n\n## 通过 git submodule 来同步第三方主题\n\n我们一般会选择第三方主题的仓库直接git clone下来。这是一个非常不好的习惯，正确做法是：Fork该第三方主题仓库，这样就会在自己账号下生成一个同名的仓库，并对应一个url，我们应该git clone自己账号下的url。\n\n这样做的原因是：我们很有可能在原来主题基础上做一些自定义的小改动，为了保持多终端的同步，我们需要将这些改动提交到远程仓库。而第三方仓库我们是无法直接push的。\n\n这样就会出现git仓库的嵌套问题，我们通过git submodule来解决这个问题。\n\n``` shell\ngit submodule add git@github.com:lvraikkonen/hexo-theme-next.git themes/next\n```\n\n我们修改主题后:\n\n``` shell\ngit commit -am \"refine themes\"\ngit push origin hexo_source\n```\n\n然后就完成了第三方主题的备份\n\n在其他电脑同步源文件时，需要执行如下命令来同步主题\n\n``` shell\ngit submodule init // 这句很重要\ngit submodule update\n```\n\n## 新机器同步\n\n在一个新机器上写博客，用以下步骤同步至最新状态\n\n新建博客文件夹 `hexo_blog`\n\n在该文件夹下初始化git仓库\n\n``` shell\ngit init\n```\n\n为本地仓库添加远程仓库\n\n``` shell\ngit remote add origin git@github.com:lvraikkonen/HEXOSource.git\n```\n\n切换至hexo_source分支\n\n``` shell\ngit checkout -b hexo_source\n```\n\n获取`hexo_source`分支源文件\n\n``` shell\ngit pull origin hexo_source\n```\n\n然后就是写博客，并将.md博客文件放至_posts文件夹，然后添加修改到本地仓库\n\n``` shell\ngit add .\ngit commit -m \"写了一篇博客\"\ngit push origin hexo_source\n```\n\n至此，已经完成了博客的撰写并修改了远端仓库的博客源文件，然后使用`hexo g`和`hexo d`更新博客就OK啦！\n\n## 新机器安装npm失败解决方案\n\n由于众所周知的原因，好多东西无法安装，可以添加第三方源来解决\n\n``` shell\n# 添加淘宝源\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n# nrm类似包管理器\ncnpm install nrm -g\nnrm ls\n# 使用淘宝\nnrm use taobao\nnpm install -g hexo-cli\n```\n\n\n## 参考\n\n- [关于博客同步的解决办法](http://devtian.me/2015/03/17/blog-sync-solution/)\n- [使用Git Submodule管理子模块](https://segmentfault.com/a/1190000003076028)\n","slug":"±∏∑›Hexo‘¥Œƒº˛÷¡GitHub","published":1,"updated":"2017-06-05T07:03:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3p20044zd688h6im852","content":"<p>本文转自：<a href=\"http://www.leyar.me/backup-your-blog-to-github/\" target=\"_blank\" rel=\"noopener\">http://www.leyar.me/backup-your-blog-to-github/</a></p>\n<p>Hexo是一款基于Node.js的静态博客框架，前一阵俺的笔记本泡水直接退役，但是博客的原文件还在那台死去的机器上，所以备份啊。。。<br>本质上，Hexo是将本地的md文件编译成静态文件上传到github上（或者其他），所以建议是将本地的整个Hexo项目（blog）原件同步提交到github或者其他代码托管的站点。</p>\n<p>下面记录一下备份、以及在另外的电脑上恢复博客的过程，为了以后备查。</p>\n<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><p>已创建有 GitHub 仓库，并且已使用 <code>hexo-deployer-git</code> 部署到 <code>master</code> 分支。（发布博文并托管到Github上）<br>如果不满足请自行 google hexo 部署到 GitHub 的操作方法。</p>\n<h2 id=\"备份过程\"><a href=\"#备份过程\" class=\"headerlink\" title=\"备份过程\"></a>备份过程</h2><p>在Github网站创建一个新仓库(或者使用Github托管博客的仓库，在该仓库下创建一个新的分支)，比如我新建的仓库名为 <code>HEXOSource</code></p>\n<p>在本地hexo根目录中， 初始化git仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n<p>创建并切换到名为 <code>hexo_source</code> 的分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b hexo_source</span><br></pre></td></tr></table></figure>\n<p>创建忽略规则文件 <code>.gitignore</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi .gitignore</span><br></pre></td></tr></table></figure>\n<p>按需添加如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.DS_Store</span><br><span class=\"line\">Thumbs.db</span><br><span class=\"line\">db.json  </span><br><span class=\"line\">*.log</span><br><span class=\"line\">.deploy*/</span><br><span class=\"line\">node_modules/</span><br><span class=\"line\">.npmignore</span><br><span class=\"line\">public/</span><br></pre></td></tr></table></figure>\n<p>上面最后一行 public 目录，因其已被 hexo 插件同步到 master 分支里，因此不需要再同步，deploy 是 hexo 的 git 配置存放目录，也不需要同步。其他内容可选择忽略也可以选择同步。</p>\n<p>添加内容到仓库并提交到远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m \"first commit\"</span><br><span class=\"line\">git remote add origin git@github.com:lvraikkonen/HEXOSource.git\t\t# 后面仓库目录改成自己新建的。</span><br><span class=\"line\">git push -u origin hexo_source</span><br></pre></td></tr></table></figure>\n<p>按照以上的步骤就进行了 hexo 源文件的初次备份。<br>以后每次修改了内容之后，都可通过以下几条命令实现同步。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m \"...\"\t # 双引号内填写更新内容</span><br><span class=\"line\">git push origin hexo_source\t# 或者 git push</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过-git-submodule-来同步第三方主题\"><a href=\"#通过-git-submodule-来同步第三方主题\" class=\"headerlink\" title=\"通过 git submodule 来同步第三方主题\"></a>通过 git submodule 来同步第三方主题</h2><p>我们一般会选择第三方主题的仓库直接git clone下来。这是一个非常不好的习惯，正确做法是：Fork该第三方主题仓库，这样就会在自己账号下生成一个同名的仓库，并对应一个url，我们应该git clone自己账号下的url。</p>\n<p>这样做的原因是：我们很有可能在原来主题基础上做一些自定义的小改动，为了保持多终端的同步，我们需要将这些改动提交到远程仓库。而第三方仓库我们是无法直接push的。</p>\n<p>这样就会出现git仓库的嵌套问题，我们通过git submodule来解决这个问题。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule add git@github.com:lvraikkonen/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>\n<p>我们修改主题后:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -am \"refine themes\"</span><br><span class=\"line\">git push origin hexo_source</span><br></pre></td></tr></table></figure>\n<p>然后就完成了第三方主题的备份</p>\n<p>在其他电脑同步源文件时，需要执行如下命令来同步主题</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule init // 这句很重要</span><br><span class=\"line\">git submodule update</span><br></pre></td></tr></table></figure>\n<h2 id=\"新机器同步\"><a href=\"#新机器同步\" class=\"headerlink\" title=\"新机器同步\"></a>新机器同步</h2><p>在一个新机器上写博客，用以下步骤同步至最新状态</p>\n<p>新建博客文件夹 <code>hexo_blog</code></p>\n<p>在该文件夹下初始化git仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n<p>为本地仓库添加远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:lvraikkonen/HEXOSource.git</span><br></pre></td></tr></table></figure>\n<p>切换至hexo_source分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b hexo_source</span><br></pre></td></tr></table></figure>\n<p>获取<code>hexo_source</code>分支源文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin hexo_source</span><br></pre></td></tr></table></figure>\n<p>然后就是写博客，并将.md博客文件放至_posts文件夹，然后添加修改到本地仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m \"写了一篇博客\"</span><br><span class=\"line\">git push origin hexo_source</span><br></pre></td></tr></table></figure>\n<p>至此，已经完成了博客的撰写并修改了远端仓库的博客源文件，然后使用<code>hexo g</code>和<code>hexo d</code>更新博客就OK啦！</p>\n<h2 id=\"新机器安装npm失败解决方案\"><a href=\"#新机器安装npm失败解决方案\" class=\"headerlink\" title=\"新机器安装npm失败解决方案\"></a>新机器安装npm失败解决方案</h2><p>由于众所周知的原因，好多东西无法安装，可以添加第三方源来解决</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 添加淘宝源</span></span><br><span class=\"line\">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> nrm类似包管理器</span></span><br><span class=\"line\">cnpm install nrm -g</span><br><span class=\"line\">nrm ls</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用淘宝</span></span><br><span class=\"line\">nrm use taobao</span><br><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://devtian.me/2015/03/17/blog-sync-solution/\" target=\"_blank\" rel=\"noopener\">关于博客同步的解决办法</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000003076028\" target=\"_blank\" rel=\"noopener\">使用Git Submodule管理子模块</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>本文转自：<a href=\"http://www.leyar.me/backup-your-blog-to-github/\" target=\"_blank\" rel=\"noopener\">http://www.leyar.me/backup-your-blog-to-github/</a></p>\n<p>Hexo是一款基于Node.js的静态博客框架，前一阵俺的笔记本泡水直接退役，但是博客的原文件还在那台死去的机器上，所以备份啊。。。<br>本质上，Hexo是将本地的md文件编译成静态文件上传到github上（或者其他），所以建议是将本地的整个Hexo项目（blog）原件同步提交到github或者其他代码托管的站点。</p>\n<p>下面记录一下备份、以及在另外的电脑上恢复博客的过程，为了以后备查。</p>\n<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><p>已创建有 GitHub 仓库，并且已使用 <code>hexo-deployer-git</code> 部署到 <code>master</code> 分支。（发布博文并托管到Github上）<br>如果不满足请自行 google hexo 部署到 GitHub 的操作方法。</p>\n<h2 id=\"备份过程\"><a href=\"#备份过程\" class=\"headerlink\" title=\"备份过程\"></a>备份过程</h2><p>在Github网站创建一个新仓库(或者使用Github托管博客的仓库，在该仓库下创建一个新的分支)，比如我新建的仓库名为 <code>HEXOSource</code></p>\n<p>在本地hexo根目录中， 初始化git仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n<p>创建并切换到名为 <code>hexo_source</code> 的分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b hexo_source</span><br></pre></td></tr></table></figure>\n<p>创建忽略规则文件 <code>.gitignore</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi .gitignore</span><br></pre></td></tr></table></figure>\n<p>按需添加如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.DS_Store</span><br><span class=\"line\">Thumbs.db</span><br><span class=\"line\">db.json  </span><br><span class=\"line\">*.log</span><br><span class=\"line\">.deploy*/</span><br><span class=\"line\">node_modules/</span><br><span class=\"line\">.npmignore</span><br><span class=\"line\">public/</span><br></pre></td></tr></table></figure>\n<p>上面最后一行 public 目录，因其已被 hexo 插件同步到 master 分支里，因此不需要再同步，deploy 是 hexo 的 git 配置存放目录，也不需要同步。其他内容可选择忽略也可以选择同步。</p>\n<p>添加内容到仓库并提交到远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m \"first commit\"</span><br><span class=\"line\">git remote add origin git@github.com:lvraikkonen/HEXOSource.git\t\t# 后面仓库目录改成自己新建的。</span><br><span class=\"line\">git push -u origin hexo_source</span><br></pre></td></tr></table></figure>\n<p>按照以上的步骤就进行了 hexo 源文件的初次备份。<br>以后每次修改了内容之后，都可通过以下几条命令实现同步。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m \"...\"\t # 双引号内填写更新内容</span><br><span class=\"line\">git push origin hexo_source\t# 或者 git push</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过-git-submodule-来同步第三方主题\"><a href=\"#通过-git-submodule-来同步第三方主题\" class=\"headerlink\" title=\"通过 git submodule 来同步第三方主题\"></a>通过 git submodule 来同步第三方主题</h2><p>我们一般会选择第三方主题的仓库直接git clone下来。这是一个非常不好的习惯，正确做法是：Fork该第三方主题仓库，这样就会在自己账号下生成一个同名的仓库，并对应一个url，我们应该git clone自己账号下的url。</p>\n<p>这样做的原因是：我们很有可能在原来主题基础上做一些自定义的小改动，为了保持多终端的同步，我们需要将这些改动提交到远程仓库。而第三方仓库我们是无法直接push的。</p>\n<p>这样就会出现git仓库的嵌套问题，我们通过git submodule来解决这个问题。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule add git@github.com:lvraikkonen/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>\n<p>我们修改主题后:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -am \"refine themes\"</span><br><span class=\"line\">git push origin hexo_source</span><br></pre></td></tr></table></figure>\n<p>然后就完成了第三方主题的备份</p>\n<p>在其他电脑同步源文件时，需要执行如下命令来同步主题</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule init // 这句很重要</span><br><span class=\"line\">git submodule update</span><br></pre></td></tr></table></figure>\n<h2 id=\"新机器同步\"><a href=\"#新机器同步\" class=\"headerlink\" title=\"新机器同步\"></a>新机器同步</h2><p>在一个新机器上写博客，用以下步骤同步至最新状态</p>\n<p>新建博客文件夹 <code>hexo_blog</code></p>\n<p>在该文件夹下初始化git仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n<p>为本地仓库添加远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:lvraikkonen/HEXOSource.git</span><br></pre></td></tr></table></figure>\n<p>切换至hexo_source分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b hexo_source</span><br></pre></td></tr></table></figure>\n<p>获取<code>hexo_source</code>分支源文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin hexo_source</span><br></pre></td></tr></table></figure>\n<p>然后就是写博客，并将.md博客文件放至_posts文件夹，然后添加修改到本地仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m \"写了一篇博客\"</span><br><span class=\"line\">git push origin hexo_source</span><br></pre></td></tr></table></figure>\n<p>至此，已经完成了博客的撰写并修改了远端仓库的博客源文件，然后使用<code>hexo g</code>和<code>hexo d</code>更新博客就OK啦！</p>\n<h2 id=\"新机器安装npm失败解决方案\"><a href=\"#新机器安装npm失败解决方案\" class=\"headerlink\" title=\"新机器安装npm失败解决方案\"></a>新机器安装npm失败解决方案</h2><p>由于众所周知的原因，好多东西无法安装，可以添加第三方源来解决</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 添加淘宝源</span></span><br><span class=\"line\">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> nrm类似包管理器</span></span><br><span class=\"line\">cnpm install nrm -g</span><br><span class=\"line\">nrm ls</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用淘宝</span></span><br><span class=\"line\">nrm use taobao</span><br><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://devtian.me/2015/03/17/blog-sync-solution/\" target=\"_blank\" rel=\"noopener\">关于博客同步的解决办法</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000003076028\" target=\"_blank\" rel=\"noopener\">使用Git Submodule管理子模块</a></li>\n</ul>\n"},{"title":"如何拍摄星空","date":"2016-09-07T13:09:03.000Z","_content":"\n好久没写博客了，重新拾起来吧。今天说点技术无关的话题——摄影\n\n我是一个纯业余的风光狗，向往美丽的大自然，喜欢仰望天空，把深邃的星空拍摄下来，以免子孙后代在严重的光污染中忘记了这篇美丽星空的存在。下面简单介绍一下如何拍星空：\n\n[来自知乎我的回答](https://www.zhihu.com/question/27296697/answer/43051123)\n我曾经在西藏拍摄过星空，对于拍摄有一定的体会和经验，我说说拍摄方法吧：\n\n1. 首先，光污染问题。国内很多的地方，尤其是大城市，肉眼几乎看不到几颗星星，更不用说银河了。所以要拍银河星空的话，必须要到完全没有光污染的旷野，当然半夜在荒郊野岭拍照对于心理是个很大的挑战。\n2. 关于拍摄器材。要有个大光圈的广角镜头，最好用单反或者SONY的高级微单来拍，要的是机身的优秀高感也就是ISO能力；光圈的话，当然越大越好，因为外界环境很黑暗，所以需要长时间曝光，进光量一定要够；角度越广角越好，广角更能拍出宽阔感。推荐佳能的14L镜头，这个绝对是星空专用镜头。（一定要用三脚架，越稳定越好）\n3. 关于拍摄参数。M档，我的常用参数是，光圈f2.8，快门15-20秒，感光度ISO1600-6400\n关于对焦。我来纠正一下很多人误传的一条知识：手动对焦值无穷远再往回拧一点点。这是绝对的错误，这个一点点到底是多少？没人能说清。所以正确的对焦方法是：打开相机的实时取景功能LV，放大到10倍，然后看星点是否对上焦（也就是实心点不发虚），然后调整曝光参数，试拍两张，再调整感光度，达到满意为止。\n掌握这几点之后，你肯定能拍出肯漂亮的星空银河了，不过没有前景的话，照片就会很枯燥。所以找个漂亮的前景也很重要，因为使用大光圈，所以前景在构图时候不要离得太近，否则会虚掉。至于补光，我只能说多试几次。关于补光的话，不要一直开着手电筒对着前景照射，否则会强烈过曝，正确的方式是：在按下快门到曝光结束这段时间段的最后一秒，打开手电筒对着前景闪一下，这就足够了。\n\n祝大家都能拍出漂亮的星空照\n附上在西藏拍的银河和泸沽湖拍的星空\n\n1. 西藏定日县城外小河沟拍的银河\n![Tibet Milkyway](http://7xkfga.com1.z0.glb.clouddn.com/tibetStar.jpg)\n\n2. 云南泸沽湖边的星空\n![LuguLakeStar](http://7xkfga.com1.z0.glb.clouddn.com/luguStar.jpeg)\n\n\n版权声明：<br>\n<hr>\n除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br>\n","source":"_posts/»Á∫Œ≈ƒ…„–«ø’.md","raw":"---\ntitle: 如何拍摄星空\ndate: 2016-09-07 21:09:03\ntags: \n- 摄影\n---\n\n好久没写博客了，重新拾起来吧。今天说点技术无关的话题——摄影\n\n我是一个纯业余的风光狗，向往美丽的大自然，喜欢仰望天空，把深邃的星空拍摄下来，以免子孙后代在严重的光污染中忘记了这篇美丽星空的存在。下面简单介绍一下如何拍星空：\n\n[来自知乎我的回答](https://www.zhihu.com/question/27296697/answer/43051123)\n我曾经在西藏拍摄过星空，对于拍摄有一定的体会和经验，我说说拍摄方法吧：\n\n1. 首先，光污染问题。国内很多的地方，尤其是大城市，肉眼几乎看不到几颗星星，更不用说银河了。所以要拍银河星空的话，必须要到完全没有光污染的旷野，当然半夜在荒郊野岭拍照对于心理是个很大的挑战。\n2. 关于拍摄器材。要有个大光圈的广角镜头，最好用单反或者SONY的高级微单来拍，要的是机身的优秀高感也就是ISO能力；光圈的话，当然越大越好，因为外界环境很黑暗，所以需要长时间曝光，进光量一定要够；角度越广角越好，广角更能拍出宽阔感。推荐佳能的14L镜头，这个绝对是星空专用镜头。（一定要用三脚架，越稳定越好）\n3. 关于拍摄参数。M档，我的常用参数是，光圈f2.8，快门15-20秒，感光度ISO1600-6400\n关于对焦。我来纠正一下很多人误传的一条知识：手动对焦值无穷远再往回拧一点点。这是绝对的错误，这个一点点到底是多少？没人能说清。所以正确的对焦方法是：打开相机的实时取景功能LV，放大到10倍，然后看星点是否对上焦（也就是实心点不发虚），然后调整曝光参数，试拍两张，再调整感光度，达到满意为止。\n掌握这几点之后，你肯定能拍出肯漂亮的星空银河了，不过没有前景的话，照片就会很枯燥。所以找个漂亮的前景也很重要，因为使用大光圈，所以前景在构图时候不要离得太近，否则会虚掉。至于补光，我只能说多试几次。关于补光的话，不要一直开着手电筒对着前景照射，否则会强烈过曝，正确的方式是：在按下快门到曝光结束这段时间段的最后一秒，打开手电筒对着前景闪一下，这就足够了。\n\n祝大家都能拍出漂亮的星空照\n附上在西藏拍的银河和泸沽湖拍的星空\n\n1. 西藏定日县城外小河沟拍的银河\n![Tibet Milkyway](http://7xkfga.com1.z0.glb.clouddn.com/tibetStar.jpg)\n\n2. 云南泸沽湖边的星空\n![LuguLakeStar](http://7xkfga.com1.z0.glb.clouddn.com/luguStar.jpeg)\n\n\n版权声明：<br>\n<hr>\n除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br>\n","slug":"»Á∫Œ≈ƒ…„–«ø’","published":1,"updated":"2017-05-27T11:08:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3p30047zd681idrgplw","content":"<p>好久没写博客了，重新拾起来吧。今天说点技术无关的话题——摄影</p>\n<p>我是一个纯业余的风光狗，向往美丽的大自然，喜欢仰望天空，把深邃的星空拍摄下来，以免子孙后代在严重的光污染中忘记了这篇美丽星空的存在。下面简单介绍一下如何拍星空：</p>\n<p><a href=\"https://www.zhihu.com/question/27296697/answer/43051123\" target=\"_blank\" rel=\"noopener\">来自知乎我的回答</a><br>我曾经在西藏拍摄过星空，对于拍摄有一定的体会和经验，我说说拍摄方法吧：</p>\n<ol>\n<li>首先，光污染问题。国内很多的地方，尤其是大城市，肉眼几乎看不到几颗星星，更不用说银河了。所以要拍银河星空的话，必须要到完全没有光污染的旷野，当然半夜在荒郊野岭拍照对于心理是个很大的挑战。</li>\n<li>关于拍摄器材。要有个大光圈的广角镜头，最好用单反或者SONY的高级微单来拍，要的是机身的优秀高感也就是ISO能力；光圈的话，当然越大越好，因为外界环境很黑暗，所以需要长时间曝光，进光量一定要够；角度越广角越好，广角更能拍出宽阔感。推荐佳能的14L镜头，这个绝对是星空专用镜头。（一定要用三脚架，越稳定越好）</li>\n<li>关于拍摄参数。M档，我的常用参数是，光圈f2.8，快门15-20秒，感光度ISO1600-6400<br>关于对焦。我来纠正一下很多人误传的一条知识：手动对焦值无穷远再往回拧一点点。这是绝对的错误，这个一点点到底是多少？没人能说清。所以正确的对焦方法是：打开相机的实时取景功能LV，放大到10倍，然后看星点是否对上焦（也就是实心点不发虚），然后调整曝光参数，试拍两张，再调整感光度，达到满意为止。<br>掌握这几点之后，你肯定能拍出肯漂亮的星空银河了，不过没有前景的话，照片就会很枯燥。所以找个漂亮的前景也很重要，因为使用大光圈，所以前景在构图时候不要离得太近，否则会虚掉。至于补光，我只能说多试几次。关于补光的话，不要一直开着手电筒对着前景照射，否则会强烈过曝，正确的方式是：在按下快门到曝光结束这段时间段的最后一秒，打开手电筒对着前景闪一下，这就足够了。</li>\n</ol>\n<p>祝大家都能拍出漂亮的星空照<br>附上在西藏拍的银河和泸沽湖拍的星空</p>\n<ol>\n<li><p>西藏定日县城外小河沟拍的银河<br><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/tibetStar.jpg\" alt=\"Tibet Milkyway\"></p>\n</li>\n<li><p>云南泸沽湖边的星空<br><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/luguStar.jpeg\" alt=\"LuguLakeStar\"></p>\n</li>\n</ol>\n<p>版权声明：<br></p>\n<p><hr><br>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>\n","site":{"data":{}},"excerpt":"","more":"<p>好久没写博客了，重新拾起来吧。今天说点技术无关的话题——摄影</p>\n<p>我是一个纯业余的风光狗，向往美丽的大自然，喜欢仰望天空，把深邃的星空拍摄下来，以免子孙后代在严重的光污染中忘记了这篇美丽星空的存在。下面简单介绍一下如何拍星空：</p>\n<p><a href=\"https://www.zhihu.com/question/27296697/answer/43051123\" target=\"_blank\" rel=\"noopener\">来自知乎我的回答</a><br>我曾经在西藏拍摄过星空，对于拍摄有一定的体会和经验，我说说拍摄方法吧：</p>\n<ol>\n<li>首先，光污染问题。国内很多的地方，尤其是大城市，肉眼几乎看不到几颗星星，更不用说银河了。所以要拍银河星空的话，必须要到完全没有光污染的旷野，当然半夜在荒郊野岭拍照对于心理是个很大的挑战。</li>\n<li>关于拍摄器材。要有个大光圈的广角镜头，最好用单反或者SONY的高级微单来拍，要的是机身的优秀高感也就是ISO能力；光圈的话，当然越大越好，因为外界环境很黑暗，所以需要长时间曝光，进光量一定要够；角度越广角越好，广角更能拍出宽阔感。推荐佳能的14L镜头，这个绝对是星空专用镜头。（一定要用三脚架，越稳定越好）</li>\n<li>关于拍摄参数。M档，我的常用参数是，光圈f2.8，快门15-20秒，感光度ISO1600-6400<br>关于对焦。我来纠正一下很多人误传的一条知识：手动对焦值无穷远再往回拧一点点。这是绝对的错误，这个一点点到底是多少？没人能说清。所以正确的对焦方法是：打开相机的实时取景功能LV，放大到10倍，然后看星点是否对上焦（也就是实心点不发虚），然后调整曝光参数，试拍两张，再调整感光度，达到满意为止。<br>掌握这几点之后，你肯定能拍出肯漂亮的星空银河了，不过没有前景的话，照片就会很枯燥。所以找个漂亮的前景也很重要，因为使用大光圈，所以前景在构图时候不要离得太近，否则会虚掉。至于补光，我只能说多试几次。关于补光的话，不要一直开着手电筒对着前景照射，否则会强烈过曝，正确的方式是：在按下快门到曝光结束这段时间段的最后一秒，打开手电筒对着前景闪一下，这就足够了。</li>\n</ol>\n<p>祝大家都能拍出漂亮的星空照<br>附上在西藏拍的银河和泸沽湖拍的星空</p>\n<ol>\n<li><p>西藏定日县城外小河沟拍的银河<br><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/tibetStar.jpg\" alt=\"Tibet Milkyway\"></p>\n</li>\n<li><p>云南泸沽湖边的星空<br><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/luguStar.jpeg\" alt=\"LuguLakeStar\"></p>\n</li>\n</ol>\n<p>版权声明：<br></p>\n<p><hr><br>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>\n"},{"title":"搜索和排序之搜索","date":"2017-06-12T09:31:57.000Z","_content":"\n未完成\n\n## 基本概念\n\n查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。\n\n查找表按照操作方式可分为：\n\n1. 静态查找表（Static Search Table）：只做查找操作的查找表。它的主要操作是：\n    - 查询某个“特定的”数据元素是否在表中\n    - 检索某个“特定的”数据元素和各种属性\n\n2. 动态查找表（Dynamic Search Table）：在查找中同时进行插入或删除等操作：\n    - 查找时插入数据\n    - 查找时删除数据\n\n<!-- more -->\n\n## 无序表查找\n\n在数据不排序的线性查找，遍历数据元素。\n\n算法分析：最好情况是第一个位置就找到了，为O(1)；最坏情况在最后一个位置找到，为O(n)， 平均查找次数为 (n+1)/2, **时间复杂度为O(n)**\n\n```python\ndef sequential_search(lst, key):\n    length = len(lst)\n    for i in range(length):\n        if lst[i] == key:\n            return i\n        else:\n            return False\n\nif __name__ == '__main__':\n    l = [1,5,8,124,22,54,7,99,300,222]\n    result = sequential_search(l, 123)\n    print result\n```\n\n### 快速选择算法 (quick selection algorithm)\n\n快速选择算法能够在平均O(n)时间内从一个无序数组中返回第k大的元素。算法实际上利用了快速排序的思想，将数组依照一个轴值分割成两个部分，左边元素都比轴值小，右边元素都比轴值大。由于轴值下标已知，则可以判断所求元素落在数组的哪一部分，并在那一部分继续进行上述操作，直至找到该元素。与快排不同，由于快速选择算法只在乎所求元素所在的那一部分，所以时间复杂度是O(n)。\n\n``` python\n\n```\n\n## 有序表查找\n\n数据按某种方式进行过排序\n\n### 二分查找 Binary Search\n\n算法内容：在查找表中不断取中间元素与查找值进行比较，以二分之一的倍率进行表范围的缩小。时间复杂度：O(logn)\n\n``` python\ndef binary_search(lst, key):\n    low, high = 0, len(lst)-1\n    while low < high:\n        mid = (low + high) / 2\n        if key < lst[mid]:\n            high = mid - 1\n        elif key > lst[mid]:\n            low = mid + 1\n        else:\n            return mid\n    return False\n\nif __name__ == '__main__':\n    l = [1, 5, 7, 8, 22, 54, 99, 123, 200, 222, 444]\n    result = binary_search(l, 123)\n    print result\n```\n\n### 插值查找\n\n插值查找是二分查找演化而来，相比于二分查找(折半),该算法考虑的是每次折的时候折多少，即不一定是1/2。在二分查找中mid=(low+high)/2=low+1/2*(high-low)，插值查找就是对1/2(系数,或者说比例)进行改变，它将1/2变成 (key - array[low])/(array[high] - array[low]),其实就是计算线性比例。\n\n时间复杂度：O(logn)\n\n_ note: 因为插值查找是依赖线性比例的，如果当前数组分布不是均匀的，那么该算法就不合适。_\n\n``` python\ndef interpolate_search(lst, key):\n    low, high = 0, len(lst)-1\n    while low < high:\n        mid = low + (high - low) * (key - lst[low])/(lst[high] - lst[low])\n        if key < lst[mid]:\n            high = mid - 1\n        elif key > lst[mid]:\n            low = mid + 1\n        else:\n            return mid\n    return False\n\nif __name__ == '__main__':\n    l = [1, 5, 7, 8, 22, 54, 99, 123, 200, 222, 444]\n    result = binary_search(l, 123)\n    print result\n```\n\n### 斐波那契查找\n\n查找算法：在斐波那契数列找一个等于略大于查找表中元素个数的数F(n)，将原查找表扩展为长度为F(n)(如果要补充元素，则补充重复最后一个元素，直到满足数组元素个数为F(n)个元素)，完成后进行斐波那契分割，即F(n)个元素分割为前半部分F(n-1)个元素，后半部分F(n-2)个元素，找出要查找的元素在那一部分并递归，直到找到。\n时间复杂度：O(logn)，平均性能优于二分查找。\n\n**利用斐波那契数列的性质，黄金分割的原理来确定mid的位置**\n\n``` python\n```\n\n## 线性索引查找\n\n对于海量的无序数据，为了提高查找速度，一般会为其构造索引表。\n索引就是把一个关键字与它相对应的记录进行关联的过程。\n一个索引由若干个索引项构成，每个索引项至少包含关键字和其对应的记录在存储器中的位置等信息。\n\n索引按照结构可以分为：线性索引、树形索引和多级索引。\n线性索引：将索引项的集合通过线性结构来组织，也叫索引表。\n\n线性索引可分为：稠密索引、分块索引和倒排索引\n\n### 稠密索引\n\n### 分块索引\n\n### 倒排索引\n\n## 二叉排序树\n\n二叉排序树又称为二叉查找树。它或者是一颗空树，或者是具有下列性质的二叉树：\n\n- 若它的左子树不为空，则左子树上所有节点的值均小于它的根结构的值；\n- 若它的右子树不为空，则右子树上所有节点的值均大于它的根结构的值；\n- 它的左、右子树也分别为二叉排序树。\n\n![BSTPic](assets/DataStructure_Searching-ca306.png)\n\n二叉排序树的操作：\n\n- 查找：对比节点的值和关键字，相等则表明找到了；小了则往节点的左子树去找，大了则往右子树去找，这么递归下去，最后返回布尔值或找到的节点。\n- 插入：从根节点开始逐个与关键字进行对比，小了去左边，大了去右边，碰到子树为空的情况就将新的节点链接。\n- 删除：如果要删除的节点是叶子，直接删；如果只有左子树或只有右子树，则删除节点后，将子树链接到父节点即可；如果同时有左右子树，则可以将二叉排序树进行中序遍历，取将要被删除的节点的前驱或者后继节点替代这个被删除的节点的位置。\n\n二叉排序树总结：\n\n二叉排序树以链式进行存储，保持了链接结构在插入和删除操作上的优点。\n\n在极端情况下，查询次数为1，但最大操作次数不会超过树的深度。也就是说，二叉排序树的查找性能取决于二叉排序树的形状，也就引申出了后面的平衡二叉树。\n\n给定一个元素集合，可以构造不同的二叉排序树，当它同时是一个完全二叉树的时候，查找的时间复杂度为O(log(n))，近似于二分查找。\n\n当出现最极端的斜树时，其时间复杂度为O(n)，等同于顺序查找，效果最差。\n\n## 平衡二叉树\n\n## 多路查找树 B树\n\n### 2-3树\n\n### 3-4树\n\n### B树\n\n### B+树\n\n## 散列表\n\n散列表：所有的元素之间没有任何关系。元素的存储位置，是利用元素的关键字通过某个函数直接计算出来的。这个一一对应的关系函数称为散列函数或Hash函数。\n\n采用散列技术将记录存储在一块连续的存储空间中，称为散列表或哈希表（Hash Table）。关键字对应的存储位置，称为散列地址。\n\n散列表是一种面向查找的存储结构。它最适合求解的问题是查找与给定值相等的记录。但是对于某个关键字能对应很多记录的情况就不适用，比如查找所有的“男”性。也不适合范围查找，比如查找年龄20~30之间的人。排序、最大、最小等也不合适。\n\n因此，**散列表通常用于关键字不重复的数据结构**。比如python的字典数据类型。\n\n设计出一个简单、均匀、存储利用率高的散列函数是散列技术中最关键的问题。\n但是，一般散列函数都面临着冲突的问题。\n冲突：两个不同的关键字，通过散列函数计算后结果却相同的现象。collision\n\n### 散列函数构造\n\n好的散列函数：计算简单、散列地址分布均匀\n\n1. 直接定址法\n\n  例如取关键字的某个线性函数为散列函数：\n  f(key) = a*key + b (a,b为常数）\n\n2. 数字分析法\n\n  抽取关键字里的数字，根据数字的特点进行地址分配\n\n3. 平方取中法\n\n  将关键字的数字求平方，再截取部分\n\n4. 折叠法\n\n  将关键字的数字分割后分别计算，再合并计算，一种玩弄数字的手段。\n\n5. 除留余数法\n\n  最为常见的方法之一。\n  对于表长为m的数据集合，散列公式为：\n  f(key) = key mod p (p<=m)\n  mod：取模（求余数）\n  该方法最关键的是p的选择，而且数据量较大的时候，冲突是必然的。一般会选择接近m的质数。\n  随机数法\n  选择一个随机数，取关键字的随机函数值为它的散列地址。\n  f(key) = random(key)\n\n总结，实际情况下根据不同的数据特性采用不同的散列方法，考虑下面一些主要问题：\n\n- 计算散列地址所需的时间\n- 关键字的长度\n- 散列表的大小\n- 关键字的分布情况\n- 记录查找的频率\n\n### 处理散列冲突\n\n### 散列表查找实现\n\n### 散列表查找性能分析\n","source":"_posts/À—À˜∫Õ≈≈–Ú÷ÆÀ—À˜.md","raw":"---\ntitle: 搜索和排序之搜索\ntags:\n  - Algorithm\n  - Data Structure\n  - 面试\ndate: 2017-06-12 17:31:57\n---\n\n未完成\n\n## 基本概念\n\n查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。\n\n查找表按照操作方式可分为：\n\n1. 静态查找表（Static Search Table）：只做查找操作的查找表。它的主要操作是：\n    - 查询某个“特定的”数据元素是否在表中\n    - 检索某个“特定的”数据元素和各种属性\n\n2. 动态查找表（Dynamic Search Table）：在查找中同时进行插入或删除等操作：\n    - 查找时插入数据\n    - 查找时删除数据\n\n<!-- more -->\n\n## 无序表查找\n\n在数据不排序的线性查找，遍历数据元素。\n\n算法分析：最好情况是第一个位置就找到了，为O(1)；最坏情况在最后一个位置找到，为O(n)， 平均查找次数为 (n+1)/2, **时间复杂度为O(n)**\n\n```python\ndef sequential_search(lst, key):\n    length = len(lst)\n    for i in range(length):\n        if lst[i] == key:\n            return i\n        else:\n            return False\n\nif __name__ == '__main__':\n    l = [1,5,8,124,22,54,7,99,300,222]\n    result = sequential_search(l, 123)\n    print result\n```\n\n### 快速选择算法 (quick selection algorithm)\n\n快速选择算法能够在平均O(n)时间内从一个无序数组中返回第k大的元素。算法实际上利用了快速排序的思想，将数组依照一个轴值分割成两个部分，左边元素都比轴值小，右边元素都比轴值大。由于轴值下标已知，则可以判断所求元素落在数组的哪一部分，并在那一部分继续进行上述操作，直至找到该元素。与快排不同，由于快速选择算法只在乎所求元素所在的那一部分，所以时间复杂度是O(n)。\n\n``` python\n\n```\n\n## 有序表查找\n\n数据按某种方式进行过排序\n\n### 二分查找 Binary Search\n\n算法内容：在查找表中不断取中间元素与查找值进行比较，以二分之一的倍率进行表范围的缩小。时间复杂度：O(logn)\n\n``` python\ndef binary_search(lst, key):\n    low, high = 0, len(lst)-1\n    while low < high:\n        mid = (low + high) / 2\n        if key < lst[mid]:\n            high = mid - 1\n        elif key > lst[mid]:\n            low = mid + 1\n        else:\n            return mid\n    return False\n\nif __name__ == '__main__':\n    l = [1, 5, 7, 8, 22, 54, 99, 123, 200, 222, 444]\n    result = binary_search(l, 123)\n    print result\n```\n\n### 插值查找\n\n插值查找是二分查找演化而来，相比于二分查找(折半),该算法考虑的是每次折的时候折多少，即不一定是1/2。在二分查找中mid=(low+high)/2=low+1/2*(high-low)，插值查找就是对1/2(系数,或者说比例)进行改变，它将1/2变成 (key - array[low])/(array[high] - array[low]),其实就是计算线性比例。\n\n时间复杂度：O(logn)\n\n_ note: 因为插值查找是依赖线性比例的，如果当前数组分布不是均匀的，那么该算法就不合适。_\n\n``` python\ndef interpolate_search(lst, key):\n    low, high = 0, len(lst)-1\n    while low < high:\n        mid = low + (high - low) * (key - lst[low])/(lst[high] - lst[low])\n        if key < lst[mid]:\n            high = mid - 1\n        elif key > lst[mid]:\n            low = mid + 1\n        else:\n            return mid\n    return False\n\nif __name__ == '__main__':\n    l = [1, 5, 7, 8, 22, 54, 99, 123, 200, 222, 444]\n    result = binary_search(l, 123)\n    print result\n```\n\n### 斐波那契查找\n\n查找算法：在斐波那契数列找一个等于略大于查找表中元素个数的数F(n)，将原查找表扩展为长度为F(n)(如果要补充元素，则补充重复最后一个元素，直到满足数组元素个数为F(n)个元素)，完成后进行斐波那契分割，即F(n)个元素分割为前半部分F(n-1)个元素，后半部分F(n-2)个元素，找出要查找的元素在那一部分并递归，直到找到。\n时间复杂度：O(logn)，平均性能优于二分查找。\n\n**利用斐波那契数列的性质，黄金分割的原理来确定mid的位置**\n\n``` python\n```\n\n## 线性索引查找\n\n对于海量的无序数据，为了提高查找速度，一般会为其构造索引表。\n索引就是把一个关键字与它相对应的记录进行关联的过程。\n一个索引由若干个索引项构成，每个索引项至少包含关键字和其对应的记录在存储器中的位置等信息。\n\n索引按照结构可以分为：线性索引、树形索引和多级索引。\n线性索引：将索引项的集合通过线性结构来组织，也叫索引表。\n\n线性索引可分为：稠密索引、分块索引和倒排索引\n\n### 稠密索引\n\n### 分块索引\n\n### 倒排索引\n\n## 二叉排序树\n\n二叉排序树又称为二叉查找树。它或者是一颗空树，或者是具有下列性质的二叉树：\n\n- 若它的左子树不为空，则左子树上所有节点的值均小于它的根结构的值；\n- 若它的右子树不为空，则右子树上所有节点的值均大于它的根结构的值；\n- 它的左、右子树也分别为二叉排序树。\n\n![BSTPic](assets/DataStructure_Searching-ca306.png)\n\n二叉排序树的操作：\n\n- 查找：对比节点的值和关键字，相等则表明找到了；小了则往节点的左子树去找，大了则往右子树去找，这么递归下去，最后返回布尔值或找到的节点。\n- 插入：从根节点开始逐个与关键字进行对比，小了去左边，大了去右边，碰到子树为空的情况就将新的节点链接。\n- 删除：如果要删除的节点是叶子，直接删；如果只有左子树或只有右子树，则删除节点后，将子树链接到父节点即可；如果同时有左右子树，则可以将二叉排序树进行中序遍历，取将要被删除的节点的前驱或者后继节点替代这个被删除的节点的位置。\n\n二叉排序树总结：\n\n二叉排序树以链式进行存储，保持了链接结构在插入和删除操作上的优点。\n\n在极端情况下，查询次数为1，但最大操作次数不会超过树的深度。也就是说，二叉排序树的查找性能取决于二叉排序树的形状，也就引申出了后面的平衡二叉树。\n\n给定一个元素集合，可以构造不同的二叉排序树，当它同时是一个完全二叉树的时候，查找的时间复杂度为O(log(n))，近似于二分查找。\n\n当出现最极端的斜树时，其时间复杂度为O(n)，等同于顺序查找，效果最差。\n\n## 平衡二叉树\n\n## 多路查找树 B树\n\n### 2-3树\n\n### 3-4树\n\n### B树\n\n### B+树\n\n## 散列表\n\n散列表：所有的元素之间没有任何关系。元素的存储位置，是利用元素的关键字通过某个函数直接计算出来的。这个一一对应的关系函数称为散列函数或Hash函数。\n\n采用散列技术将记录存储在一块连续的存储空间中，称为散列表或哈希表（Hash Table）。关键字对应的存储位置，称为散列地址。\n\n散列表是一种面向查找的存储结构。它最适合求解的问题是查找与给定值相等的记录。但是对于某个关键字能对应很多记录的情况就不适用，比如查找所有的“男”性。也不适合范围查找，比如查找年龄20~30之间的人。排序、最大、最小等也不合适。\n\n因此，**散列表通常用于关键字不重复的数据结构**。比如python的字典数据类型。\n\n设计出一个简单、均匀、存储利用率高的散列函数是散列技术中最关键的问题。\n但是，一般散列函数都面临着冲突的问题。\n冲突：两个不同的关键字，通过散列函数计算后结果却相同的现象。collision\n\n### 散列函数构造\n\n好的散列函数：计算简单、散列地址分布均匀\n\n1. 直接定址法\n\n  例如取关键字的某个线性函数为散列函数：\n  f(key) = a*key + b (a,b为常数）\n\n2. 数字分析法\n\n  抽取关键字里的数字，根据数字的特点进行地址分配\n\n3. 平方取中法\n\n  将关键字的数字求平方，再截取部分\n\n4. 折叠法\n\n  将关键字的数字分割后分别计算，再合并计算，一种玩弄数字的手段。\n\n5. 除留余数法\n\n  最为常见的方法之一。\n  对于表长为m的数据集合，散列公式为：\n  f(key) = key mod p (p<=m)\n  mod：取模（求余数）\n  该方法最关键的是p的选择，而且数据量较大的时候，冲突是必然的。一般会选择接近m的质数。\n  随机数法\n  选择一个随机数，取关键字的随机函数值为它的散列地址。\n  f(key) = random(key)\n\n总结，实际情况下根据不同的数据特性采用不同的散列方法，考虑下面一些主要问题：\n\n- 计算散列地址所需的时间\n- 关键字的长度\n- 散列表的大小\n- 关键字的分布情况\n- 记录查找的频率\n\n### 处理散列冲突\n\n### 散列表查找实现\n\n### 散列表查找性能分析\n","slug":"À—À˜∫Õ≈≈–Ú÷ÆÀ—À˜","published":1,"updated":"2017-06-12T09:33:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3p5004czd68r2ex5q80","content":"<p>未完成</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p>\n<p>查找表按照操作方式可分为：</p>\n<ol>\n<li><p>静态查找表（Static Search Table）：只做查找操作的查找表。它的主要操作是：</p>\n<ul>\n<li>查询某个“特定的”数据元素是否在表中</li>\n<li>检索某个“特定的”数据元素和各种属性</li>\n</ul>\n</li>\n<li><p>动态查找表（Dynamic Search Table）：在查找中同时进行插入或删除等操作：</p>\n<ul>\n<li>查找时插入数据</li>\n<li>查找时删除数据</li>\n</ul>\n</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"无序表查找\"><a href=\"#无序表查找\" class=\"headerlink\" title=\"无序表查找\"></a>无序表查找</h2><p>在数据不排序的线性查找，遍历数据元素。</p>\n<p>算法分析：最好情况是第一个位置就找到了，为O(1)；最坏情况在最后一个位置找到，为O(n)， 平均查找次数为 (n+1)/2, <strong>时间复杂度为O(n)</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sequential_search</span><span class=\"params\">(lst, key)</span>:</span></span><br><span class=\"line\">    length = len(lst)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(length):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lst[i] == key:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    l = [<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">124</span>,<span class=\"number\">22</span>,<span class=\"number\">54</span>,<span class=\"number\">7</span>,<span class=\"number\">99</span>,<span class=\"number\">300</span>,<span class=\"number\">222</span>]</span><br><span class=\"line\">    result = sequential_search(l, <span class=\"number\">123</span>)</span><br><span class=\"line\">    <span class=\"keyword\">print</span> result</span><br></pre></td></tr></table></figure>\n<h3 id=\"快速选择算法-quick-selection-algorithm\"><a href=\"#快速选择算法-quick-selection-algorithm\" class=\"headerlink\" title=\"快速选择算法 (quick selection algorithm)\"></a>快速选择算法 (quick selection algorithm)</h3><p>快速选择算法能够在平均O(n)时间内从一个无序数组中返回第k大的元素。算法实际上利用了快速排序的思想，将数组依照一个轴值分割成两个部分，左边元素都比轴值小，右边元素都比轴值大。由于轴值下标已知，则可以判断所求元素落在数组的哪一部分，并在那一部分继续进行上述操作，直至找到该元素。与快排不同，由于快速选择算法只在乎所求元素所在的那一部分，所以时间复杂度是O(n)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"有序表查找\"><a href=\"#有序表查找\" class=\"headerlink\" title=\"有序表查找\"></a>有序表查找</h2><p>数据按某种方式进行过排序</p>\n<h3 id=\"二分查找-Binary-Search\"><a href=\"#二分查找-Binary-Search\" class=\"headerlink\" title=\"二分查找 Binary Search\"></a>二分查找 Binary Search</h3><p>算法内容：在查找表中不断取中间元素与查找值进行比较，以二分之一的倍率进行表范围的缩小。时间复杂度：O(logn)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binary_search</span><span class=\"params\">(lst, key)</span>:</span></span><br><span class=\"line\">    low, high = <span class=\"number\">0</span>, len(lst)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> low &lt; high:</span><br><span class=\"line\">        mid = (low + high) / <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> key &lt; lst[mid]:</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> key &gt; lst[mid]:</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    l = [<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">22</span>, <span class=\"number\">54</span>, <span class=\"number\">99</span>, <span class=\"number\">123</span>, <span class=\"number\">200</span>, <span class=\"number\">222</span>, <span class=\"number\">444</span>]</span><br><span class=\"line\">    result = binary_search(l, <span class=\"number\">123</span>)</span><br><span class=\"line\">    <span class=\"keyword\">print</span> result</span><br></pre></td></tr></table></figure>\n<h3 id=\"插值查找\"><a href=\"#插值查找\" class=\"headerlink\" title=\"插值查找\"></a>插值查找</h3><p>插值查找是二分查找演化而来，相比于二分查找(折半),该算法考虑的是每次折的时候折多少，即不一定是1/2。在二分查找中mid=(low+high)/2=low+1/2*(high-low)，插值查找就是对1/2(系数,或者说比例)进行改变，它将1/2变成 (key - array[low])/(array[high] - array[low]),其实就是计算线性比例。</p>\n<p>时间复杂度：O(logn)</p>\n<p>_ note: 因为插值查找是依赖线性比例的，如果当前数组分布不是均匀的，那么该算法就不合适。_</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">interpolate_search</span><span class=\"params\">(lst, key)</span>:</span></span><br><span class=\"line\">    low, high = <span class=\"number\">0</span>, len(lst)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> low &lt; high:</span><br><span class=\"line\">        mid = low + (high - low) * (key - lst[low])/(lst[high] - lst[low])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> key &lt; lst[mid]:</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> key &gt; lst[mid]:</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    l = [<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">22</span>, <span class=\"number\">54</span>, <span class=\"number\">99</span>, <span class=\"number\">123</span>, <span class=\"number\">200</span>, <span class=\"number\">222</span>, <span class=\"number\">444</span>]</span><br><span class=\"line\">    result = binary_search(l, <span class=\"number\">123</span>)</span><br><span class=\"line\">    <span class=\"keyword\">print</span> result</span><br></pre></td></tr></table></figure>\n<h3 id=\"斐波那契查找\"><a href=\"#斐波那契查找\" class=\"headerlink\" title=\"斐波那契查找\"></a>斐波那契查找</h3><p>查找算法：在斐波那契数列找一个等于略大于查找表中元素个数的数F(n)，将原查找表扩展为长度为F(n)(如果要补充元素，则补充重复最后一个元素，直到满足数组元素个数为F(n)个元素)，完成后进行斐波那契分割，即F(n)个元素分割为前半部分F(n-1)个元素，后半部分F(n-2)个元素，找出要查找的元素在那一部分并递归，直到找到。<br>时间复杂度：O(logn)，平均性能优于二分查找。</p>\n<p><strong>利用斐波那契数列的性质，黄金分割的原理来确定mid的位置</strong></p>\n<pre><code class=\"python\">\n</code></pre>\n<h2 id=\"线性索引查找\"><a href=\"#线性索引查找\" class=\"headerlink\" title=\"线性索引查找\"></a>线性索引查找</h2><p>对于海量的无序数据，为了提高查找速度，一般会为其构造索引表。<br>索引就是把一个关键字与它相对应的记录进行关联的过程。<br>一个索引由若干个索引项构成，每个索引项至少包含关键字和其对应的记录在存储器中的位置等信息。</p>\n<p>索引按照结构可以分为：线性索引、树形索引和多级索引。<br>线性索引：将索引项的集合通过线性结构来组织，也叫索引表。</p>\n<p>线性索引可分为：稠密索引、分块索引和倒排索引</p>\n<h3 id=\"稠密索引\"><a href=\"#稠密索引\" class=\"headerlink\" title=\"稠密索引\"></a>稠密索引</h3><h3 id=\"分块索引\"><a href=\"#分块索引\" class=\"headerlink\" title=\"分块索引\"></a>分块索引</h3><h3 id=\"倒排索引\"><a href=\"#倒排索引\" class=\"headerlink\" title=\"倒排索引\"></a>倒排索引</h3><h2 id=\"二叉排序树\"><a href=\"#二叉排序树\" class=\"headerlink\" title=\"二叉排序树\"></a>二叉排序树</h2><p>二叉排序树又称为二叉查找树。它或者是一颗空树，或者是具有下列性质的二叉树：</p>\n<ul>\n<li>若它的左子树不为空，则左子树上所有节点的值均小于它的根结构的值；</li>\n<li>若它的右子树不为空，则右子树上所有节点的值均大于它的根结构的值；</li>\n<li>它的左、右子树也分别为二叉排序树。</li>\n</ul>\n<p><img src=\"assets/DataStructure_Searching-ca306.png\" alt=\"BSTPic\"></p>\n<p>二叉排序树的操作：</p>\n<ul>\n<li>查找：对比节点的值和关键字，相等则表明找到了；小了则往节点的左子树去找，大了则往右子树去找，这么递归下去，最后返回布尔值或找到的节点。</li>\n<li>插入：从根节点开始逐个与关键字进行对比，小了去左边，大了去右边，碰到子树为空的情况就将新的节点链接。</li>\n<li>删除：如果要删除的节点是叶子，直接删；如果只有左子树或只有右子树，则删除节点后，将子树链接到父节点即可；如果同时有左右子树，则可以将二叉排序树进行中序遍历，取将要被删除的节点的前驱或者后继节点替代这个被删除的节点的位置。</li>\n</ul>\n<p>二叉排序树总结：</p>\n<p>二叉排序树以链式进行存储，保持了链接结构在插入和删除操作上的优点。</p>\n<p>在极端情况下，查询次数为1，但最大操作次数不会超过树的深度。也就是说，二叉排序树的查找性能取决于二叉排序树的形状，也就引申出了后面的平衡二叉树。</p>\n<p>给定一个元素集合，可以构造不同的二叉排序树，当它同时是一个完全二叉树的时候，查找的时间复杂度为O(log(n))，近似于二分查找。</p>\n<p>当出现最极端的斜树时，其时间复杂度为O(n)，等同于顺序查找，效果最差。</p>\n<h2 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h2><h2 id=\"多路查找树-B树\"><a href=\"#多路查找树-B树\" class=\"headerlink\" title=\"多路查找树 B树\"></a>多路查找树 B树</h2><h3 id=\"2-3树\"><a href=\"#2-3树\" class=\"headerlink\" title=\"2-3树\"></a>2-3树</h3><h3 id=\"3-4树\"><a href=\"#3-4树\" class=\"headerlink\" title=\"3-4树\"></a>3-4树</h3><h3 id=\"B树\"><a href=\"#B树\" class=\"headerlink\" title=\"B树\"></a>B树</h3><h3 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h3><h2 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h2><p>散列表：所有的元素之间没有任何关系。元素的存储位置，是利用元素的关键字通过某个函数直接计算出来的。这个一一对应的关系函数称为散列函数或Hash函数。</p>\n<p>采用散列技术将记录存储在一块连续的存储空间中，称为散列表或哈希表（Hash Table）。关键字对应的存储位置，称为散列地址。</p>\n<p>散列表是一种面向查找的存储结构。它最适合求解的问题是查找与给定值相等的记录。但是对于某个关键字能对应很多记录的情况就不适用，比如查找所有的“男”性。也不适合范围查找，比如查找年龄20~30之间的人。排序、最大、最小等也不合适。</p>\n<p>因此，<strong>散列表通常用于关键字不重复的数据结构</strong>。比如python的字典数据类型。</p>\n<p>设计出一个简单、均匀、存储利用率高的散列函数是散列技术中最关键的问题。<br>但是，一般散列函数都面临着冲突的问题。<br>冲突：两个不同的关键字，通过散列函数计算后结果却相同的现象。collision</p>\n<h3 id=\"散列函数构造\"><a href=\"#散列函数构造\" class=\"headerlink\" title=\"散列函数构造\"></a>散列函数构造</h3><p>好的散列函数：计算简单、散列地址分布均匀</p>\n<ol>\n<li><p>直接定址法</p>\n<p>例如取关键字的某个线性函数为散列函数：<br>f(key) = a*key + b (a,b为常数）</p>\n</li>\n<li><p>数字分析法</p>\n<p>抽取关键字里的数字，根据数字的特点进行地址分配</p>\n</li>\n<li><p>平方取中法</p>\n<p>将关键字的数字求平方，再截取部分</p>\n</li>\n<li><p>折叠法</p>\n<p>将关键字的数字分割后分别计算，再合并计算，一种玩弄数字的手段。</p>\n</li>\n<li><p>除留余数法</p>\n<p>最为常见的方法之一。<br>对于表长为m的数据集合，散列公式为：<br>f(key) = key mod p (p&lt;=m)<br>mod：取模（求余数）<br>该方法最关键的是p的选择，而且数据量较大的时候，冲突是必然的。一般会选择接近m的质数。<br>随机数法<br>选择一个随机数，取关键字的随机函数值为它的散列地址。<br>f(key) = random(key)</p>\n</li>\n</ol>\n<p>总结，实际情况下根据不同的数据特性采用不同的散列方法，考虑下面一些主要问题：</p>\n<ul>\n<li>计算散列地址所需的时间</li>\n<li>关键字的长度</li>\n<li>散列表的大小</li>\n<li>关键字的分布情况</li>\n<li>记录查找的频率</li>\n</ul>\n<h3 id=\"处理散列冲突\"><a href=\"#处理散列冲突\" class=\"headerlink\" title=\"处理散列冲突\"></a>处理散列冲突</h3><h3 id=\"散列表查找实现\"><a href=\"#散列表查找实现\" class=\"headerlink\" title=\"散列表查找实现\"></a>散列表查找实现</h3><h3 id=\"散列表查找性能分析\"><a href=\"#散列表查找性能分析\" class=\"headerlink\" title=\"散列表查找性能分析\"></a>散列表查找性能分析</h3>","site":{"data":{}},"excerpt":"<p>未完成</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p>\n<p>查找表按照操作方式可分为：</p>\n<ol>\n<li><p>静态查找表（Static Search Table）：只做查找操作的查找表。它的主要操作是：</p>\n<ul>\n<li>查询某个“特定的”数据元素是否在表中</li>\n<li>检索某个“特定的”数据元素和各种属性</li>\n</ul>\n</li>\n<li><p>动态查找表（Dynamic Search Table）：在查找中同时进行插入或删除等操作：</p>\n<ul>\n<li>查找时插入数据</li>\n<li>查找时删除数据</li>\n</ul>\n</li>\n</ol>","more":"<h2 id=\"无序表查找\"><a href=\"#无序表查找\" class=\"headerlink\" title=\"无序表查找\"></a>无序表查找</h2><p>在数据不排序的线性查找，遍历数据元素。</p>\n<p>算法分析：最好情况是第一个位置就找到了，为O(1)；最坏情况在最后一个位置找到，为O(n)， 平均查找次数为 (n+1)/2, <strong>时间复杂度为O(n)</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sequential_search</span><span class=\"params\">(lst, key)</span>:</span></span><br><span class=\"line\">    length = len(lst)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(length):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lst[i] == key:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    l = [<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">124</span>,<span class=\"number\">22</span>,<span class=\"number\">54</span>,<span class=\"number\">7</span>,<span class=\"number\">99</span>,<span class=\"number\">300</span>,<span class=\"number\">222</span>]</span><br><span class=\"line\">    result = sequential_search(l, <span class=\"number\">123</span>)</span><br><span class=\"line\">    <span class=\"keyword\">print</span> result</span><br></pre></td></tr></table></figure>\n<h3 id=\"快速选择算法-quick-selection-algorithm\"><a href=\"#快速选择算法-quick-selection-algorithm\" class=\"headerlink\" title=\"快速选择算法 (quick selection algorithm)\"></a>快速选择算法 (quick selection algorithm)</h3><p>快速选择算法能够在平均O(n)时间内从一个无序数组中返回第k大的元素。算法实际上利用了快速排序的思想，将数组依照一个轴值分割成两个部分，左边元素都比轴值小，右边元素都比轴值大。由于轴值下标已知，则可以判断所求元素落在数组的哪一部分，并在那一部分继续进行上述操作，直至找到该元素。与快排不同，由于快速选择算法只在乎所求元素所在的那一部分，所以时间复杂度是O(n)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"有序表查找\"><a href=\"#有序表查找\" class=\"headerlink\" title=\"有序表查找\"></a>有序表查找</h2><p>数据按某种方式进行过排序</p>\n<h3 id=\"二分查找-Binary-Search\"><a href=\"#二分查找-Binary-Search\" class=\"headerlink\" title=\"二分查找 Binary Search\"></a>二分查找 Binary Search</h3><p>算法内容：在查找表中不断取中间元素与查找值进行比较，以二分之一的倍率进行表范围的缩小。时间复杂度：O(logn)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binary_search</span><span class=\"params\">(lst, key)</span>:</span></span><br><span class=\"line\">    low, high = <span class=\"number\">0</span>, len(lst)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> low &lt; high:</span><br><span class=\"line\">        mid = (low + high) / <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> key &lt; lst[mid]:</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> key &gt; lst[mid]:</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    l = [<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">22</span>, <span class=\"number\">54</span>, <span class=\"number\">99</span>, <span class=\"number\">123</span>, <span class=\"number\">200</span>, <span class=\"number\">222</span>, <span class=\"number\">444</span>]</span><br><span class=\"line\">    result = binary_search(l, <span class=\"number\">123</span>)</span><br><span class=\"line\">    <span class=\"keyword\">print</span> result</span><br></pre></td></tr></table></figure>\n<h3 id=\"插值查找\"><a href=\"#插值查找\" class=\"headerlink\" title=\"插值查找\"></a>插值查找</h3><p>插值查找是二分查找演化而来，相比于二分查找(折半),该算法考虑的是每次折的时候折多少，即不一定是1/2。在二分查找中mid=(low+high)/2=low+1/2*(high-low)，插值查找就是对1/2(系数,或者说比例)进行改变，它将1/2变成 (key - array[low])/(array[high] - array[low]),其实就是计算线性比例。</p>\n<p>时间复杂度：O(logn)</p>\n<p>_ note: 因为插值查找是依赖线性比例的，如果当前数组分布不是均匀的，那么该算法就不合适。_</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">interpolate_search</span><span class=\"params\">(lst, key)</span>:</span></span><br><span class=\"line\">    low, high = <span class=\"number\">0</span>, len(lst)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> low &lt; high:</span><br><span class=\"line\">        mid = low + (high - low) * (key - lst[low])/(lst[high] - lst[low])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> key &lt; lst[mid]:</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> key &gt; lst[mid]:</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    l = [<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">22</span>, <span class=\"number\">54</span>, <span class=\"number\">99</span>, <span class=\"number\">123</span>, <span class=\"number\">200</span>, <span class=\"number\">222</span>, <span class=\"number\">444</span>]</span><br><span class=\"line\">    result = binary_search(l, <span class=\"number\">123</span>)</span><br><span class=\"line\">    <span class=\"keyword\">print</span> result</span><br></pre></td></tr></table></figure>\n<h3 id=\"斐波那契查找\"><a href=\"#斐波那契查找\" class=\"headerlink\" title=\"斐波那契查找\"></a>斐波那契查找</h3><p>查找算法：在斐波那契数列找一个等于略大于查找表中元素个数的数F(n)，将原查找表扩展为长度为F(n)(如果要补充元素，则补充重复最后一个元素，直到满足数组元素个数为F(n)个元素)，完成后进行斐波那契分割，即F(n)个元素分割为前半部分F(n-1)个元素，后半部分F(n-2)个元素，找出要查找的元素在那一部分并递归，直到找到。<br>时间复杂度：O(logn)，平均性能优于二分查找。</p>\n<p><strong>利用斐波那契数列的性质，黄金分割的原理来确定mid的位置</strong></p>\n<pre><code class=\"python\">\n</code></pre>\n<h2 id=\"线性索引查找\"><a href=\"#线性索引查找\" class=\"headerlink\" title=\"线性索引查找\"></a>线性索引查找</h2><p>对于海量的无序数据，为了提高查找速度，一般会为其构造索引表。<br>索引就是把一个关键字与它相对应的记录进行关联的过程。<br>一个索引由若干个索引项构成，每个索引项至少包含关键字和其对应的记录在存储器中的位置等信息。</p>\n<p>索引按照结构可以分为：线性索引、树形索引和多级索引。<br>线性索引：将索引项的集合通过线性结构来组织，也叫索引表。</p>\n<p>线性索引可分为：稠密索引、分块索引和倒排索引</p>\n<h3 id=\"稠密索引\"><a href=\"#稠密索引\" class=\"headerlink\" title=\"稠密索引\"></a>稠密索引</h3><h3 id=\"分块索引\"><a href=\"#分块索引\" class=\"headerlink\" title=\"分块索引\"></a>分块索引</h3><h3 id=\"倒排索引\"><a href=\"#倒排索引\" class=\"headerlink\" title=\"倒排索引\"></a>倒排索引</h3><h2 id=\"二叉排序树\"><a href=\"#二叉排序树\" class=\"headerlink\" title=\"二叉排序树\"></a>二叉排序树</h2><p>二叉排序树又称为二叉查找树。它或者是一颗空树，或者是具有下列性质的二叉树：</p>\n<ul>\n<li>若它的左子树不为空，则左子树上所有节点的值均小于它的根结构的值；</li>\n<li>若它的右子树不为空，则右子树上所有节点的值均大于它的根结构的值；</li>\n<li>它的左、右子树也分别为二叉排序树。</li>\n</ul>\n<p><img src=\"assets/DataStructure_Searching-ca306.png\" alt=\"BSTPic\"></p>\n<p>二叉排序树的操作：</p>\n<ul>\n<li>查找：对比节点的值和关键字，相等则表明找到了；小了则往节点的左子树去找，大了则往右子树去找，这么递归下去，最后返回布尔值或找到的节点。</li>\n<li>插入：从根节点开始逐个与关键字进行对比，小了去左边，大了去右边，碰到子树为空的情况就将新的节点链接。</li>\n<li>删除：如果要删除的节点是叶子，直接删；如果只有左子树或只有右子树，则删除节点后，将子树链接到父节点即可；如果同时有左右子树，则可以将二叉排序树进行中序遍历，取将要被删除的节点的前驱或者后继节点替代这个被删除的节点的位置。</li>\n</ul>\n<p>二叉排序树总结：</p>\n<p>二叉排序树以链式进行存储，保持了链接结构在插入和删除操作上的优点。</p>\n<p>在极端情况下，查询次数为1，但最大操作次数不会超过树的深度。也就是说，二叉排序树的查找性能取决于二叉排序树的形状，也就引申出了后面的平衡二叉树。</p>\n<p>给定一个元素集合，可以构造不同的二叉排序树，当它同时是一个完全二叉树的时候，查找的时间复杂度为O(log(n))，近似于二分查找。</p>\n<p>当出现最极端的斜树时，其时间复杂度为O(n)，等同于顺序查找，效果最差。</p>\n<h2 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h2><h2 id=\"多路查找树-B树\"><a href=\"#多路查找树-B树\" class=\"headerlink\" title=\"多路查找树 B树\"></a>多路查找树 B树</h2><h3 id=\"2-3树\"><a href=\"#2-3树\" class=\"headerlink\" title=\"2-3树\"></a>2-3树</h3><h3 id=\"3-4树\"><a href=\"#3-4树\" class=\"headerlink\" title=\"3-4树\"></a>3-4树</h3><h3 id=\"B树\"><a href=\"#B树\" class=\"headerlink\" title=\"B树\"></a>B树</h3><h3 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h3><h2 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h2><p>散列表：所有的元素之间没有任何关系。元素的存储位置，是利用元素的关键字通过某个函数直接计算出来的。这个一一对应的关系函数称为散列函数或Hash函数。</p>\n<p>采用散列技术将记录存储在一块连续的存储空间中，称为散列表或哈希表（Hash Table）。关键字对应的存储位置，称为散列地址。</p>\n<p>散列表是一种面向查找的存储结构。它最适合求解的问题是查找与给定值相等的记录。但是对于某个关键字能对应很多记录的情况就不适用，比如查找所有的“男”性。也不适合范围查找，比如查找年龄20~30之间的人。排序、最大、最小等也不合适。</p>\n<p>因此，<strong>散列表通常用于关键字不重复的数据结构</strong>。比如python的字典数据类型。</p>\n<p>设计出一个简单、均匀、存储利用率高的散列函数是散列技术中最关键的问题。<br>但是，一般散列函数都面临着冲突的问题。<br>冲突：两个不同的关键字，通过散列函数计算后结果却相同的现象。collision</p>\n<h3 id=\"散列函数构造\"><a href=\"#散列函数构造\" class=\"headerlink\" title=\"散列函数构造\"></a>散列函数构造</h3><p>好的散列函数：计算简单、散列地址分布均匀</p>\n<ol>\n<li><p>直接定址法</p>\n<p>例如取关键字的某个线性函数为散列函数：<br>f(key) = a*key + b (a,b为常数）</p>\n</li>\n<li><p>数字分析法</p>\n<p>抽取关键字里的数字，根据数字的特点进行地址分配</p>\n</li>\n<li><p>平方取中法</p>\n<p>将关键字的数字求平方，再截取部分</p>\n</li>\n<li><p>折叠法</p>\n<p>将关键字的数字分割后分别计算，再合并计算，一种玩弄数字的手段。</p>\n</li>\n<li><p>除留余数法</p>\n<p>最为常见的方法之一。<br>对于表长为m的数据集合，散列公式为：<br>f(key) = key mod p (p&lt;=m)<br>mod：取模（求余数）<br>该方法最关键的是p的选择，而且数据量较大的时候，冲突是必然的。一般会选择接近m的质数。<br>随机数法<br>选择一个随机数，取关键字的随机函数值为它的散列地址。<br>f(key) = random(key)</p>\n</li>\n</ol>\n<p>总结，实际情况下根据不同的数据特性采用不同的散列方法，考虑下面一些主要问题：</p>\n<ul>\n<li>计算散列地址所需的时间</li>\n<li>关键字的长度</li>\n<li>散列表的大小</li>\n<li>关键字的分布情况</li>\n<li>记录查找的频率</li>\n</ul>\n<h3 id=\"处理散列冲突\"><a href=\"#处理散列冲突\" class=\"headerlink\" title=\"处理散列冲突\"></a>处理散列冲突</h3><h3 id=\"散列表查找实现\"><a href=\"#散列表查找实现\" class=\"headerlink\" title=\"散列表查找实现\"></a>散列表查找实现</h3><h3 id=\"散列表查找性能分析\"><a href=\"#散列表查找性能分析\" class=\"headerlink\" title=\"散列表查找性能分析\"></a>散列表查找性能分析</h3>"},{"title":"搜索和排序之排序","date":"2017-06-12T09:31:43.000Z","_content":"\n未完成\n\n<!-- more -->\n\n## Bubble Sort 冒泡排序\n\n冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。\n\n步骤：\n\n1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n2. 对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。\n3. 针对所有的元素重复以上的步骤，除了最后一个。\n4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n``` python\n\n```\n\n针对上述代码还有两种优化方案。\n\n## Selection Sort 选择排序\n\n选择排序无疑是最简单直观的排序。它的工作原理如下。\n\n步骤：\n\n1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。\n2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n3. 以此类推，直到所有元素均排序完毕。\n\n``` python\n\n```\n\n## Insertion Sort 插入排序\n\n插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n\n步骤：\n\n1. 从第一个元素开始，该元素可以认为已经被排序\n2. 取出下一个元素，在已经排序的元素序列中从后向前扫描\n3. 如果被扫描的元素（已排序）大于新元素，将该元素后移一位\n4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置\n5. 将新元素插入到该位置后\n6. 重复步骤2~5\n\n``` python\n\n```\n\n## Shell Sort 希尔排序\n\n希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。\n\n希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。\n\n\n``` python\n\n```\n\n## Merge Sort 归并排序\n\n归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。\n\n先考虑合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。\n\n再考虑递归分解，基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。\n\n``` python\n\n```\n\n## Quick Sort 快速排序\n\n快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。\n\n步骤：\n\n1. 从数列中挑出一个元素作为基准数。\n2. 分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。\n3. 再对左右区间递归执行第二步，直至各区间只有一个数。\n\n``` python\n\n```\n\n\n## Heap Sort 堆排序\n\n堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。\n\n### 二叉堆\n\n二叉堆具有以下性质：\n\n- 父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。\n- 每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。\n\n步骤：\n1. 构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。\n2. 堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0...n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0...n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。\n3. 最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点。\n\n``` python\n\n```\n\n## Bucket Sort 桶排序\n\n## Counting Sort 计数排序\n\n##\n\n## 总结\n\n| 排序方法 |  平均情况 | 最好情况 | 最坏情况 | 辅助空间 | 稳定性\n|--------- |---------------|-------|------|--------|--------|\n|冒泡排序|\tO(n2)|\tO(n)|\tO(n2)|\tO(1)|\t稳定   |\n|选择排序|\tO(n2)|\tO(n2)|\tO(n2)|\tO(1)|\t不稳定 |\n|插入排序|\tO(n2)|\tO(n)|\tO(n2)|\tO(1)|\t稳定   |\n|希尔排序|\tO(nlogn)~O(n2) |\tO(n1.3)|\tO(n2)|\tO(1)|\t不稳定|\n|堆排序\t|O(nlogn)|\tO(nlogn)|\tO(nlogn)|\tO(1)|\t不稳定|\n|归并排序|\tO(nlogn)|\tO(nlogn)|\tO(nlogn)|\tO(n)|\t稳定|\n|快速排序|\tO(nlogn)|\tO(nlogn)|\tO(n2)|\tO(logn)~O(n)|\t不稳定|\n","source":"_posts/À—À˜∫Õ≈≈–Ú÷Æ≈≈–Ú.md","raw":"---\ntitle: 搜索和排序之排序\ntags:\n  - Algorithm\n  - Data Structure\n  - 面试\ndate: 2017-06-12 17:31:43\n---\n\n未完成\n\n<!-- more -->\n\n## Bubble Sort 冒泡排序\n\n冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。\n\n步骤：\n\n1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n2. 对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。\n3. 针对所有的元素重复以上的步骤，除了最后一个。\n4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n``` python\n\n```\n\n针对上述代码还有两种优化方案。\n\n## Selection Sort 选择排序\n\n选择排序无疑是最简单直观的排序。它的工作原理如下。\n\n步骤：\n\n1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。\n2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n3. 以此类推，直到所有元素均排序完毕。\n\n``` python\n\n```\n\n## Insertion Sort 插入排序\n\n插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n\n步骤：\n\n1. 从第一个元素开始，该元素可以认为已经被排序\n2. 取出下一个元素，在已经排序的元素序列中从后向前扫描\n3. 如果被扫描的元素（已排序）大于新元素，将该元素后移一位\n4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置\n5. 将新元素插入到该位置后\n6. 重复步骤2~5\n\n``` python\n\n```\n\n## Shell Sort 希尔排序\n\n希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。\n\n希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。\n\n\n``` python\n\n```\n\n## Merge Sort 归并排序\n\n归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。\n\n先考虑合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。\n\n再考虑递归分解，基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。\n\n``` python\n\n```\n\n## Quick Sort 快速排序\n\n快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。\n\n步骤：\n\n1. 从数列中挑出一个元素作为基准数。\n2. 分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。\n3. 再对左右区间递归执行第二步，直至各区间只有一个数。\n\n``` python\n\n```\n\n\n## Heap Sort 堆排序\n\n堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。\n\n### 二叉堆\n\n二叉堆具有以下性质：\n\n- 父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。\n- 每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。\n\n步骤：\n1. 构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。\n2. 堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0...n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0...n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。\n3. 最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点。\n\n``` python\n\n```\n\n## Bucket Sort 桶排序\n\n## Counting Sort 计数排序\n\n##\n\n## 总结\n\n| 排序方法 |  平均情况 | 最好情况 | 最坏情况 | 辅助空间 | 稳定性\n|--------- |---------------|-------|------|--------|--------|\n|冒泡排序|\tO(n2)|\tO(n)|\tO(n2)|\tO(1)|\t稳定   |\n|选择排序|\tO(n2)|\tO(n2)|\tO(n2)|\tO(1)|\t不稳定 |\n|插入排序|\tO(n2)|\tO(n)|\tO(n2)|\tO(1)|\t稳定   |\n|希尔排序|\tO(nlogn)~O(n2) |\tO(n1.3)|\tO(n2)|\tO(1)|\t不稳定|\n|堆排序\t|O(nlogn)|\tO(nlogn)|\tO(nlogn)|\tO(1)|\t不稳定|\n|归并排序|\tO(nlogn)|\tO(nlogn)|\tO(nlogn)|\tO(n)|\t稳定|\n|快速排序|\tO(nlogn)|\tO(nlogn)|\tO(n2)|\tO(logn)~O(n)|\t不稳定|\n","slug":"À—À˜∫Õ≈≈–Ú÷Æ≈≈–Ú","published":1,"updated":"2017-06-12T09:33:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3p7004fzd68wp0l5fmb","content":"<p>未完成</p>\n<a id=\"more\"></a>\n<h2 id=\"Bubble-Sort-冒泡排序\"><a href=\"#Bubble-Sort-冒泡排序\" class=\"headerlink\" title=\"Bubble Sort 冒泡排序\"></a>Bubble Sort 冒泡排序</h2><p>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p>\n<p>步骤：</p>\n<ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>针对上述代码还有两种优化方案。</p>\n<h2 id=\"Selection-Sort-选择排序\"><a href=\"#Selection-Sort-选择排序\" class=\"headerlink\" title=\"Selection Sort 选择排序\"></a>Selection Sort 选择排序</h2><p>选择排序无疑是最简单直观的排序。它的工作原理如下。</p>\n<p>步骤：</p>\n<ol>\n<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>\n<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>\n<li>以此类推，直到所有元素均排序完毕。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Insertion-Sort-插入排序\"><a href=\"#Insertion-Sort-插入排序\" class=\"headerlink\" title=\"Insertion Sort 插入排序\"></a>Insertion Sort 插入排序</h2><p>插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>\n<p>步骤：</p>\n<ol>\n<li>从第一个元素开始，该元素可以认为已经被排序</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>\n<li>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</li>\n<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>\n<li>将新元素插入到该位置后</li>\n<li>重复步骤2~5</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Shell-Sort-希尔排序\"><a href=\"#Shell-Sort-希尔排序\" class=\"headerlink\" title=\"Shell Sort 希尔排序\"></a>Shell Sort 希尔排序</h2><p>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。</p>\n<p>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Merge-Sort-归并排序\"><a href=\"#Merge-Sort-归并排序\" class=\"headerlink\" title=\"Merge Sort 归并排序\"></a>Merge Sort 归并排序</h2><p>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p>\n<p>先考虑合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p>\n<p>再考虑递归分解，基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Quick-Sort-快速排序\"><a href=\"#Quick-Sort-快速排序\" class=\"headerlink\" title=\"Quick Sort 快速排序\"></a>Quick Sort 快速排序</h2><p>快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。</p>\n<p>步骤：</p>\n<ol>\n<li>从数列中挑出一个元素作为基准数。</li>\n<li>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。</li>\n<li>再对左右区间递归执行第二步，直至各区间只有一个数。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Heap-Sort-堆排序\"><a href=\"#Heap-Sort-堆排序\" class=\"headerlink\" title=\"Heap Sort 堆排序\"></a>Heap Sort 堆排序</h2><p>堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。</p>\n<h3 id=\"二叉堆\"><a href=\"#二叉堆\" class=\"headerlink\" title=\"二叉堆\"></a>二叉堆</h3><p>二叉堆具有以下性质：</p>\n<ul>\n<li>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</li>\n<li>每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</li>\n</ul>\n<p>步骤：</p>\n<ol>\n<li>构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</li>\n<li>堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</li>\n<li>最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Bucket-Sort-桶排序\"><a href=\"#Bucket-Sort-桶排序\" class=\"headerlink\" title=\"Bucket Sort 桶排序\"></a>Bucket Sort 桶排序</h2><h2 id=\"Counting-Sort-计数排序\"><a href=\"#Counting-Sort-计数排序\" class=\"headerlink\" title=\"Counting Sort 计数排序\"></a>Counting Sort 计数排序</h2><p>##</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><table>\n<thead>\n<tr>\n<th>排序方法</th>\n<th>平均情况</th>\n<th>最好情况</th>\n<th>最坏情况</th>\n<th>辅助空间</th>\n<th>稳定性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>冒泡排序</td>\n<td>O(n2)</td>\n<td>O(n)</td>\n<td>O(n2)</td>\n<td>O(1)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>选择排序</td>\n<td>O(n2)</td>\n<td>O(n2)</td>\n<td>O(n2)</td>\n<td>O(1)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td>插入排序</td>\n<td>O(n2)</td>\n<td>O(n)</td>\n<td>O(n2)</td>\n<td>O(1)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>希尔排序</td>\n<td>O(nlogn)~O(n2)</td>\n<td>O(n1.3)</td>\n<td>O(n2)</td>\n<td>O(1)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td>堆排序</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(1)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td>归并排序</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(n)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>快速排序</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(n2)</td>\n<td>O(logn)~O(n)</td>\n<td>不稳定</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<p>未完成</p>","more":"<h2 id=\"Bubble-Sort-冒泡排序\"><a href=\"#Bubble-Sort-冒泡排序\" class=\"headerlink\" title=\"Bubble Sort 冒泡排序\"></a>Bubble Sort 冒泡排序</h2><p>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p>\n<p>步骤：</p>\n<ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>针对上述代码还有两种优化方案。</p>\n<h2 id=\"Selection-Sort-选择排序\"><a href=\"#Selection-Sort-选择排序\" class=\"headerlink\" title=\"Selection Sort 选择排序\"></a>Selection Sort 选择排序</h2><p>选择排序无疑是最简单直观的排序。它的工作原理如下。</p>\n<p>步骤：</p>\n<ol>\n<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>\n<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>\n<li>以此类推，直到所有元素均排序完毕。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Insertion-Sort-插入排序\"><a href=\"#Insertion-Sort-插入排序\" class=\"headerlink\" title=\"Insertion Sort 插入排序\"></a>Insertion Sort 插入排序</h2><p>插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>\n<p>步骤：</p>\n<ol>\n<li>从第一个元素开始，该元素可以认为已经被排序</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>\n<li>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</li>\n<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>\n<li>将新元素插入到该位置后</li>\n<li>重复步骤2~5</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Shell-Sort-希尔排序\"><a href=\"#Shell-Sort-希尔排序\" class=\"headerlink\" title=\"Shell Sort 希尔排序\"></a>Shell Sort 希尔排序</h2><p>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。</p>\n<p>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Merge-Sort-归并排序\"><a href=\"#Merge-Sort-归并排序\" class=\"headerlink\" title=\"Merge Sort 归并排序\"></a>Merge Sort 归并排序</h2><p>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p>\n<p>先考虑合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p>\n<p>再考虑递归分解，基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Quick-Sort-快速排序\"><a href=\"#Quick-Sort-快速排序\" class=\"headerlink\" title=\"Quick Sort 快速排序\"></a>Quick Sort 快速排序</h2><p>快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。</p>\n<p>步骤：</p>\n<ol>\n<li>从数列中挑出一个元素作为基准数。</li>\n<li>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。</li>\n<li>再对左右区间递归执行第二步，直至各区间只有一个数。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Heap-Sort-堆排序\"><a href=\"#Heap-Sort-堆排序\" class=\"headerlink\" title=\"Heap Sort 堆排序\"></a>Heap Sort 堆排序</h2><p>堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。</p>\n<h3 id=\"二叉堆\"><a href=\"#二叉堆\" class=\"headerlink\" title=\"二叉堆\"></a>二叉堆</h3><p>二叉堆具有以下性质：</p>\n<ul>\n<li>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</li>\n<li>每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</li>\n</ul>\n<p>步骤：</p>\n<ol>\n<li>构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</li>\n<li>堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</li>\n<li>最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Bucket-Sort-桶排序\"><a href=\"#Bucket-Sort-桶排序\" class=\"headerlink\" title=\"Bucket Sort 桶排序\"></a>Bucket Sort 桶排序</h2><h2 id=\"Counting-Sort-计数排序\"><a href=\"#Counting-Sort-计数排序\" class=\"headerlink\" title=\"Counting Sort 计数排序\"></a>Counting Sort 计数排序</h2><p>##</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><table>\n<thead>\n<tr>\n<th>排序方法</th>\n<th>平均情况</th>\n<th>最好情况</th>\n<th>最坏情况</th>\n<th>辅助空间</th>\n<th>稳定性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>冒泡排序</td>\n<td>O(n2)</td>\n<td>O(n)</td>\n<td>O(n2)</td>\n<td>O(1)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>选择排序</td>\n<td>O(n2)</td>\n<td>O(n2)</td>\n<td>O(n2)</td>\n<td>O(1)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td>插入排序</td>\n<td>O(n2)</td>\n<td>O(n)</td>\n<td>O(n2)</td>\n<td>O(1)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>希尔排序</td>\n<td>O(nlogn)~O(n2)</td>\n<td>O(n1.3)</td>\n<td>O(n2)</td>\n<td>O(1)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td>堆排序</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(1)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td>归并排序</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(n)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>快速排序</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(n2)</td>\n<td>O(logn)~O(n)</td>\n<td>不稳定</td>\n</tr>\n</tbody>\n</table>"},{"title":"设计短链接TinyURL","date":"2017-05-27T10:45:29.000Z","_content":"\n\n","source":"_posts/…Ëº∆∂Ã¡¥Ω”TinyURL.md","raw":"---\ntitle: 设计短链接TinyURL\ndate: 2017-05-27 18:45:29\ntags: \n- leetcode\n---\n\n\n","slug":"…Ëº∆∂Ã¡¥Ω”TinyURL","published":1,"updated":"2017-05-27T10:52:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3p9004jzd68kkvadsh6","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"看懂SQL Server执行计划","date":"2017-06-02T01:28:00.000Z","_content":"\n\n当我们写的SQL语句传到SQL Server的时候，查询分析器会将语句依次进行解析（Parse）、绑定（Bind）、查询优化（Optimization，有时候也被称为简化）、执行（Execution）。除去执行步骤外，前三个步骤之后就生成了执行计划，也就是SQL Server按照该计划获取物理数据方式，最后执行步骤按照执行计划执行查询从而获得结果。\n\n## 执行计划\n\n- 查询优化器对输入的 T-SQL 查询语句通过\"计算\"而选择出效率最高的一种执行方案，这个执行方案就是执行计划。\n- 执行计划可以告诉你这个查询将会被如何执行或者已经被如何执行过，可以通过执行计划看到 SQL 代码中那些效率比较低的地方。\n- 查看执行计划的方式我们可以通过图形化的界面，或者文本，或者XML格式查看，这样会比较方便理解执行计划要表达出来的意思。\n\n<!-- more -->\n\n当一个查询被提交到 SQL Server 后，服务器端很多进程实际上要做很多事情来确保数据出入的完整性。\n\n对于 T-SQL 来说, 处理的主要有两个阶段：关系引擎阶段( `relational engine`)和存储引擎阶段( `storage engine`)。\n\n- 关系引擎主要要做的事情就是首先确保 Query 语句能够正确的解析，然后交给查询优化并产生执行计划，然后执行计划就以二进制格式发到存储引擎来更新或者读取数据。\n\n- 存储引擎主要处理的比如像锁、索引的维护和事务等\n\n所以对于执行计划，重点的是关注关系引擎。\n\n## 估算执行计划和实际执行计划\n\nEstimated Execution Plans vs. Actual Execution Plans\n\n它们之间的区别就是: **估算的执行计划** 是从查询优化器来的，是输入关系引擎的，它的执行步骤包括一些运算符等等都是通过一系列的逻辑分析出来的，是一种通过逻辑推算出来的计划，只能代表查询优化器的观点；**实际执行计划** 是真实的执行了\"估算执行计划\"后的一种真实的结果，是实实在在真实的执行反馈, 是属于存储引擎。\n\n\n以上描述了关于执行计划的概念，下面以实际案例去解读一些基本语句， 例如`SELECT`, `UPDATE`,`INSERT`, `DELETE` 等查询的执行计划。\n\n------------------------------------我是分隔符-----------------------------------\n\n有大约78个执行计划中的操作符，可以去 [MSDN Book Online](https://msdn.microsoft.com/en-us/library/ms175913.aspx) 随时查\n\n下表表示一下常见的执行计划元素\n\n|  |   |   |\n|---|---|---|\n|**Select (Result)** | **Sort** | Spool                                     |\n|**Clustered Index Scan** | **Key Lookup** | Eager Spool             |\n|**NonClustered Index Scan** | **Compute Scalar** | Stream Aggregate |\n|**Clustered Index Seek** | Constant Scan | Distribute Streams   |\n|**NonClustered Index Seek** | **Table Scan** | Repartition Streams  |\n|**Hash Match** | **RID Lookup** | Gather Streams                    |\n|**Nested Loops** | **Filter** | Bitmap                              |\n|**Merge Join** | Lazy Spool | Split                             |\n\n\n操作符分为阻断式 `blocking` 和非阻断式`non-blocking`\n\n## 常见操作符的执行计划解释\n\n### Table Scan 表扫描\n\n<img src='https://i-msdn.sec.s-msft.com/dynimg/IC121534.gif' atl=\"Table Scan\" align=\"left\"/><br>\n\n\n当表中没有聚集索引，又没有合适索引的情况下，会出现这个操作。这个操作是很耗性能的，他的出现也意味着优化器要遍历整张表去查找你所需要的数据\n\n### Clustered Index Scan / Index Scan 聚集索引扫描/非聚集索引扫描\n\n<img src='https://i-msdn.sec.s-msft.com/dynimg/IC72069.gif' atl=\"Clustered Index Scan\" align=\"left\"/><br>\n\n这个图标两个操作都可以使用，一个聚集索引扫描，一个是非聚集索引扫描。\n\n- 聚集索引扫描：聚集索引的数据体积实际是就是表本身，也就是说表有多少行多少列，聚集所有就有多少行多少列，那么聚集索引扫描就跟表扫描差不多，也要进行全表扫描，遍历所有表数据，查找出你想要的数据。\n\n- 非聚集索引扫描：非聚集索引的体积是根据你的索引创建情况而定的，可以只包含你要查询的列。那么进行非聚集索引扫描，便是你非聚集中包含的列的所有行进行遍历，查找出你想要的数据。\n\n看下面这个查询\n\n``` sql\nSELECT ct.*\nFROM Person.ContactType AS ct;\n```\n\n这个表有一个聚簇索引PK_ContactType_ContactTypeID，聚簇索引的叶子结点是存储数据的，所以对于这个聚簇索引的扫描和全表扫面基本类似，基本也是一行一行地进行扫描来满足查询。\n\n![IndexScan](http://7xkfga.com1.z0.glb.clouddn.com/IndexScan.png)\n\n\n如果在执行计划中遇到索引扫描，说明查询有可能返回比需要更多的行，这时候建议使用 `WHERE`语句去优化查询，确保只是需要的那些行被返回。\n\n### Clustered Index Seek / Index Seek 聚集索引查找/非聚集索引查找\n\n<img src='https://i-msdn.sec.s-msft.com/dynimg/IC322.gif' atl=\"Clustered Index Scan\" align=\"left\"/><br>\n\n聚集索引查找和非聚集索引查找都是使用该图标。\n\n- 聚集索引查找：聚集索引包含整个表的数据，也就是在聚集索引的数据上根据键值取数据。\n\n- 非聚集索引查找：非聚集索引包含创建索引时所包含列的数据，在这些非聚集索引的数据上根据键值取数据。\n\n``` sql\nSELECT ct.*\nFROM Person.ContactType AS ct\nWHERE ct.ContactTypeID = 7\n```\n\n![IndexSeek](http://7xkfga.com1.z0.glb.clouddn.com/ClusterIndexSeek.png)\n\n这个表有一个聚簇索引PK_ContactType_ContactTypeID，建在ContactTypeID字段上，查询使用了这个聚簇索引来查找指定的数据。\n\n索引查找和索引扫描不同，使用查找可以让优化器准确地通过键值找到索引的位置。\n\n以上几种查询的性能对比：\n\n- [Table Scan] 表扫描（最慢）：对表记录逐行进行检查\n- [Clustered Index Scan] 聚集索引扫描（较慢）：按聚集索引对记录逐行进行检查\n- [Index Scan] 索引扫描（普通）：根据索引滤出部分数据在进行逐行检查\n- [Index Seek] 索引查找（较快）：根据索引定位记录所在位置再取出记录\n- [Clustered Index Seek] 聚集索引查找（最快）：直接根据聚集索引获取记录\n\n### Key Lookup 键值查找\n\n<img src='https://i-msdn.sec.s-msft.com/dynimg/IC165506.gif' atl=\"Key Lookup\" align=\"left\"/><br>\n\n首先需要说的是查找，查找与扫描在性能上完全不是一个级别的，扫描需要遍历整张表，而查找只需要通过键值直接提取数据，返回结果，性能要好。\n\n当你查找的列没有完全被非聚集索引包含，就需要使用键值查找在聚集索引上查找非聚集索引不包含的列。\n\n### RID Lookup RID查找\n\n<img src='https://i-msdn.sec.s-msft.com/dynimg/IC57221.gif' atl=\"RID Lookup\" align=\"left\"/><br>\n\n跟键值查找类似，只不过RID查找，是需要查找的列没有完全被非聚集索引包含，而剩余的列所在的表又不存在聚集索引，不能键值查找，只能根据行表示Rid来查询数据。\n\n\n``` sql\nSELECT p.BusinessEntityID\n     , p.LastName\n     , p.FirstName\n     , p.NameStyle\nFROM Person.Person AS p\nWHERE p.LastName LIKE 'Jaf%';\n```\n\n![keyLookup](http://7xkfga.com1.z0.glb.clouddn.com/keyLookup.png)\n\n`Person.Person` 表有非聚簇索引 `IX_Person_LastName_FirstName_MiddleName`作用在LastName、FirstName和MiddleName列上面，而列 `NameStyle`并没有被非聚集索引所包含，所以需要使用 `KeyLookUp`在聚集索引上查找不包含的列。如果这个列所在的表不存在聚集索引，那就只能通过RId，也就是行号在查询了。\n\n### Sort\n\n对数据集合进行排序，需要注意的是，有些数据集合在索引扫描后是自带排序的。\n\n### Filter\n\n根据出现在having之后的操作运算符，进行筛选\n\n### Computer Scalar\n\n在需要查询的列中需要自定义列，比如count(\\*) as cnt , select name+''+age 等会出现此符号。\n\n## JOIN 连接查询\n\n当多表连接时，SQL Server会采用三类不同的连接方式：散列连接，循环嵌套连接，合并连接\n\n\n### Hash Join\n\n<img src='https://i-msdn.sec.s-msft.com/dynimg/IC113753.gif' atl=\"Hash Match\" align=\"left\"/><br>\n\n这个图标有两种地方用到，一种是表关联，一种是数据聚合运算时 (`GROUP BY`)\n\n下面有两个概念：\n\n> Hashing：在数据库中根据每一行的数据内容，转换成唯一符号格式，存放到临时哈希表中，当需要原始数据时，可以给还原回来。类似加密解密技术，但是他能更有效的支持数据查询。\n\n> Hash Table：通过hashing处理，把数据以key/value的形式存储在表格中，在数据库中他被放在tempdb中。\n\nHash Join是做大数据集连接时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立散列表 `Hash Table`，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。这种方式适用于较小的表完全可以放于内存中的情况\n\n如果在执行计划中见到Hash Match Join，也许应该检查一下是不是缺少或者没有使用索引、没有用到WHERE等等。\n\n### Nested Loops Join\n\n<img src='https://i-msdn.sec.s-msft.com/dynimg/IC138581.gif' atl=\"Nested Loop Join\" align=\"left\"/><br>\n\n这个操作符号，把两个不同列的数据集汇总到一张表中。提示信息中的Output List中有两个数据集，下面的数据集（inner set）会一一扫描与上面的数据集（out set），直到扫描完为止，这个操作才算是完成。\n\n对于被连接的数据子集较小的情况，嵌套循环连接是个较好的选择。在嵌套循环中，内表被外表驱动，外表返回的每一行都要在内表中检索找到与它匹配的行，因此整个查询返回的结果集不能太大\n\n### Merge Join\n\n<img src='https://i-msdn.sec.s-msft.com/dynimg/IC173813.gif' atl=\"Merge Join\" align=\"left\"/><br>\n\n这种关联算法是对两个已经排过序的集合进行合并。如果两个聚合是无序的则将先给集合排序再进行一一合并，由于是排过序的集合，左右两个集合自上而下合并效率是相当快的。\n\n通常情况下散列连接的效果都比排序合并连接要好，然而如果行源已经被排过序，在执行排序合并连接时不需要再排序了，这时排序合并连接的性能会优于散列连接。Merge join 用在没有索引，并且数据已经排序的情况。\n\n``` sql\nSELECT c.CustomerID\nFROM Sales.SalesOrderDetail od\nJOIN Sales.SalesOrderHeader oh\nON od.SalesOrderID = oh.SalesOrderID\nJOIN Sales.Customer c ON oh.CustomerID = c.CustomerID\n```\n\n![joinPlan](http://7xkfga.com1.z0.glb.clouddn.com/MergeJoin.png)\n\n由于没有使用WHERE语句，所以优化器对Customer表使用聚集索引扫描，对SalesOrderHeader表使用非聚集索引扫描\n\nCustomer表和SalesOrderHeader表使用Merge Join操作符进行关联，关联字段是CustomerID字段，这个字段在上面的索引扫描之后都是有序的。如果不是有序的，优化器会在前面进行排序或者是直接将两个表进行Hash Join连接。\n\n## 根据执行计划细节要做的优化操作\n\n1. 如果select * 通常情况下聚集索引会比非聚集索引更优。\n2. 如果出现Nested Loops，需要查下是否需要聚集索引，非聚集索引是否可以包含所有需要的列。\n3. Hash Match连接操作更适合于需要做Hashing算法集合很小的连接。\n4. Merge Join时需要检查下原有的集合是否已经有排序，如果没有排序，使用索引能否解决。\n5. 出现表扫描，聚集索引扫描，非聚集索引扫描时，考虑语句是否可以加where限制，select * 是否可以去除不必要的列。\n6. 出现Rid查找时，是否可以加索引优化解决。\n7. 在计划中看到不是你想要的索引时，看能否在语句中强制使用你想用的索引解决问题，强制使用索引的办法Select CluName1,CluName2 from Table with(index=IndexName)。\n8. 看到不是你想要的连接算法时，尝试强制使用你想要的算法解决问题。强制使用连接算法的语句：select * from t1 left join t2 on t1.id=t2.id option(Hash/Loop/Merge Join)\n9. 看到不是你想要的聚合算法是，尝试强制使用你想要的聚合算法。强制使用聚合算法的语句示例：select  age ,count(age) as cnt from t1 group by age  option(order/hash group)\n10. 看到不是你想要的解析执行顺序是，或这解析顺序耗时过大时，尝试强制使用你定的执行顺序。option（force order）\n11. 看到有多个线程来合并执行你的sql语句而影响到性能时，尝试强制是不并行操作。option（maxdop 1）\n12. 在存储过程中，由于参数不同导致执行计划不同，也影响啦性能时尝试指定参数来优化。option（optiomize for（@name='zlh'））\n13. 不操作多余的列，多余的行，不做务必要的聚合，排序。\n","source":"_posts/ø¥∂ÆSQL-Server÷¥––º∆ªÆ.md","raw":"---\ntitle: 看懂SQL Server执行计划\ndate: 2017-06-02 09:28:00\ntags:\n  - SQL Server\n\n---\n\n\n当我们写的SQL语句传到SQL Server的时候，查询分析器会将语句依次进行解析（Parse）、绑定（Bind）、查询优化（Optimization，有时候也被称为简化）、执行（Execution）。除去执行步骤外，前三个步骤之后就生成了执行计划，也就是SQL Server按照该计划获取物理数据方式，最后执行步骤按照执行计划执行查询从而获得结果。\n\n## 执行计划\n\n- 查询优化器对输入的 T-SQL 查询语句通过\"计算\"而选择出效率最高的一种执行方案，这个执行方案就是执行计划。\n- 执行计划可以告诉你这个查询将会被如何执行或者已经被如何执行过，可以通过执行计划看到 SQL 代码中那些效率比较低的地方。\n- 查看执行计划的方式我们可以通过图形化的界面，或者文本，或者XML格式查看，这样会比较方便理解执行计划要表达出来的意思。\n\n<!-- more -->\n\n当一个查询被提交到 SQL Server 后，服务器端很多进程实际上要做很多事情来确保数据出入的完整性。\n\n对于 T-SQL 来说, 处理的主要有两个阶段：关系引擎阶段( `relational engine`)和存储引擎阶段( `storage engine`)。\n\n- 关系引擎主要要做的事情就是首先确保 Query 语句能够正确的解析，然后交给查询优化并产生执行计划，然后执行计划就以二进制格式发到存储引擎来更新或者读取数据。\n\n- 存储引擎主要处理的比如像锁、索引的维护和事务等\n\n所以对于执行计划，重点的是关注关系引擎。\n\n## 估算执行计划和实际执行计划\n\nEstimated Execution Plans vs. Actual Execution Plans\n\n它们之间的区别就是: **估算的执行计划** 是从查询优化器来的，是输入关系引擎的，它的执行步骤包括一些运算符等等都是通过一系列的逻辑分析出来的，是一种通过逻辑推算出来的计划，只能代表查询优化器的观点；**实际执行计划** 是真实的执行了\"估算执行计划\"后的一种真实的结果，是实实在在真实的执行反馈, 是属于存储引擎。\n\n\n以上描述了关于执行计划的概念，下面以实际案例去解读一些基本语句， 例如`SELECT`, `UPDATE`,`INSERT`, `DELETE` 等查询的执行计划。\n\n------------------------------------我是分隔符-----------------------------------\n\n有大约78个执行计划中的操作符，可以去 [MSDN Book Online](https://msdn.microsoft.com/en-us/library/ms175913.aspx) 随时查\n\n下表表示一下常见的执行计划元素\n\n|  |   |   |\n|---|---|---|\n|**Select (Result)** | **Sort** | Spool                                     |\n|**Clustered Index Scan** | **Key Lookup** | Eager Spool             |\n|**NonClustered Index Scan** | **Compute Scalar** | Stream Aggregate |\n|**Clustered Index Seek** | Constant Scan | Distribute Streams   |\n|**NonClustered Index Seek** | **Table Scan** | Repartition Streams  |\n|**Hash Match** | **RID Lookup** | Gather Streams                    |\n|**Nested Loops** | **Filter** | Bitmap                              |\n|**Merge Join** | Lazy Spool | Split                             |\n\n\n操作符分为阻断式 `blocking` 和非阻断式`non-blocking`\n\n## 常见操作符的执行计划解释\n\n### Table Scan 表扫描\n\n<img src='https://i-msdn.sec.s-msft.com/dynimg/IC121534.gif' atl=\"Table Scan\" align=\"left\"/><br>\n\n\n当表中没有聚集索引，又没有合适索引的情况下，会出现这个操作。这个操作是很耗性能的，他的出现也意味着优化器要遍历整张表去查找你所需要的数据\n\n### Clustered Index Scan / Index Scan 聚集索引扫描/非聚集索引扫描\n\n<img src='https://i-msdn.sec.s-msft.com/dynimg/IC72069.gif' atl=\"Clustered Index Scan\" align=\"left\"/><br>\n\n这个图标两个操作都可以使用，一个聚集索引扫描，一个是非聚集索引扫描。\n\n- 聚集索引扫描：聚集索引的数据体积实际是就是表本身，也就是说表有多少行多少列，聚集所有就有多少行多少列，那么聚集索引扫描就跟表扫描差不多，也要进行全表扫描，遍历所有表数据，查找出你想要的数据。\n\n- 非聚集索引扫描：非聚集索引的体积是根据你的索引创建情况而定的，可以只包含你要查询的列。那么进行非聚集索引扫描，便是你非聚集中包含的列的所有行进行遍历，查找出你想要的数据。\n\n看下面这个查询\n\n``` sql\nSELECT ct.*\nFROM Person.ContactType AS ct;\n```\n\n这个表有一个聚簇索引PK_ContactType_ContactTypeID，聚簇索引的叶子结点是存储数据的，所以对于这个聚簇索引的扫描和全表扫面基本类似，基本也是一行一行地进行扫描来满足查询。\n\n![IndexScan](http://7xkfga.com1.z0.glb.clouddn.com/IndexScan.png)\n\n\n如果在执行计划中遇到索引扫描，说明查询有可能返回比需要更多的行，这时候建议使用 `WHERE`语句去优化查询，确保只是需要的那些行被返回。\n\n### Clustered Index Seek / Index Seek 聚集索引查找/非聚集索引查找\n\n<img src='https://i-msdn.sec.s-msft.com/dynimg/IC322.gif' atl=\"Clustered Index Scan\" align=\"left\"/><br>\n\n聚集索引查找和非聚集索引查找都是使用该图标。\n\n- 聚集索引查找：聚集索引包含整个表的数据，也就是在聚集索引的数据上根据键值取数据。\n\n- 非聚集索引查找：非聚集索引包含创建索引时所包含列的数据，在这些非聚集索引的数据上根据键值取数据。\n\n``` sql\nSELECT ct.*\nFROM Person.ContactType AS ct\nWHERE ct.ContactTypeID = 7\n```\n\n![IndexSeek](http://7xkfga.com1.z0.glb.clouddn.com/ClusterIndexSeek.png)\n\n这个表有一个聚簇索引PK_ContactType_ContactTypeID，建在ContactTypeID字段上，查询使用了这个聚簇索引来查找指定的数据。\n\n索引查找和索引扫描不同，使用查找可以让优化器准确地通过键值找到索引的位置。\n\n以上几种查询的性能对比：\n\n- [Table Scan] 表扫描（最慢）：对表记录逐行进行检查\n- [Clustered Index Scan] 聚集索引扫描（较慢）：按聚集索引对记录逐行进行检查\n- [Index Scan] 索引扫描（普通）：根据索引滤出部分数据在进行逐行检查\n- [Index Seek] 索引查找（较快）：根据索引定位记录所在位置再取出记录\n- [Clustered Index Seek] 聚集索引查找（最快）：直接根据聚集索引获取记录\n\n### Key Lookup 键值查找\n\n<img src='https://i-msdn.sec.s-msft.com/dynimg/IC165506.gif' atl=\"Key Lookup\" align=\"left\"/><br>\n\n首先需要说的是查找，查找与扫描在性能上完全不是一个级别的，扫描需要遍历整张表，而查找只需要通过键值直接提取数据，返回结果，性能要好。\n\n当你查找的列没有完全被非聚集索引包含，就需要使用键值查找在聚集索引上查找非聚集索引不包含的列。\n\n### RID Lookup RID查找\n\n<img src='https://i-msdn.sec.s-msft.com/dynimg/IC57221.gif' atl=\"RID Lookup\" align=\"left\"/><br>\n\n跟键值查找类似，只不过RID查找，是需要查找的列没有完全被非聚集索引包含，而剩余的列所在的表又不存在聚集索引，不能键值查找，只能根据行表示Rid来查询数据。\n\n\n``` sql\nSELECT p.BusinessEntityID\n     , p.LastName\n     , p.FirstName\n     , p.NameStyle\nFROM Person.Person AS p\nWHERE p.LastName LIKE 'Jaf%';\n```\n\n![keyLookup](http://7xkfga.com1.z0.glb.clouddn.com/keyLookup.png)\n\n`Person.Person` 表有非聚簇索引 `IX_Person_LastName_FirstName_MiddleName`作用在LastName、FirstName和MiddleName列上面，而列 `NameStyle`并没有被非聚集索引所包含，所以需要使用 `KeyLookUp`在聚集索引上查找不包含的列。如果这个列所在的表不存在聚集索引，那就只能通过RId，也就是行号在查询了。\n\n### Sort\n\n对数据集合进行排序，需要注意的是，有些数据集合在索引扫描后是自带排序的。\n\n### Filter\n\n根据出现在having之后的操作运算符，进行筛选\n\n### Computer Scalar\n\n在需要查询的列中需要自定义列，比如count(\\*) as cnt , select name+''+age 等会出现此符号。\n\n## JOIN 连接查询\n\n当多表连接时，SQL Server会采用三类不同的连接方式：散列连接，循环嵌套连接，合并连接\n\n\n### Hash Join\n\n<img src='https://i-msdn.sec.s-msft.com/dynimg/IC113753.gif' atl=\"Hash Match\" align=\"left\"/><br>\n\n这个图标有两种地方用到，一种是表关联，一种是数据聚合运算时 (`GROUP BY`)\n\n下面有两个概念：\n\n> Hashing：在数据库中根据每一行的数据内容，转换成唯一符号格式，存放到临时哈希表中，当需要原始数据时，可以给还原回来。类似加密解密技术，但是他能更有效的支持数据查询。\n\n> Hash Table：通过hashing处理，把数据以key/value的形式存储在表格中，在数据库中他被放在tempdb中。\n\nHash Join是做大数据集连接时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立散列表 `Hash Table`，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。这种方式适用于较小的表完全可以放于内存中的情况\n\n如果在执行计划中见到Hash Match Join，也许应该检查一下是不是缺少或者没有使用索引、没有用到WHERE等等。\n\n### Nested Loops Join\n\n<img src='https://i-msdn.sec.s-msft.com/dynimg/IC138581.gif' atl=\"Nested Loop Join\" align=\"left\"/><br>\n\n这个操作符号，把两个不同列的数据集汇总到一张表中。提示信息中的Output List中有两个数据集，下面的数据集（inner set）会一一扫描与上面的数据集（out set），直到扫描完为止，这个操作才算是完成。\n\n对于被连接的数据子集较小的情况，嵌套循环连接是个较好的选择。在嵌套循环中，内表被外表驱动，外表返回的每一行都要在内表中检索找到与它匹配的行，因此整个查询返回的结果集不能太大\n\n### Merge Join\n\n<img src='https://i-msdn.sec.s-msft.com/dynimg/IC173813.gif' atl=\"Merge Join\" align=\"left\"/><br>\n\n这种关联算法是对两个已经排过序的集合进行合并。如果两个聚合是无序的则将先给集合排序再进行一一合并，由于是排过序的集合，左右两个集合自上而下合并效率是相当快的。\n\n通常情况下散列连接的效果都比排序合并连接要好，然而如果行源已经被排过序，在执行排序合并连接时不需要再排序了，这时排序合并连接的性能会优于散列连接。Merge join 用在没有索引，并且数据已经排序的情况。\n\n``` sql\nSELECT c.CustomerID\nFROM Sales.SalesOrderDetail od\nJOIN Sales.SalesOrderHeader oh\nON od.SalesOrderID = oh.SalesOrderID\nJOIN Sales.Customer c ON oh.CustomerID = c.CustomerID\n```\n\n![joinPlan](http://7xkfga.com1.z0.glb.clouddn.com/MergeJoin.png)\n\n由于没有使用WHERE语句，所以优化器对Customer表使用聚集索引扫描，对SalesOrderHeader表使用非聚集索引扫描\n\nCustomer表和SalesOrderHeader表使用Merge Join操作符进行关联，关联字段是CustomerID字段，这个字段在上面的索引扫描之后都是有序的。如果不是有序的，优化器会在前面进行排序或者是直接将两个表进行Hash Join连接。\n\n## 根据执行计划细节要做的优化操作\n\n1. 如果select * 通常情况下聚集索引会比非聚集索引更优。\n2. 如果出现Nested Loops，需要查下是否需要聚集索引，非聚集索引是否可以包含所有需要的列。\n3. Hash Match连接操作更适合于需要做Hashing算法集合很小的连接。\n4. Merge Join时需要检查下原有的集合是否已经有排序，如果没有排序，使用索引能否解决。\n5. 出现表扫描，聚集索引扫描，非聚集索引扫描时，考虑语句是否可以加where限制，select * 是否可以去除不必要的列。\n6. 出现Rid查找时，是否可以加索引优化解决。\n7. 在计划中看到不是你想要的索引时，看能否在语句中强制使用你想用的索引解决问题，强制使用索引的办法Select CluName1,CluName2 from Table with(index=IndexName)。\n8. 看到不是你想要的连接算法时，尝试强制使用你想要的算法解决问题。强制使用连接算法的语句：select * from t1 left join t2 on t1.id=t2.id option(Hash/Loop/Merge Join)\n9. 看到不是你想要的聚合算法是，尝试强制使用你想要的聚合算法。强制使用聚合算法的语句示例：select  age ,count(age) as cnt from t1 group by age  option(order/hash group)\n10. 看到不是你想要的解析执行顺序是，或这解析顺序耗时过大时，尝试强制使用你定的执行顺序。option（force order）\n11. 看到有多个线程来合并执行你的sql语句而影响到性能时，尝试强制是不并行操作。option（maxdop 1）\n12. 在存储过程中，由于参数不同导致执行计划不同，也影响啦性能时尝试指定参数来优化。option（optiomize for（@name='zlh'））\n13. 不操作多余的列，多余的行，不做务必要的聚合，排序。\n","slug":"ø¥∂ÆSQL-Server÷¥––º∆ªÆ","published":1,"updated":"2017-06-13T08:13:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3pa004kzd680gqifh2n","content":"<p>当我们写的SQL语句传到SQL Server的时候，查询分析器会将语句依次进行解析（Parse）、绑定（Bind）、查询优化（Optimization，有时候也被称为简化）、执行（Execution）。除去执行步骤外，前三个步骤之后就生成了执行计划，也就是SQL Server按照该计划获取物理数据方式，最后执行步骤按照执行计划执行查询从而获得结果。</p>\n<h2 id=\"执行计划\"><a href=\"#执行计划\" class=\"headerlink\" title=\"执行计划\"></a>执行计划</h2><ul>\n<li>查询优化器对输入的 T-SQL 查询语句通过”计算”而选择出效率最高的一种执行方案，这个执行方案就是执行计划。</li>\n<li>执行计划可以告诉你这个查询将会被如何执行或者已经被如何执行过，可以通过执行计划看到 SQL 代码中那些效率比较低的地方。</li>\n<li>查看执行计划的方式我们可以通过图形化的界面，或者文本，或者XML格式查看，这样会比较方便理解执行计划要表达出来的意思。</li>\n</ul>\n<a id=\"more\"></a>\n<p>当一个查询被提交到 SQL Server 后，服务器端很多进程实际上要做很多事情来确保数据出入的完整性。</p>\n<p>对于 T-SQL 来说, 处理的主要有两个阶段：关系引擎阶段( <code>relational engine</code>)和存储引擎阶段( <code>storage engine</code>)。</p>\n<ul>\n<li><p>关系引擎主要要做的事情就是首先确保 Query 语句能够正确的解析，然后交给查询优化并产生执行计划，然后执行计划就以二进制格式发到存储引擎来更新或者读取数据。</p>\n</li>\n<li><p>存储引擎主要处理的比如像锁、索引的维护和事务等</p>\n</li>\n</ul>\n<p>所以对于执行计划，重点的是关注关系引擎。</p>\n<h2 id=\"估算执行计划和实际执行计划\"><a href=\"#估算执行计划和实际执行计划\" class=\"headerlink\" title=\"估算执行计划和实际执行计划\"></a>估算执行计划和实际执行计划</h2><p>Estimated Execution Plans vs. Actual Execution Plans</p>\n<p>它们之间的区别就是: <strong>估算的执行计划</strong> 是从查询优化器来的，是输入关系引擎的，它的执行步骤包括一些运算符等等都是通过一系列的逻辑分析出来的，是一种通过逻辑推算出来的计划，只能代表查询优化器的观点；<strong>实际执行计划</strong> 是真实的执行了”估算执行计划”后的一种真实的结果，是实实在在真实的执行反馈, 是属于存储引擎。</p>\n<p>以上描述了关于执行计划的概念，下面以实际案例去解读一些基本语句， 例如<code>SELECT</code>, <code>UPDATE</code>,<code>INSERT</code>, <code>DELETE</code> 等查询的执行计划。</p>\n<p>————————————我是分隔符———————————–</p>\n<p>有大约78个执行计划中的操作符，可以去 <a href=\"https://msdn.microsoft.com/en-us/library/ms175913.aspx\" target=\"_blank\" rel=\"noopener\">MSDN Book Online</a> 随时查</p>\n<p>下表表示一下常见的执行计划元素</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Select (Result)</strong></td>\n<td><strong>Sort</strong></td>\n<td>Spool</td>\n</tr>\n<tr>\n<td><strong>Clustered Index Scan</strong></td>\n<td><strong>Key Lookup</strong></td>\n<td>Eager Spool</td>\n</tr>\n<tr>\n<td><strong>NonClustered Index Scan</strong></td>\n<td><strong>Compute Scalar</strong></td>\n<td>Stream Aggregate</td>\n</tr>\n<tr>\n<td><strong>Clustered Index Seek</strong></td>\n<td>Constant Scan</td>\n<td>Distribute Streams</td>\n</tr>\n<tr>\n<td><strong>NonClustered Index Seek</strong></td>\n<td><strong>Table Scan</strong></td>\n<td>Repartition Streams</td>\n</tr>\n<tr>\n<td><strong>Hash Match</strong></td>\n<td><strong>RID Lookup</strong></td>\n<td>Gather Streams</td>\n</tr>\n<tr>\n<td><strong>Nested Loops</strong></td>\n<td><strong>Filter</strong></td>\n<td>Bitmap</td>\n</tr>\n<tr>\n<td><strong>Merge Join</strong></td>\n<td>Lazy Spool</td>\n<td>Split</td>\n</tr>\n</tbody>\n</table>\n<p>操作符分为阻断式 <code>blocking</code> 和非阻断式<code>non-blocking</code></p>\n<h2 id=\"常见操作符的执行计划解释\"><a href=\"#常见操作符的执行计划解释\" class=\"headerlink\" title=\"常见操作符的执行计划解释\"></a>常见操作符的执行计划解释</h2><h3 id=\"Table-Scan-表扫描\"><a href=\"#Table-Scan-表扫描\" class=\"headerlink\" title=\"Table Scan 表扫描\"></a>Table Scan 表扫描</h3><p><img src=\"https://i-msdn.sec.s-msft.com/dynimg/IC121534.gif\" atl=\"Table Scan\" align=\"left\"><br></p>\n<p>当表中没有聚集索引，又没有合适索引的情况下，会出现这个操作。这个操作是很耗性能的，他的出现也意味着优化器要遍历整张表去查找你所需要的数据</p>\n<h3 id=\"Clustered-Index-Scan-Index-Scan-聚集索引扫描-非聚集索引扫描\"><a href=\"#Clustered-Index-Scan-Index-Scan-聚集索引扫描-非聚集索引扫描\" class=\"headerlink\" title=\"Clustered Index Scan / Index Scan 聚集索引扫描/非聚集索引扫描\"></a>Clustered Index Scan / Index Scan 聚集索引扫描/非聚集索引扫描</h3><p><img src=\"https://i-msdn.sec.s-msft.com/dynimg/IC72069.gif\" atl=\"Clustered Index Scan\" align=\"left\"><br></p>\n<p>这个图标两个操作都可以使用，一个聚集索引扫描，一个是非聚集索引扫描。</p>\n<ul>\n<li><p>聚集索引扫描：聚集索引的数据体积实际是就是表本身，也就是说表有多少行多少列，聚集所有就有多少行多少列，那么聚集索引扫描就跟表扫描差不多，也要进行全表扫描，遍历所有表数据，查找出你想要的数据。</p>\n</li>\n<li><p>非聚集索引扫描：非聚集索引的体积是根据你的索引创建情况而定的，可以只包含你要查询的列。那么进行非聚集索引扫描，便是你非聚集中包含的列的所有行进行遍历，查找出你想要的数据。</p>\n</li>\n</ul>\n<p>看下面这个查询</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ct.*</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Person.ContactType <span class=\"keyword\">AS</span> ct;</span><br></pre></td></tr></table></figure>\n<p>这个表有一个聚簇索引PK_ContactType_ContactTypeID，聚簇索引的叶子结点是存储数据的，所以对于这个聚簇索引的扫描和全表扫面基本类似，基本也是一行一行地进行扫描来满足查询。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/IndexScan.png\" alt=\"IndexScan\"></p>\n<p>如果在执行计划中遇到索引扫描，说明查询有可能返回比需要更多的行，这时候建议使用 <code>WHERE</code>语句去优化查询，确保只是需要的那些行被返回。</p>\n<h3 id=\"Clustered-Index-Seek-Index-Seek-聚集索引查找-非聚集索引查找\"><a href=\"#Clustered-Index-Seek-Index-Seek-聚集索引查找-非聚集索引查找\" class=\"headerlink\" title=\"Clustered Index Seek / Index Seek 聚集索引查找/非聚集索引查找\"></a>Clustered Index Seek / Index Seek 聚集索引查找/非聚集索引查找</h3><p><img src=\"https://i-msdn.sec.s-msft.com/dynimg/IC322.gif\" atl=\"Clustered Index Scan\" align=\"left\"><br></p>\n<p>聚集索引查找和非聚集索引查找都是使用该图标。</p>\n<ul>\n<li><p>聚集索引查找：聚集索引包含整个表的数据，也就是在聚集索引的数据上根据键值取数据。</p>\n</li>\n<li><p>非聚集索引查找：非聚集索引包含创建索引时所包含列的数据，在这些非聚集索引的数据上根据键值取数据。</p>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ct.*</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Person.ContactType <span class=\"keyword\">AS</span> ct</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> ct.ContactTypeID = <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/ClusterIndexSeek.png\" alt=\"IndexSeek\"></p>\n<p>这个表有一个聚簇索引PK_ContactType_ContactTypeID，建在ContactTypeID字段上，查询使用了这个聚簇索引来查找指定的数据。</p>\n<p>索引查找和索引扫描不同，使用查找可以让优化器准确地通过键值找到索引的位置。</p>\n<p>以上几种查询的性能对比：</p>\n<ul>\n<li>[Table Scan] 表扫描（最慢）：对表记录逐行进行检查</li>\n<li>[Clustered Index Scan] 聚集索引扫描（较慢）：按聚集索引对记录逐行进行检查</li>\n<li>[Index Scan] 索引扫描（普通）：根据索引滤出部分数据在进行逐行检查</li>\n<li>[Index Seek] 索引查找（较快）：根据索引定位记录所在位置再取出记录</li>\n<li>[Clustered Index Seek] 聚集索引查找（最快）：直接根据聚集索引获取记录</li>\n</ul>\n<h3 id=\"Key-Lookup-键值查找\"><a href=\"#Key-Lookup-键值查找\" class=\"headerlink\" title=\"Key Lookup 键值查找\"></a>Key Lookup 键值查找</h3><p><img src=\"https://i-msdn.sec.s-msft.com/dynimg/IC165506.gif\" atl=\"Key Lookup\" align=\"left\"><br></p>\n<p>首先需要说的是查找，查找与扫描在性能上完全不是一个级别的，扫描需要遍历整张表，而查找只需要通过键值直接提取数据，返回结果，性能要好。</p>\n<p>当你查找的列没有完全被非聚集索引包含，就需要使用键值查找在聚集索引上查找非聚集索引不包含的列。</p>\n<h3 id=\"RID-Lookup-RID查找\"><a href=\"#RID-Lookup-RID查找\" class=\"headerlink\" title=\"RID Lookup RID查找\"></a>RID Lookup RID查找</h3><p><img src=\"https://i-msdn.sec.s-msft.com/dynimg/IC57221.gif\" atl=\"RID Lookup\" align=\"left\"><br></p>\n<p>跟键值查找类似，只不过RID查找，是需要查找的列没有完全被非聚集索引包含，而剩余的列所在的表又不存在聚集索引，不能键值查找，只能根据行表示Rid来查询数据。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> p.BusinessEntityID</span><br><span class=\"line\">     , p.LastName</span><br><span class=\"line\">     , p.FirstName</span><br><span class=\"line\">     , p.NameStyle</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Person.Person <span class=\"keyword\">AS</span> p</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> p.LastName <span class=\"keyword\">LIKE</span> <span class=\"string\">'Jaf%'</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/keyLookup.png\" alt=\"keyLookup\"></p>\n<p><code>Person.Person</code> 表有非聚簇索引 <code>IX_Person_LastName_FirstName_MiddleName</code>作用在LastName、FirstName和MiddleName列上面，而列 <code>NameStyle</code>并没有被非聚集索引所包含，所以需要使用 <code>KeyLookUp</code>在聚集索引上查找不包含的列。如果这个列所在的表不存在聚集索引，那就只能通过RId，也就是行号在查询了。</p>\n<h3 id=\"Sort\"><a href=\"#Sort\" class=\"headerlink\" title=\"Sort\"></a>Sort</h3><p>对数据集合进行排序，需要注意的是，有些数据集合在索引扫描后是自带排序的。</p>\n<h3 id=\"Filter\"><a href=\"#Filter\" class=\"headerlink\" title=\"Filter\"></a>Filter</h3><p>根据出现在having之后的操作运算符，进行筛选</p>\n<h3 id=\"Computer-Scalar\"><a href=\"#Computer-Scalar\" class=\"headerlink\" title=\"Computer Scalar\"></a>Computer Scalar</h3><p>在需要查询的列中需要自定义列，比如count(*) as cnt , select name+’’+age 等会出现此符号。</p>\n<h2 id=\"JOIN-连接查询\"><a href=\"#JOIN-连接查询\" class=\"headerlink\" title=\"JOIN 连接查询\"></a>JOIN 连接查询</h2><p>当多表连接时，SQL Server会采用三类不同的连接方式：散列连接，循环嵌套连接，合并连接</p>\n<h3 id=\"Hash-Join\"><a href=\"#Hash-Join\" class=\"headerlink\" title=\"Hash Join\"></a>Hash Join</h3><p><img src=\"https://i-msdn.sec.s-msft.com/dynimg/IC113753.gif\" atl=\"Hash Match\" align=\"left\"><br></p>\n<p>这个图标有两种地方用到，一种是表关联，一种是数据聚合运算时 (<code>GROUP BY</code>)</p>\n<p>下面有两个概念：</p>\n<blockquote>\n<p>Hashing：在数据库中根据每一行的数据内容，转换成唯一符号格式，存放到临时哈希表中，当需要原始数据时，可以给还原回来。类似加密解密技术，但是他能更有效的支持数据查询。</p>\n</blockquote>\n<blockquote>\n<p>Hash Table：通过hashing处理，把数据以key/value的形式存储在表格中，在数据库中他被放在tempdb中。</p>\n</blockquote>\n<p>Hash Join是做大数据集连接时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立散列表 <code>Hash Table</code>，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。这种方式适用于较小的表完全可以放于内存中的情况</p>\n<p>如果在执行计划中见到Hash Match Join，也许应该检查一下是不是缺少或者没有使用索引、没有用到WHERE等等。</p>\n<h3 id=\"Nested-Loops-Join\"><a href=\"#Nested-Loops-Join\" class=\"headerlink\" title=\"Nested Loops Join\"></a>Nested Loops Join</h3><p><img src=\"https://i-msdn.sec.s-msft.com/dynimg/IC138581.gif\" atl=\"Nested Loop Join\" align=\"left\"><br></p>\n<p>这个操作符号，把两个不同列的数据集汇总到一张表中。提示信息中的Output List中有两个数据集，下面的数据集（inner set）会一一扫描与上面的数据集（out set），直到扫描完为止，这个操作才算是完成。</p>\n<p>对于被连接的数据子集较小的情况，嵌套循环连接是个较好的选择。在嵌套循环中，内表被外表驱动，外表返回的每一行都要在内表中检索找到与它匹配的行，因此整个查询返回的结果集不能太大</p>\n<h3 id=\"Merge-Join\"><a href=\"#Merge-Join\" class=\"headerlink\" title=\"Merge Join\"></a>Merge Join</h3><p><img src=\"https://i-msdn.sec.s-msft.com/dynimg/IC173813.gif\" atl=\"Merge Join\" align=\"left\"><br></p>\n<p>这种关联算法是对两个已经排过序的集合进行合并。如果两个聚合是无序的则将先给集合排序再进行一一合并，由于是排过序的集合，左右两个集合自上而下合并效率是相当快的。</p>\n<p>通常情况下散列连接的效果都比排序合并连接要好，然而如果行源已经被排过序，在执行排序合并连接时不需要再排序了，这时排序合并连接的性能会优于散列连接。Merge join 用在没有索引，并且数据已经排序的情况。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> c.CustomerID</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.SalesOrderDetail od</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> Sales.SalesOrderHeader oh</span><br><span class=\"line\"><span class=\"keyword\">ON</span> od.SalesOrderID = oh.SalesOrderID</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> Sales.Customer c <span class=\"keyword\">ON</span> oh.CustomerID = c.CustomerID</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/MergeJoin.png\" alt=\"joinPlan\"></p>\n<p>由于没有使用WHERE语句，所以优化器对Customer表使用聚集索引扫描，对SalesOrderHeader表使用非聚集索引扫描</p>\n<p>Customer表和SalesOrderHeader表使用Merge Join操作符进行关联，关联字段是CustomerID字段，这个字段在上面的索引扫描之后都是有序的。如果不是有序的，优化器会在前面进行排序或者是直接将两个表进行Hash Join连接。</p>\n<h2 id=\"根据执行计划细节要做的优化操作\"><a href=\"#根据执行计划细节要做的优化操作\" class=\"headerlink\" title=\"根据执行计划细节要做的优化操作\"></a>根据执行计划细节要做的优化操作</h2><ol>\n<li>如果select * 通常情况下聚集索引会比非聚集索引更优。</li>\n<li>如果出现Nested Loops，需要查下是否需要聚集索引，非聚集索引是否可以包含所有需要的列。</li>\n<li>Hash Match连接操作更适合于需要做Hashing算法集合很小的连接。</li>\n<li>Merge Join时需要检查下原有的集合是否已经有排序，如果没有排序，使用索引能否解决。</li>\n<li>出现表扫描，聚集索引扫描，非聚集索引扫描时，考虑语句是否可以加where限制，select * 是否可以去除不必要的列。</li>\n<li>出现Rid查找时，是否可以加索引优化解决。</li>\n<li>在计划中看到不是你想要的索引时，看能否在语句中强制使用你想用的索引解决问题，强制使用索引的办法Select CluName1,CluName2 from Table with(index=IndexName)。</li>\n<li>看到不是你想要的连接算法时，尝试强制使用你想要的算法解决问题。强制使用连接算法的语句：select * from t1 left join t2 on t1.id=t2.id option(Hash/Loop/Merge Join)</li>\n<li>看到不是你想要的聚合算法是，尝试强制使用你想要的聚合算法。强制使用聚合算法的语句示例：select  age ,count(age) as cnt from t1 group by age  option(order/hash group)</li>\n<li>看到不是你想要的解析执行顺序是，或这解析顺序耗时过大时，尝试强制使用你定的执行顺序。option（force order）</li>\n<li>看到有多个线程来合并执行你的sql语句而影响到性能时，尝试强制是不并行操作。option（maxdop 1）</li>\n<li>在存储过程中，由于参数不同导致执行计划不同，也影响啦性能时尝试指定参数来优化。option（optiomize for（@name=’zlh’））</li>\n<li>不操作多余的列，多余的行，不做务必要的聚合，排序。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>当我们写的SQL语句传到SQL Server的时候，查询分析器会将语句依次进行解析（Parse）、绑定（Bind）、查询优化（Optimization，有时候也被称为简化）、执行（Execution）。除去执行步骤外，前三个步骤之后就生成了执行计划，也就是SQL Server按照该计划获取物理数据方式，最后执行步骤按照执行计划执行查询从而获得结果。</p>\n<h2 id=\"执行计划\"><a href=\"#执行计划\" class=\"headerlink\" title=\"执行计划\"></a>执行计划</h2><ul>\n<li>查询优化器对输入的 T-SQL 查询语句通过”计算”而选择出效率最高的一种执行方案，这个执行方案就是执行计划。</li>\n<li>执行计划可以告诉你这个查询将会被如何执行或者已经被如何执行过，可以通过执行计划看到 SQL 代码中那些效率比较低的地方。</li>\n<li>查看执行计划的方式我们可以通过图形化的界面，或者文本，或者XML格式查看，这样会比较方便理解执行计划要表达出来的意思。</li>\n</ul>","more":"<p>当一个查询被提交到 SQL Server 后，服务器端很多进程实际上要做很多事情来确保数据出入的完整性。</p>\n<p>对于 T-SQL 来说, 处理的主要有两个阶段：关系引擎阶段( <code>relational engine</code>)和存储引擎阶段( <code>storage engine</code>)。</p>\n<ul>\n<li><p>关系引擎主要要做的事情就是首先确保 Query 语句能够正确的解析，然后交给查询优化并产生执行计划，然后执行计划就以二进制格式发到存储引擎来更新或者读取数据。</p>\n</li>\n<li><p>存储引擎主要处理的比如像锁、索引的维护和事务等</p>\n</li>\n</ul>\n<p>所以对于执行计划，重点的是关注关系引擎。</p>\n<h2 id=\"估算执行计划和实际执行计划\"><a href=\"#估算执行计划和实际执行计划\" class=\"headerlink\" title=\"估算执行计划和实际执行计划\"></a>估算执行计划和实际执行计划</h2><p>Estimated Execution Plans vs. Actual Execution Plans</p>\n<p>它们之间的区别就是: <strong>估算的执行计划</strong> 是从查询优化器来的，是输入关系引擎的，它的执行步骤包括一些运算符等等都是通过一系列的逻辑分析出来的，是一种通过逻辑推算出来的计划，只能代表查询优化器的观点；<strong>实际执行计划</strong> 是真实的执行了”估算执行计划”后的一种真实的结果，是实实在在真实的执行反馈, 是属于存储引擎。</p>\n<p>以上描述了关于执行计划的概念，下面以实际案例去解读一些基本语句， 例如<code>SELECT</code>, <code>UPDATE</code>,<code>INSERT</code>, <code>DELETE</code> 等查询的执行计划。</p>\n<p>————————————我是分隔符———————————–</p>\n<p>有大约78个执行计划中的操作符，可以去 <a href=\"https://msdn.microsoft.com/en-us/library/ms175913.aspx\" target=\"_blank\" rel=\"noopener\">MSDN Book Online</a> 随时查</p>\n<p>下表表示一下常见的执行计划元素</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Select (Result)</strong></td>\n<td><strong>Sort</strong></td>\n<td>Spool</td>\n</tr>\n<tr>\n<td><strong>Clustered Index Scan</strong></td>\n<td><strong>Key Lookup</strong></td>\n<td>Eager Spool</td>\n</tr>\n<tr>\n<td><strong>NonClustered Index Scan</strong></td>\n<td><strong>Compute Scalar</strong></td>\n<td>Stream Aggregate</td>\n</tr>\n<tr>\n<td><strong>Clustered Index Seek</strong></td>\n<td>Constant Scan</td>\n<td>Distribute Streams</td>\n</tr>\n<tr>\n<td><strong>NonClustered Index Seek</strong></td>\n<td><strong>Table Scan</strong></td>\n<td>Repartition Streams</td>\n</tr>\n<tr>\n<td><strong>Hash Match</strong></td>\n<td><strong>RID Lookup</strong></td>\n<td>Gather Streams</td>\n</tr>\n<tr>\n<td><strong>Nested Loops</strong></td>\n<td><strong>Filter</strong></td>\n<td>Bitmap</td>\n</tr>\n<tr>\n<td><strong>Merge Join</strong></td>\n<td>Lazy Spool</td>\n<td>Split</td>\n</tr>\n</tbody>\n</table>\n<p>操作符分为阻断式 <code>blocking</code> 和非阻断式<code>non-blocking</code></p>\n<h2 id=\"常见操作符的执行计划解释\"><a href=\"#常见操作符的执行计划解释\" class=\"headerlink\" title=\"常见操作符的执行计划解释\"></a>常见操作符的执行计划解释</h2><h3 id=\"Table-Scan-表扫描\"><a href=\"#Table-Scan-表扫描\" class=\"headerlink\" title=\"Table Scan 表扫描\"></a>Table Scan 表扫描</h3><p><img src=\"https://i-msdn.sec.s-msft.com/dynimg/IC121534.gif\" atl=\"Table Scan\" align=\"left\"><br></p>\n<p>当表中没有聚集索引，又没有合适索引的情况下，会出现这个操作。这个操作是很耗性能的，他的出现也意味着优化器要遍历整张表去查找你所需要的数据</p>\n<h3 id=\"Clustered-Index-Scan-Index-Scan-聚集索引扫描-非聚集索引扫描\"><a href=\"#Clustered-Index-Scan-Index-Scan-聚集索引扫描-非聚集索引扫描\" class=\"headerlink\" title=\"Clustered Index Scan / Index Scan 聚集索引扫描/非聚集索引扫描\"></a>Clustered Index Scan / Index Scan 聚集索引扫描/非聚集索引扫描</h3><p><img src=\"https://i-msdn.sec.s-msft.com/dynimg/IC72069.gif\" atl=\"Clustered Index Scan\" align=\"left\"><br></p>\n<p>这个图标两个操作都可以使用，一个聚集索引扫描，一个是非聚集索引扫描。</p>\n<ul>\n<li><p>聚集索引扫描：聚集索引的数据体积实际是就是表本身，也就是说表有多少行多少列，聚集所有就有多少行多少列，那么聚集索引扫描就跟表扫描差不多，也要进行全表扫描，遍历所有表数据，查找出你想要的数据。</p>\n</li>\n<li><p>非聚集索引扫描：非聚集索引的体积是根据你的索引创建情况而定的，可以只包含你要查询的列。那么进行非聚集索引扫描，便是你非聚集中包含的列的所有行进行遍历，查找出你想要的数据。</p>\n</li>\n</ul>\n<p>看下面这个查询</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ct.*</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Person.ContactType <span class=\"keyword\">AS</span> ct;</span><br></pre></td></tr></table></figure>\n<p>这个表有一个聚簇索引PK_ContactType_ContactTypeID，聚簇索引的叶子结点是存储数据的，所以对于这个聚簇索引的扫描和全表扫面基本类似，基本也是一行一行地进行扫描来满足查询。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/IndexScan.png\" alt=\"IndexScan\"></p>\n<p>如果在执行计划中遇到索引扫描，说明查询有可能返回比需要更多的行，这时候建议使用 <code>WHERE</code>语句去优化查询，确保只是需要的那些行被返回。</p>\n<h3 id=\"Clustered-Index-Seek-Index-Seek-聚集索引查找-非聚集索引查找\"><a href=\"#Clustered-Index-Seek-Index-Seek-聚集索引查找-非聚集索引查找\" class=\"headerlink\" title=\"Clustered Index Seek / Index Seek 聚集索引查找/非聚集索引查找\"></a>Clustered Index Seek / Index Seek 聚集索引查找/非聚集索引查找</h3><p><img src=\"https://i-msdn.sec.s-msft.com/dynimg/IC322.gif\" atl=\"Clustered Index Scan\" align=\"left\"><br></p>\n<p>聚集索引查找和非聚集索引查找都是使用该图标。</p>\n<ul>\n<li><p>聚集索引查找：聚集索引包含整个表的数据，也就是在聚集索引的数据上根据键值取数据。</p>\n</li>\n<li><p>非聚集索引查找：非聚集索引包含创建索引时所包含列的数据，在这些非聚集索引的数据上根据键值取数据。</p>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ct.*</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Person.ContactType <span class=\"keyword\">AS</span> ct</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> ct.ContactTypeID = <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/ClusterIndexSeek.png\" alt=\"IndexSeek\"></p>\n<p>这个表有一个聚簇索引PK_ContactType_ContactTypeID，建在ContactTypeID字段上，查询使用了这个聚簇索引来查找指定的数据。</p>\n<p>索引查找和索引扫描不同，使用查找可以让优化器准确地通过键值找到索引的位置。</p>\n<p>以上几种查询的性能对比：</p>\n<ul>\n<li>[Table Scan] 表扫描（最慢）：对表记录逐行进行检查</li>\n<li>[Clustered Index Scan] 聚集索引扫描（较慢）：按聚集索引对记录逐行进行检查</li>\n<li>[Index Scan] 索引扫描（普通）：根据索引滤出部分数据在进行逐行检查</li>\n<li>[Index Seek] 索引查找（较快）：根据索引定位记录所在位置再取出记录</li>\n<li>[Clustered Index Seek] 聚集索引查找（最快）：直接根据聚集索引获取记录</li>\n</ul>\n<h3 id=\"Key-Lookup-键值查找\"><a href=\"#Key-Lookup-键值查找\" class=\"headerlink\" title=\"Key Lookup 键值查找\"></a>Key Lookup 键值查找</h3><p><img src=\"https://i-msdn.sec.s-msft.com/dynimg/IC165506.gif\" atl=\"Key Lookup\" align=\"left\"><br></p>\n<p>首先需要说的是查找，查找与扫描在性能上完全不是一个级别的，扫描需要遍历整张表，而查找只需要通过键值直接提取数据，返回结果，性能要好。</p>\n<p>当你查找的列没有完全被非聚集索引包含，就需要使用键值查找在聚集索引上查找非聚集索引不包含的列。</p>\n<h3 id=\"RID-Lookup-RID查找\"><a href=\"#RID-Lookup-RID查找\" class=\"headerlink\" title=\"RID Lookup RID查找\"></a>RID Lookup RID查找</h3><p><img src=\"https://i-msdn.sec.s-msft.com/dynimg/IC57221.gif\" atl=\"RID Lookup\" align=\"left\"><br></p>\n<p>跟键值查找类似，只不过RID查找，是需要查找的列没有完全被非聚集索引包含，而剩余的列所在的表又不存在聚集索引，不能键值查找，只能根据行表示Rid来查询数据。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> p.BusinessEntityID</span><br><span class=\"line\">     , p.LastName</span><br><span class=\"line\">     , p.FirstName</span><br><span class=\"line\">     , p.NameStyle</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Person.Person <span class=\"keyword\">AS</span> p</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> p.LastName <span class=\"keyword\">LIKE</span> <span class=\"string\">'Jaf%'</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/keyLookup.png\" alt=\"keyLookup\"></p>\n<p><code>Person.Person</code> 表有非聚簇索引 <code>IX_Person_LastName_FirstName_MiddleName</code>作用在LastName、FirstName和MiddleName列上面，而列 <code>NameStyle</code>并没有被非聚集索引所包含，所以需要使用 <code>KeyLookUp</code>在聚集索引上查找不包含的列。如果这个列所在的表不存在聚集索引，那就只能通过RId，也就是行号在查询了。</p>\n<h3 id=\"Sort\"><a href=\"#Sort\" class=\"headerlink\" title=\"Sort\"></a>Sort</h3><p>对数据集合进行排序，需要注意的是，有些数据集合在索引扫描后是自带排序的。</p>\n<h3 id=\"Filter\"><a href=\"#Filter\" class=\"headerlink\" title=\"Filter\"></a>Filter</h3><p>根据出现在having之后的操作运算符，进行筛选</p>\n<h3 id=\"Computer-Scalar\"><a href=\"#Computer-Scalar\" class=\"headerlink\" title=\"Computer Scalar\"></a>Computer Scalar</h3><p>在需要查询的列中需要自定义列，比如count(*) as cnt , select name+’’+age 等会出现此符号。</p>\n<h2 id=\"JOIN-连接查询\"><a href=\"#JOIN-连接查询\" class=\"headerlink\" title=\"JOIN 连接查询\"></a>JOIN 连接查询</h2><p>当多表连接时，SQL Server会采用三类不同的连接方式：散列连接，循环嵌套连接，合并连接</p>\n<h3 id=\"Hash-Join\"><a href=\"#Hash-Join\" class=\"headerlink\" title=\"Hash Join\"></a>Hash Join</h3><p><img src=\"https://i-msdn.sec.s-msft.com/dynimg/IC113753.gif\" atl=\"Hash Match\" align=\"left\"><br></p>\n<p>这个图标有两种地方用到，一种是表关联，一种是数据聚合运算时 (<code>GROUP BY</code>)</p>\n<p>下面有两个概念：</p>\n<blockquote>\n<p>Hashing：在数据库中根据每一行的数据内容，转换成唯一符号格式，存放到临时哈希表中，当需要原始数据时，可以给还原回来。类似加密解密技术，但是他能更有效的支持数据查询。</p>\n</blockquote>\n<blockquote>\n<p>Hash Table：通过hashing处理，把数据以key/value的形式存储在表格中，在数据库中他被放在tempdb中。</p>\n</blockquote>\n<p>Hash Join是做大数据集连接时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立散列表 <code>Hash Table</code>，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。这种方式适用于较小的表完全可以放于内存中的情况</p>\n<p>如果在执行计划中见到Hash Match Join，也许应该检查一下是不是缺少或者没有使用索引、没有用到WHERE等等。</p>\n<h3 id=\"Nested-Loops-Join\"><a href=\"#Nested-Loops-Join\" class=\"headerlink\" title=\"Nested Loops Join\"></a>Nested Loops Join</h3><p><img src=\"https://i-msdn.sec.s-msft.com/dynimg/IC138581.gif\" atl=\"Nested Loop Join\" align=\"left\"><br></p>\n<p>这个操作符号，把两个不同列的数据集汇总到一张表中。提示信息中的Output List中有两个数据集，下面的数据集（inner set）会一一扫描与上面的数据集（out set），直到扫描完为止，这个操作才算是完成。</p>\n<p>对于被连接的数据子集较小的情况，嵌套循环连接是个较好的选择。在嵌套循环中，内表被外表驱动，外表返回的每一行都要在内表中检索找到与它匹配的行，因此整个查询返回的结果集不能太大</p>\n<h3 id=\"Merge-Join\"><a href=\"#Merge-Join\" class=\"headerlink\" title=\"Merge Join\"></a>Merge Join</h3><p><img src=\"https://i-msdn.sec.s-msft.com/dynimg/IC173813.gif\" atl=\"Merge Join\" align=\"left\"><br></p>\n<p>这种关联算法是对两个已经排过序的集合进行合并。如果两个聚合是无序的则将先给集合排序再进行一一合并，由于是排过序的集合，左右两个集合自上而下合并效率是相当快的。</p>\n<p>通常情况下散列连接的效果都比排序合并连接要好，然而如果行源已经被排过序，在执行排序合并连接时不需要再排序了，这时排序合并连接的性能会优于散列连接。Merge join 用在没有索引，并且数据已经排序的情况。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> c.CustomerID</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Sales.SalesOrderDetail od</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> Sales.SalesOrderHeader oh</span><br><span class=\"line\"><span class=\"keyword\">ON</span> od.SalesOrderID = oh.SalesOrderID</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> Sales.Customer c <span class=\"keyword\">ON</span> oh.CustomerID = c.CustomerID</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/MergeJoin.png\" alt=\"joinPlan\"></p>\n<p>由于没有使用WHERE语句，所以优化器对Customer表使用聚集索引扫描，对SalesOrderHeader表使用非聚集索引扫描</p>\n<p>Customer表和SalesOrderHeader表使用Merge Join操作符进行关联，关联字段是CustomerID字段，这个字段在上面的索引扫描之后都是有序的。如果不是有序的，优化器会在前面进行排序或者是直接将两个表进行Hash Join连接。</p>\n<h2 id=\"根据执行计划细节要做的优化操作\"><a href=\"#根据执行计划细节要做的优化操作\" class=\"headerlink\" title=\"根据执行计划细节要做的优化操作\"></a>根据执行计划细节要做的优化操作</h2><ol>\n<li>如果select * 通常情况下聚集索引会比非聚集索引更优。</li>\n<li>如果出现Nested Loops，需要查下是否需要聚集索引，非聚集索引是否可以包含所有需要的列。</li>\n<li>Hash Match连接操作更适合于需要做Hashing算法集合很小的连接。</li>\n<li>Merge Join时需要检查下原有的集合是否已经有排序，如果没有排序，使用索引能否解决。</li>\n<li>出现表扫描，聚集索引扫描，非聚集索引扫描时，考虑语句是否可以加where限制，select * 是否可以去除不必要的列。</li>\n<li>出现Rid查找时，是否可以加索引优化解决。</li>\n<li>在计划中看到不是你想要的索引时，看能否在语句中强制使用你想用的索引解决问题，强制使用索引的办法Select CluName1,CluName2 from Table with(index=IndexName)。</li>\n<li>看到不是你想要的连接算法时，尝试强制使用你想要的算法解决问题。强制使用连接算法的语句：select * from t1 left join t2 on t1.id=t2.id option(Hash/Loop/Merge Join)</li>\n<li>看到不是你想要的聚合算法是，尝试强制使用你想要的聚合算法。强制使用聚合算法的语句示例：select  age ,count(age) as cnt from t1 group by age  option(order/hash group)</li>\n<li>看到不是你想要的解析执行顺序是，或这解析顺序耗时过大时，尝试强制使用你定的执行顺序。option（force order）</li>\n<li>看到有多个线程来合并执行你的sql语句而影响到性能时，尝试强制是不并行操作。option（maxdop 1）</li>\n<li>在存储过程中，由于参数不同导致执行计划不同，也影响啦性能时尝试指定参数来优化。option（optiomize for（@name=’zlh’））</li>\n<li>不操作多余的列，多余的行，不做务必要的聚合，排序。</li>\n</ol>"},{"title":"堆栈和队列","date":"2017-06-13T08:47:05.000Z","_content":"\n\n\n栈 (Stack)是一种后进先出(last in first off，LIFO)的数据结构\n\n队列(Queue)则是一种先进先出 (fisrt in first out，FIFO)的结构\n\n![Stack_Queue](http://7xkfga.com1.z0.glb.clouddn.com/stack_queue.png)\n\n<!-- more -->\n\n## 栈\n\n``` python\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def is_empty(self):\n        return not self.items\n\n    def push(self, item):\n        \"\"\"adds a new item to the top of the stack\"\"\"\n        self.items.append(item)\n    \n    def pop(self):\n        \"\"\"\n        removes the top item from the stack,\n        popping an empty stack (list) will result in an error\n        \"\"\"\n        if not self.is_empty():\n            return self.items.pop()\n        return \"Pop from empty stack\"\n\n    def peek(self):\n        \"\"\"returns the top item from the stack but does not remove it\"\"\"\n        if not self.is_empty():\n            return self.items[len(self.items) - 1]\n        return \"Stack is Empty\"\n\n    def size(self):\n        return len(self.items)\n```\n\n## 队列\n\n\n","source":"_posts/∂—’ª∫Õ∂”¡–.md","raw":"---\ntitle: 堆栈和队列\ntags:\n  - Algorithm\n  - Data Structure\n  - 面试\ndate: 2017-06-13 16:47:05\n---\n\n\n\n栈 (Stack)是一种后进先出(last in first off，LIFO)的数据结构\n\n队列(Queue)则是一种先进先出 (fisrt in first out，FIFO)的结构\n\n![Stack_Queue](http://7xkfga.com1.z0.glb.clouddn.com/stack_queue.png)\n\n<!-- more -->\n\n## 栈\n\n``` python\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def is_empty(self):\n        return not self.items\n\n    def push(self, item):\n        \"\"\"adds a new item to the top of the stack\"\"\"\n        self.items.append(item)\n    \n    def pop(self):\n        \"\"\"\n        removes the top item from the stack,\n        popping an empty stack (list) will result in an error\n        \"\"\"\n        if not self.is_empty():\n            return self.items.pop()\n        return \"Pop from empty stack\"\n\n    def peek(self):\n        \"\"\"returns the top item from the stack but does not remove it\"\"\"\n        if not self.is_empty():\n            return self.items[len(self.items) - 1]\n        return \"Stack is Empty\"\n\n    def size(self):\n        return len(self.items)\n```\n\n## 队列\n\n\n","slug":"∂—’ª∫Õ∂”¡–","published":1,"updated":"2017-06-16T03:53:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3pe004ozd68lgu6b3h0","content":"<p>栈 (Stack)是一种后进先出(last in first off，LIFO)的数据结构</p>\n<p>队列(Queue)则是一种先进先出 (fisrt in first out，FIFO)的结构</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/stack_queue.png\" alt=\"Stack_Queue\"></p>\n<a id=\"more\"></a>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.items = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_empty</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> self.items</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, item)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"adds a new item to the top of the stack\"\"\"</span></span><br><span class=\"line\">        self.items.append(item)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        removes the top item from the stack,</span></span><br><span class=\"line\"><span class=\"string\">        popping an empty stack (list) will result in an error</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.is_empty():</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.items.pop()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Pop from empty stack\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">peek</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"returns the top item from the stack but does not remove it\"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.is_empty():</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.items[len(self.items) - <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Stack is Empty\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">size</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(self.items)</span><br></pre></td></tr></table></figure>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2>","site":{"data":{}},"excerpt":"<p>栈 (Stack)是一种后进先出(last in first off，LIFO)的数据结构</p>\n<p>队列(Queue)则是一种先进先出 (fisrt in first out，FIFO)的结构</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/stack_queue.png\" alt=\"Stack_Queue\"></p>","more":"<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.items = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_empty</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> self.items</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, item)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"adds a new item to the top of the stack\"\"\"</span></span><br><span class=\"line\">        self.items.append(item)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        removes the top item from the stack,</span></span><br><span class=\"line\"><span class=\"string\">        popping an empty stack (list) will result in an error</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.is_empty():</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.items.pop()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Pop from empty stack\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">peek</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"returns the top item from the stack but does not remove it\"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.is_empty():</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.items[len(self.items) - <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Stack is Empty\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">size</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(self.items)</span><br></pre></td></tr></table></figure>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2>"},{"title":"二叉树的遍历","date":"2017-05-27T10:30:28.000Z","_content":"\n\n二叉树的遍历分为：\n\n1. 深度优先搜索(Depth First Search)\n\n    是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。深度优先搜索二叉树是先访问根结点，然后遍历左子树接着是遍历右子树，因此我们可以利用堆栈的先进后出的特点，先将右子树压栈，再将左子树压栈，这样左子树就位于栈顶，可以保证结点的左子树先与右子树被遍历。\n\n2. 广度优先搜索(Breadth First Search)\n\n    是从根结点开始沿着树的宽度搜索遍历，可以利用队列实现广度优先搜索\n\n二叉树的深度优先遍历的非递归的通用做法是采用栈，广度优先遍历的非递归的通用做法是采用队列\n\n<!-- more -->\n\n\n## 深度优先实现\n\n深度优先遍历又分为：前序、中序、后序遍历\n\n- 前序遍历：根节点->左子树->右子树\n- 中序遍历：左子树->根节点->右子树\n- 后序遍历：左子树->右子树->根节点\n\n**_note: 二叉搜索树BST的中序遍历，返回的结果是按顺序排列的_**\n\n### 递归实现\n\n前序遍历伪代码：\n\n```\npreorder(node)\n  if (node = null)\n    return\n  visit(node)\n  preorder(node.left)\n  preorder(node.right)\n```\n\n根节点->左子树->右子树\n\npython实现\n\n``` python\ndef preorder(self, node):\n    \"\"\"前序遍历\"\"\"\n    if node:\n        print node.data\n        self.preorder(node.left)\n        self.preorder(node.right)\n```\n\n\n中序遍历伪代码：\n\n```\ninorder(node)\n  if (node = null)\n    return\n  inorder(node.left)\n  visit(node)\n  inorder(node.right)\n```\n\n左子树->根节点->右子树\n\n``` python\ndef inorder(self, node):\n    \"\"\"中序遍历\"\"\"\n    if node:\n        self.inorder(node.left)\n        print node.data\n        self.inorder(node.right)\n```\n\n后序遍历伪代码：\n\n```\npostorder(node)\n  if (node = null)\n    return\n  postorder(node.left)\n  postorder(node.right)\n  visit(node)\n```\n\n左子树->右子树->根节点\n\n``` python\ndef postorder(self, node):\n    \"\"\"后序遍历\"\"\"\n    if node:\n        self.postorder(node.left)\n        self.postorder(node.right)\n        print node.data\n```\n\n### 非递归实现\n\n因为当遍历过根节点之后还要回来，所以必须将其存起来。考虑到后进先出的特点，选用栈存储。\n\n前序遍历伪代码：\n\n```\niterativePreorder(node)\n  parentStack = empty stack\n  while (not parentStack.isEmpty() or node ≠ null)\n    if (node ≠ null)\n      visit(node)\n      if (node.right ≠ null) parentStack.push(node.right)\n      node = node.left   \n    else     \n      node = parentStack.pop()\n```\n\n``` python\ndef preorderTraversal__iterative(root):\n    \"\"\"\n    :type root: TreeNode\n    \"\"\"\n    node = root\n    stack = []\n    while node or stack:\n        if node:\n            print node.val\n            if node.right:\n                stack.append(node.right)\n            node = node.left\n        else:\n            node = stack.pop()\n    return\n```\n\n\n中序遍历伪代码：\n\n```\niterativeInorder(node)\n  s ← empty stack\n  while (not s.isEmpty() or node ≠ null)\n    while (node ≠ null)\n      s.push(node)\n      node ← node.left\n    else\n      node ← s.pop()\n      visit(node)\n      node ← node.right\n```\n\n``` python\ndef inorderTraversal_iterative(root):\n    \"\"\"\n    :type root: TreeNode\n    \"\"\"\n    node = root\n    stack = []\n    while node or stack:\n        while node:\n            stack.append(node)\n            node = node.left\n        node = stack.pop()\n        print node.val\n        node = node.right\n    return result\n```\n\n后序遍历\n\n后序遍历伪代码：\n\n```\niterativePostorder(node)\n  s ← empty stack\n  lastNodeVisited ← null\n  while (not s.isEmpty() or node ≠ null)\n    if (node ≠ null)\n      s.push(node)\n      node ← node.left\n    else\n      peekNode ← s.peek()\n      // if right child exists and traversing node\n      // from left child, then move right\n      if (peekNode.right ≠ null and lastNodeVisited ≠ peekNode.right)\n        node ← peekNode.right\n      else\n        visit(peekNode)\n        lastNodeVisited ← s.pop()\n```\n\n``` python\ndef postorderTraversal(node):\n    if node is None:\n        return []\n    stack = []\n    result = []\n    lastNodeVisited = None\n    while stack or node:\n        if node:\n            stack.append(node)\n            node = node.left\n        else:\n            peekNode = stack[-1]\n            if peekNode.right and lastNodeVisited != peekNode.right:\n                node = peekNode.right\n            else:\n                result.append(peekNode)\n                lastVisitedNode = stack.pop()\n    return result\n```\n\n\n## 广度优先实现\n\n伪代码\n\n```\nlevelorder(root)\n  q ← empty queue\n  q.enqueue(root)\n  while (not q.isEmpty())\n    node ← q.dequeue()\n    visit(node)\n    if (node.left ≠ null)\n      q.enqueue(node.left)\n    if (node.right ≠ null)\n      q.enqueue(node.right)\n```","source":"_posts/∂˛≤Ê ˜µƒ±È¿˙.md","raw":"---\ntitle: 二叉树的遍历\ndate: 2017-05-27 18:30:28\ntags:\n- Data Structure\n---\n\n\n二叉树的遍历分为：\n\n1. 深度优先搜索(Depth First Search)\n\n    是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。深度优先搜索二叉树是先访问根结点，然后遍历左子树接着是遍历右子树，因此我们可以利用堆栈的先进后出的特点，先将右子树压栈，再将左子树压栈，这样左子树就位于栈顶，可以保证结点的左子树先与右子树被遍历。\n\n2. 广度优先搜索(Breadth First Search)\n\n    是从根结点开始沿着树的宽度搜索遍历，可以利用队列实现广度优先搜索\n\n二叉树的深度优先遍历的非递归的通用做法是采用栈，广度优先遍历的非递归的通用做法是采用队列\n\n<!-- more -->\n\n\n## 深度优先实现\n\n深度优先遍历又分为：前序、中序、后序遍历\n\n- 前序遍历：根节点->左子树->右子树\n- 中序遍历：左子树->根节点->右子树\n- 后序遍历：左子树->右子树->根节点\n\n**_note: 二叉搜索树BST的中序遍历，返回的结果是按顺序排列的_**\n\n### 递归实现\n\n前序遍历伪代码：\n\n```\npreorder(node)\n  if (node = null)\n    return\n  visit(node)\n  preorder(node.left)\n  preorder(node.right)\n```\n\n根节点->左子树->右子树\n\npython实现\n\n``` python\ndef preorder(self, node):\n    \"\"\"前序遍历\"\"\"\n    if node:\n        print node.data\n        self.preorder(node.left)\n        self.preorder(node.right)\n```\n\n\n中序遍历伪代码：\n\n```\ninorder(node)\n  if (node = null)\n    return\n  inorder(node.left)\n  visit(node)\n  inorder(node.right)\n```\n\n左子树->根节点->右子树\n\n``` python\ndef inorder(self, node):\n    \"\"\"中序遍历\"\"\"\n    if node:\n        self.inorder(node.left)\n        print node.data\n        self.inorder(node.right)\n```\n\n后序遍历伪代码：\n\n```\npostorder(node)\n  if (node = null)\n    return\n  postorder(node.left)\n  postorder(node.right)\n  visit(node)\n```\n\n左子树->右子树->根节点\n\n``` python\ndef postorder(self, node):\n    \"\"\"后序遍历\"\"\"\n    if node:\n        self.postorder(node.left)\n        self.postorder(node.right)\n        print node.data\n```\n\n### 非递归实现\n\n因为当遍历过根节点之后还要回来，所以必须将其存起来。考虑到后进先出的特点，选用栈存储。\n\n前序遍历伪代码：\n\n```\niterativePreorder(node)\n  parentStack = empty stack\n  while (not parentStack.isEmpty() or node ≠ null)\n    if (node ≠ null)\n      visit(node)\n      if (node.right ≠ null) parentStack.push(node.right)\n      node = node.left   \n    else     \n      node = parentStack.pop()\n```\n\n``` python\ndef preorderTraversal__iterative(root):\n    \"\"\"\n    :type root: TreeNode\n    \"\"\"\n    node = root\n    stack = []\n    while node or stack:\n        if node:\n            print node.val\n            if node.right:\n                stack.append(node.right)\n            node = node.left\n        else:\n            node = stack.pop()\n    return\n```\n\n\n中序遍历伪代码：\n\n```\niterativeInorder(node)\n  s ← empty stack\n  while (not s.isEmpty() or node ≠ null)\n    while (node ≠ null)\n      s.push(node)\n      node ← node.left\n    else\n      node ← s.pop()\n      visit(node)\n      node ← node.right\n```\n\n``` python\ndef inorderTraversal_iterative(root):\n    \"\"\"\n    :type root: TreeNode\n    \"\"\"\n    node = root\n    stack = []\n    while node or stack:\n        while node:\n            stack.append(node)\n            node = node.left\n        node = stack.pop()\n        print node.val\n        node = node.right\n    return result\n```\n\n后序遍历\n\n后序遍历伪代码：\n\n```\niterativePostorder(node)\n  s ← empty stack\n  lastNodeVisited ← null\n  while (not s.isEmpty() or node ≠ null)\n    if (node ≠ null)\n      s.push(node)\n      node ← node.left\n    else\n      peekNode ← s.peek()\n      // if right child exists and traversing node\n      // from left child, then move right\n      if (peekNode.right ≠ null and lastNodeVisited ≠ peekNode.right)\n        node ← peekNode.right\n      else\n        visit(peekNode)\n        lastNodeVisited ← s.pop()\n```\n\n``` python\ndef postorderTraversal(node):\n    if node is None:\n        return []\n    stack = []\n    result = []\n    lastNodeVisited = None\n    while stack or node:\n        if node:\n            stack.append(node)\n            node = node.left\n        else:\n            peekNode = stack[-1]\n            if peekNode.right and lastNodeVisited != peekNode.right:\n                node = peekNode.right\n            else:\n                result.append(peekNode)\n                lastVisitedNode = stack.pop()\n    return result\n```\n\n\n## 广度优先实现\n\n伪代码\n\n```\nlevelorder(root)\n  q ← empty queue\n  q.enqueue(root)\n  while (not q.isEmpty())\n    node ← q.dequeue()\n    visit(node)\n    if (node.left ≠ null)\n      q.enqueue(node.left)\n    if (node.right ≠ null)\n      q.enqueue(node.right)\n```","slug":"∂˛≤Ê ˜µƒ±È¿˙","published":1,"updated":"2017-05-27T10:49:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3pf004qzd68yw0o1mab","content":"<p>二叉树的遍历分为：</p>\n<ol>\n<li><p>深度优先搜索(Depth First Search)</p>\n<p> 是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。深度优先搜索二叉树是先访问根结点，然后遍历左子树接着是遍历右子树，因此我们可以利用堆栈的先进后出的特点，先将右子树压栈，再将左子树压栈，这样左子树就位于栈顶，可以保证结点的左子树先与右子树被遍历。</p>\n</li>\n<li><p>广度优先搜索(Breadth First Search)</p>\n<p> 是从根结点开始沿着树的宽度搜索遍历，可以利用队列实现广度优先搜索</p>\n</li>\n</ol>\n<p>二叉树的深度优先遍历的非递归的通用做法是采用栈，广度优先遍历的非递归的通用做法是采用队列</p>\n<a id=\"more\"></a>\n<h2 id=\"深度优先实现\"><a href=\"#深度优先实现\" class=\"headerlink\" title=\"深度优先实现\"></a>深度优先实现</h2><p>深度优先遍历又分为：前序、中序、后序遍历</p>\n<ul>\n<li>前序遍历：根节点-&gt;左子树-&gt;右子树</li>\n<li>中序遍历：左子树-&gt;根节点-&gt;右子树</li>\n<li>后序遍历：左子树-&gt;右子树-&gt;根节点</li>\n</ul>\n<p><strong><em>note: 二叉搜索树BST的中序遍历，返回的结果是按顺序排列的</em></strong></p>\n<h3 id=\"递归实现\"><a href=\"#递归实现\" class=\"headerlink\" title=\"递归实现\"></a>递归实现</h3><p>前序遍历伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preorder(node)</span><br><span class=\"line\">  if (node = null)</span><br><span class=\"line\">    return</span><br><span class=\"line\">  visit(node)</span><br><span class=\"line\">  preorder(node.left)</span><br><span class=\"line\">  preorder(node.right)</span><br></pre></td></tr></table></figure>\n<p>根节点-&gt;左子树-&gt;右子树</p>\n<p>python实现</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorder</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"前序遍历\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> node.data</span><br><span class=\"line\">        self.preorder(node.left)</span><br><span class=\"line\">        self.preorder(node.right)</span><br></pre></td></tr></table></figure>\n<p>中序遍历伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inorder(node)</span><br><span class=\"line\">  if (node = null)</span><br><span class=\"line\">    return</span><br><span class=\"line\">  inorder(node.left)</span><br><span class=\"line\">  visit(node)</span><br><span class=\"line\">  inorder(node.right)</span><br></pre></td></tr></table></figure>\n<p>左子树-&gt;根节点-&gt;右子树</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorder</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"中序遍历\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">        self.inorder(node.left)</span><br><span class=\"line\">        <span class=\"keyword\">print</span> node.data</span><br><span class=\"line\">        self.inorder(node.right)</span><br></pre></td></tr></table></figure>\n<p>后序遍历伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">postorder(node)</span><br><span class=\"line\">  if (node = null)</span><br><span class=\"line\">    return</span><br><span class=\"line\">  postorder(node.left)</span><br><span class=\"line\">  postorder(node.right)</span><br><span class=\"line\">  visit(node)</span><br></pre></td></tr></table></figure>\n<p>左子树-&gt;右子树-&gt;根节点</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">postorder</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"后序遍历\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">        self.postorder(node.left)</span><br><span class=\"line\">        self.postorder(node.right)</span><br><span class=\"line\">        <span class=\"keyword\">print</span> node.data</span><br></pre></td></tr></table></figure>\n<h3 id=\"非递归实现\"><a href=\"#非递归实现\" class=\"headerlink\" title=\"非递归实现\"></a>非递归实现</h3><p>因为当遍历过根节点之后还要回来，所以必须将其存起来。考虑到后进先出的特点，选用栈存储。</p>\n<p>前序遍历伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iterativePreorder(node)</span><br><span class=\"line\">  parentStack = empty stack</span><br><span class=\"line\">  while (not parentStack.isEmpty() or node ≠ null)</span><br><span class=\"line\">    if (node ≠ null)</span><br><span class=\"line\">      visit(node)</span><br><span class=\"line\">      if (node.right ≠ null) parentStack.push(node.right)</span><br><span class=\"line\">      node = node.left   </span><br><span class=\"line\">    else     </span><br><span class=\"line\">      node = parentStack.pop()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorderTraversal__iterative</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    node = root</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> node <span class=\"keyword\">or</span> stack:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">print</span> node.val</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">                stack.append(node.right)</span><br><span class=\"line\">            node = node.left</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            node = stack.pop()</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<p>中序遍历伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iterativeInorder(node)</span><br><span class=\"line\">  s ← empty stack</span><br><span class=\"line\">  while (not s.isEmpty() or node ≠ null)</span><br><span class=\"line\">    while (node ≠ null)</span><br><span class=\"line\">      s.push(node)</span><br><span class=\"line\">      node ← node.left</span><br><span class=\"line\">    else</span><br><span class=\"line\">      node ← s.pop()</span><br><span class=\"line\">      visit(node)</span><br><span class=\"line\">      node ← node.right</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorderTraversal_iterative</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    node = root</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> node <span class=\"keyword\">or</span> stack:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> node:</span><br><span class=\"line\">            stack.append(node)</span><br><span class=\"line\">            node = node.left</span><br><span class=\"line\">        node = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">print</span> node.val</span><br><span class=\"line\">        node = node.right</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<p>后序遍历</p>\n<p>后序遍历伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iterativePostorder(node)</span><br><span class=\"line\">  s ← empty stack</span><br><span class=\"line\">  lastNodeVisited ← null</span><br><span class=\"line\">  while (not s.isEmpty() or node ≠ null)</span><br><span class=\"line\">    if (node ≠ null)</span><br><span class=\"line\">      s.push(node)</span><br><span class=\"line\">      node ← node.left</span><br><span class=\"line\">    else</span><br><span class=\"line\">      peekNode ← s.peek()</span><br><span class=\"line\">      // if right child exists and traversing node</span><br><span class=\"line\">      // from left child, then move right</span><br><span class=\"line\">      if (peekNode.right ≠ null and lastNodeVisited ≠ peekNode.right)</span><br><span class=\"line\">        node ← peekNode.right</span><br><span class=\"line\">      else</span><br><span class=\"line\">        visit(peekNode)</span><br><span class=\"line\">        lastNodeVisited ← s.pop()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">postorderTraversal</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> node <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    lastNodeVisited = <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack <span class=\"keyword\">or</span> node:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            stack.append(node)</span><br><span class=\"line\">            node = node.left</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            peekNode = stack[<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> peekNode.right <span class=\"keyword\">and</span> lastNodeVisited != peekNode.right:</span><br><span class=\"line\">                node = peekNode.right</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                result.append(peekNode)</span><br><span class=\"line\">                lastVisitedNode = stack.pop()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<h2 id=\"广度优先实现\"><a href=\"#广度优先实现\" class=\"headerlink\" title=\"广度优先实现\"></a>广度优先实现</h2><p>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">levelorder(root)</span><br><span class=\"line\">  q ← empty queue</span><br><span class=\"line\">  q.enqueue(root)</span><br><span class=\"line\">  while (not q.isEmpty())</span><br><span class=\"line\">    node ← q.dequeue()</span><br><span class=\"line\">    visit(node)</span><br><span class=\"line\">    if (node.left ≠ null)</span><br><span class=\"line\">      q.enqueue(node.left)</span><br><span class=\"line\">    if (node.right ≠ null)</span><br><span class=\"line\">      q.enqueue(node.right)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>二叉树的遍历分为：</p>\n<ol>\n<li><p>深度优先搜索(Depth First Search)</p>\n<p> 是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。深度优先搜索二叉树是先访问根结点，然后遍历左子树接着是遍历右子树，因此我们可以利用堆栈的先进后出的特点，先将右子树压栈，再将左子树压栈，这样左子树就位于栈顶，可以保证结点的左子树先与右子树被遍历。</p>\n</li>\n<li><p>广度优先搜索(Breadth First Search)</p>\n<p> 是从根结点开始沿着树的宽度搜索遍历，可以利用队列实现广度优先搜索</p>\n</li>\n</ol>\n<p>二叉树的深度优先遍历的非递归的通用做法是采用栈，广度优先遍历的非递归的通用做法是采用队列</p>","more":"<h2 id=\"深度优先实现\"><a href=\"#深度优先实现\" class=\"headerlink\" title=\"深度优先实现\"></a>深度优先实现</h2><p>深度优先遍历又分为：前序、中序、后序遍历</p>\n<ul>\n<li>前序遍历：根节点-&gt;左子树-&gt;右子树</li>\n<li>中序遍历：左子树-&gt;根节点-&gt;右子树</li>\n<li>后序遍历：左子树-&gt;右子树-&gt;根节点</li>\n</ul>\n<p><strong><em>note: 二叉搜索树BST的中序遍历，返回的结果是按顺序排列的</em></strong></p>\n<h3 id=\"递归实现\"><a href=\"#递归实现\" class=\"headerlink\" title=\"递归实现\"></a>递归实现</h3><p>前序遍历伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preorder(node)</span><br><span class=\"line\">  if (node = null)</span><br><span class=\"line\">    return</span><br><span class=\"line\">  visit(node)</span><br><span class=\"line\">  preorder(node.left)</span><br><span class=\"line\">  preorder(node.right)</span><br></pre></td></tr></table></figure>\n<p>根节点-&gt;左子树-&gt;右子树</p>\n<p>python实现</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorder</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"前序遍历\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> node.data</span><br><span class=\"line\">        self.preorder(node.left)</span><br><span class=\"line\">        self.preorder(node.right)</span><br></pre></td></tr></table></figure>\n<p>中序遍历伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inorder(node)</span><br><span class=\"line\">  if (node = null)</span><br><span class=\"line\">    return</span><br><span class=\"line\">  inorder(node.left)</span><br><span class=\"line\">  visit(node)</span><br><span class=\"line\">  inorder(node.right)</span><br></pre></td></tr></table></figure>\n<p>左子树-&gt;根节点-&gt;右子树</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorder</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"中序遍历\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">        self.inorder(node.left)</span><br><span class=\"line\">        <span class=\"keyword\">print</span> node.data</span><br><span class=\"line\">        self.inorder(node.right)</span><br></pre></td></tr></table></figure>\n<p>后序遍历伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">postorder(node)</span><br><span class=\"line\">  if (node = null)</span><br><span class=\"line\">    return</span><br><span class=\"line\">  postorder(node.left)</span><br><span class=\"line\">  postorder(node.right)</span><br><span class=\"line\">  visit(node)</span><br></pre></td></tr></table></figure>\n<p>左子树-&gt;右子树-&gt;根节点</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">postorder</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"后序遍历\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">        self.postorder(node.left)</span><br><span class=\"line\">        self.postorder(node.right)</span><br><span class=\"line\">        <span class=\"keyword\">print</span> node.data</span><br></pre></td></tr></table></figure>\n<h3 id=\"非递归实现\"><a href=\"#非递归实现\" class=\"headerlink\" title=\"非递归实现\"></a>非递归实现</h3><p>因为当遍历过根节点之后还要回来，所以必须将其存起来。考虑到后进先出的特点，选用栈存储。</p>\n<p>前序遍历伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iterativePreorder(node)</span><br><span class=\"line\">  parentStack = empty stack</span><br><span class=\"line\">  while (not parentStack.isEmpty() or node ≠ null)</span><br><span class=\"line\">    if (node ≠ null)</span><br><span class=\"line\">      visit(node)</span><br><span class=\"line\">      if (node.right ≠ null) parentStack.push(node.right)</span><br><span class=\"line\">      node = node.left   </span><br><span class=\"line\">    else     </span><br><span class=\"line\">      node = parentStack.pop()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorderTraversal__iterative</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    node = root</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> node <span class=\"keyword\">or</span> stack:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">print</span> node.val</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">                stack.append(node.right)</span><br><span class=\"line\">            node = node.left</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            node = stack.pop()</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<p>中序遍历伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iterativeInorder(node)</span><br><span class=\"line\">  s ← empty stack</span><br><span class=\"line\">  while (not s.isEmpty() or node ≠ null)</span><br><span class=\"line\">    while (node ≠ null)</span><br><span class=\"line\">      s.push(node)</span><br><span class=\"line\">      node ← node.left</span><br><span class=\"line\">    else</span><br><span class=\"line\">      node ← s.pop()</span><br><span class=\"line\">      visit(node)</span><br><span class=\"line\">      node ← node.right</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorderTraversal_iterative</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    node = root</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> node <span class=\"keyword\">or</span> stack:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> node:</span><br><span class=\"line\">            stack.append(node)</span><br><span class=\"line\">            node = node.left</span><br><span class=\"line\">        node = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">print</span> node.val</span><br><span class=\"line\">        node = node.right</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<p>后序遍历</p>\n<p>后序遍历伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iterativePostorder(node)</span><br><span class=\"line\">  s ← empty stack</span><br><span class=\"line\">  lastNodeVisited ← null</span><br><span class=\"line\">  while (not s.isEmpty() or node ≠ null)</span><br><span class=\"line\">    if (node ≠ null)</span><br><span class=\"line\">      s.push(node)</span><br><span class=\"line\">      node ← node.left</span><br><span class=\"line\">    else</span><br><span class=\"line\">      peekNode ← s.peek()</span><br><span class=\"line\">      // if right child exists and traversing node</span><br><span class=\"line\">      // from left child, then move right</span><br><span class=\"line\">      if (peekNode.right ≠ null and lastNodeVisited ≠ peekNode.right)</span><br><span class=\"line\">        node ← peekNode.right</span><br><span class=\"line\">      else</span><br><span class=\"line\">        visit(peekNode)</span><br><span class=\"line\">        lastNodeVisited ← s.pop()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">postorderTraversal</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> node <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    lastNodeVisited = <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack <span class=\"keyword\">or</span> node:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            stack.append(node)</span><br><span class=\"line\">            node = node.left</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            peekNode = stack[<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> peekNode.right <span class=\"keyword\">and</span> lastNodeVisited != peekNode.right:</span><br><span class=\"line\">                node = peekNode.right</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                result.append(peekNode)</span><br><span class=\"line\">                lastVisitedNode = stack.pop()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<h2 id=\"广度优先实现\"><a href=\"#广度优先实现\" class=\"headerlink\" title=\"广度优先实现\"></a>广度优先实现</h2><p>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">levelorder(root)</span><br><span class=\"line\">  q ← empty queue</span><br><span class=\"line\">  q.enqueue(root)</span><br><span class=\"line\">  while (not q.isEmpty())</span><br><span class=\"line\">    node ← q.dequeue()</span><br><span class=\"line\">    visit(node)</span><br><span class=\"line\">    if (node.left ≠ null)</span><br><span class=\"line\">      q.enqueue(node.left)</span><br><span class=\"line\">    if (node.right ≠ null)</span><br><span class=\"line\">      q.enqueue(node.right)</span><br></pre></td></tr></table></figure>"},{"title":"搞懂Python装饰器","date":"2017-07-20T03:49:07.000Z","_content":"\n\n装饰器是Python中的一个高阶概念，装饰器是可调用的对象，其参数是另外一个函数。装饰器可能会处理被装饰的函数然后把它返回，或者将其替换成另外一个函数或者可调用对象。\n\n这么介绍装饰器确实很难懂，还是以例子逐步理解更容易些。\n\n装饰器的强大在于它能够在不修改原有业务逻辑的情况下对代码进行扩展，常见的应用场景有：权限校验、用户认证、日志记录、性能测试、事务处理、缓存等。\n\n下面记录一下我逐步理解装饰器的过程。\n\n<!-- more -->\n\n## 一等函数\n\n在Python中，函数是一等对象，也就是说函数是满足以下条件的程序实体：\n\n1. 在运行时创建\n2. 能赋值给变量或者数据结构中的元素\n3. 能作为参数传给函数\n4. 能作为函数的返回结果\n\n下面先看一个简单函数的定义\n\n``` python\ndef hello():\n    print(\"Hello world!\")\n```\n\npython解释器遇到这段代码的时候，发生了两件事：\n\n1. 编译代码生成一个函数对象\n2. 将名为\"hello\"的名字绑定到这个函数对象上\n\n![createSimpleFunc](http://7xkfga.com1.z0.glb.clouddn.com/createfunc.png)\n\nPython中函数是一等对象，也就是说函数可以像int、string、float对象一样作为参数、或者作为返回值等进行传递。\n\n### 函数作为参数\n\n``` python\ndef foo(bar):\n    return bar + 1\n\nprint(foo)\nprint(foo(2))\nprint(type(foo))\n\n\ndef call_foo_with_arg(foo, arg):\n    return foo(arg)\n\nprint(call_foo_with_arg(foo, 3))\n```\n\n![](http://7xkfga.com1.z0.glb.clouddn.com/funcAsParam.png)\n\n函数 `call_foo_with_arg` 接收两个参数，其中一个是可被调用的函数对象 `foo`\n\n### 嵌套函数\n\n函数也可以定义在另外一个函数中，作为嵌套函数\n\n``` python\ndef parent():\n    print(\"Printing from the parent() function.\")\n\n    def first_child():\n        return \"Printing from the first_child() function.\"\n\n    def second_child():\n        return \"Printing from the second_child() function.\"\n\n    print(first_child())\n    print(second_child())\n```\n\n`first_child` 和 `second_child` 函数是嵌套在 `parent` 函数中的函数。\n\n![nestedFunction](http://7xkfga.com1.z0.glb.clouddn.com/nestFunc.png)\n\n当调用 `parent` 函数时，内嵌的`first_child` 和 `second_child` 函数也被调用，但是如果在 `parent` 函数中并不是调用`first_child` 和 `second_child` 函数， 而是返回这两个函数对象呢？\n\n下面歪个楼，先介绍一下Python的变量作用域的规则。\n\n## 变量作用域\n\nPython是动态语言，Python的变量名解析机制有时称为LEGB法则，当在函数中使用未认证的变量名时，Python搜索4个作用域：\n\n- local 函数内部作用域\n- enclosing 函数内部与内嵌函数之间\n- global 全局作用域\n- build-in 内置作用域\n\n``` python\ndef f1(a):\n    print(a)\n    print(b)\n\nf1(3)\n```\n\n这段程序会抛出错误：\"NameError: name 'b' is not defined\"，这是因为在函数体内，Python编译器搜索上面 LEGB 的变量，没有找到。\n\n再下面一个例子：\n\n``` python\nb = 6\ndef f2(a):\n    print(a)\n    print(b)\n    b = 9\n\nf2(3)\n```\n\n在Python中，Python不要求声明变量，但是**假定在函数体中被赋值的变量是局部变量**，所以在这个函数体中，变量b被判断成局部变量，所以在print(b)调用时会抛出 \"UnboundLocalError: local variable 'b' referenced before assignment\" 的错误。\n\n要想上面的代码运行，就必须手动在函数体内声明变量b为全局变量\n\n``` python\nb = 6\ndef f2(a):\n    global b\n    print(a)\n    print(b)\n    b = 9\n\nf2(3)\n```\n\n## 闭包\n\n有了上面的背景知识，下面就可以介绍闭包了。**闭包是指延伸了作用域的函数**。\n\n要想理解这个概念还是挺难的，下面还是用例子来说明。\n\n现在有个avg函数，用于计算不断增长的序列的平均值。\n\n``` python\ndef make_averager():\n    series = []\n\n    def averager(new_value):\n        series.append(new_value)\n        total = sum(series)\n        return total / len(series)\n\n    return averager\n\navg = make_averager()\navg(10)\navg(11)\n```\n\n调用函数 `make_averager` 时候，返回一个 `averager` 函数对象，每次调用 `averager` 函数，会把参数添加到 `series` 中，然后计算当前平均值。\n\n`series` 是 `make_averager` 函数的局部变量，调用 `avg(10)` 时， `make_averager` 函数已经返回，所以本地作用域也就不存在了。但是在 `averager` 函数中，`series` 是自由变量\n\n![closure](http://7xkfga.com1.z0.glb.clouddn.com/closure.png)\n\n这里的 `avg` 就是一个闭包，本质上它还是函数，闭包是引用了自由变量(series)的函数(averager)\n\n![avg_func](http://7xkfga.com1.z0.glb.clouddn.com/avg_func_closure.png)\n\n\n### nonlocal声明\n\n刚才的例子稍稍改动一下，使用total和count来计算移动平均值\n\n``` python\ndef make_averager():\n    count = 0\n    total = 0\n\n    def averager(new_value):\n        count += 1\n        total += new_value\n        return total / count\n\n    return averager\n\navg = make_averager()\navg(10)\n```\n\n这时候会抛出错误 \"UnboundLocalError: local variable 'count' referenced before assignment\"。这是因为：当count为数字或者任何不可变类型时，在函数体定义中 `count = count + 1` 实际上是为count赋值，所以count就变成了局部变量。为了避免这个问题，python3引入了 `nonlocal` 声明，作用是把变量标记成 **自由变量**\n\n``` python\ndef make_averager():\n    count = 0\n    total = 0\n\n    def averager(new_value):\n        nonlocal count, total\n        count += 1\n        total += new_value\n        return total / count\n\n    return averager\n\navg = make_averager()\nprint(avg(10))\nprint(avg(11))\nprint(avg(12))\n```\n\n## 装饰器\n\n了解了闭包之后，下面就可以用嵌套函数实现装饰器了。事实上，装饰器就是一种闭包的应用，只不过传递的是函数。\n\n\n### 无参数装饰器\n\n下面写一个简单的装饰器的例子\n\n\n```python\ndef makebold(fn):\n    def wrapped():\n        return '<b>' + fn() + '</b>'\n\n    return wrapped\n\ndef makeitalic(fn):\n    def wrapped():\n        return '<i>' + fn() + '</i>'\n\n    return wrapped\n\n@makebold\n@makeitalic\ndef hello():\n    return \"Hello World\"\n\nprint(hello())\n```\n\n`makeitalic` 装饰器将函数 `hello` 传递给函数 `makeitalic`，函数 `makeitalic` 执行完毕后返回被包装后的 hello 函数，而这个过程其实就是通过闭包实现的\n\n装饰器有一个语法糖@,直接@my_new_decorator就把上面一坨代码轻松化解了，这就是Pythonic的代码，简洁高效，使用语法糖其实等价于下面显式使用闭包\n\n``` python\nhello_bold = makebold(hello)\nhello_italic = makeitalic(hello)\n```\n\n装饰器是可以叠加使用的，对于Python中的\"@\"语法糖，装饰器的调用顺序与使用 @ 语法糖声明的顺序相反，上面案例中叠加装饰器相当于如下包装顺序：\n\n``` python\nhello = makebold(makeitalic(hello))\n```\n\n### 被装饰的函数带参数\n\n再来一个例子\n\n``` python\nimport time\nimport functools\n\ndef clock(func):\n\n    @functools.wraps(func)\n    def clocked(*args, **kwargs):\n        \"\"\" in wrapper \"\"\"\n        t0 = time.time()\n\n        # execute\n        result = func(*args, **kwargs)\n\n        elapsed = time.time() - t0\n\n        name = func.__name__\n        arg_lst = []\n        if args:\n            arg_lst.append(', '.join(repr(arg) for arg in args))\n        if kwargs:\n            pairs = ['%s=%r' % (k, w) for k, w in sorted(kwargs.items())]\n            arg_lst.append(', '.join(pairs))\n        arg_str = ', '.join(arg_lst)\n        print('[%0.8fs] %s(%s) -> %r ' % (elapsed, name, arg_str, result))\n\n        return result\n    return clocked\n\n@clock\ndef snooze(seconds):\n    \"\"\" sleep for seconds \"\"\"\n    time.sleep(seconds)\n\n@clock\ndef factorial(n):\n    \"\"\" calculate n! \"\"\"\n    return 1 if n<2 else n*factorial(n-1)\n```\n\n`snooze`和`factorial`函数会作为func参数传给clock函数，然后clock函数会返回`clocked`函数。所以现在`factorial`保留的是`clocked`函数的引用。但是这也是装饰器的一个副作用：会把被装饰函数的一些元数据，例如函数名、文档字符串、函数签名等信息覆盖掉。下面会使用functools库中的 `@wraps` 装饰器来避免这个。\n\n![func_ref](http://7xkfga.com1.z0.glb.clouddn.com/func_ref.png)\n\n内嵌包装函数 `clocked` 的参数跟被装饰函数的参数对应，这里使用了 `(*args, **kwargs)`，是为了适应可变参数。\n\nclocked函数做了以下几件事：\n1. 记录初始时间\n2. 调用原来的factorial函数，保存结果\n3. 计算经过的时间\n4. 格式化收集的数据，然后打印出来\n5. 返回第2步保存的结果\n\n``` python\nprint('*'*40, 'Calling factorial(6)')\nprint('6! = ', factorial(6))\n```\n\n![result](http://7xkfga.com1.z0.glb.clouddn.com/result.png)\n\n装饰器的典型行为就是：**把被装饰的函数体换成新函数，二者接受相同的参数，返回被装饰的函数本该返回的值，同时有额外操作**\n\n另外，内嵌包装函数 `clocked` 添加了functools库中的 `@wraps` 装饰器，这个装饰器可以把被包装函数的元数据，例如函数名、文档字符串、函数签名等信息保存下来。\n\n``` python\nprint(snooze(5))\nprint(snooze.__doc__)\nprint('origin func name is:', snooze.__name__)\n```\n\n```\n[5.01506114s] snooze(5) -> None\nNone\n sleep for seconds\norigin func name is: snooze\n```\n\n### 参数化装饰器\n\n如果装饰器本身需要传入参数，那就需要编写一个返回decorator的高阶函数，也就是针对装饰器进行装饰。\n\n下面代码来自 Python Cookbook：\n\n``` python\nfrom functools import wraps\nimport logging\n\ndef logged(level, name=None, message=None):\n    \"\"\"\n    Add logging to a function. level is the logging\n    level, name is the logger name, and message is the\n    log message. If name and message aren't specified,\n    they default to the function's module and name.\n    \"\"\"\n    def decorate(func):\n        logname = name if name else func.__module__\n        log = logging.getLogger(logname)\n        logmsg = message if message else func.__name__\n\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            log.log(level, logmsg)\n            return func(*args, **kwargs)\n        return wrapper\n    return decorate\n\n# Example use\n@logged(logging.DEBUG)\ndef add(x, y):\n    return x + y\n\n@logged(logging.CRITICAL, 'example')\ndef spam():\n    print('Spam!')\n```\n\n最外层的函数 `logged()` 接受参数并将它们作用在内部的装饰器函数上面。 内层的函数 `decorate()` 接受一个函数作为参数，然后在函数上面放置一个包装器。这个装饰器的处理过程相当于：\n\n\n``` python\nspam = logged(x, y)(spam)\n```\n\n首先执行`logged('x', 'y')`，返回的是 `decorate` 函数，再调用返回的函数，参数是 `spam` 函数。\n\n## 装饰器在真实世界的应用\n\n更多的装饰器的案例： [PythonDecoratorLibrary](https://wiki.python.org/moin/PythonDecoratorLibrary)\n\n### 1. 给函数调用做缓存\n\n像求第n个斐波那契数来说，是个递归算法，对于这种慢速递归，可以把耗时函数的结果先缓存起来，在调用函数之前先查询一下缓存，如果没有才调用函数\n\n``` python\nfrom functools import wraps\n\ndef memo(func):\n    cache = {}\n    miss = object()\n\n    @wraps(func)\n    def wrapper(*args):\n        result = cache.get(args, miss)\n        if result is miss:\n            result = func(*args)\n            cache[args] = result\n        return result\n\n    return wrapper\n\n@memo\n@clock\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n-2) + fib(n-1)\n```\n\n也可以使用下面的functools库里面的 `lru_cache` 装饰器来实现缓存。\n\n### 2. LRUCache\n\nLRU就是Least Recently Used，即最近最少使用，是一种内存管理算法。\n\n``` python\nimport functools\n\n@functools.lru_cache()\n@clock\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n-2) + fibonacci(n-1)\n\nprint(fibonacci(6))\n```\n\n### 3. 给函数输出记日志\n\n``` python\nimport time\nfrom functools import wraps\n\ndef log(func):\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print(\"Function running\")\n        ts = time.time()\n        result = func(*args, **kwargs)\n        te = time.time()\n        print(\"Function  = {0}\".format(func.__name__))\n        print(\"Arguments = {0} {1}\".format(args, kwargs))\n        print(\"Return    = {0}\".format(result))\n        print(\"time      = %.6f seconds\" % (te - ts))\n\n    return wrapper\n\n@log\ndef sum(x, y):\n    return x + y\n\nprint(sum(1, 2))\n```\n\n### 4. 数据库连接\n\n``` python\ndef open_and_close_db(func):\n    def wrapper(*a, **k):\n        conn = connect_db()\n        result = func(conn=conn, *a, **k)\n        conn.commit()\n        conn.close()\n        return result\n    return wrapper\n\n@open_and_close_db\ndef query_for_dict(sql, conn):\n    cur = conn.cursor()\n    try:\n        cur.execute(sql)\n        conn.commit()\n        entries = [dict(zip([i[0] for i in cur.description], row)) for row in cur.fetchall()]\n            print entries\n    except Exception,e:\n        print e\n    return entries\n```\n\n### 5. Flask路由\n\n拿Flask的 hello world来说：\n\n``` python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello World!\"\n\nif __name__ == '__main__':\n    app.run()\n```\n\n\n到这儿，装饰器的一些基本概念就都清楚了。\n\n## 参考\n\n[Python 的闭包和装饰器](https://segmentfault.com/a/1190000004461404)\n\n[Fluent Python](https://www.amazon.com/Fluent-Python-Concise-Effective-Programming/dp/1491946008/ref=sr_1_1?ie=UTF8&qid=1500368395&sr=8-1&keywords=fluent+python)\n","source":"_posts/∏„∂ÆPython◊∞ Œ∆˜.md","raw":"---\ntitle: 搞懂Python装饰器\ndate: 2017-07-20 11:49:07\ntags:\n        - Python\n        - 装饰器\n---\n\n\n装饰器是Python中的一个高阶概念，装饰器是可调用的对象，其参数是另外一个函数。装饰器可能会处理被装饰的函数然后把它返回，或者将其替换成另外一个函数或者可调用对象。\n\n这么介绍装饰器确实很难懂，还是以例子逐步理解更容易些。\n\n装饰器的强大在于它能够在不修改原有业务逻辑的情况下对代码进行扩展，常见的应用场景有：权限校验、用户认证、日志记录、性能测试、事务处理、缓存等。\n\n下面记录一下我逐步理解装饰器的过程。\n\n<!-- more -->\n\n## 一等函数\n\n在Python中，函数是一等对象，也就是说函数是满足以下条件的程序实体：\n\n1. 在运行时创建\n2. 能赋值给变量或者数据结构中的元素\n3. 能作为参数传给函数\n4. 能作为函数的返回结果\n\n下面先看一个简单函数的定义\n\n``` python\ndef hello():\n    print(\"Hello world!\")\n```\n\npython解释器遇到这段代码的时候，发生了两件事：\n\n1. 编译代码生成一个函数对象\n2. 将名为\"hello\"的名字绑定到这个函数对象上\n\n![createSimpleFunc](http://7xkfga.com1.z0.glb.clouddn.com/createfunc.png)\n\nPython中函数是一等对象，也就是说函数可以像int、string、float对象一样作为参数、或者作为返回值等进行传递。\n\n### 函数作为参数\n\n``` python\ndef foo(bar):\n    return bar + 1\n\nprint(foo)\nprint(foo(2))\nprint(type(foo))\n\n\ndef call_foo_with_arg(foo, arg):\n    return foo(arg)\n\nprint(call_foo_with_arg(foo, 3))\n```\n\n![](http://7xkfga.com1.z0.glb.clouddn.com/funcAsParam.png)\n\n函数 `call_foo_with_arg` 接收两个参数，其中一个是可被调用的函数对象 `foo`\n\n### 嵌套函数\n\n函数也可以定义在另外一个函数中，作为嵌套函数\n\n``` python\ndef parent():\n    print(\"Printing from the parent() function.\")\n\n    def first_child():\n        return \"Printing from the first_child() function.\"\n\n    def second_child():\n        return \"Printing from the second_child() function.\"\n\n    print(first_child())\n    print(second_child())\n```\n\n`first_child` 和 `second_child` 函数是嵌套在 `parent` 函数中的函数。\n\n![nestedFunction](http://7xkfga.com1.z0.glb.clouddn.com/nestFunc.png)\n\n当调用 `parent` 函数时，内嵌的`first_child` 和 `second_child` 函数也被调用，但是如果在 `parent` 函数中并不是调用`first_child` 和 `second_child` 函数， 而是返回这两个函数对象呢？\n\n下面歪个楼，先介绍一下Python的变量作用域的规则。\n\n## 变量作用域\n\nPython是动态语言，Python的变量名解析机制有时称为LEGB法则，当在函数中使用未认证的变量名时，Python搜索4个作用域：\n\n- local 函数内部作用域\n- enclosing 函数内部与内嵌函数之间\n- global 全局作用域\n- build-in 内置作用域\n\n``` python\ndef f1(a):\n    print(a)\n    print(b)\n\nf1(3)\n```\n\n这段程序会抛出错误：\"NameError: name 'b' is not defined\"，这是因为在函数体内，Python编译器搜索上面 LEGB 的变量，没有找到。\n\n再下面一个例子：\n\n``` python\nb = 6\ndef f2(a):\n    print(a)\n    print(b)\n    b = 9\n\nf2(3)\n```\n\n在Python中，Python不要求声明变量，但是**假定在函数体中被赋值的变量是局部变量**，所以在这个函数体中，变量b被判断成局部变量，所以在print(b)调用时会抛出 \"UnboundLocalError: local variable 'b' referenced before assignment\" 的错误。\n\n要想上面的代码运行，就必须手动在函数体内声明变量b为全局变量\n\n``` python\nb = 6\ndef f2(a):\n    global b\n    print(a)\n    print(b)\n    b = 9\n\nf2(3)\n```\n\n## 闭包\n\n有了上面的背景知识，下面就可以介绍闭包了。**闭包是指延伸了作用域的函数**。\n\n要想理解这个概念还是挺难的，下面还是用例子来说明。\n\n现在有个avg函数，用于计算不断增长的序列的平均值。\n\n``` python\ndef make_averager():\n    series = []\n\n    def averager(new_value):\n        series.append(new_value)\n        total = sum(series)\n        return total / len(series)\n\n    return averager\n\navg = make_averager()\navg(10)\navg(11)\n```\n\n调用函数 `make_averager` 时候，返回一个 `averager` 函数对象，每次调用 `averager` 函数，会把参数添加到 `series` 中，然后计算当前平均值。\n\n`series` 是 `make_averager` 函数的局部变量，调用 `avg(10)` 时， `make_averager` 函数已经返回，所以本地作用域也就不存在了。但是在 `averager` 函数中，`series` 是自由变量\n\n![closure](http://7xkfga.com1.z0.glb.clouddn.com/closure.png)\n\n这里的 `avg` 就是一个闭包，本质上它还是函数，闭包是引用了自由变量(series)的函数(averager)\n\n![avg_func](http://7xkfga.com1.z0.glb.clouddn.com/avg_func_closure.png)\n\n\n### nonlocal声明\n\n刚才的例子稍稍改动一下，使用total和count来计算移动平均值\n\n``` python\ndef make_averager():\n    count = 0\n    total = 0\n\n    def averager(new_value):\n        count += 1\n        total += new_value\n        return total / count\n\n    return averager\n\navg = make_averager()\navg(10)\n```\n\n这时候会抛出错误 \"UnboundLocalError: local variable 'count' referenced before assignment\"。这是因为：当count为数字或者任何不可变类型时，在函数体定义中 `count = count + 1` 实际上是为count赋值，所以count就变成了局部变量。为了避免这个问题，python3引入了 `nonlocal` 声明，作用是把变量标记成 **自由变量**\n\n``` python\ndef make_averager():\n    count = 0\n    total = 0\n\n    def averager(new_value):\n        nonlocal count, total\n        count += 1\n        total += new_value\n        return total / count\n\n    return averager\n\navg = make_averager()\nprint(avg(10))\nprint(avg(11))\nprint(avg(12))\n```\n\n## 装饰器\n\n了解了闭包之后，下面就可以用嵌套函数实现装饰器了。事实上，装饰器就是一种闭包的应用，只不过传递的是函数。\n\n\n### 无参数装饰器\n\n下面写一个简单的装饰器的例子\n\n\n```python\ndef makebold(fn):\n    def wrapped():\n        return '<b>' + fn() + '</b>'\n\n    return wrapped\n\ndef makeitalic(fn):\n    def wrapped():\n        return '<i>' + fn() + '</i>'\n\n    return wrapped\n\n@makebold\n@makeitalic\ndef hello():\n    return \"Hello World\"\n\nprint(hello())\n```\n\n`makeitalic` 装饰器将函数 `hello` 传递给函数 `makeitalic`，函数 `makeitalic` 执行完毕后返回被包装后的 hello 函数，而这个过程其实就是通过闭包实现的\n\n装饰器有一个语法糖@,直接@my_new_decorator就把上面一坨代码轻松化解了，这就是Pythonic的代码，简洁高效，使用语法糖其实等价于下面显式使用闭包\n\n``` python\nhello_bold = makebold(hello)\nhello_italic = makeitalic(hello)\n```\n\n装饰器是可以叠加使用的，对于Python中的\"@\"语法糖，装饰器的调用顺序与使用 @ 语法糖声明的顺序相反，上面案例中叠加装饰器相当于如下包装顺序：\n\n``` python\nhello = makebold(makeitalic(hello))\n```\n\n### 被装饰的函数带参数\n\n再来一个例子\n\n``` python\nimport time\nimport functools\n\ndef clock(func):\n\n    @functools.wraps(func)\n    def clocked(*args, **kwargs):\n        \"\"\" in wrapper \"\"\"\n        t0 = time.time()\n\n        # execute\n        result = func(*args, **kwargs)\n\n        elapsed = time.time() - t0\n\n        name = func.__name__\n        arg_lst = []\n        if args:\n            arg_lst.append(', '.join(repr(arg) for arg in args))\n        if kwargs:\n            pairs = ['%s=%r' % (k, w) for k, w in sorted(kwargs.items())]\n            arg_lst.append(', '.join(pairs))\n        arg_str = ', '.join(arg_lst)\n        print('[%0.8fs] %s(%s) -> %r ' % (elapsed, name, arg_str, result))\n\n        return result\n    return clocked\n\n@clock\ndef snooze(seconds):\n    \"\"\" sleep for seconds \"\"\"\n    time.sleep(seconds)\n\n@clock\ndef factorial(n):\n    \"\"\" calculate n! \"\"\"\n    return 1 if n<2 else n*factorial(n-1)\n```\n\n`snooze`和`factorial`函数会作为func参数传给clock函数，然后clock函数会返回`clocked`函数。所以现在`factorial`保留的是`clocked`函数的引用。但是这也是装饰器的一个副作用：会把被装饰函数的一些元数据，例如函数名、文档字符串、函数签名等信息覆盖掉。下面会使用functools库中的 `@wraps` 装饰器来避免这个。\n\n![func_ref](http://7xkfga.com1.z0.glb.clouddn.com/func_ref.png)\n\n内嵌包装函数 `clocked` 的参数跟被装饰函数的参数对应，这里使用了 `(*args, **kwargs)`，是为了适应可变参数。\n\nclocked函数做了以下几件事：\n1. 记录初始时间\n2. 调用原来的factorial函数，保存结果\n3. 计算经过的时间\n4. 格式化收集的数据，然后打印出来\n5. 返回第2步保存的结果\n\n``` python\nprint('*'*40, 'Calling factorial(6)')\nprint('6! = ', factorial(6))\n```\n\n![result](http://7xkfga.com1.z0.glb.clouddn.com/result.png)\n\n装饰器的典型行为就是：**把被装饰的函数体换成新函数，二者接受相同的参数，返回被装饰的函数本该返回的值，同时有额外操作**\n\n另外，内嵌包装函数 `clocked` 添加了functools库中的 `@wraps` 装饰器，这个装饰器可以把被包装函数的元数据，例如函数名、文档字符串、函数签名等信息保存下来。\n\n``` python\nprint(snooze(5))\nprint(snooze.__doc__)\nprint('origin func name is:', snooze.__name__)\n```\n\n```\n[5.01506114s] snooze(5) -> None\nNone\n sleep for seconds\norigin func name is: snooze\n```\n\n### 参数化装饰器\n\n如果装饰器本身需要传入参数，那就需要编写一个返回decorator的高阶函数，也就是针对装饰器进行装饰。\n\n下面代码来自 Python Cookbook：\n\n``` python\nfrom functools import wraps\nimport logging\n\ndef logged(level, name=None, message=None):\n    \"\"\"\n    Add logging to a function. level is the logging\n    level, name is the logger name, and message is the\n    log message. If name and message aren't specified,\n    they default to the function's module and name.\n    \"\"\"\n    def decorate(func):\n        logname = name if name else func.__module__\n        log = logging.getLogger(logname)\n        logmsg = message if message else func.__name__\n\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            log.log(level, logmsg)\n            return func(*args, **kwargs)\n        return wrapper\n    return decorate\n\n# Example use\n@logged(logging.DEBUG)\ndef add(x, y):\n    return x + y\n\n@logged(logging.CRITICAL, 'example')\ndef spam():\n    print('Spam!')\n```\n\n最外层的函数 `logged()` 接受参数并将它们作用在内部的装饰器函数上面。 内层的函数 `decorate()` 接受一个函数作为参数，然后在函数上面放置一个包装器。这个装饰器的处理过程相当于：\n\n\n``` python\nspam = logged(x, y)(spam)\n```\n\n首先执行`logged('x', 'y')`，返回的是 `decorate` 函数，再调用返回的函数，参数是 `spam` 函数。\n\n## 装饰器在真实世界的应用\n\n更多的装饰器的案例： [PythonDecoratorLibrary](https://wiki.python.org/moin/PythonDecoratorLibrary)\n\n### 1. 给函数调用做缓存\n\n像求第n个斐波那契数来说，是个递归算法，对于这种慢速递归，可以把耗时函数的结果先缓存起来，在调用函数之前先查询一下缓存，如果没有才调用函数\n\n``` python\nfrom functools import wraps\n\ndef memo(func):\n    cache = {}\n    miss = object()\n\n    @wraps(func)\n    def wrapper(*args):\n        result = cache.get(args, miss)\n        if result is miss:\n            result = func(*args)\n            cache[args] = result\n        return result\n\n    return wrapper\n\n@memo\n@clock\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n-2) + fib(n-1)\n```\n\n也可以使用下面的functools库里面的 `lru_cache` 装饰器来实现缓存。\n\n### 2. LRUCache\n\nLRU就是Least Recently Used，即最近最少使用，是一种内存管理算法。\n\n``` python\nimport functools\n\n@functools.lru_cache()\n@clock\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n-2) + fibonacci(n-1)\n\nprint(fibonacci(6))\n```\n\n### 3. 给函数输出记日志\n\n``` python\nimport time\nfrom functools import wraps\n\ndef log(func):\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print(\"Function running\")\n        ts = time.time()\n        result = func(*args, **kwargs)\n        te = time.time()\n        print(\"Function  = {0}\".format(func.__name__))\n        print(\"Arguments = {0} {1}\".format(args, kwargs))\n        print(\"Return    = {0}\".format(result))\n        print(\"time      = %.6f seconds\" % (te - ts))\n\n    return wrapper\n\n@log\ndef sum(x, y):\n    return x + y\n\nprint(sum(1, 2))\n```\n\n### 4. 数据库连接\n\n``` python\ndef open_and_close_db(func):\n    def wrapper(*a, **k):\n        conn = connect_db()\n        result = func(conn=conn, *a, **k)\n        conn.commit()\n        conn.close()\n        return result\n    return wrapper\n\n@open_and_close_db\ndef query_for_dict(sql, conn):\n    cur = conn.cursor()\n    try:\n        cur.execute(sql)\n        conn.commit()\n        entries = [dict(zip([i[0] for i in cur.description], row)) for row in cur.fetchall()]\n            print entries\n    except Exception,e:\n        print e\n    return entries\n```\n\n### 5. Flask路由\n\n拿Flask的 hello world来说：\n\n``` python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello World!\"\n\nif __name__ == '__main__':\n    app.run()\n```\n\n\n到这儿，装饰器的一些基本概念就都清楚了。\n\n## 参考\n\n[Python 的闭包和装饰器](https://segmentfault.com/a/1190000004461404)\n\n[Fluent Python](https://www.amazon.com/Fluent-Python-Concise-Effective-Programming/dp/1491946008/ref=sr_1_1?ie=UTF8&qid=1500368395&sr=8-1&keywords=fluent+python)\n","slug":"∏„∂ÆPython◊∞ Œ∆˜","published":1,"updated":"2017-07-24T09:00:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfkkp3ph004uzd68bv5cee57","content":"<p>装饰器是Python中的一个高阶概念，装饰器是可调用的对象，其参数是另外一个函数。装饰器可能会处理被装饰的函数然后把它返回，或者将其替换成另外一个函数或者可调用对象。</p>\n<p>这么介绍装饰器确实很难懂，还是以例子逐步理解更容易些。</p>\n<p>装饰器的强大在于它能够在不修改原有业务逻辑的情况下对代码进行扩展，常见的应用场景有：权限校验、用户认证、日志记录、性能测试、事务处理、缓存等。</p>\n<p>下面记录一下我逐步理解装饰器的过程。</p>\n<a id=\"more\"></a>\n<h2 id=\"一等函数\"><a href=\"#一等函数\" class=\"headerlink\" title=\"一等函数\"></a>一等函数</h2><p>在Python中，函数是一等对象，也就是说函数是满足以下条件的程序实体：</p>\n<ol>\n<li>在运行时创建</li>\n<li>能赋值给变量或者数据结构中的元素</li>\n<li>能作为参数传给函数</li>\n<li>能作为函数的返回结果</li>\n</ol>\n<p>下面先看一个简单函数的定义</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"Hello world!\"</span>)</span><br></pre></td></tr></table></figure>\n<p>python解释器遇到这段代码的时候，发生了两件事：</p>\n<ol>\n<li>编译代码生成一个函数对象</li>\n<li>将名为”hello”的名字绑定到这个函数对象上</li>\n</ol>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/createfunc.png\" alt=\"createSimpleFunc\"></p>\n<p>Python中函数是一等对象，也就是说函数可以像int、string、float对象一样作为参数、或者作为返回值等进行传递。</p>\n<h3 id=\"函数作为参数\"><a href=\"#函数作为参数\" class=\"headerlink\" title=\"函数作为参数\"></a>函数作为参数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(bar)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(foo)</span><br><span class=\"line\">print(foo(<span class=\"number\">2</span>))</span><br><span class=\"line\">print(type(foo))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">call_foo_with_arg</span><span class=\"params\">(foo, arg)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> foo(arg)</span><br><span class=\"line\"></span><br><span class=\"line\">print(call_foo_with_arg(foo, <span class=\"number\">3</span>))</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/funcAsParam.png\" alt=\"\"></p>\n<p>函数 <code>call_foo_with_arg</code> 接收两个参数，其中一个是可被调用的函数对象 <code>foo</code></p>\n<h3 id=\"嵌套函数\"><a href=\"#嵌套函数\" class=\"headerlink\" title=\"嵌套函数\"></a>嵌套函数</h3><p>函数也可以定义在另外一个函数中，作为嵌套函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parent</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"Printing from the parent() function.\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">first_child</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Printing from the first_child() function.\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">second_child</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Printing from the second_child() function.\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    print(first_child())</span><br><span class=\"line\">    print(second_child())</span><br></pre></td></tr></table></figure>\n<p><code>first_child</code> 和 <code>second_child</code> 函数是嵌套在 <code>parent</code> 函数中的函数。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/nestFunc.png\" alt=\"nestedFunction\"></p>\n<p>当调用 <code>parent</code> 函数时，内嵌的<code>first_child</code> 和 <code>second_child</code> 函数也被调用，但是如果在 <code>parent</code> 函数中并不是调用<code>first_child</code> 和 <code>second_child</code> 函数， 而是返回这两个函数对象呢？</p>\n<p>下面歪个楼，先介绍一下Python的变量作用域的规则。</p>\n<h2 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h2><p>Python是动态语言，Python的变量名解析机制有时称为LEGB法则，当在函数中使用未认证的变量名时，Python搜索4个作用域：</p>\n<ul>\n<li>local 函数内部作用域</li>\n<li>enclosing 函数内部与内嵌函数之间</li>\n<li>global 全局作用域</li>\n<li>build-in 内置作用域</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f1</span><span class=\"params\">(a)</span>:</span></span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    print(b)</span><br><span class=\"line\"></span><br><span class=\"line\">f1(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>这段程序会抛出错误：”NameError: name ‘b’ is not defined”，这是因为在函数体内，Python编译器搜索上面 LEGB 的变量，没有找到。</p>\n<p>再下面一个例子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f2</span><span class=\"params\">(a)</span>:</span></span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    print(b)</span><br><span class=\"line\">    b = <span class=\"number\">9</span></span><br><span class=\"line\"></span><br><span class=\"line\">f2(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>在Python中，Python不要求声明变量，但是<strong>假定在函数体中被赋值的变量是局部变量</strong>，所以在这个函数体中，变量b被判断成局部变量，所以在print(b)调用时会抛出 “UnboundLocalError: local variable ‘b’ referenced before assignment” 的错误。</p>\n<p>要想上面的代码运行，就必须手动在函数体内声明变量b为全局变量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f2</span><span class=\"params\">(a)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> b</span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    print(b)</span><br><span class=\"line\">    b = <span class=\"number\">9</span></span><br><span class=\"line\"></span><br><span class=\"line\">f2(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>有了上面的背景知识，下面就可以介绍闭包了。<strong>闭包是指延伸了作用域的函数</strong>。</p>\n<p>要想理解这个概念还是挺难的，下面还是用例子来说明。</p>\n<p>现在有个avg函数，用于计算不断增长的序列的平均值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_averager</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    series = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averager</span><span class=\"params\">(new_value)</span>:</span></span><br><span class=\"line\">        series.append(new_value)</span><br><span class=\"line\">        total = sum(series)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total / len(series)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> averager</span><br><span class=\"line\"></span><br><span class=\"line\">avg = make_averager()</span><br><span class=\"line\">avg(<span class=\"number\">10</span>)</span><br><span class=\"line\">avg(<span class=\"number\">11</span>)</span><br></pre></td></tr></table></figure>\n<p>调用函数 <code>make_averager</code> 时候，返回一个 <code>averager</code> 函数对象，每次调用 <code>averager</code> 函数，会把参数添加到 <code>series</code> 中，然后计算当前平均值。</p>\n<p><code>series</code> 是 <code>make_averager</code> 函数的局部变量，调用 <code>avg(10)</code> 时， <code>make_averager</code> 函数已经返回，所以本地作用域也就不存在了。但是在 <code>averager</code> 函数中，<code>series</code> 是自由变量</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/closure.png\" alt=\"closure\"></p>\n<p>这里的 <code>avg</code> 就是一个闭包，本质上它还是函数，闭包是引用了自由变量(series)的函数(averager)</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/avg_func_closure.png\" alt=\"avg_func\"></p>\n<h3 id=\"nonlocal声明\"><a href=\"#nonlocal声明\" class=\"headerlink\" title=\"nonlocal声明\"></a>nonlocal声明</h3><p>刚才的例子稍稍改动一下，使用total和count来计算移动平均值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_averager</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    total = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averager</span><span class=\"params\">(new_value)</span>:</span></span><br><span class=\"line\">        count += <span class=\"number\">1</span></span><br><span class=\"line\">        total += new_value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total / count</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> averager</span><br><span class=\"line\"></span><br><span class=\"line\">avg = make_averager()</span><br><span class=\"line\">avg(<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>这时候会抛出错误 “UnboundLocalError: local variable ‘count’ referenced before assignment”。这是因为：当count为数字或者任何不可变类型时，在函数体定义中 <code>count = count + 1</code> 实际上是为count赋值，所以count就变成了局部变量。为了避免这个问题，python3引入了 <code>nonlocal</code> 声明，作用是把变量标记成 <strong>自由变量</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_averager</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    total = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averager</span><span class=\"params\">(new_value)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span> count, total</span><br><span class=\"line\">        count += <span class=\"number\">1</span></span><br><span class=\"line\">        total += new_value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total / count</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> averager</span><br><span class=\"line\"></span><br><span class=\"line\">avg = make_averager()</span><br><span class=\"line\">print(avg(<span class=\"number\">10</span>))</span><br><span class=\"line\">print(avg(<span class=\"number\">11</span>))</span><br><span class=\"line\">print(avg(<span class=\"number\">12</span>))</span><br></pre></td></tr></table></figure>\n<h2 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h2><p>了解了闭包之后，下面就可以用嵌套函数实现装饰器了。事实上，装饰器就是一种闭包的应用，只不过传递的是函数。</p>\n<h3 id=\"无参数装饰器\"><a href=\"#无参数装饰器\" class=\"headerlink\" title=\"无参数装饰器\"></a>无参数装饰器</h3><p>下面写一个简单的装饰器的例子</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">makebold</span><span class=\"params\">(fn)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapped</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'&lt;b&gt;'</span> + fn() + <span class=\"string\">'&lt;/b&gt;'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapped</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">makeitalic</span><span class=\"params\">(fn)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapped</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'&lt;i&gt;'</span> + fn() + <span class=\"string\">'&lt;/i&gt;'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapped</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@makebold</span></span><br><span class=\"line\"><span class=\"meta\">@makeitalic</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(hello())</span><br></pre></td></tr></table></figure>\n<p><code>makeitalic</code> 装饰器将函数 <code>hello</code> 传递给函数 <code>makeitalic</code>，函数 <code>makeitalic</code> 执行完毕后返回被包装后的 hello 函数，而这个过程其实就是通过闭包实现的</p>\n<p>装饰器有一个语法糖@,直接@my_new_decorator就把上面一坨代码轻松化解了，这就是Pythonic的代码，简洁高效，使用语法糖其实等价于下面显式使用闭包</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello_bold = makebold(hello)</span><br><span class=\"line\">hello_italic = makeitalic(hello)</span><br></pre></td></tr></table></figure>\n<p>装饰器是可以叠加使用的，对于Python中的”@”语法糖，装饰器的调用顺序与使用 @ 语法糖声明的顺序相反，上面案例中叠加装饰器相当于如下包装顺序：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello = makebold(makeitalic(hello))</span><br></pre></td></tr></table></figure>\n<h3 id=\"被装饰的函数带参数\"><a href=\"#被装饰的函数带参数\" class=\"headerlink\" title=\"被装饰的函数带参数\"></a>被装饰的函数带参数</h3><p>再来一个例子</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">clock</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @functools.wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">clocked</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\" in wrapper \"\"\"</span></span><br><span class=\"line\">        t0 = time.time()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># execute</span></span><br><span class=\"line\">        result = func(*args, **kwargs)</span><br><span class=\"line\"></span><br><span class=\"line\">        elapsed = time.time() - t0</span><br><span class=\"line\"></span><br><span class=\"line\">        name = func.__name__</span><br><span class=\"line\">        arg_lst = []</span><br><span class=\"line\">        <span class=\"keyword\">if</span> args:</span><br><span class=\"line\">            arg_lst.append(<span class=\"string\">', '</span>.join(repr(arg) <span class=\"keyword\">for</span> arg <span class=\"keyword\">in</span> args))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> kwargs:</span><br><span class=\"line\">            pairs = [<span class=\"string\">'%s=%r'</span> % (k, w) <span class=\"keyword\">for</span> k, w <span class=\"keyword\">in</span> sorted(kwargs.items())]</span><br><span class=\"line\">            arg_lst.append(<span class=\"string\">', '</span>.join(pairs))</span><br><span class=\"line\">        arg_str = <span class=\"string\">', '</span>.join(arg_lst)</span><br><span class=\"line\">        print(<span class=\"string\">'[%0.8fs] %s(%s) -&gt; %r '</span> % (elapsed, name, arg_str, result))</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    <span class=\"keyword\">return</span> clocked</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@clock</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">snooze</span><span class=\"params\">(seconds)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\" sleep for seconds \"\"\"</span></span><br><span class=\"line\">    time.sleep(seconds)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@clock</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">factorial</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\" calculate n! \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span> <span class=\"keyword\">if</span> n&lt;<span class=\"number\">2</span> <span class=\"keyword\">else</span> n*factorial(n<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<p><code>snooze</code>和<code>factorial</code>函数会作为func参数传给clock函数，然后clock函数会返回<code>clocked</code>函数。所以现在<code>factorial</code>保留的是<code>clocked</code>函数的引用。但是这也是装饰器的一个副作用：会把被装饰函数的一些元数据，例如函数名、文档字符串、函数签名等信息覆盖掉。下面会使用functools库中的 <code>@wraps</code> 装饰器来避免这个。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/func_ref.png\" alt=\"func_ref\"></p>\n<p>内嵌包装函数 <code>clocked</code> 的参数跟被装饰函数的参数对应，这里使用了 <code>(*args, **kwargs)</code>，是为了适应可变参数。</p>\n<p>clocked函数做了以下几件事：</p>\n<ol>\n<li>记录初始时间</li>\n<li>调用原来的factorial函数，保存结果</li>\n<li>计算经过的时间</li>\n<li>格式化收集的数据，然后打印出来</li>\n<li>返回第2步保存的结果</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(<span class=\"string\">'*'</span>*<span class=\"number\">40</span>, <span class=\"string\">'Calling factorial(6)'</span>)</span><br><span class=\"line\">print(<span class=\"string\">'6! = '</span>, factorial(<span class=\"number\">6</span>))</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/result.png\" alt=\"result\"></p>\n<p>装饰器的典型行为就是：<strong>把被装饰的函数体换成新函数，二者接受相同的参数，返回被装饰的函数本该返回的值，同时有额外操作</strong></p>\n<p>另外，内嵌包装函数 <code>clocked</code> 添加了functools库中的 <code>@wraps</code> 装饰器，这个装饰器可以把被包装函数的元数据，例如函数名、文档字符串、函数签名等信息保存下来。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(snooze(<span class=\"number\">5</span>))</span><br><span class=\"line\">print(snooze.__doc__)</span><br><span class=\"line\">print(<span class=\"string\">'origin func name is:'</span>, snooze.__name__)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[5.01506114s] snooze(5) -&gt; None</span><br><span class=\"line\">None</span><br><span class=\"line\"> sleep for seconds</span><br><span class=\"line\">origin func name is: snooze</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数化装饰器\"><a href=\"#参数化装饰器\" class=\"headerlink\" title=\"参数化装饰器\"></a>参数化装饰器</h3><p>如果装饰器本身需要传入参数，那就需要编写一个返回decorator的高阶函数，也就是针对装饰器进行装饰。</p>\n<p>下面代码来自 Python Cookbook：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> wraps</span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">logged</span><span class=\"params\">(level, name=None, message=None)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    Add logging to a function. level is the logging</span></span><br><span class=\"line\"><span class=\"string\">    level, name is the logger name, and message is the</span></span><br><span class=\"line\"><span class=\"string\">    log message. If name and message aren't specified,</span></span><br><span class=\"line\"><span class=\"string\">    they default to the function's module and name.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorate</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">        logname = name <span class=\"keyword\">if</span> name <span class=\"keyword\">else</span> func.__module__</span><br><span class=\"line\">        log = logging.getLogger(logname)</span><br><span class=\"line\">        logmsg = message <span class=\"keyword\">if</span> message <span class=\"keyword\">else</span> func.__name__</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">        @wraps(func)</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">            log.log(level, logmsg)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Example use</span></span><br><span class=\"line\"><span class=\"meta\">@logged(logging.DEBUG)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@logged(logging.CRITICAL, 'example')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spam</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Spam!'</span>)</span><br></pre></td></tr></table></figure>\n<p>最外层的函数 <code>logged()</code> 接受参数并将它们作用在内部的装饰器函数上面。 内层的函数 <code>decorate()</code> 接受一个函数作为参数，然后在函数上面放置一个包装器。这个装饰器的处理过程相当于：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spam = logged(x, y)(spam)</span><br></pre></td></tr></table></figure>\n<p>首先执行<code>logged(&#39;x&#39;, &#39;y&#39;)</code>，返回的是 <code>decorate</code> 函数，再调用返回的函数，参数是 <code>spam</code> 函数。</p>\n<h2 id=\"装饰器在真实世界的应用\"><a href=\"#装饰器在真实世界的应用\" class=\"headerlink\" title=\"装饰器在真实世界的应用\"></a>装饰器在真实世界的应用</h2><p>更多的装饰器的案例： <a href=\"https://wiki.python.org/moin/PythonDecoratorLibrary\" target=\"_blank\" rel=\"noopener\">PythonDecoratorLibrary</a></p>\n<h3 id=\"1-给函数调用做缓存\"><a href=\"#1-给函数调用做缓存\" class=\"headerlink\" title=\"1. 给函数调用做缓存\"></a>1. 给函数调用做缓存</h3><p>像求第n个斐波那契数来说，是个递归算法，对于这种慢速递归，可以把耗时函数的结果先缓存起来，在调用函数之前先查询一下缓存，如果没有才调用函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> wraps</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">memo</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    cache = &#123;&#125;</span><br><span class=\"line\">    miss = object()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args)</span>:</span></span><br><span class=\"line\">        result = cache.get(args, miss)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> result <span class=\"keyword\">is</span> miss:</span><br><span class=\"line\">            result = func(*args)</span><br><span class=\"line\">            cache[args] = result</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@memo</span></span><br><span class=\"line\"><span class=\"meta\">@clock</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &lt; <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fib(n<span class=\"number\">-2</span>) + fib(n<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<p>也可以使用下面的functools库里面的 <code>lru_cache</code> 装饰器来实现缓存。</p>\n<h3 id=\"2-LRUCache\"><a href=\"#2-LRUCache\" class=\"headerlink\" title=\"2. LRUCache\"></a>2. LRUCache</h3><p>LRU就是Least Recently Used，即最近最少使用，是一种内存管理算法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@functools.lru_cache()</span></span><br><span class=\"line\"><span class=\"meta\">@clock</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fibonacci</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &lt; <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fibonacci(n<span class=\"number\">-2</span>) + fibonacci(n<span class=\"number\">-1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(fibonacci(<span class=\"number\">6</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-给函数输出记日志\"><a href=\"#3-给函数输出记日志\" class=\"headerlink\" title=\"3. 给函数输出记日志\"></a>3. 给函数输出记日志</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> wraps</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"Function running\"</span>)</span><br><span class=\"line\">        ts = time.time()</span><br><span class=\"line\">        result = func(*args, **kwargs)</span><br><span class=\"line\">        te = time.time()</span><br><span class=\"line\">        print(<span class=\"string\">\"Function  = &#123;0&#125;\"</span>.format(func.__name__))</span><br><span class=\"line\">        print(<span class=\"string\">\"Arguments = &#123;0&#125; &#123;1&#125;\"</span>.format(args, kwargs))</span><br><span class=\"line\">        print(<span class=\"string\">\"Return    = &#123;0&#125;\"</span>.format(result))</span><br><span class=\"line\">        print(<span class=\"string\">\"time      = %.6f seconds\"</span> % (te - ts))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\"></span><br><span class=\"line\">print(sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-数据库连接\"><a href=\"#4-数据库连接\" class=\"headerlink\" title=\"4. 数据库连接\"></a>4. 数据库连接</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">open_and_close_db</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*a, **k)</span>:</span></span><br><span class=\"line\">        conn = connect_db()</span><br><span class=\"line\">        result = func(conn=conn, *a, **k)</span><br><span class=\"line\">        conn.commit()</span><br><span class=\"line\">        conn.close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@open_and_close_db</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">query_for_dict</span><span class=\"params\">(sql, conn)</span>:</span></span><br><span class=\"line\">    cur = conn.cursor()</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        cur.execute(sql)</span><br><span class=\"line\">        conn.commit()</span><br><span class=\"line\">        entries = [dict(zip([i[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> cur.description], row)) <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> cur.fetchall()]</span><br><span class=\"line\">            <span class=\"keyword\">print</span> entries</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception,e:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> e</span><br><span class=\"line\">    <span class=\"keyword\">return</span> entries</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-Flask路由\"><a href=\"#5-Flask路由\" class=\"headerlink\" title=\"5. Flask路由\"></a>5. Flask路由</h3><p>拿Flask的 hello world来说：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(\"/\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p>到这儿，装饰器的一些基本概念就都清楚了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://segmentfault.com/a/1190000004461404\" target=\"_blank\" rel=\"noopener\">Python 的闭包和装饰器</a></p>\n<p><a href=\"https://www.amazon.com/Fluent-Python-Concise-Effective-Programming/dp/1491946008/ref=sr_1_1?ie=UTF8&amp;qid=1500368395&amp;sr=8-1&amp;keywords=fluent+python\" target=\"_blank\" rel=\"noopener\">Fluent Python</a></p>\n","site":{"data":{}},"excerpt":"<p>装饰器是Python中的一个高阶概念，装饰器是可调用的对象，其参数是另外一个函数。装饰器可能会处理被装饰的函数然后把它返回，或者将其替换成另外一个函数或者可调用对象。</p>\n<p>这么介绍装饰器确实很难懂，还是以例子逐步理解更容易些。</p>\n<p>装饰器的强大在于它能够在不修改原有业务逻辑的情况下对代码进行扩展，常见的应用场景有：权限校验、用户认证、日志记录、性能测试、事务处理、缓存等。</p>\n<p>下面记录一下我逐步理解装饰器的过程。</p>","more":"<h2 id=\"一等函数\"><a href=\"#一等函数\" class=\"headerlink\" title=\"一等函数\"></a>一等函数</h2><p>在Python中，函数是一等对象，也就是说函数是满足以下条件的程序实体：</p>\n<ol>\n<li>在运行时创建</li>\n<li>能赋值给变量或者数据结构中的元素</li>\n<li>能作为参数传给函数</li>\n<li>能作为函数的返回结果</li>\n</ol>\n<p>下面先看一个简单函数的定义</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"Hello world!\"</span>)</span><br></pre></td></tr></table></figure>\n<p>python解释器遇到这段代码的时候，发生了两件事：</p>\n<ol>\n<li>编译代码生成一个函数对象</li>\n<li>将名为”hello”的名字绑定到这个函数对象上</li>\n</ol>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/createfunc.png\" alt=\"createSimpleFunc\"></p>\n<p>Python中函数是一等对象，也就是说函数可以像int、string、float对象一样作为参数、或者作为返回值等进行传递。</p>\n<h3 id=\"函数作为参数\"><a href=\"#函数作为参数\" class=\"headerlink\" title=\"函数作为参数\"></a>函数作为参数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(bar)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(foo)</span><br><span class=\"line\">print(foo(<span class=\"number\">2</span>))</span><br><span class=\"line\">print(type(foo))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">call_foo_with_arg</span><span class=\"params\">(foo, arg)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> foo(arg)</span><br><span class=\"line\"></span><br><span class=\"line\">print(call_foo_with_arg(foo, <span class=\"number\">3</span>))</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/funcAsParam.png\" alt=\"\"></p>\n<p>函数 <code>call_foo_with_arg</code> 接收两个参数，其中一个是可被调用的函数对象 <code>foo</code></p>\n<h3 id=\"嵌套函数\"><a href=\"#嵌套函数\" class=\"headerlink\" title=\"嵌套函数\"></a>嵌套函数</h3><p>函数也可以定义在另外一个函数中，作为嵌套函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parent</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"Printing from the parent() function.\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">first_child</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Printing from the first_child() function.\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">second_child</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Printing from the second_child() function.\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    print(first_child())</span><br><span class=\"line\">    print(second_child())</span><br></pre></td></tr></table></figure>\n<p><code>first_child</code> 和 <code>second_child</code> 函数是嵌套在 <code>parent</code> 函数中的函数。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/nestFunc.png\" alt=\"nestedFunction\"></p>\n<p>当调用 <code>parent</code> 函数时，内嵌的<code>first_child</code> 和 <code>second_child</code> 函数也被调用，但是如果在 <code>parent</code> 函数中并不是调用<code>first_child</code> 和 <code>second_child</code> 函数， 而是返回这两个函数对象呢？</p>\n<p>下面歪个楼，先介绍一下Python的变量作用域的规则。</p>\n<h2 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h2><p>Python是动态语言，Python的变量名解析机制有时称为LEGB法则，当在函数中使用未认证的变量名时，Python搜索4个作用域：</p>\n<ul>\n<li>local 函数内部作用域</li>\n<li>enclosing 函数内部与内嵌函数之间</li>\n<li>global 全局作用域</li>\n<li>build-in 内置作用域</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f1</span><span class=\"params\">(a)</span>:</span></span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    print(b)</span><br><span class=\"line\"></span><br><span class=\"line\">f1(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>这段程序会抛出错误：”NameError: name ‘b’ is not defined”，这是因为在函数体内，Python编译器搜索上面 LEGB 的变量，没有找到。</p>\n<p>再下面一个例子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f2</span><span class=\"params\">(a)</span>:</span></span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    print(b)</span><br><span class=\"line\">    b = <span class=\"number\">9</span></span><br><span class=\"line\"></span><br><span class=\"line\">f2(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>在Python中，Python不要求声明变量，但是<strong>假定在函数体中被赋值的变量是局部变量</strong>，所以在这个函数体中，变量b被判断成局部变量，所以在print(b)调用时会抛出 “UnboundLocalError: local variable ‘b’ referenced before assignment” 的错误。</p>\n<p>要想上面的代码运行，就必须手动在函数体内声明变量b为全局变量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f2</span><span class=\"params\">(a)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> b</span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    print(b)</span><br><span class=\"line\">    b = <span class=\"number\">9</span></span><br><span class=\"line\"></span><br><span class=\"line\">f2(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>有了上面的背景知识，下面就可以介绍闭包了。<strong>闭包是指延伸了作用域的函数</strong>。</p>\n<p>要想理解这个概念还是挺难的，下面还是用例子来说明。</p>\n<p>现在有个avg函数，用于计算不断增长的序列的平均值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_averager</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    series = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averager</span><span class=\"params\">(new_value)</span>:</span></span><br><span class=\"line\">        series.append(new_value)</span><br><span class=\"line\">        total = sum(series)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total / len(series)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> averager</span><br><span class=\"line\"></span><br><span class=\"line\">avg = make_averager()</span><br><span class=\"line\">avg(<span class=\"number\">10</span>)</span><br><span class=\"line\">avg(<span class=\"number\">11</span>)</span><br></pre></td></tr></table></figure>\n<p>调用函数 <code>make_averager</code> 时候，返回一个 <code>averager</code> 函数对象，每次调用 <code>averager</code> 函数，会把参数添加到 <code>series</code> 中，然后计算当前平均值。</p>\n<p><code>series</code> 是 <code>make_averager</code> 函数的局部变量，调用 <code>avg(10)</code> 时， <code>make_averager</code> 函数已经返回，所以本地作用域也就不存在了。但是在 <code>averager</code> 函数中，<code>series</code> 是自由变量</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/closure.png\" alt=\"closure\"></p>\n<p>这里的 <code>avg</code> 就是一个闭包，本质上它还是函数，闭包是引用了自由变量(series)的函数(averager)</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/avg_func_closure.png\" alt=\"avg_func\"></p>\n<h3 id=\"nonlocal声明\"><a href=\"#nonlocal声明\" class=\"headerlink\" title=\"nonlocal声明\"></a>nonlocal声明</h3><p>刚才的例子稍稍改动一下，使用total和count来计算移动平均值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_averager</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    total = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averager</span><span class=\"params\">(new_value)</span>:</span></span><br><span class=\"line\">        count += <span class=\"number\">1</span></span><br><span class=\"line\">        total += new_value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total / count</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> averager</span><br><span class=\"line\"></span><br><span class=\"line\">avg = make_averager()</span><br><span class=\"line\">avg(<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>这时候会抛出错误 “UnboundLocalError: local variable ‘count’ referenced before assignment”。这是因为：当count为数字或者任何不可变类型时，在函数体定义中 <code>count = count + 1</code> 实际上是为count赋值，所以count就变成了局部变量。为了避免这个问题，python3引入了 <code>nonlocal</code> 声明，作用是把变量标记成 <strong>自由变量</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_averager</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    total = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averager</span><span class=\"params\">(new_value)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span> count, total</span><br><span class=\"line\">        count += <span class=\"number\">1</span></span><br><span class=\"line\">        total += new_value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total / count</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> averager</span><br><span class=\"line\"></span><br><span class=\"line\">avg = make_averager()</span><br><span class=\"line\">print(avg(<span class=\"number\">10</span>))</span><br><span class=\"line\">print(avg(<span class=\"number\">11</span>))</span><br><span class=\"line\">print(avg(<span class=\"number\">12</span>))</span><br></pre></td></tr></table></figure>\n<h2 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h2><p>了解了闭包之后，下面就可以用嵌套函数实现装饰器了。事实上，装饰器就是一种闭包的应用，只不过传递的是函数。</p>\n<h3 id=\"无参数装饰器\"><a href=\"#无参数装饰器\" class=\"headerlink\" title=\"无参数装饰器\"></a>无参数装饰器</h3><p>下面写一个简单的装饰器的例子</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">makebold</span><span class=\"params\">(fn)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapped</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'&lt;b&gt;'</span> + fn() + <span class=\"string\">'&lt;/b&gt;'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapped</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">makeitalic</span><span class=\"params\">(fn)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapped</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'&lt;i&gt;'</span> + fn() + <span class=\"string\">'&lt;/i&gt;'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapped</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@makebold</span></span><br><span class=\"line\"><span class=\"meta\">@makeitalic</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(hello())</span><br></pre></td></tr></table></figure>\n<p><code>makeitalic</code> 装饰器将函数 <code>hello</code> 传递给函数 <code>makeitalic</code>，函数 <code>makeitalic</code> 执行完毕后返回被包装后的 hello 函数，而这个过程其实就是通过闭包实现的</p>\n<p>装饰器有一个语法糖@,直接@my_new_decorator就把上面一坨代码轻松化解了，这就是Pythonic的代码，简洁高效，使用语法糖其实等价于下面显式使用闭包</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello_bold = makebold(hello)</span><br><span class=\"line\">hello_italic = makeitalic(hello)</span><br></pre></td></tr></table></figure>\n<p>装饰器是可以叠加使用的，对于Python中的”@”语法糖，装饰器的调用顺序与使用 @ 语法糖声明的顺序相反，上面案例中叠加装饰器相当于如下包装顺序：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello = makebold(makeitalic(hello))</span><br></pre></td></tr></table></figure>\n<h3 id=\"被装饰的函数带参数\"><a href=\"#被装饰的函数带参数\" class=\"headerlink\" title=\"被装饰的函数带参数\"></a>被装饰的函数带参数</h3><p>再来一个例子</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">clock</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @functools.wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">clocked</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\" in wrapper \"\"\"</span></span><br><span class=\"line\">        t0 = time.time()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># execute</span></span><br><span class=\"line\">        result = func(*args, **kwargs)</span><br><span class=\"line\"></span><br><span class=\"line\">        elapsed = time.time() - t0</span><br><span class=\"line\"></span><br><span class=\"line\">        name = func.__name__</span><br><span class=\"line\">        arg_lst = []</span><br><span class=\"line\">        <span class=\"keyword\">if</span> args:</span><br><span class=\"line\">            arg_lst.append(<span class=\"string\">', '</span>.join(repr(arg) <span class=\"keyword\">for</span> arg <span class=\"keyword\">in</span> args))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> kwargs:</span><br><span class=\"line\">            pairs = [<span class=\"string\">'%s=%r'</span> % (k, w) <span class=\"keyword\">for</span> k, w <span class=\"keyword\">in</span> sorted(kwargs.items())]</span><br><span class=\"line\">            arg_lst.append(<span class=\"string\">', '</span>.join(pairs))</span><br><span class=\"line\">        arg_str = <span class=\"string\">', '</span>.join(arg_lst)</span><br><span class=\"line\">        print(<span class=\"string\">'[%0.8fs] %s(%s) -&gt; %r '</span> % (elapsed, name, arg_str, result))</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    <span class=\"keyword\">return</span> clocked</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@clock</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">snooze</span><span class=\"params\">(seconds)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\" sleep for seconds \"\"\"</span></span><br><span class=\"line\">    time.sleep(seconds)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@clock</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">factorial</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\" calculate n! \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span> <span class=\"keyword\">if</span> n&lt;<span class=\"number\">2</span> <span class=\"keyword\">else</span> n*factorial(n<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<p><code>snooze</code>和<code>factorial</code>函数会作为func参数传给clock函数，然后clock函数会返回<code>clocked</code>函数。所以现在<code>factorial</code>保留的是<code>clocked</code>函数的引用。但是这也是装饰器的一个副作用：会把被装饰函数的一些元数据，例如函数名、文档字符串、函数签名等信息覆盖掉。下面会使用functools库中的 <code>@wraps</code> 装饰器来避免这个。</p>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/func_ref.png\" alt=\"func_ref\"></p>\n<p>内嵌包装函数 <code>clocked</code> 的参数跟被装饰函数的参数对应，这里使用了 <code>(*args, **kwargs)</code>，是为了适应可变参数。</p>\n<p>clocked函数做了以下几件事：</p>\n<ol>\n<li>记录初始时间</li>\n<li>调用原来的factorial函数，保存结果</li>\n<li>计算经过的时间</li>\n<li>格式化收集的数据，然后打印出来</li>\n<li>返回第2步保存的结果</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(<span class=\"string\">'*'</span>*<span class=\"number\">40</span>, <span class=\"string\">'Calling factorial(6)'</span>)</span><br><span class=\"line\">print(<span class=\"string\">'6! = '</span>, factorial(<span class=\"number\">6</span>))</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://7xkfga.com1.z0.glb.clouddn.com/result.png\" alt=\"result\"></p>\n<p>装饰器的典型行为就是：<strong>把被装饰的函数体换成新函数，二者接受相同的参数，返回被装饰的函数本该返回的值，同时有额外操作</strong></p>\n<p>另外，内嵌包装函数 <code>clocked</code> 添加了functools库中的 <code>@wraps</code> 装饰器，这个装饰器可以把被包装函数的元数据，例如函数名、文档字符串、函数签名等信息保存下来。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(snooze(<span class=\"number\">5</span>))</span><br><span class=\"line\">print(snooze.__doc__)</span><br><span class=\"line\">print(<span class=\"string\">'origin func name is:'</span>, snooze.__name__)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[5.01506114s] snooze(5) -&gt; None</span><br><span class=\"line\">None</span><br><span class=\"line\"> sleep for seconds</span><br><span class=\"line\">origin func name is: snooze</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数化装饰器\"><a href=\"#参数化装饰器\" class=\"headerlink\" title=\"参数化装饰器\"></a>参数化装饰器</h3><p>如果装饰器本身需要传入参数，那就需要编写一个返回decorator的高阶函数，也就是针对装饰器进行装饰。</p>\n<p>下面代码来自 Python Cookbook：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> wraps</span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">logged</span><span class=\"params\">(level, name=None, message=None)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    Add logging to a function. level is the logging</span></span><br><span class=\"line\"><span class=\"string\">    level, name is the logger name, and message is the</span></span><br><span class=\"line\"><span class=\"string\">    log message. If name and message aren't specified,</span></span><br><span class=\"line\"><span class=\"string\">    they default to the function's module and name.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorate</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">        logname = name <span class=\"keyword\">if</span> name <span class=\"keyword\">else</span> func.__module__</span><br><span class=\"line\">        log = logging.getLogger(logname)</span><br><span class=\"line\">        logmsg = message <span class=\"keyword\">if</span> message <span class=\"keyword\">else</span> func.__name__</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">        @wraps(func)</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">            log.log(level, logmsg)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Example use</span></span><br><span class=\"line\"><span class=\"meta\">@logged(logging.DEBUG)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@logged(logging.CRITICAL, 'example')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spam</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Spam!'</span>)</span><br></pre></td></tr></table></figure>\n<p>最外层的函数 <code>logged()</code> 接受参数并将它们作用在内部的装饰器函数上面。 内层的函数 <code>decorate()</code> 接受一个函数作为参数，然后在函数上面放置一个包装器。这个装饰器的处理过程相当于：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spam = logged(x, y)(spam)</span><br></pre></td></tr></table></figure>\n<p>首先执行<code>logged(&#39;x&#39;, &#39;y&#39;)</code>，返回的是 <code>decorate</code> 函数，再调用返回的函数，参数是 <code>spam</code> 函数。</p>\n<h2 id=\"装饰器在真实世界的应用\"><a href=\"#装饰器在真实世界的应用\" class=\"headerlink\" title=\"装饰器在真实世界的应用\"></a>装饰器在真实世界的应用</h2><p>更多的装饰器的案例： <a href=\"https://wiki.python.org/moin/PythonDecoratorLibrary\" target=\"_blank\" rel=\"noopener\">PythonDecoratorLibrary</a></p>\n<h3 id=\"1-给函数调用做缓存\"><a href=\"#1-给函数调用做缓存\" class=\"headerlink\" title=\"1. 给函数调用做缓存\"></a>1. 给函数调用做缓存</h3><p>像求第n个斐波那契数来说，是个递归算法，对于这种慢速递归，可以把耗时函数的结果先缓存起来，在调用函数之前先查询一下缓存，如果没有才调用函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> wraps</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">memo</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    cache = &#123;&#125;</span><br><span class=\"line\">    miss = object()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args)</span>:</span></span><br><span class=\"line\">        result = cache.get(args, miss)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> result <span class=\"keyword\">is</span> miss:</span><br><span class=\"line\">            result = func(*args)</span><br><span class=\"line\">            cache[args] = result</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@memo</span></span><br><span class=\"line\"><span class=\"meta\">@clock</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &lt; <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fib(n<span class=\"number\">-2</span>) + fib(n<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<p>也可以使用下面的functools库里面的 <code>lru_cache</code> 装饰器来实现缓存。</p>\n<h3 id=\"2-LRUCache\"><a href=\"#2-LRUCache\" class=\"headerlink\" title=\"2. LRUCache\"></a>2. LRUCache</h3><p>LRU就是Least Recently Used，即最近最少使用，是一种内存管理算法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@functools.lru_cache()</span></span><br><span class=\"line\"><span class=\"meta\">@clock</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fibonacci</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &lt; <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fibonacci(n<span class=\"number\">-2</span>) + fibonacci(n<span class=\"number\">-1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(fibonacci(<span class=\"number\">6</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-给函数输出记日志\"><a href=\"#3-给函数输出记日志\" class=\"headerlink\" title=\"3. 给函数输出记日志\"></a>3. 给函数输出记日志</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> wraps</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"Function running\"</span>)</span><br><span class=\"line\">        ts = time.time()</span><br><span class=\"line\">        result = func(*args, **kwargs)</span><br><span class=\"line\">        te = time.time()</span><br><span class=\"line\">        print(<span class=\"string\">\"Function  = &#123;0&#125;\"</span>.format(func.__name__))</span><br><span class=\"line\">        print(<span class=\"string\">\"Arguments = &#123;0&#125; &#123;1&#125;\"</span>.format(args, kwargs))</span><br><span class=\"line\">        print(<span class=\"string\">\"Return    = &#123;0&#125;\"</span>.format(result))</span><br><span class=\"line\">        print(<span class=\"string\">\"time      = %.6f seconds\"</span> % (te - ts))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\"></span><br><span class=\"line\">print(sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-数据库连接\"><a href=\"#4-数据库连接\" class=\"headerlink\" title=\"4. 数据库连接\"></a>4. 数据库连接</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">open_and_close_db</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*a, **k)</span>:</span></span><br><span class=\"line\">        conn = connect_db()</span><br><span class=\"line\">        result = func(conn=conn, *a, **k)</span><br><span class=\"line\">        conn.commit()</span><br><span class=\"line\">        conn.close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@open_and_close_db</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">query_for_dict</span><span class=\"params\">(sql, conn)</span>:</span></span><br><span class=\"line\">    cur = conn.cursor()</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        cur.execute(sql)</span><br><span class=\"line\">        conn.commit()</span><br><span class=\"line\">        entries = [dict(zip([i[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> cur.description], row)) <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> cur.fetchall()]</span><br><span class=\"line\">            <span class=\"keyword\">print</span> entries</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception,e:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> e</span><br><span class=\"line\">    <span class=\"keyword\">return</span> entries</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-Flask路由\"><a href=\"#5-Flask路由\" class=\"headerlink\" title=\"5. Flask路由\"></a>5. Flask路由</h3><p>拿Flask的 hello world来说：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(\"/\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p>到这儿，装饰器的一些基本概念就都清楚了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://segmentfault.com/a/1190000004461404\" target=\"_blank\" rel=\"noopener\">Python 的闭包和装饰器</a></p>\n<p><a href=\"https://www.amazon.com/Fluent-Python-Concise-Effective-Programming/dp/1491946008/ref=sr_1_1?ie=UTF8&amp;qid=1500368395&amp;sr=8-1&amp;keywords=fluent+python\" target=\"_blank\" rel=\"noopener\">Fluent Python</a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjfkkp3n4000dzd6870yujcfo","category_id":"cjfkkp3n7000fzd68b6b7m1ua","_id":"cjfkkp3nd000szd680ns8u56r"},{"post_id":"cjfkkp3na000lzd680z97zvbc","category_id":"cjfkkp3n7000fzd68b6b7m1ua","_id":"cjfkkp3nf000wzd68v4dnxtrn"},{"post_id":"cjfkkp3nc000rzd68b631dzew","category_id":"cjfkkp3n7000fzd68b6b7m1ua","_id":"cjfkkp3nl0012zd6893hlp5ik"},{"post_id":"cjfkkp3nn0018zd68uxbfrbzc","category_id":"cjfkkp3nh000zzd6896hddda8","_id":"cjfkkp3nr001hzd68pfh7xt3l"},{"post_id":"cjfkkp3n5000ezd68wd1l1ul0","category_id":"cjfkkp3na000mzd685r9ffpe5","_id":"cjfkkp3nu001ozd68v609mtyn"},{"post_id":"cjfkkp3n5000ezd68wd1l1ul0","category_id":"cjfkkp3np001czd68188u66oy","_id":"cjfkkp3nv001rzd68f54hgb48"},{"post_id":"cjfkkp3nr001gzd68ihb95g9y","category_id":"cjfkkp3nh000zzd6896hddda8","_id":"cjfkkp3nx001tzd68xkmgw7xu"},{"post_id":"cjfkkp3ns001kzd68e6v6vxwh","category_id":"cjfkkp3nh000zzd6896hddda8","_id":"cjfkkp3nz001xzd68xlkwir5p"},{"post_id":"cjfkkp3ne000vzd68bmchlqpm","category_id":"cjfkkp3nh000zzd6896hddda8","_id":"cjfkkp3o10020zd68kvbsofe4"},{"post_id":"cjfkkp3n7000izd6897q3n5r7","category_id":"cjfkkp3na000mzd685r9ffpe5","_id":"cjfkkp3o20025zd68sjb9267d"},{"post_id":"cjfkkp3n7000izd6897q3n5r7","category_id":"cjfkkp3nu001nzd685yyxmrzs","_id":"cjfkkp3o30028zd685bzmmji5"},{"post_id":"cjfkkp3nk0011zd680q1xzux7","category_id":"cjfkkp3na000mzd685r9ffpe5","_id":"cjfkkp3o6002ezd68d4t8298z"},{"post_id":"cjfkkp3nk0011zd680q1xzux7","category_id":"cjfkkp3np001czd68188u66oy","_id":"cjfkkp3o8002izd68mcv2nm9h"},{"post_id":"cjfkkp3n8000kzd68qohnumgw","category_id":"cjfkkp3nh000zzd6896hddda8","_id":"cjfkkp3o9002mzd68ao2femlj"},{"post_id":"cjfkkp3n8000kzd68qohnumgw","category_id":"cjfkkp3o4002azd68r34u88ba","_id":"cjfkkp3ob002qzd68ozl2uqgn"},{"post_id":"cjfkkp3nl0014zd68uhpxd9ms","category_id":"cjfkkp3nh000zzd6896hddda8","_id":"cjfkkp3oc002uzd68gdgotl90"},{"post_id":"cjfkkp3nl0014zd68uhpxd9ms","category_id":"cjfkkp3o4002azd68r34u88ba","_id":"cjfkkp3od002xzd68ulcdies4"},{"post_id":"cjfkkp3nb000pzd68bd7tuqhe","category_id":"cjfkkp3nh000zzd6896hddda8","_id":"cjfkkp3of002zzd68636ab19b"},{"post_id":"cjfkkp3nb000pzd68bd7tuqhe","category_id":"cjfkkp3o4002azd68r34u88ba","_id":"cjfkkp3oh0033zd68xtyck4a8"},{"post_id":"cjfkkp3nq001ezd68vwc6ht9b","category_id":"cjfkkp3nh000zzd6896hddda8","_id":"cjfkkp3om003czd680pc2erqn"},{"post_id":"cjfkkp3nq001ezd68vwc6ht9b","category_id":"cjfkkp3of0030zd68576qu4r6","_id":"cjfkkp3oo003gzd68w8ttrgfc"},{"post_id":"cjfkkp3nv001pzd68q48nsiie","category_id":"cjfkkp3oi0036zd68svvb8aa3","_id":"cjfkkp3oq003kzd68ctm7lags"},{"post_id":"cjfkkp3nw001szd68qjglnp7r","category_id":"cjfkkp3oi0036zd68svvb8aa3","_id":"cjfkkp3os003pzd68e2743x1t"},{"post_id":"cjfkkp3nx001uzd685gcq3koz","category_id":"cjfkkp3oi0036zd68svvb8aa3","_id":"cjfkkp3ow003vzd68bhli6wvh"},{"post_id":"cjfkkp3ot003szd684moshw1f","category_id":"cjfkkp3n7000fzd68b6b7m1ua","_id":"cjfkkp3p00040zd68i4xzj67t"},{"post_id":"cjfkkp3nz001yzd68sqgo9aq6","category_id":"cjfkkp3oi0036zd68svvb8aa3","_id":"cjfkkp3p20045zd68j969yvnp"},{"post_id":"cjfkkp3ng000yzd68y49naw54","category_id":"cjfkkp3nh000zzd6896hddda8","_id":"cjfkkp3p40049zd689tuiy0w2"},{"post_id":"cjfkkp3ng000yzd68y49naw54","category_id":"cjfkkp3o4002azd68r34u88ba","_id":"cjfkkp3p6004dzd68pu2aj3lr"},{"post_id":"cjfkkp3o10021zd68x3bn2shw","category_id":"cjfkkp3oi0036zd68svvb8aa3","_id":"cjfkkp3p8004hzd68zb76lpqn"},{"post_id":"cjfkkp3o20026zd68x5lhji3x","category_id":"cjfkkp3oi0036zd68svvb8aa3","_id":"cjfkkp3pd004lzd68ukkq5uuh"},{"post_id":"cjfkkp3no001azd68yv852244","category_id":"cjfkkp3oc002tzd68jghcej8e","_id":"cjfkkp3pj0051zd68i5ub3oy2"},{"post_id":"cjfkkp3no001azd68yv852244","category_id":"cjfkkp3p8004gzd68z08jbhbj","_id":"cjfkkp3pj0053zd68fdz0az8k"},{"post_id":"cjfkkp3no001azd68yv852244","category_id":"cjfkkp3pg004szd68i54g98v0","_id":"cjfkkp3pj0055zd68qltcw15f"},{"post_id":"cjfkkp3oy003xzd6866w0bjlu","category_id":"cjfkkp3pd004mzd68g3slamhl","_id":"cjfkkp3pk0058zd68b3rc548j"},{"post_id":"cjfkkp3oy003xzd6866w0bjlu","category_id":"cjfkkp3pi004yzd68kl0yth5g","_id":"cjfkkp3pk0059zd68dxrk3w1p"}],"PostTag":[{"post_id":"cjfkkp3mu0004zd68tou7spz9","tag_id":"cjfkkp3mw0006zd68ejzupbsz","_id":"cjfkkp3n1000bzd68emssuo02"},{"post_id":"cjfkkp3mx0008zd68kcfiow45","tag_id":"cjfkkp3mw0006zd68ejzupbsz","_id":"cjfkkp3n7000hzd684zarazt7"},{"post_id":"cjfkkp3mx0008zd68kcfiow45","tag_id":"cjfkkp3n0000azd68mckvmuol","_id":"cjfkkp3n8000jzd68kgu7sky4"},{"post_id":"cjfkkp3n4000dzd6870yujcfo","tag_id":"cjfkkp3n7000gzd68t4uejfyi","_id":"cjfkkp3nb000ozd68cmdv82t2"},{"post_id":"cjfkkp3na000lzd680z97zvbc","tag_id":"cjfkkp3n7000gzd68t4uejfyi","_id":"cjfkkp3nc000qzd68g447umsh"},{"post_id":"cjfkkp3nc000rzd68b631dzew","tag_id":"cjfkkp3n7000gzd68t4uejfyi","_id":"cjfkkp3nf000xzd68j3whjryc"},{"post_id":"cjfkkp3n5000ezd68wd1l1ul0","tag_id":"cjfkkp3nb000nzd68ik1kkhqk","_id":"cjfkkp3nl0013zd68wyjwwdgu"},{"post_id":"cjfkkp3n5000ezd68wd1l1ul0","tag_id":"cjfkkp3nd000uzd685065yrj8","_id":"cjfkkp3nm0015zd68k51s0g5x"},{"post_id":"cjfkkp3nk0011zd680q1xzux7","tag_id":"cjfkkp3nd000uzd685065yrj8","_id":"cjfkkp3no0019zd68k0vgeqth"},{"post_id":"cjfkkp3nk0011zd680q1xzux7","tag_id":"cjfkkp3nb000nzd68ik1kkhqk","_id":"cjfkkp3np001bzd68lrch998z"},{"post_id":"cjfkkp3n7000izd6897q3n5r7","tag_id":"cjfkkp3nb000nzd68ik1kkhqk","_id":"cjfkkp3nq001fzd68gboheqp3"},{"post_id":"cjfkkp3n7000izd6897q3n5r7","tag_id":"cjfkkp3nm0017zd68d0d7fvgc","_id":"cjfkkp3nr001izd68eybma8gp"},{"post_id":"cjfkkp3n8000kzd68qohnumgw","tag_id":"cjfkkp3np001dzd68mk9eoicf","_id":"cjfkkp3o1001zzd68fj8b577n"},{"post_id":"cjfkkp3n8000kzd68qohnumgw","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3o20023zd68rctkns81"},{"post_id":"cjfkkp3n8000kzd68qohnumgw","tag_id":"cjfkkp3nv001qzd68tifpkjrq","_id":"cjfkkp3o30027zd684nlc74ut"},{"post_id":"cjfkkp3nb000pzd68bd7tuqhe","tag_id":"cjfkkp3np001dzd68mk9eoicf","_id":"cjfkkp3o8002jzd68i0kyfu0p"},{"post_id":"cjfkkp3nb000pzd68bd7tuqhe","tag_id":"cjfkkp3o20024zd68oo226i06","_id":"cjfkkp3oa002nzd68z83n73lg"},{"post_id":"cjfkkp3nb000pzd68bd7tuqhe","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3ob002rzd68nrjqtf10"},{"post_id":"cjfkkp3ne000vzd68bmchlqpm","tag_id":"cjfkkp3o20024zd68oo226i06","_id":"cjfkkp3oh0034zd688siu2q43"},{"post_id":"cjfkkp3ne000vzd68bmchlqpm","tag_id":"cjfkkp3np001dzd68mk9eoicf","_id":"cjfkkp3oj0037zd68rap35hea"},{"post_id":"cjfkkp3ne000vzd68bmchlqpm","tag_id":"cjfkkp3oc002vzd68lfcf8ads","_id":"cjfkkp3ol003azd68hq4sljku"},{"post_id":"cjfkkp3oq003mzd68nnol4j3b","tag_id":"cjfkkp3mw0006zd68ejzupbsz","_id":"cjfkkp3ot003rzd687y2b2pv1"},{"post_id":"cjfkkp3ng000yzd68y49naw54","tag_id":"cjfkkp3o20024zd68oo226i06","_id":"cjfkkp3oz003yzd68kbcrfncb"},{"post_id":"cjfkkp3ng000yzd68y49naw54","tag_id":"cjfkkp3np001dzd68mk9eoicf","_id":"cjfkkp3p10042zd686yliilw4"},{"post_id":"cjfkkp3ng000yzd68y49naw54","tag_id":"cjfkkp3on003fzd686lmb71u8","_id":"cjfkkp3p20046zd685jpgvged"},{"post_id":"cjfkkp3ng000yzd68y49naw54","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3p4004azd68rtqezcrg"},{"post_id":"cjfkkp3ng000yzd68y49naw54","tag_id":"cjfkkp3nv001qzd68tifpkjrq","_id":"cjfkkp3p6004ezd684rgb85op"},{"post_id":"cjfkkp3nl0014zd68uhpxd9ms","tag_id":"cjfkkp3o20024zd68oo226i06","_id":"cjfkkp3pf004pzd687mshsd9p"},{"post_id":"cjfkkp3nl0014zd68uhpxd9ms","tag_id":"cjfkkp3p10043zd68vujljiif","_id":"cjfkkp3pg004rzd68i3zlmzzf"},{"post_id":"cjfkkp3nl0014zd68uhpxd9ms","tag_id":"cjfkkp3np001dzd68mk9eoicf","_id":"cjfkkp3pi004vzd68x85ueheo"},{"post_id":"cjfkkp3nl0014zd68uhpxd9ms","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3pi004wzd688s4ueq3a"},{"post_id":"cjfkkp3pa004kzd680gqifh2n","tag_id":"cjfkkp3mw0006zd68ejzupbsz","_id":"cjfkkp3pi004zzd68o112iexk"},{"post_id":"cjfkkp3nn0018zd68uxbfrbzc","tag_id":"cjfkkp3np001dzd68mk9eoicf","_id":"cjfkkp3pj0052zd68zdkr7f5n"},{"post_id":"cjfkkp3nn0018zd68uxbfrbzc","tag_id":"cjfkkp3o20024zd68oo226i06","_id":"cjfkkp3pj0054zd68km1b08ii"},{"post_id":"cjfkkp3nn0018zd68uxbfrbzc","tag_id":"cjfkkp3nv001qzd68tifpkjrq","_id":"cjfkkp3pk0057zd683143mwsy"},{"post_id":"cjfkkp3nq001ezd68vwc6ht9b","tag_id":"cjfkkp3pj0050zd68kt4fy280","_id":"cjfkkp3pl005czd68atzkvssn"},{"post_id":"cjfkkp3nq001ezd68vwc6ht9b","tag_id":"cjfkkp3nv001qzd68tifpkjrq","_id":"cjfkkp3pl005dzd68dk94kkac"},{"post_id":"cjfkkp3nq001ezd68vwc6ht9b","tag_id":"cjfkkp3pk005azd68d61uk48s","_id":"cjfkkp3pl005fzd6870d6o67z"},{"post_id":"cjfkkp3nr001gzd68ihb95g9y","tag_id":"cjfkkp3np001dzd68mk9eoicf","_id":"cjfkkp3pm005hzd68wh4pzm1g"},{"post_id":"cjfkkp3nr001gzd68ihb95g9y","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3pm005izd68othw4v5q"},{"post_id":"cjfkkp3nr001gzd68ihb95g9y","tag_id":"cjfkkp3nv001qzd68tifpkjrq","_id":"cjfkkp3pm005kzd68ueuuxuw9"},{"post_id":"cjfkkp3ns001kzd68e6v6vxwh","tag_id":"cjfkkp3nv001qzd68tifpkjrq","_id":"cjfkkp3pn005ozd683gdtn5pp"},{"post_id":"cjfkkp3ns001kzd68e6v6vxwh","tag_id":"cjfkkp3pm005jzd6888kxrdk7","_id":"cjfkkp3pn005pzd68zfyupsoz"},{"post_id":"cjfkkp3ns001kzd68e6v6vxwh","tag_id":"cjfkkp3pm005lzd68x3xag4w6","_id":"cjfkkp3pn005rzd681lke3eb5"},{"post_id":"cjfkkp3ns001kzd68e6v6vxwh","tag_id":"cjfkkp3pk005azd68d61uk48s","_id":"cjfkkp3pn005szd68n3xsgey5"},{"post_id":"cjfkkp3nt001mzd68n01srzou","tag_id":"cjfkkp3pn005nzd68kqu54oui","_id":"cjfkkp3po005uzd68zlydilt3"},{"post_id":"cjfkkp3nt001mzd68n01srzou","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3po005vzd688iq6sw0s"},{"post_id":"cjfkkp3nv001pzd68q48nsiie","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3po005xzd68kp066nv7"},{"post_id":"cjfkkp3nv001pzd68q48nsiie","tag_id":"cjfkkp3pn005qzd68pzxmls9e","_id":"cjfkkp3pp005yzd689u4guyfb"},{"post_id":"cjfkkp3nw001szd68qjglnp7r","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3pp0060zd68av5hutyo"},{"post_id":"cjfkkp3nw001szd68qjglnp7r","tag_id":"cjfkkp3pn005qzd68pzxmls9e","_id":"cjfkkp3pp0061zd68bzh3oawe"},{"post_id":"cjfkkp3nx001uzd685gcq3koz","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3pq0063zd685es6xgja"},{"post_id":"cjfkkp3nx001uzd685gcq3koz","tag_id":"cjfkkp3pn005qzd68pzxmls9e","_id":"cjfkkp3pq0064zd68om02693n"},{"post_id":"cjfkkp3nz001yzd68sqgo9aq6","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3pq0066zd68bvc8vx0c"},{"post_id":"cjfkkp3nz001yzd68sqgo9aq6","tag_id":"cjfkkp3pn005qzd68pzxmls9e","_id":"cjfkkp3pq0067zd68cczv5rbz"},{"post_id":"cjfkkp3o10021zd68x3bn2shw","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3pr0069zd68d7tp869n"},{"post_id":"cjfkkp3o10021zd68x3bn2shw","tag_id":"cjfkkp3pn005qzd68pzxmls9e","_id":"cjfkkp3pr006azd68o565c3u6"},{"post_id":"cjfkkp3o20026zd68x5lhji3x","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3pr006czd68emknot4b"},{"post_id":"cjfkkp3o20026zd68x5lhji3x","tag_id":"cjfkkp3pn005qzd68pzxmls9e","_id":"cjfkkp3ps006dzd68kcpwglh6"},{"post_id":"cjfkkp3o30029zd68v6bt8tct","tag_id":"cjfkkp3pr0068zd68ytcoo2w7","_id":"cjfkkp3pt006fzd68z2lurbsj"},{"post_id":"cjfkkp3o30029zd68v6bt8tct","tag_id":"cjfkkp3pr006bzd68pwajtp13","_id":"cjfkkp3pt006gzd681o5zdbrc"},{"post_id":"cjfkkp3o4002czd68befva0em","tag_id":"cjfkkp3pr0068zd68ytcoo2w7","_id":"cjfkkp3pt006izd6808mea1mb"},{"post_id":"cjfkkp3o6002dzd68ugaife6f","tag_id":"cjfkkp3pt006hzd680zal7s0p","_id":"cjfkkp3pv006mzd6853peqrjm"},{"post_id":"cjfkkp3o6002dzd68ugaife6f","tag_id":"cjfkkp3pu006jzd68vr0dsrwf","_id":"cjfkkp3pv006nzd68j3dqmh06"},{"post_id":"cjfkkp3o6002dzd68ugaife6f","tag_id":"cjfkkp3pr006bzd68pwajtp13","_id":"cjfkkp3pv006pzd68y43d5zd9"},{"post_id":"cjfkkp3o7002hzd68z5r10x0j","tag_id":"cjfkkp3pv006lzd686dv1akft","_id":"cjfkkp3pv006qzd68ive2u8ae"},{"post_id":"cjfkkp3o9002kzd68866nsmse","tag_id":"cjfkkp3pv006lzd686dv1akft","_id":"cjfkkp3pw006szd68hg124tcz"},{"post_id":"cjfkkp3oa002pzd68balpsfte","tag_id":"cjfkkp3pv006lzd686dv1akft","_id":"cjfkkp3pw006uzd687fuy102q"},{"post_id":"cjfkkp3ob002szd686ki107k4","tag_id":"cjfkkp3pv006lzd686dv1akft","_id":"cjfkkp3px006wzd687wfs2x9z"},{"post_id":"cjfkkp3od002wzd680ljnmtvh","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3px006yzd684muhopsw"},{"post_id":"cjfkkp3od002wzd680ljnmtvh","tag_id":"cjfkkp3px006vzd683izz94y4","_id":"cjfkkp3px006zzd683vai3g9e"},{"post_id":"cjfkkp3oe002yzd68xvzpqzbv","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3py0072zd68fq8vflvr"},{"post_id":"cjfkkp3oe002yzd68xvzpqzbv","tag_id":"cjfkkp3px006xzd682rd129kw","_id":"cjfkkp3py0073zd68faiqdbk8"},{"post_id":"cjfkkp3oe002yzd68xvzpqzbv","tag_id":"cjfkkp3px0070zd688u4lc4oi","_id":"cjfkkp3pz0075zd68gnjoi57h"},{"post_id":"cjfkkp3of0031zd68jg4f0gcp","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3pz0076zd68oaakrv8l"},{"post_id":"cjfkkp3of0031zd68jg4f0gcp","tag_id":"cjfkkp3py0071zd68jbik98uk","_id":"cjfkkp3pz0078zd68cp45815a"},{"post_id":"cjfkkp3oh0035zd68ksy0430p","tag_id":"cjfkkp3py0074zd68tykkq72s","_id":"cjfkkp3q00079zd68jfwyl4c4"},{"post_id":"cjfkkp3oj0038zd6829stm37j","tag_id":"cjfkkp3px006vzd683izz94y4","_id":"cjfkkp3q0007bzd68jl0rcmy2"},{"post_id":"cjfkkp3oj0038zd6829stm37j","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3q0007czd684e61gc3e"},{"post_id":"cjfkkp3ol003bzd68zvbp4q14","tag_id":"cjfkkp3q0007azd68jewn955z","_id":"cjfkkp3q1007ezd6813b2i775"},{"post_id":"cjfkkp3om003dzd68es6tcgjc","tag_id":"cjfkkp3mw0006zd68ejzupbsz","_id":"cjfkkp3q2007hzd68pmhj20p4"},{"post_id":"cjfkkp3om003dzd68es6tcgjc","tag_id":"cjfkkp3q0007azd68jewn955z","_id":"cjfkkp3q2007izd68nrjy7vga"},{"post_id":"cjfkkp3om003dzd68es6tcgjc","tag_id":"cjfkkp3q1007fzd68uhe8vh85","_id":"cjfkkp3q2007kzd68f2bx6p8p"},{"post_id":"cjfkkp3oo003hzd68bxp62rw2","tag_id":"cjfkkp3q2007gzd68wpirgbzo","_id":"cjfkkp3q3007lzd6883fqs1ef"},{"post_id":"cjfkkp3oo003hzd68bxp62rw2","tag_id":"cjfkkp3mw0006zd68ejzupbsz","_id":"cjfkkp3q3007nzd68b97gytbr"},{"post_id":"cjfkkp3op003izd68aqir8zq4","tag_id":"cjfkkp3mw0006zd68ejzupbsz","_id":"cjfkkp3q4007pzd68bk3m2ca3"},{"post_id":"cjfkkp3op003izd68aqir8zq4","tag_id":"cjfkkp3q0007azd68jewn955z","_id":"cjfkkp3q4007qzd68gtomsvpt"},{"post_id":"cjfkkp3op003izd68aqir8zq4","tag_id":"cjfkkp3q1007fzd68uhe8vh85","_id":"cjfkkp3q4007szd68icz3xhk0"},{"post_id":"cjfkkp3or003nzd68okn7xva8","tag_id":"cjfkkp3q2007gzd68wpirgbzo","_id":"cjfkkp3q4007tzd68xc66cc2o"},{"post_id":"cjfkkp3ot003szd684moshw1f","tag_id":"cjfkkp3q4007rzd685nbbcryd","_id":"cjfkkp3q5007wzd68ozscq4k7"},{"post_id":"cjfkkp3ot003szd684moshw1f","tag_id":"cjfkkp3q4007uzd68bpdk79k2","_id":"cjfkkp3q5007xzd688q4v122b"},{"post_id":"cjfkkp3ov003tzd681j2amu7v","tag_id":"cjfkkp3o20024zd68oo226i06","_id":"cjfkkp3q60080zd68xvzc8xto"},{"post_id":"cjfkkp3ov003tzd681j2amu7v","tag_id":"cjfkkp3px006vzd683izz94y4","_id":"cjfkkp3q60081zd68l40c6e1k"},{"post_id":"cjfkkp3ov003tzd681j2amu7v","tag_id":"cjfkkp3py0074zd68tykkq72s","_id":"cjfkkp3q60083zd681ux5r5u1"},{"post_id":"cjfkkp3oy003xzd6866w0bjlu","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3q60084zd68htp967dr"},{"post_id":"cjfkkp3oy003xzd6866w0bjlu","tag_id":"cjfkkp3q5007zzd68ng2b0kpq","_id":"cjfkkp3q70086zd68uzw3or4s"},{"post_id":"cjfkkp3oz003zzd68f6gzavmp","tag_id":"cjfkkp3q60082zd685ssu8cah","_id":"cjfkkp3q70088zd687v7axnsh"},{"post_id":"cjfkkp3oz003zzd68f6gzavmp","tag_id":"cjfkkp3q60085zd68s260c1ll","_id":"cjfkkp3q70089zd681ge18itu"},{"post_id":"cjfkkp3p20044zd688h6im852","tag_id":"cjfkkp3pu006jzd68vr0dsrwf","_id":"cjfkkp3q8008czd68eltof18w"},{"post_id":"cjfkkp3p20044zd688h6im852","tag_id":"cjfkkp3pr0068zd68ytcoo2w7","_id":"cjfkkp3q8008dzd68cu88capc"},{"post_id":"cjfkkp3p30047zd681idrgplw","tag_id":"cjfkkp3q8008bzd68cnfulfjk","_id":"cjfkkp3q9008fzd68yu1ozqeo"},{"post_id":"cjfkkp3p5004czd68r2ex5q80","tag_id":"cjfkkp3o20024zd68oo226i06","_id":"cjfkkp3qb008izd68pe3g8xxq"},{"post_id":"cjfkkp3p5004czd68r2ex5q80","tag_id":"cjfkkp3px006vzd683izz94y4","_id":"cjfkkp3qb008jzd68smk9jaq8"},{"post_id":"cjfkkp3p5004czd68r2ex5q80","tag_id":"cjfkkp3py0074zd68tykkq72s","_id":"cjfkkp3qc008lzd68f6xwkhol"},{"post_id":"cjfkkp3p7004fzd68wp0l5fmb","tag_id":"cjfkkp3o20024zd68oo226i06","_id":"cjfkkp3qc008nzd68c7coqyln"},{"post_id":"cjfkkp3p7004fzd68wp0l5fmb","tag_id":"cjfkkp3px006vzd683izz94y4","_id":"cjfkkp3qc008ozd68ku5dyayr"},{"post_id":"cjfkkp3p7004fzd68wp0l5fmb","tag_id":"cjfkkp3py0074zd68tykkq72s","_id":"cjfkkp3qd008qzd68l4mv3nj7"},{"post_id":"cjfkkp3p9004jzd68kkvadsh6","tag_id":"cjfkkp3qc008mzd68a7ov1fhr","_id":"cjfkkp3qd008rzd682niq1uj1"},{"post_id":"cjfkkp3pe004ozd68lgu6b3h0","tag_id":"cjfkkp3o20024zd68oo226i06","_id":"cjfkkp3qe008uzd68rz87k3b5"},{"post_id":"cjfkkp3pe004ozd68lgu6b3h0","tag_id":"cjfkkp3px006vzd683izz94y4","_id":"cjfkkp3qe008vzd68kxxn8dwt"},{"post_id":"cjfkkp3pe004ozd68lgu6b3h0","tag_id":"cjfkkp3py0074zd68tykkq72s","_id":"cjfkkp3qe008xzd680xqsn69q"},{"post_id":"cjfkkp3pf004qzd68yw0o1mab","tag_id":"cjfkkp3px006vzd683izz94y4","_id":"cjfkkp3qe008yzd68ahkkmt1h"},{"post_id":"cjfkkp3ph004uzd68bv5cee57","tag_id":"cjfkkp3nt001lzd680tbx7ug1","_id":"cjfkkp3qf008zzd6875sccf9a"},{"post_id":"cjfkkp3ph004uzd68bv5cee57","tag_id":"cjfkkp3qe008wzd683etd8jy7","_id":"cjfkkp3qf0090zd683hggco86"}],"Tag":[{"name":"SQL Server","_id":"cjfkkp3mw0006zd68ejzupbsz"},{"name":"优化","_id":"cjfkkp3n0000azd68mckvmuol"},{"name":"Octopress","_id":"cjfkkp3n7000gzd68t4uejfyi"},{"name":"Big Data","_id":"cjfkkp3nb000nzd68ik1kkhqk"},{"name":"Spark","_id":"cjfkkp3nd000uzd685065yrj8"},{"name":"Hadoop","_id":"cjfkkp3nm0017zd68d0d7fvgc"},{"name":"Machine Learning","_id":"cjfkkp3np001dzd68mk9eoicf"},{"name":"Python","_id":"cjfkkp3nt001lzd680tbx7ug1"},{"name":"Scikit-Learn","_id":"cjfkkp3nv001qzd68tifpkjrq"},{"name":"Algorithm","_id":"cjfkkp3o20024zd68oo226i06"},{"name":"Bayes","_id":"cjfkkp3oc002vzd68lfcf8ads"},{"name":"Logistic Regression","_id":"cjfkkp3on003fzd686lmb71u8"},{"name":"Coursera","_id":"cjfkkp3p10043zd68vujljiif"},{"name":"Kaggle","_id":"cjfkkp3pj0050zd68kt4fy280"},{"name":"Text Mining","_id":"cjfkkp3pk005azd68d61uk48s"},{"name":"Feature Extraction","_id":"cjfkkp3pm005jzd6888kxrdk7"},{"name":"NLP","_id":"cjfkkp3pm005lzd68x3xag4w6"},{"name":"Anaconda","_id":"cjfkkp3pn005nzd68kqu54oui"},{"name":"Flask","_id":"cjfkkp3pn005qzd68pzxmls9e"},{"name":"hexo","_id":"cjfkkp3pr0068zd68ytcoo2w7"},{"name":"Cheat Sheet","_id":"cjfkkp3pr006bzd68pwajtp13"},{"name":"Markdown","_id":"cjfkkp3pt006hzd680zal7s0p"},{"name":"备忘","_id":"cjfkkp3pu006jzd68vr0dsrwf"},{"name":"MongoDB","_id":"cjfkkp3pv006lzd686dv1akft"},{"name":"Data Structure","_id":"cjfkkp3px006vzd683izz94y4"},{"name":"dict","_id":"cjfkkp3px006xzd682rd129kw"},{"name":"hash","_id":"cjfkkp3px0070zd688u4lc4oi"},{"name":"Reference","_id":"cjfkkp3py0071zd68jbik98uk"},{"name":"面试","_id":"cjfkkp3py0074zd68tykkq72s"},{"name":"Database","_id":"cjfkkp3q0007azd68jewn955z"},{"name":"表分区","_id":"cjfkkp3q1007fzd68uhe8vh85"},{"name":"SQL","_id":"cjfkkp3q2007gzd68wpirgbzo"},{"name":"git","_id":"cjfkkp3q4007rzd685nbbcryd"},{"name":"github","_id":"cjfkkp3q4007uzd68bpdk79k2"},{"name":"爬虫","_id":"cjfkkp3q5007zzd68ng2b0kpq"},{"name":"d3.js","_id":"cjfkkp3q60082zd685ssu8cah"},{"name":"visualization","_id":"cjfkkp3q60085zd68s260c1ll"},{"name":"摄影","_id":"cjfkkp3q8008bzd68cnfulfjk"},{"name":"leetcode","_id":"cjfkkp3qc008mzd68a7ov1fhr"},{"name":"装饰器","_id":"cjfkkp3qe008wzd683etd8jy7"}]}}